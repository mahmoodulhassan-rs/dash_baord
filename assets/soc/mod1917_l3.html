<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="Author" content="<username>"> <meta name="GENERATOR" content="urg/version [en] (platform name) [urg]">
<title>Unified Coverage Report :: Line split page</title>
<link type="text/css" rel="stylesheet" href="css/.urg.css">
<link type="text/css" rel="stylesheet" href="css/.layout.css">
<script type="text/javascript" src="js/.jquery.js"></script>
<script type="text/javascript" src="js/.jquery-ui.js"></script>
<script type="text/javascript" src="js/.sortable.js"></script>
<script type="text/javascript" src="js/.colResizable.js"></script>
<script type="text/javascript" src="js/.layout.js"></script>
<script type="text/javascript">
var layout, westLayout, centerLayout;
$(document).ready(function () {
  layout = $("body").layout({ 
    resizable: true,
    spacing_open: 4,
    spacing_closed: 4,
    north: {
      size: 76
    },
    south: {
      size: 45,
      initClosed: true
    }  });
  $("table").colResizable({    liveDrag:true,
    fixed:false,
    draggingClass:"dragging"
  });
});
</script>
</head>
<body><div class="ui-layout-north">
<div class="logo"></div>
<center class="pagetitle">Line split page</center>
<div align="center"><a href="dashboard.html" ><b>dashboard</b></a> | <a href="hierarchy.html" ><b>hierarchy</b></a> | <a href="modlist.html" ><b>modlist</b></a> | groups | <a href="tests.html" ><b>tests</b></a> | <a href="asserts.html" ><b>asserts</b></a></div>

</div>
<div class="ui-layout-center">
Go <a href="mod1917.html#l3">back</a>
<pre class="code"><br clear=all>
1116                       begin
1117       1/1                if (~n_txreset)
1118                             // asynchronous reset.
1119                             begin
1120       1/1                      retry_test_sync1 &lt;= 1'b0;
1121                             end
1122                          else
1123                             begin
1124       1/1                      retry_test_sync1 &lt;= retry_test;
1125                             end
1126                       end
1127                    
1128                    
1129                       // synchronise tx_frame_ready from the dma block. frame_ready is disabled
1130                       // when a received pause frame is active. frame_ready is used by the
1131                       // tx state machine to trigger frame transmission.
1132                       always@(posedge tx_clk or negedge n_txreset)
1133                       begin
1134       1/1                if (~n_txreset)
1135                             // asynchronous reset.
1136                             begin
1137       1/1                      frame_ready       &lt;= 1'b0;
1138       1/1                      tx_paused         &lt;= 1'b0;
1139                             end
1140       1/1                else if (~en_transmit_sync)
1141                             // synchronous reset (from software).
1142                             begin
1143       1/1                      frame_ready       &lt;= 1'b0;
1144       1/1                      tx_paused         &lt;= 1'b0;
1145                             end
1146                          else
1147                             begin
1148                                // ensure that tx is only paused when idle. if a pause frame is
1149                                // transmitted, then pause counter for received frames must
1150                                // still count down to zero.
1151       1/1                      frame_ready       &lt;= tx_frame_ready &amp; ~(pause_tx &amp;
1152                                                     (data_type == TYPE_IDLE));
1153       1/1                      tx_paused         &lt;= (~frame_ready &amp; (data_type == TYPE_IDLE)) |
1154                                                 (pause_frame_transmitting |pfc_frame_transmitting);
1155                             end
1156                       end
1157                    
1158                    // Transmission of pause frames
1159                    //-----------------------------
1160                    
1161                      // First we need to synchronize the incoming pins ...
1162                      //   tx_pause_zero,
1163                      //   tx_pfc_sel,
1164                      //   tx_pfc_pause,
1165                      //   tx_pfc_pause_zero,
1166                      // These are effectively static signals and are sampled based on tx_pause
1167                      // input which is toggle detected below and will have at least 2 cycle
1168                      // delay hence these signals will be stable by the time they are read.
1169                      always@(posedge tx_clk or negedge n_txreset)
1170                      begin
1171       1/1              if (~n_txreset)
1172                        begin
1173       1/1                tx_pause_0_sync1        &lt;= 1'b0;
1174       1/1                tx_pfc_sel_sync1        &lt;= 1'b0;
1175       1/1                tx_pfc_pause_sync1      &lt;= 8'h00;
1176       1/1                tx_pfc_pause_0_sync1    &lt;= 8'h00;
1177                        end
1178                        else
1179                        begin
1180       1/1                tx_pause_0_sync1        &lt;= tx_pause_zero;
1181       1/1                tx_pfc_sel_sync1        &lt;= tx_pfc_sel;
1182       1/1                tx_pfc_pause_sync1      &lt;= tx_pfc_pause;
1183       1/1                tx_pfc_pause_0_sync1    &lt;= tx_pfc_pause_zero;
1184                        end
1185                      end
1186                    
1187                      // Synchonize the pause request from pins, which is a toggle
1188                      // and create a pulse request
1189                      edma_sync_toggle_detect i_edma_sync_toggle_detect_tx_pause (
1190                        .clk      (tx_clk),
1191                        .reset_n  (n_txreset),
1192                        .din      (tx_pause),
1193                        .rise_edge(),
1194                        .fall_edge(),
1195                        .any_edge (pause_request_pins)
1196                      );
1197                    
1198                      assign pause_is_pfc_pins          = tx_pfc_sel_sync1;
1199                      assign pause_802p3_type_pins      = tx_pause_0_sync1;
1200                      assign pause_pfc_pri_vector_pins  = tx_pfc_pause_sync1;
1201                      assign pause_pfc_zero_vector_pins = tx_pfc_pause_0_sync1;
1202                    
1203                      // Now create the same signals from the registers ...
1204                      // First synchronize the signals from the register block (in pclk domain)
1205                      // tx_pause_frame_req     - classic 802.3 pause request nzero
1206                      // tx_pfc_frame_req       - pfc pause request
1207                      // tx_pause_frame_zero    - classic 802.3 pause request zero
1208                      // tx_pfc_frame_pri       - can assume these are static at the point they are read
1209                      // tx_pfc_frame_zero      - can assume these are static at the point they are read
1210                       edma_sync_toggle_detect # (
1211                          .DIN_W(3)
1212                       ) i_edma_sync_toggle_detect_tx_pause_pfc (
1213                          .clk      (tx_clk),
1214                          .reset_n  (n_txreset),
1215                          .din      ({tx_pause_frame_req,tx_pause_frame_zero,tx_pfc_frame_req}),
1216                          .rise_edge(),
1217                          .fall_edge(),
1218                          .any_edge ({tx_pause_frame_req_edge,tx_pause_frame_zero_edge,tx_pfc_frame_req_edge}));
1219                    
1220                       edma_sync_toggle_detect # (
1221                          .DIN_W(2)
1222                       ) i_edma_sync_toggle_detect_rx_fill_level (
1223                          .clk      (tx_clk),
1224                          .reset_n  (n_txreset),
1225                          .din      ({rx_fill_level_low,rx_fill_level_high}),
1226                          .rise_edge({rx_fill_level_low_rise,rx_fill_level_high_rise}),
1227                          .fall_edge(),
1228                          .any_edge ());
1229                    
1230                      // register rx_fill_level_high_rise to enable subsequent rx_fill_level_low_rise action
1231                      // we should only send a zero quantum pause frame if rx_fill_level_high_rise has previously
1232                      // initiated a pause frame request. Clear this signal when the zero quantum pause frame is
1233                      // requested by rx_fill_level_low_rise or when transmit is disabled
1234                      always@(posedge tx_clk or negedge n_txreset)
1235                      begin
1236       1/1              if (~n_txreset)
1237                        begin
1238       1/1                rx_fill_pause_sent &lt;= 1'b0;
1239                        end
1240       1/1              else if (rx_fill_level_high_rise)
1241                        begin
1242       <font color = "red">0/1     ==>        rx_fill_pause_sent &lt;= 1'b1;</font>
1243                        end
1244       1/1              else if (rx_fill_level_low_rise | ~en_transmit_sync)
1245                        begin
1246       1/1                rx_fill_pause_sent &lt;= 1'b0;
1247                        end
                        MISSING_ELSE
1248                      end
1249                    
1250                      assign pause_request_reg            = tx_pause_frame_req_edge | rx_fill_level_high_rise |
1251                                                            (pause_802p3_type_reg) |
1252                                                            (pause_is_pfc_reg);
1253                      assign pause_is_pfc_reg             = tx_pfc_frame_req_edge;
1254                      assign pause_802p3_type_reg         = tx_pause_frame_zero_edge | (rx_fill_level_low_rise &amp; rx_fill_pause_sent);  // rx_fill_level_low_rise can only initiate zero pause frame transmission if non-zero pause frame previously sent
1255                      assign pause_pfc_pri_vector_reg     = tx_pfc_frame_pri;   // Assume static
1256                      assign pause_pfc_pri_vector_reg_par = tx_pfc_frame_pri_par;
1257                      assign pause_pfc_zero_vector_reg    = tx_pfc_frame_zero;  // Assume static
1258                    
1259                    
1260                      // Now multiplex these onto a single set of signals ...
1261                      // Make the pins have higher priority ...
1262                      assign pause_request              = (pause_request_pins | pause_request_reg) &amp;
1263                                                          en_transmit_sync &amp; full_duplex;
1264                      always @(*)
1265                      begin
1266       1/1              if (pause_request_pins)
1267                        begin
1268       <font color = "red">0/1     ==>        pause_is_pfc             = pause_is_pfc_pins;</font>
1269       <font color = "red">0/1     ==>        pause_802p3_type         = pause_802p3_type_pins;</font>
1270       <font color = "red">0/1     ==>        pause_pfc_pri_vector     = pause_pfc_pri_vector_pins;</font>
1271       <font color = "red">0/1     ==>        pause_pfc_pri_vector_par = ^pause_pfc_pri_vector_pins;</font>
1272       <font color = "red">0/1     ==>        pause_pfc_zero_vector    = pause_pfc_zero_vector_pins;</font>
1273                        end
1274                        else
1275                        begin
1276       1/1                pause_is_pfc             = pause_is_pfc_reg;
1277       1/1                pause_802p3_type         = pause_802p3_type_reg;
1278       1/1                pause_pfc_pri_vector     = pause_pfc_pri_vector_reg;
1279       1/1                pause_pfc_pri_vector_par = pause_pfc_pri_vector_reg_par;
1280       1/1                pause_pfc_zero_vector    = pause_pfc_zero_vector_reg;
1281                        end
1282                      end
1283                    
1284                    
1285                    
1286                       // The tx_pause_quantum registers are considered to be static
1287                       // and therefore no need to control when these are sampled and used in the pause frame.
1288                       // This is a slight change of functioanlity and required that the tx_pause_quantum* registers
1289                       // are updated when no pause frames are being sent.
1290                       // This was implemented to save registers but not expected to affect real operating conditions.
1291                       // Previouse *quant_held* registers have been removed.
1292                       //
1293                       // When pfc priority pause uses single quantum set all priority quantums to be the same, this
1294                       // is already done in gem_registers
1295                       assign tx_pause_quant        = tx_pause_quantum;
1296                       assign tx_pause_quant_par    = tx_pause_quantum_par;
1297                       assign tx_pause_quant_p1     = tx_pause_quantum_p1;
1298                       assign tx_pause_quant_par_p1 = tx_pause_quantum_p1_par;
1299                       assign tx_pause_quant_p2     = tx_pause_quantum_p2;
1300                       assign tx_pause_quant_par_p2 = tx_pause_quantum_p2_par;
1301                       assign tx_pause_quant_p3     = tx_pause_quantum_p3;
1302                       assign tx_pause_quant_par_p3 = tx_pause_quantum_p3_par;
1303                       assign tx_pause_quant_p4     = tx_pause_quantum_p4;
1304                       assign tx_pause_quant_par_p4 = tx_pause_quantum_p4_par;
1305                       assign tx_pause_quant_p5     = tx_pause_quantum_p5;
1306                       assign tx_pause_quant_par_p5 = tx_pause_quantum_p5_par;
1307                       assign tx_pause_quant_p6     = tx_pause_quantum_p6;
1308                       assign tx_pause_quant_par_p6 = tx_pause_quantum_p6_par;
1309                       assign tx_pause_quant_p7     = tx_pause_quantum_p7;
1310                       assign tx_pause_quant_par_p7 = tx_pause_quantum_p7_par;
1311                    
1312                      // When a pause frame request is detected, then we will schedule it for transmission
1313                      // Only when the data pipeline is empty can we accept the pause frame information
1314                      // until then, we just store the information in holding, or scheduling registers ...
1315                      //
1316                      assign allow_pause = (end_frame |
1317                                           (data_type == TYPE_IDLE &amp; ~pfc_or_pause_frame_transmitting));
1318                      always@(posedge tx_clk or negedge n_txreset)
1319                      begin
1320       1/1              if (~n_txreset)
1321                        begin
1322       1/1                pause_request_sched             &lt;= 1'b0;
1323       1/1                pause_is_pfc_sched              &lt;= 1'b0;
1324       1/1                pause_802p3_type_sched          &lt;= 1'b0;
1325       1/1                pause_pfc_pri_vector_sched      &lt;= 8'h00;
1326       1/1                pause_pfc_zero_vector_sched     &lt;= 8'h00;
1327       1/1                pause_frame_transmitting        &lt;= 1'b0;
1328       1/1                pfc_frame_transmitting          &lt;= 1'b0;
1329       1/1                tx_pause_zero_held              &lt;= 1'b0;
1330       1/1                tx_pfc_pri_held                 &lt;= 8'h00;
1331       1/1                tx_pfc_zero_held                &lt;= 8'h00;
1332                        end
1333                        else
1334                        begin
1335       1/1                if (~en_transmit_sync)
1336                          begin
1337       1/1                  pause_request_sched             &lt;= 1'b0;
1338       1/1                  pause_is_pfc_sched              &lt;= 1'b0;
1339       1/1                  pause_802p3_type_sched          &lt;= 1'b0;
1340       1/1                  pause_pfc_pri_vector_sched      &lt;= 8'h00;
1341       1/1                  pause_pfc_zero_vector_sched     &lt;= 8'h00;
1342       1/1                  pause_frame_transmitting        &lt;= 1'b0;
1343       1/1                  pfc_frame_transmitting          &lt;= 1'b0;
1344       1/1                  tx_pause_zero_held              &lt;= 1'b0;
1345       1/1                  tx_pfc_pri_held                 &lt;= 8'h00;
1346       1/1                  tx_pfc_zero_held                &lt;= 8'h00;
1347                          end
1348                    
1349       1/1                else if (pause_request)
1350                          begin
1351       <font color = "red">0/1     ==>          if (allow_pause)</font>
1352                            begin
1353                              // Take direct from pins/registers
1354       <font color = "red">0/1     ==>            pause_request_sched           &lt;= 1'b0;</font>
1355       <font color = "red">0/1     ==>            pause_frame_transmitting      &lt;= ~pause_is_pfc;</font>
1356       <font color = "red">0/1     ==>            pfc_frame_transmitting        &lt;= pause_is_pfc;</font>
1357                    
1358       <font color = "red">0/1     ==>            tx_pause_zero_held            &lt;= pause_802p3_type;</font>
1359       <font color = "red">0/1     ==>            tx_pfc_pri_held               &lt;= pause_pfc_pri_vector;</font>
1360       <font color = "red">0/1     ==>            tx_pfc_zero_held              &lt;= pause_pfc_zero_vector;</font>
1361                            end
1362                            else
1363                            begin
1364       <font color = "red">0/1     ==>            pause_request_sched           &lt;= 1'b1;</font>
1365       <font color = "red">0/1     ==>            pause_frame_transmitting      &lt;= pause_frame_transmitting;</font>
1366       <font color = "red">0/1     ==>            pfc_frame_transmitting        &lt;= pfc_frame_transmitting;</font>
1367       <font color = "red">0/1     ==>            pause_is_pfc_sched            &lt;= pause_is_pfc;</font>
1368       <font color = "red">0/1     ==>            pause_802p3_type_sched        &lt;= pause_802p3_type;</font>
1369       <font color = "red">0/1     ==>            pause_pfc_pri_vector_sched    &lt;= pause_pfc_pri_vector;</font>
1370       <font color = "red">0/1     ==>            pause_pfc_zero_vector_sched   &lt;= pause_pfc_zero_vector;</font>
1371                            end
1372                          end
1373                    
1374                          // execute any previously scheduled pause frames when pipeline becomes
1375                          // idle
1376       1/1                else if (pause_request_sched &amp; allow_pause)
1377                          begin
1378                            // Take from Holding registers ...
1379       <font color = "red">0/1     ==>          pause_request_sched       &lt;= 1'b0;</font>
1380       <font color = "red">0/1     ==>          pause_frame_transmitting  &lt;= ~pause_is_pfc_sched;</font>
1381       <font color = "red">0/1     ==>          pfc_frame_transmitting    &lt;= pause_is_pfc_sched;</font>
1382       <font color = "red">0/1     ==>          tx_pause_zero_held        &lt;= pause_802p3_type_sched;</font>
1383       <font color = "red">0/1     ==>          tx_pfc_pri_held           &lt;= pause_pfc_pri_vector_sched;</font>
1384       <font color = "red">0/1     ==>          tx_pfc_zero_held          &lt;= pause_pfc_zero_vector_sched;</font>
1385                          end
1386                    
1387                          else
1388                          begin
1389       1/1                  if (end_frame)
1390                            begin
1391       1/1                    pause_frame_transmitting   &lt;= 1'b0;
1392       1/1                    pfc_frame_transmitting     &lt;= 1'b0;
1393                            end
1394                            else
1395                            begin
1396       1/1                    pause_frame_transmitting   &lt;= pause_frame_transmitting;
1397       1/1                    pfc_frame_transmitting     &lt;= pfc_frame_transmitting;
1398                            end
1399       1/1                  tx_pause_zero_held        &lt;= tx_pause_zero_held;
1400       1/1                  tx_pfc_pri_held           &lt;= tx_pfc_pri_held;
1401       1/1                  tx_pfc_zero_held          &lt;= tx_pfc_zero_held;
1402                          end
1403                        end
1404                      end
1405                    
1406                      // Optional parity
1407                      generate if (p_edma_asf_dap_prot == 1) begin : gen_pfc_par
1408                        reg tx_pfc_pri_held_par_r;
1409                        reg pause_pfc_pri_vector_sched_par_r;
1410                        always@(posedge tx_clk or negedge n_txreset)
1411                        begin
1412                          if (~n_txreset)
1413                          begin
1414                            pause_pfc_pri_vector_sched_par_r  &lt;= 1'b0;
1415                            tx_pfc_pri_held_par_r             &lt;= 1'b0;
1416                          end
1417                          else if (~en_transmit_sync)
1418                          begin
1419                            pause_pfc_pri_vector_sched_par_r  &lt;= 1'b0;
1420                            tx_pfc_pri_held_par_r             &lt;= 1'b0;
1421                          end
1422                          else if (pause_request)
1423                          begin
1424                            if (allow_pause)
1425                              tx_pfc_pri_held_par_r             &lt;= pause_pfc_pri_vector_par;
1426                            else
1427                              pause_pfc_pri_vector_sched_par_r  &lt;= pause_pfc_pri_vector_par;
1428                          end
1429                          else if (pause_request_sched &amp; allow_pause)
1430                            tx_pfc_pri_held_par_r &lt;= pause_pfc_pri_vector_sched_par_r;
1431                        end
1432                        assign tx_pfc_pri_held_par  = tx_pfc_pri_held_par_r;
1433                      end else begin : gen_no_pfc_par
1434                        assign tx_pfc_pri_held_par  = 1'b0;
1435                      end
1436                      endgenerate
1437                    
1438                    
1439                    
1440                    // Pausing of transmission
1441                    //------------------------
1442                    
1443                       // synchronise pause_enable from the network configuration register
1444                       // to tx_clk.
1445                       cdnsdru_datasync_v1 i_cdnsdru_datasync_v1_pause_enable (
1446                          .clk(tx_clk),
1447                          .reset_n(n_txreset),
1448                          .din(pause_enable),
1449                          .dout(pause_enable_sync));
1450                    
1451                       // synchronise new_pause_tog from gem_rx to tx_clk.
1452                       edma_sync_toggle_detect i_edma_sync_toggle_detect_new_pause_tog (
1453                          .clk(tx_clk),
1454                          .reset_n(n_txreset),
1455                          .din(new_pause_tog),
1456                          .rise_edge(),
1457                          .fall_edge(),
1458                          .any_edge(load_new_pause_time));
1459                    
1460                    
1461                       // decrement the pause time counter whenever it is non-zero
1462                       // providing gem_tx has indicated that transmission has paused.
1463                       assign decrement_pause_time = ~pause_time_zero_dec &amp; tx_paused;
1464                    
1465                    
1466                       // preset pause quantum counter whenever a new pause time value
1467                       // is loaded or when the pause time counter is decremented.
1468                       assign preset_count_512 = load_new_pause_time |
1469                                                 (decrement_pause_time &amp; (count_512 == 7'h00));
1470                    
1471                    
1472                       // counter for pause quantum.
1473                       always@(posedge tx_clk or negedge n_txreset)
1474                       begin
1475       1/1                if(~n_txreset)
1476                             // asynchronous reset.
1477       1/1                   count_512 &lt;= 7'h00;
1478       1/1                else if (~en_transmit_sync)
1479                             // synchronous reset (from software).
1480       1/1                   count_512 &lt;= 7'h00;
1481       1/1                else if (~pause_enable_sync)
1482                             // disable pause for reception.
1483       1/1                   count_512 &lt;= 7'h00;
1484       <font color = "red">0/1     ==>        else if (preset_count_512 &amp; tx_byte_mode)</font>
1485                             // load bit time count in tx_byte_mode.
1486       <font color = "red">0/1     ==>           count_512 &lt;= 7'h3f;  // 64 tx_clks in byte mode.</font>
1487       <font color = "red">0/1     ==>        else if (preset_count_512)</font>
1488                             // load bit time count in 10/100 mode.
1489       <font color = "red">0/1     ==>           count_512 &lt;= 7'h7f;  // 128 tx_clks in nibble mode.</font>
1490       <font color = "red">0/1     ==>        else if (decrement_pause_time)</font>
1491                             // count down if pause_time is non-zero.
1492       <font color = "red">0/1     ==>           count_512 &lt;= count_512 - 7'h01;</font>
1493                          else
1494                             // hold count once zero.
1495       <font color = "red">0/1     ==>           count_512 &lt;= count_512;</font>
1496                       end
1497                    
1498                    
1499                       // Update and decrement pause time register (next value).
1500                       // Also indicate when pause timer is changing value so pclk can be updated.
1501                       always@(en_transmit_sync or pause_enable_sync or load_new_pause_time or
1502                               new_pause_time or decrement_pause_time or retry_test_sync1 or
1503                               count_512 or tx_pause_time_cnt)
1504                       begin
1505       1/1                if (~en_transmit_sync)
1506                             begin
1507                                // synchronous reset (from software).
1508       1/1                      tx_pause_tim_cnt_nxt = 16'h0000;
1509       1/1                      tx_pause_time_change = 1'b0;
1510                             end
1511       1/1                else if (~pause_enable_sync)
1512                             begin
1513                                // disable pause for reception.
1514       1/1                      tx_pause_tim_cnt_nxt = 16'h0000;
1515       1/1                      tx_pause_time_change = 1'b0;
1516                             end
1517       <font color = "red">0/1     ==>        else if (load_new_pause_time)</font>
1518                             begin
1519                                // new pause quantum received from rx.
1520       <font color = "red">0/1     ==>              tx_pause_tim_cnt_nxt = new_pause_time;</font>
1521       <font color = "red">0/1     ==>              tx_pause_time_change = 1'b1;</font>
1522                             end
1523       <font color = "red">0/1     ==>        else if (decrement_pause_time &amp; retry_test_sync1)</font>
1524                             begin
1525                                // test mode, decrement every clock until zero.
1526       <font color = "red">0/1     ==>              tx_pause_tim_cnt_nxt = tx_pause_time_cnt - 16'h0001;</font>
1527       <font color = "red">0/1     ==>              tx_pause_time_change = 1'b1;</font>
1528                             end
1529       <font color = "red">0/1     ==>        else if (decrement_pause_time &amp; (count_512 == 7'h00))</font>
1530                             begin
1531                                // decrement every 512 bit times
1532       <font color = "red">0/1     ==>              tx_pause_tim_cnt_nxt = tx_pause_time_cnt - 16'h0001;</font>
1533       <font color = "red">0/1     ==>              tx_pause_time_change = 1'b1;</font>
1534                             end
1535                          else
1536                             begin
1537                                // hold pause count at zero.
1538       <font color = "red">0/1     ==>              tx_pause_tim_cnt_nxt = tx_pause_time_cnt;</font>
1539       <font color = "red">0/1     ==>              tx_pause_time_change = 1'b0;</font>
1540                             end
1541                       end
1542                    
1543                       // update and decrement pause time register (current value).
1544                       always@(posedge tx_clk or negedge n_txreset)
1545                       begin
1546       1/1                if(~n_txreset)
1547       1/1                   tx_pause_time_cnt &lt;= 16'h0000;
1548                          else
1549       1/1                   tx_pause_time_cnt &lt;= tx_pause_tim_cnt_nxt;
1550                       end
1551                    
1552                    
1553                       // decode when pause timer reaches zero
1554                       assign pause_time_zero_dec = (tx_pause_time_cnt == 16'h0000);
1555                    
1556                    
1557                       // EEE stuff
1558                       // Need to pause transmission after deassertion of tx_lpi_en.
1559                       // Load system wake time from tw_sys_tx_time register into sys_waking
1560                       // counter on assertion of tx_lpi_en and then count down after deassertion.
1561                       // The value loaded is multiplied by 8 and decremented every tx_clk cycle.
1562                       // This means tw_sys_tx_time counts 64ns periods (8 * 8ns) in gigabit mode,
1563                       // 320ns periods (8 * 40ns) in 100M mode and 3200ns periods at 10M.
1564                       // Transmission will be paused until sys_waking counter reaches zero.
1565                       always@(posedge tx_clk or negedge n_txreset)
1566                       begin
1567       1/1                if(~n_txreset)
1568                             // asynchronous reset.
1569       1/1                   sys_waking &lt;= 19'h00000;
1570                             // do not reset on ~en_transmit_sync - user might want to disable transmit along with asserting and deasserting tx_lpi_en
1571       1/1                else if (tx_lpi_en_sync)
1572                             // load wake time.
1573       <font color = "red">0/1     ==>           sys_waking &lt;= {tw_sys_tx_time,3'h0};</font>
1574       1/1                else if (sys_waking != 19'h00000)
1575       <font color = "red">0/1     ==>           sys_waking &lt;= sys_waking - 19'h00001;</font>
1576                          else
1577                             // hold count once zero.
1578       1/1                   sys_waking &lt;= sys_waking;
1579                       end
1580                    
1581                       // pause_tx set when pause is enabled and the pause time counter
1582                       // is non-zero. this signal stops gem_tx commencing a new frame
1583                       // transmission whilst the counter is set, although any currently
1584                       // executing frames will be completed.
1585                       // Also pause transmission when sys_waking is non zero or tx_lpi_en is active
1586                       assign pause_tx = (pause_enable_sync &amp; ~pause_time_zero_dec) || (sys_waking != 19'h00000) || tx_lpi_en_sync;
1587                    
1588                    
1589                    
1590                       // tx_pause_time_tog indication to register block.
1591                       // Indication is sent whenever a new pause frame is received or when the
1592                       // pause timer decrements.
1593                       always@(posedge tx_clk or negedge n_txreset)
1594                       begin
1595       1/1                if(~n_txreset)
1596                             begin
1597                                // asynchronous reset.
1598       1/1                      tx_pause_time_tog    &lt;= 1'b0;
1599       1/1                      tx_pause_time        &lt;= 16'h0000;
1600       1/1                      tx_pause_tog_in_prog &lt;= 1'b0;
1601       1/1                      tx_pause_tog_pending &lt;= 1'b0;
1602                             end
1603       1/1                else if (~en_transmit_sync | ~pause_enable_sync)
1604                             begin
1605                                // synchronous reset or pause disabled for reception.
1606       1/1                      tx_pause_time_tog    &lt;= tx_pause_time_tog;
1607       1/1                      tx_pause_time        &lt;= 16'h0000;
1608       1/1                      tx_pause_tog_in_prog &lt;= 1'b0;
1609       1/1                      tx_pause_tog_pending &lt;= 1'b0;
1610                             end
1611       <font color = "red">0/1     ==>        else if (pause_tog_ack_edge &amp; (tx_pause_tog_pending |</font>
1612                                                         tx_pause_time_change))
1613                             begin
1614                                // acknowledge seen and have new change pending
1615       <font color = "red">0/1     ==>              tx_pause_time_tog    &lt;= ~tx_pause_time_tog;</font>
1616       <font color = "red">0/1     ==>              tx_pause_time        &lt;= tx_pause_tim_cnt_nxt;</font>
1617       <font color = "red">0/1     ==>              tx_pause_tog_in_prog &lt;= 1'b1;</font>
1618       <font color = "red">0/1     ==>              tx_pause_tog_pending &lt;= 1'b0;</font>
1619                             end
1620       <font color = "red">0/1     ==>        else if (pause_tog_ack_edge)</font>
1621                             begin
1622                                // acknowledge seen and no new change pending
1623       <font color = "red">0/1     ==>              tx_pause_time_tog    &lt;= tx_pause_time_tog;</font>
1624       <font color = "red">0/1     ==>              tx_pause_time        &lt;= tx_pause_time;</font>
1625       <font color = "red">0/1     ==>              tx_pause_tog_in_prog &lt;= 1'b0;</font>
1626       <font color = "red">0/1     ==>              tx_pause_tog_pending &lt;= 1'b0;</font>
1627                             end
1628       <font color = "red">0/1     ==>        else if (tx_pause_time_change &amp; ~tx_pause_tog_in_prog)</font>
1629                             begin
1630                                // signal new pause time value to pclk
1631       <font color = "red">0/1     ==>              tx_pause_time_tog    &lt;= ~tx_pause_time_tog;</font>
1632       <font color = "red">0/1     ==>              tx_pause_time        &lt;= tx_pause_tim_cnt_nxt;</font>
1633       <font color = "red">0/1     ==>              tx_pause_tog_in_prog &lt;= 1'b1;</font>
1634       <font color = "red">0/1     ==>              tx_pause_tog_pending &lt;= 1'b0;</font>
1635                             end
1636       <font color = "red">0/1     ==>        else if (tx_pause_time_change)</font>
1637                             begin
1638                                // new pause time but busy, store as pending
1639       <font color = "red">0/1     ==>              tx_pause_time_tog    &lt;= tx_pause_time_tog;</font>
1640       <font color = "red">0/1     ==>              tx_pause_time        &lt;= tx_pause_time;</font>
1641       <font color = "red">0/1     ==>              tx_pause_tog_in_prog &lt;= 1'b1;</font>
1642       <font color = "red">0/1     ==>              tx_pause_tog_pending &lt;= 1'b1;</font>
1643                             end
1644                          else
1645                             begin
1646                                // maintain values
1647       <font color = "red">0/1     ==>              tx_pause_time_tog    &lt;= tx_pause_time_tog;</font>
1648       <font color = "red">0/1     ==>              tx_pause_time        &lt;= tx_pause_time;</font>
1649       <font color = "red">0/1     ==>              tx_pause_tog_in_prog &lt;= tx_pause_tog_in_prog;</font>
1650       <font color = "red">0/1     ==>              tx_pause_tog_pending &lt;= tx_pause_tog_pending;</font>
1651                             end
1652                       end
1653                    
1654                    
1655                       // synchronise tx_pause_time_tog acknowledge from registers.
1656                       edma_sync_toggle_detect i_edma_sync_toggle_detect_ (
1657                          .clk(tx_clk),
1658                          .reset_n(n_txreset),
1659                          .din(tx_pause_tog_ack),
1660                          .rise_edge(),
1661                          .fall_edge(),
1662                          .any_edge(pause_tog_ack_edge));
1663                    
1664                    
1665                    
1666                       // generate fifo_underrun until end of frame.
1667                       always@(posedge tx_clk or negedge n_txreset)
1668                       begin
1669       1/1                if (~n_txreset)
1670                             // asynchronous reset.
1671       1/1                   fifo_underrun     &lt;= 1'b0;
1672       1/1                else if (~en_transmit_sync)
1673                             // synchronous reset (from software).
1674       1/1                   fifo_underrun     &lt;= 1'b0;
1675       1/1                else if (underflow)
1676                             // fifo_underrun condition is not detected
1677                             // during pause frame transmission.
1678       <font color = "red">0/1     ==>           fifo_underrun     &lt;= 1'b1;</font>
1679       1/1                else if (end_frame)
1680                             // clear flag at end of frame.
1681       1/1                   fifo_underrun     &lt;= 1'b0;
1682                          else
1683                             // hold flag state until end of frame.
1684       1/1                   fifo_underrun     &lt;= fifo_underrun;
1685                       end
1686                    
1687                    
1688                       // generate fifo_err_underrun until end of frame.
1689                       // Used to force correct status report depending if underflow was caused
1690                       // by tx_r_err asserted or tx_r_underflow.
1691                       always@(posedge tx_clk or negedge n_txreset)
1692                       begin
1693       1/1                if (~n_txreset)
1694                             // asynchronous reset.
1695       1/1                   fifo_err_underrun     &lt;= 1'b0;
1696       1/1                else if (~en_transmit_sync)
1697                             // synchronous reset (from software).
1698       1/1                   fifo_err_underrun     &lt;= 1'b0;
1699       1/1                else if (err_underflow)
1700                             // fifo_err_underrun condition is not detected
1701                             // during pause frame transmission.
1702       <font color = "red">0/1     ==>           fifo_err_underrun     &lt;= 1'b1;</font>
1703       1/1                else if (end_frame)
1704                             // clear flag at end of frame.
1705       1/1                   fifo_err_underrun     &lt;= 1'b0;
1706                          else
1707                             // hold flag state until end of frame.
1708       1/1                   fifo_err_underrun     &lt;= fifo_err_underrun;
1709                       end
1710                    
1711                    
1712                       // synchronize tx_lpi_en for metastability.
1713                       cdnsdru_datasync_v1 i_cdnsdru_datasync_v1_tx_lpi_en (
1714                          .clk(tx_clk),
1715                          .reset_n(n_txreset),
1716                          .din(tx_lpi_en),
1717                          .dout(tx_lpi_en_sync));
1718                    
1719                    
1720                       // assert txd output. txd contains either nibble or
1721                       // byte data depending on the mode. assert tx_en output
1722                       // derived from mac_tx_state block. assert tx_er with
1723                       // tx_en during tx fifo underrun.
1724                       always@(posedge tx_clk or negedge n_txreset)
1725                       begin
1726       1/1                if (~n_txreset)
1727                             // asynchronous reset.
1728                             begin
1729       1/1                      txd     &lt;= 8'h00;
1730       1/1                      tx_en   &lt;= 1'b0;
1731       1/1                      tx_er   &lt;= 1'b0;
1732                             end
1733       1/1                else if (tx_lpi_en_sync)
1734                             begin
1735       <font color = "red">0/1     ==>              txd     &lt;= 8'h01;</font>
1736       <font color = "red">0/1     ==>              tx_en   &lt;= 1'b0;</font>
1737       <font color = "red">0/1     ==>              tx_er   &lt;= 1'b1;</font>
1738                             end
1739                          else
1740                             // mii/gmii registered outputs from module.
1741                             begin
1742       1/1                      txd     &lt;= txd_next[7:0];
1743       1/1                      tx_en   &lt;= tx_en_next | bp_active;
1744       1/1                      tx_er   &lt;= tx_er_next;
1745                             end
1746                       end
1747                    
1748                       generate if (p_edma_asf_dap_prot == 1) begin : gen_txd_par
1749                         reg  txd_par_r;
1750                         always@(posedge tx_clk or negedge n_txreset)
1751                         begin
1752                          if (~n_txreset)
1753                            txd_par_r &lt;= 1'b0;
1754                          else if (tx_lpi_en_sync)
1755                            txd_par_r &lt;= 1'b1;
1756                          else
1757                            txd_par_r &lt;= txd_next[8];
1758                         end
1759                         assign txd_par = txd_par_r;
1760                       end else begin : gen_no_txd_par
1761                         assign txd_par = 1'b0;
1762                       end
1763                       endgenerate
1764                    
1765                       always@(posedge tx_clk or negedge n_txreset)
1766                       begin
1767       1/1                if (~n_txreset)
1768                          begin
1769       1/1                   frame_size_buf &lt;= 14'h0000;
1770       1/1                   txd_frame_size &lt;= 14'h0000;
1771                          end
1772                          else
1773                          begin
1774       1/1                  if (tx_r_sop)
1775       1/1                    frame_size_buf &lt;= tx_r_frame_size_mux;
                        MISSING_ELSE
1776       1/1                  txd_frame_size &lt;= frame_size_buf;
1777                          end
1778                       end
1779                    
1780                       always@(posedge tx_clk or negedge n_txreset)
1781                       begin
1782       1/1                if (~n_txreset)
1783                             // asynchronous reset.
1784       1/1                   mac_txing_dma_frame &lt;= 1'b0;
1785       1/1                else if (tx_lpi_en_sync)
1786       <font color = "red">0/1     ==>           mac_txing_dma_frame &lt;= 1'b0;</font>
1787       1/1                else if (bp_active)
1788       <font color = "red">0/1     ==>           mac_txing_dma_frame &lt;= 1'b0;</font>
1789                          else
1790       1/1                   mac_txing_dma_frame &lt;= (tx_en_next &amp; txd_rdy &amp; ~pfc_or_pause_frame_transmitting) | (interframe_gap &amp; ifg_eats_qav_credit);
1791                       end
1792                    
1793                    
1794                       // synchronize dma_tx_status_tog for metastability. This signal
1795                       // toggles each time the dma block has taken frame status
1796                       // information and is used by the tx module to reset the status
1797                       // outputs following resynchronization.
1798                       edma_sync_toggle_detect i_edma_sync_toggle_detect_dma_tx_status_tog (
1799                          .clk(tx_clk),
1800                          .reset_n(n_txreset),
1801                          .din(dma_tx_status_tog),
1802                          .rise_edge(),
1803                          .fall_edge(),
1804                          .any_edge(dma_status_edge));
1805                    
1806                    
1807                       // synchronise tx_status_wr_tog for metastability. This signal
1808                       // toggles each time the registers block has taken frame status
1809                       // information and is used by the tx module to reset the status
1810                       // outputs following resynchronization.
1811                       edma_sync_toggle_detect i_edma_sync_toggle_detect_tx_status_wr_tog (
1812                          .clk(tx_clk),
1813                          .reset_n(n_txreset),
1814                          .din(tx_status_wr_tog),
1815                          .rise_edge(),
1816                          .fall_edge(),
1817                          .any_edge(tx_status_edge));
1818                    
1819                    
1820                       // work out how many bytes are valid in new transmit data.
1821                       // tx_r_mod only valid when set with tx_r_eop and tx_r_mod.
1822                       // otherwise data size determined by dma_bus_width.
1823                       always@(tx_r_valid or tx_r_eop or tx_r_mod or dma_bus_width)
1824                       begin
1825       1/1                if (tx_r_valid &amp; tx_r_eop)
1826       1/1                   case (dma_bus_width[1:0])
1827                                // 32-bit transmit data bus.
1828                                2'b00: begin
1829       1/1                                if ((tx_r_mod[1:0] == 2'b00)) // 4 bytes valid.
1830       1/1                                   no_of_valid_bytes = 5'b00100;
1831                                          else // 1-3 bytes valid.
1832       1/1                                   no_of_valid_bytes = {3'b000,tx_r_mod[1:0]};
1833                                       end
1834                                // 64-bit transmit data bus.
1835                                2'b01: begin
1836       <font color = "red">0/1     ==>                        if (tx_r_mod[2:0] == 3'b000) // 8 bytes valid.</font>
1837       <font color = "red">0/1     ==>                           no_of_valid_bytes = 5'b01000;</font>
1838                                          else // 1-7 bytes valid.
1839       <font color = "red">0/1     ==>                           no_of_valid_bytes = {2'b00,tx_r_mod[2:0]};</font>
1840                                       end
1841                                // 128-bit transmit data bus.
1842                                default: begin
1843       <font color = "red">0/1     ==>                          if (tx_r_mod == 4'h0) // 16 bytes valid.</font>
1844       <font color = "red">0/1     ==>                             no_of_valid_bytes = 5'b10000;</font>
1845                                            else // 1-15 bytes valid.
1846       <font color = "red">0/1     ==>                             no_of_valid_bytes = {1'b0,tx_r_mod[3:0]};</font>
1847                                         end
1848                             endcase
1849       1/1                else if (tx_r_valid &amp; ~tx_r_eop)
1850       1/1                   case (dma_bus_width[1:0])
1851       1/1                      2'b00: no_of_valid_bytes   = 5'b00100;   // 32-bit data bus.
1852       <font color = "red">0/1     ==>              2'b01: no_of_valid_bytes   = 5'b01000;   // 64-bit data bus.</font>
1853       <font color = "red">0/1     ==>              default: no_of_valid_bytes = 5'b10000;   // 128-bit data bus.</font>
1854                             endcase
1855                          else
1856       1/1                   no_of_valid_bytes = 5'b00000;
1857                       end
1858                    
1859                    
1860                    
1861                    
1862                    generate if (p_edma_tsu == 1) begin : gen_tsu
1863                    
1864                       reg           ptp_cap_v1_long;         // indicates PTP version 1 TS may be inserted
1865                       reg           ptp_cap_v2_long;         // indicates PTP version 2 TS may be inserted
1866                       reg     [3:0] tx_ts_insert_count_ptp_r;
1867                       wire          tsu_timer_safe_to_sample_c; // Qualifer
1868                       reg           sof_tx_tog;                 // Toggle version of sof_tx
1869                       wire          sof_tx_sync;                // 2nd Sync flop for sof_tx (into tsu_clk)
1870                       reg           sof_tx_sync_d1;             // delayed flop for rising edge detect
1871                       wire          tx_sof_pclk;
1872                       reg           tx_ts_insert_ptp_v1_c;     // indicates PTP version 1 TS will be inserted
1873                       reg           tx_ts_insert_ptp_v2_c;     // indicates PTP version 2 TS will be inserted
1874                       reg           tx_ts_update_cor_fld_c;    // indicates PTP version 2 correction field will be updated
1875                    
1876                       // tx_clk domain outputs
1877                       wire          one_step_sync_mode_sync,oss_correction_field_sync_r,tx_sof_tsu;
1878                       reg    [77:0] tsu_ptp_tx_timer_out_r;
1879                       reg     [6:0] ptp_timestamp_position_latch; // latched timestamp position value
1880                       reg    [77:0] tx_r_timestamp_r;
1881                       reg    [55:0] correction_field;
1882                       reg    [48:0] correction_field_int;
1883                       wire   [47:0] cf_ns_reordered;
1884                       wire   [48:0] cf_ns_add_eg_ts;
1885                       reg    [49:0] eg_ts_sub_cf_ns;
1886                    
1887                    
1888                       always@(posedge tx_clk or negedge n_txreset)
1889                       begin
1890       1/1              if (~n_txreset)
1891                           begin
1892       1/1                    ptp_cap_v1_long &lt;= 1'b0;
1893       1/1                    ptp_cap_v2_long &lt;= 1'b0;
1894       1/1                    tx_ts_insert_count_ptp_r &lt;= 4'b0000;
1895                           end
1896       1/1              else if (~tx_en | ~en_transmit_sync)
1897                           begin
1898       1/1                    tx_ts_insert_count_ptp_r &lt;= 4'b0000;
1899       1/1                    ptp_cap_v1_long &lt;= 1'b0;
1900       1/1                    ptp_cap_v2_long &lt;= 1'b0;
1901                           end
1902                        else
1903                          begin
1904       1/1                    if (en_tx_ptp_count &amp; ~nibble_sel &amp; (data_type == TYPE_DATA))
1905                                begin
1906       1/1                        if (((tx_ts_insert_ptp_v1) || (tx_ts_insert_ptp_v2) || (tx_ts_update_cor_fld)))
1907                                    begin
1908                                      // this will only increment to a maximum of 4'b1001 at which point tx_ts_insert_ptp_v2 will go low
1909       <font color = "red">0/1     ==>                    tx_ts_insert_count_ptp_r &lt;= tx_ts_insert_count_ptp_r + 4'b0001;</font>
1910                                    end
                        MISSING_ELSE
1911                                end
                        MISSING_ELSE
1912       1/1                  if (ptp_timestamp_position_cap == 1'b1)
1913       <font color = "red">0/1     ==>             ptp_cap_v2_long &lt;= 1'b1;</font>
                        MISSING_ELSE
1914                    
1915       1/1                  if (ptp_timestamp_position_cap_v1 == 1'b1)
1916       <font color = "red">0/1     ==>             ptp_cap_v1_long &lt;= 1'b1;</font>
                        MISSING_ELSE
1917                           end
1918                       end
1919                       assign tx_ts_insert_count_ptp  = tx_ts_insert_count_ptp_r;
1920                    
1921                      // capture timestamp bytes for ease of use later
1922                      // for PTP version 1 there is an 8B TS
1923                      // for PTP version 2 there is an 10B TS
1924                      // format in PTP TS format 48b sec, 32b nsec (ie top 2b of nsec = 2'b00)
1925                      assign tsu_ptp_tx_ts_latched = {tsu_timer_sampled_on_sof_safe[77:30], 2'b00, tsu_timer_sampled_on_sof_safe[29:0]};
1926                    
1927                      // reorder correction field bytes before doing addition because most significant byte of correction is transmitted first
1928                      assign cf_ns_reordered = {correction_field[7:0],correction_field[15:8],correction_field[23:16],correction_field[31:24],correction_field[39:32],correction_field[47:40]};
1929                    
1930                      // add egress time stamp nanoseconds to the correction field
1931                      assign cf_ns_add_eg_ts = cf_ns_reordered + {18'h00000,tsu_timer_sampled_on_sof_safe[29:0]};
1932                    
1933                      // subtract correction field from egress time stamp nanoseconds and add one billion if the seconds value has rolled over
1934                      // (correction_field[48] ^ tsu_timer_sampled_on_sof_safe[30]) indicates seconds bit roll-over
1935                      always @(*)
1936                      begin
1937       1/1              if (correction_field[48] ^ tsu_timer_sampled_on_sof_safe[30])
1938       <font color = "red">0/1     ==>        eg_ts_sub_cf_ns = {18'h00000,tsu_timer_sampled_on_sof_safe[29:0]} - cf_ns_reordered + 48'd1000000000;</font>
1939                        else
1940       1/1                eg_ts_sub_cf_ns = {2'd0,{{18'h00000,tsu_timer_sampled_on_sof_safe[29:0]} - cf_ns_reordered}};
1941                      end
1942                    
1943                    
1944                       always@(*)
1945                       begin
1946       1/1                if (correction_field[54])
1947                             // negative number indicated so subtract correction field from the egress timestamp
1948       <font color = "red">0/1     ==>           correction_field_int = {1'b0,eg_ts_sub_cf_ns[47:0]};</font>
1949       1/1                else if (correction_field[48] ^ tsu_timer_sampled_on_sof_safe[30])
1950                             // add an extra billion because the seconds value has rolled over
1951       <font color = "red">0/1     ==>           correction_field_int = cf_ns_add_eg_ts[47:0] + 48'd1000000000;</font>
1952                          else
1953                             // just do a simple addition
1954       1/1                   correction_field_int = {1'b0,cf_ns_add_eg_ts[47:0]};
1955                       end
1956                    
1957                       assign correction_field_new  = (correction_field[55] | correction_field_int[47]) ? 64'h7FFFFFFFFFFFFFFF
1958                                                                                                        : {correction_field_int[47:0],16'h0000};
1959                    
1960                      // In order to support single step timestamp insertion with maximum accuracy, the timstamp
1961                      // must be captured based on the tx_sof event, passed into the TSU clock. that way the timestamp
1962                      // can be accurately captured asap.  the captured TS must then be passed back to the TX clock for
1963                      // insertion into the timestamp.
1964                      // Timestamp location for PTPoE is offset 48 (34 of PTP frame + 14 ethernet header)
1965                      // It is &gt; than this for PTPoIP, so use PTPoE as worst case
1966                      // Minimum sized ethernet frame is 64bytes
1967                      // By enforcing the rule that TSU clock is &gt; 1/8th the frequency of TX_CLK, this allows for 6 TSU clocks
1968                      // to create a toggle signal on tx_sof, pass into TSU domain and sample the TS into a stable bank of registers.
1969                      // This final register bank will be stable for an entire frame, i.e. &gt;= 64 tx_clks. It will also be stable at
1970                      // the point this module needs to sample it for insertion into the frame, and it will be stable at the point
1971                      // gem_dma_pbuf_tx_rd.v needs to sample it on tx_r_eop.
1972                    
1973                      // first synchronize the SOF event to the TSU clock domain
1974                       cdnsdru_datasync_v1 i_cdnsdru_datasync_v1_sof_tx_tog (
1975                         .clk    (tsu_clk),
1976                         .reset_n(n_tsureset),
1977                         .din    (sof_tx_tog),
1978                         .dout   (sof_tx_sync)
1979                       );
1980                    
1981                      // register sof_tx_sync for edge detection
1982                      always@(posedge tsu_clk or negedge n_tsureset)
1983       1/1              if (~n_tsureset)
1984       1/1                sof_tx_sync_d1  &lt;= 1'b0;
1985                        else
1986       1/1                sof_tx_sync_d1  &lt;= sof_tx_sync;
1987                    
1988                      // detect the SOF event in TSU clock domain
1989                      assign tx_sof_tsu = sof_tx_sync_d1 ^ sof_tx_sync;
1990                    
1991                      // sample the time in TSU clock domain.  This will remain valid for an entire frame
1992                      // from sof_tx to next sof_tx
1993                      reg [77:0]  tsu_timer_sampled_on_sof_r;
1994                      always@(posedge tsu_clk or negedge n_tsureset)
1995                      begin
1996       1/1              if (~n_tsureset)
1997       1/1                tsu_timer_sampled_on_sof_r  &lt;= {78{1'b0}};
1998       1/1              else if (tx_sof_tsu)
1999       1/1                tsu_timer_sampled_on_sof_r  &lt;= tsu_timer_cnt[93:16];
                        MISSING_ELSE
2000                      end
2001                    
2002                      if (p_edma_asf_dap_prot == 1) begin : gen_tsu_par
2003                        reg [9:0] tsu_timer_par_sampled_on_sof_r;
2004                        reg [9:0] tsu_ptp_tx_timer_par_out_r;
2005                        reg [9:0] tx_r_timestamp_par_r;
2006                    
2007                        always@(posedge tsu_clk or negedge n_tsureset)
2008                        begin
2009                          if (~n_tsureset)
2010                            tsu_timer_par_sampled_on_sof_r  &lt;= {10{1'b0}};
2011                          else if (tx_sof_tsu)
2012                            tsu_timer_par_sampled_on_sof_r  &lt;= tsu_timer_cnt_par[11:2];
2013                        end
2014                    
2015                        always@(posedge pclk or negedge n_preset)
2016                        begin
2017                          if (~n_preset)
2018                            tsu_ptp_tx_timer_par_out_r  &lt;= {10{1'b0}};
2019                          else if (tx_sof_pclk)
2020                            tsu_ptp_tx_timer_par_out_r  &lt;= tsu_timer_par_sampled_on_sof_r;
2021                        end
2022                    
2023                        always@(posedge tx_clk or negedge n_txreset)
2024                        begin
2025                          if (~n_txreset)
2026                            tx_r_timestamp_par_r  &lt;= {10{1'b0}};
2027                          else if (~en_transmit_sync)
2028                            tx_r_timestamp_par_r  &lt;= {10{1'b0}};
2029                          else if (end_frame)
2030                            tx_r_timestamp_par_r  &lt;= tsu_timer_par_sampled_on_sof_safe;
2031                        end
2032                        assign tsu_timer_par_sampled_on_sof_safe = tsu_timer_par_sampled_on_sof_r &amp; {10{tsu_timer_safe_to_sample}};
2033                        assign tsu_ptp_tx_timer_par_out     = tsu_ptp_tx_timer_par_out_r;
2034                        assign tx_r_timestamp_par           = tx_r_timestamp_par_r;
2035                      end else begin : gen_no_tsu_par
2036                        assign tsu_timer_par_sampled_on_sof_safe = {10{1'b0}};
2037                        assign tsu_ptp_tx_timer_par_out     = {10{1'b0}};
2038                        assign tx_r_timestamp_par           = {10{1'b0}};
2039                      end
2040                    
2041                      edma_sync_toggle_detect i_edma_sync_toggle_detect_safe_to_sample (
2042                        .clk(tx_clk),
2043                        .reset_n(n_txreset),
2044                        .din(sof_tx_sync_d1),
2045                        .rise_edge(),
2046                        .fall_edge(),
2047                        .any_edge(tsu_timer_safe_to_sample_c));
2048                    
2049                       reg tsu_timer_safe_to_sample_r;
2050                       always@(posedge tx_clk or negedge n_txreset)
2051                       begin
2052       1/1                if (~n_txreset)
2053                             // asynchronous reset.
2054       1/1                  tsu_timer_safe_to_sample_r &lt;= 1'b0;
2055       1/1                else if (tsu_timer_safe_to_sample_c)
2056       1/1                  tsu_timer_safe_to_sample_r &lt;= 1'b1;
2057       1/1                else if (data_type == TYPE_SFD)
2058       1/1                  tsu_timer_safe_to_sample_r &lt;= 1'b0;
                        MISSING_ELSE
2059                       end
2060                       assign tsu_timer_safe_to_sample = tsu_timer_safe_to_sample_r;
2061                       assign tsu_timer_sampled_on_sof_safe = tsu_timer_sampled_on_sof_r &amp; {78{tsu_timer_safe_to_sample_r}};
2062                    
2063                      // Now synchonize to pclk
2064                      edma_sync_toggle_detect i_edma_sync_toggle_detect_sof_tx_sync_d1 (
2065                        .clk(pclk),
2066                        .reset_n(n_preset),
2067                        .din(sof_tx_sync_d1),
2068                        .rise_edge(),
2069                        .fall_edge(),
2070                        .any_edge(tx_sof_pclk));
2071                    
2072                      always@(posedge pclk or negedge n_preset)
2073                      begin
2074       1/1              if (~n_preset)
2075       1/1                tsu_ptp_tx_timer_out_r  &lt;= {78{1'b0}};
2076       1/1              else if (tx_sof_pclk)
2077       1/1                tsu_ptp_tx_timer_out_r  &lt;= tsu_timer_sampled_on_sof_r;
                        MISSING_ELSE
2078                      end
2079                    
2080                      // generate delayed signals
2081                       cdnsdru_datasync_v1 i_cdnsdru_datasync_v1_one_step_sync_mode (
2082                          .clk(tx_clk),
2083                          .reset_n(n_txreset),
2084                          .din(one_step_sync_mode),
2085                          .dout(one_step_sync_mode_sync));
2086                    
2087                       cdnsdru_datasync_v1 i_cdnsdru_datasync_v1_oss_correction_field (
2088                          .clk(tx_clk),
2089                          .reset_n(n_txreset),
2090                          .din(oss_correction_field),
2091                          .dout(oss_correction_field_sync_r));
2092                    
2093                       // mark position for TS insertion for 10 bytes which is maximum no of TS bytes
2094                       // (where TS is 10 bytes for ptp version 2, and 8 bytes for ptp version 1)
2095                       // the _early signal compares one count less (ie no_of_valid_bytes less)
2096                       // and is then registered to improve timing
2097                       wire [7:0] ptp_ts_position_latch_p10;
2098                       wire [7:0] ptp_ts_position_latch_p8;
2099                    
2100                       assign ptp_ts_position_latch_p10 = ptp_timestamp_position_latch + 7'd10;
2101                       assign ptp_ts_position_latch_p8  = ptp_timestamp_position_latch + 7'd8;
2102                    
2103                       always@(*)
2104                       begin
2105                          // identify bytes to be replaced
2106                    
2107       1/1                if ((tx_ptp_count &gt;= ptp_timestamp_position_latch) &amp;
2108                              (tx_ptp_count &lt; ptp_ts_position_latch_p8[6:0]))
2109                    
2110       <font color = "red">0/1     ==>           tx_ts_insert_ptp_v1_c = (ptp_cap_v1_long &amp; one_step_sync_mode_sync);</font>
2111                          else
2112       1/1                   tx_ts_insert_ptp_v1_c = 1'b0;
2113                    
2114       1/1                if ((tx_ptp_count &gt;= ptp_timestamp_position_latch) &amp;
2115                              (tx_ptp_count &lt; ptp_ts_position_latch_p10[6:0]))
2116                    
2117       <font color = "red">0/1     ==>           tx_ts_insert_ptp_v2_c = (ptp_cap_v2_long &amp; one_step_sync_mode_sync);</font>
2118                          else
2119       1/1                   tx_ts_insert_ptp_v2_c = 1'b0;
2120                    
2121       1/1                if ((tx_ptp_count &gt;= (ptp_timestamp_position_latch - 7'd26)) &amp;
2122                              (tx_ptp_count &lt; (ptp_timestamp_position_latch - 7'd18)))
2123                    
2124       <font color = "red">0/1     ==>           tx_ts_update_cor_fld_c = (ptp_cap_v2_long &amp; oss_correction_field_sync_r);</font>
2125                          else
2126       1/1                   tx_ts_update_cor_fld_c = 1'b0;
2127                       end
2128                       assign tx_ts_insert_ptp_v1 = tx_ts_insert_ptp_v1_c;
2129                       assign tx_ts_insert_ptp_v2 = tx_ts_insert_ptp_v2_c;
2130                       assign tx_ts_update_cor_fld= tx_ts_update_cor_fld_c;
2131                    
2132                       always@(posedge tx_clk or negedge n_txreset)
2133                         begin
2134       1/1                if (~n_txreset)
2135                             begin
2136       1/1                      sof_tx_tog &lt;= 1'b0;
2137                             end
2138       1/1                else if (~tx_en | ~en_transmit_sync)
2139                             begin
2140       1/1                      sof_tx_tog &lt;= sof_tx_tog;
2141                             end
2142       1/1                else if (data_type == TYPE_SFD)
2143                             begin
2144       1/1                      sof_tx_tog &lt;= ~sof_tx_tog;
2145                             end
                        MISSING_ELSE
2146                         end
2147                    
2148                       // Determine location of timestamp in PTP sync frame in units of tx_ptp_count
2149                       // set value to maximum at sof to avoid early tx_ts_insert being active early
2150                       wire [7:0] ptp_timestamp_position_latch_p34;
2151                       wire [7:0] ptp_timestamp_position_latch_p8;
2152                       assign ptp_timestamp_position_latch_p34 = ptp_timestamp_position + 7'd34;
2153                       assign ptp_timestamp_position_latch_p8  = ptp_timestamp_position + 7'd8;
2154                    
2155                       always@(posedge tx_clk or negedge n_txreset)
2156                         begin
2157       1/1                if (~n_txreset)
2158                             begin
2159       1/1                     ptp_timestamp_position_latch  &lt;= 7'h7f;
2160                             end
2161                    
2162                          else
2163       1/1                  if (ptp_timestamp_position_cap) // sync frame is recognized at the messageType field for version 2
2164                               begin
2165                                 // ptp version 2 insertion point is 34 bytes after messageType field
2166       <font color = "red">0/1     ==>               ptp_timestamp_position_latch  &lt;= ptp_timestamp_position_latch_p34[6:0];</font>
2167                               end
2168                    
2169       1/1                  else if (ptp_timestamp_position_cap_v1) // sync frame is recognized at the control field for version 1
2170                               begin
2171                                 // ptp version 1 insertion point is 8 bytes after control field
2172       <font color = "red">0/1     ==>               ptp_timestamp_position_latch  &lt;= ptp_timestamp_position_latch_p8[6:0];</font>
2173                               end
2174                    
2175       1/1                  else if (start_frame)
2176                               begin
2177       1/1                       ptp_timestamp_position_latch  &lt;= 7'h7f;
2178                               end
2179                            else
2180                               begin
2181       1/1                       ptp_timestamp_position_latch  &lt;= ptp_timestamp_position_latch;
2182                               end
2183                         end
2184                    
2185                       always@(posedge tx_clk or negedge n_txreset)
2186                       begin
2187       1/1                if (~n_txreset)
2188                            // asynchronous reset.
2189       1/1                  tx_r_timestamp_r         &lt;= {78{1'b0}};
2190       1/1                else if (~en_transmit_sync)
2191                            // synchronous reset (from software).
2192       1/1                  tx_r_timestamp_r         &lt;= {78{1'b0}};
2193       1/1                else if (end_frame)
2194                            // this is actually a clock boundary, but is safe as tsu_timer_cnt will always be stable at this point
2195       1/1                  tx_r_timestamp_r         &lt;= tsu_timer_sampled_on_sof_safe;
                        MISSING_ELSE
2196                       end
2197                    
2198                       // Seven bytes of the correction field need to be captured from transmit_data_buf. Six bytes represent the nanosecond value
2199                       // and the least significant byte contains the least significant second bit from the ingress time stamp of the sync frame.
2200                       // The correction field is captured 27 bytes before where the egress timestamp is situated as indicated by ptp_timestamp_position_latch
2201                       always@(posedge tx_clk or negedge n_txreset)
2202                         begin
2203       1/1                if (~n_txreset)
2204                             begin
2205       1/1                      correction_field &lt;= {56{1'b0}};
2206                             end
2207       1/1                else if ((tx_ptp_count == (ptp_timestamp_position_latch - 7'd27)) &amp; sync_frame_tx)
2208                             begin
2209       <font color = "red">0/1     ==>              correction_field &lt;= transmit_data_buf[63:8];</font>
2210                             end
                        MISSING_ELSE
2211                         end
2212                    
2213                       assign oss_correction_field_sync = oss_correction_field_sync_r;
2214                       assign tsu_ptp_tx_timer_out      = tsu_ptp_tx_timer_out_r;
2215                       assign tx_r_timestamp            = tx_r_timestamp_r;
2216                    
2217                      ////////////////////////////////////////////////
2218                    
2219                    end else begin : gen_no_tsu
2220                       assign oss_correction_field_sync = 1'b0;
2221                       assign tsu_ptp_tx_timer_out      = {78{1'b0}};
2222                       assign tsu_ptp_tx_timer_par_out  = {10{1'b0}};
2223                       assign tx_r_timestamp            = {78{1'b0}};
2224                       assign tx_r_timestamp_par        = {10{1'b0}};
2225                       assign tsu_timer_sampled_on_sof_safe  = {78{1'b0}};
2226                       assign tsu_timer_par_sampled_on_sof_safe = {10{1'b0}};
2227                       assign tsu_ptp_tx_ts_latched     = {80{1'b0}};
2228                       assign tsu_timer_safe_to_sample  = 1'b0;
2229                       assign correction_field_new      = {64{1'b0}};
2230                       assign tx_ts_insert_ptp_v1       = 1'b0;
2231                       assign tx_ts_insert_ptp_v2       = 1'b0;
2232                       assign tx_ts_update_cor_fld      = 1'b0;
2233                       assign tx_ts_insert_count_ptp    = 4'h0;
2234                    end
2235                    endgenerate
2236                    
2237                    
2238                       // unused parts of transmit data bus tied to logic 0.
2239                       always@(dma_bus_width or tx_r_data or tx_r_par)
2240                       begin
2241       1/1                case (dma_bus_width)
2242                             // 32-bit dma bus
2243                             2'b00: begin
2244       1/1                            transmit_par  = { 12'd0, tx_r_par[3:0]};        // drop and pass some of the parity
2245       1/1                            transmit_data = { 96'd0, tx_r_data[31:0]};
2246                                    end
2247                             // 64-bit dma bus
2248                             2'b01: begin
2249       <font color = "red">0/1     ==>                    transmit_par  = { 8'd0, tx_r_par[7:0]};         // drop and pass some of the parity</font>
2250       <font color = "red">0/1     ==>                    transmit_data = { 64'd0, tx_r_data[63:0]};</font>
2251                                    end
2252                             // 128-bit dma bus
2253                             default: begin
2254       <font color = "red">0/1     ==>                      transmit_par  = tx_r_par[15:0];</font>
2255       <font color = "red">0/1     ==>                      transmit_data = tx_r_data[127:0];</font>
2256                                      end
2257                          endcase
2258                       end
2259                    
2260                    
2261                       // store number of bytes for first transfer of frame. This
2262                       // is required as the previous frame is still propagating
2263                       // through the tx and a new frame must be queued prior to
2264                       // the end of frame trigger.
2265                       always@(posedge tx_clk or negedge n_txreset)
2266                       begin
2267       1/1                if (~n_txreset)
2268                             // asynchronous reset.
2269       1/1                   new_frame_bytes &lt;= 5'h00;
2270       1/1                else if (~en_transmit_sync)
2271                             // synchronous reset (from software).
2272       1/1                   new_frame_bytes &lt;= 5'h00;
2273       1/1                else if (tx_r_valid &amp; tx_r_sop)
2274                             // first valid word of frame following tx_r_data_rdy.
2275       1/1                   new_frame_bytes &lt;= no_of_valid_bytes;
2276                          else
2277                             // hold the value from one frame to the next.
2278       1/1                   new_frame_bytes &lt;= new_frame_bytes;
2279                       end
2280                    
2281                    
2282                       // register tx_no_crc at start of packet.
2283                       always@(posedge tx_clk or negedge n_txreset)
2284                       begin
2285       1/1                if (~n_txreset)
2286                             // asynchronous reset.
2287       1/1                   tx_no_crc_sop &lt;= 1'b0;
2288       1/1                else if (~en_transmit_sync | collision_int | late_coll_occured |
2289                                   too_many_retries | fifo_underrun | stat_underflow_pend)
2290                             // synchronous reset (from software).
2291       1/1                   tx_no_crc_sop &lt;= 1'b0;
2292       1/1                else if (tx_r_valid &amp; tx_r_sop)
2293                             // tx_no_crc is registered with sop for use with the
2294                             // exposed fifo interface. It is assigned to bit[0] of tx_r_control
2295       1/1                   tx_no_crc_sop &lt;= tx_r_control;
2296                          else
2297                             // hold value from one frame to the next.
2298       1/1                   tx_no_crc_sop &lt;= tx_no_crc_sop;
2299                       end
2300                    
2301                       // register tx_no_crc at start of frame.
2302                       always@(posedge tx_clk or negedge n_txreset)
2303                       begin
2304       1/1                if (~n_txreset)
2305                             // asynchronous reset.
2306       1/1                   tx_no_crc_held &lt;= 1'b0;
2307       1/1                else if (~en_transmit_sync | collision_int | late_coll_occured |
2308                                   too_many_retries | fifo_underrun | stat_underflow_pend)
2309                             // synchronous reset (from software).
2310       1/1                   tx_no_crc_held &lt;= 1'b0;
2311       1/1                else if (start_frame)
2312                             // tx_no_crc_held is registered with start_frame. this is required
2313                             // as new frame is read from fifo interface prior to decision
2314                             // in main tx state machine on whether the frame currently being
2315                             // transmitted should include crc. hence tx_no_crc_held will
2316                             // not be updated until new frame commences transmission.
2317       1/1                   tx_no_crc_held &lt;= tx_no_crc_sop;
2318                          else
2319                             // hold value from one frame to the next.
2320       1/1                   tx_no_crc_held &lt;= tx_no_crc_held;
2321                       end
2322                    
2323                    
2324                       // only assign tx_no_crc for data frames, not pause frames.
2325                       assign tx_no_crc_valid = tx_no_crc_held &amp; ~pfc_or_pause_frame_transmitting;
2326                    
2327                    
2328                       // calculate number of stored bytes in transmit_data_buf.
2329                       always@(posedge tx_clk or negedge n_txreset)
2330                       begin
2331       1/1                if (~n_txreset)
2332                             // asynchronous reset.
2333                             begin
2334       1/1                     no_of_stored_bytes &lt;= 5'h00;
2335                             end
2336       1/1                else if (~en_transmit_sync | collision_int | late_coll_occured |
2337                                   too_many_retries | fifo_underrun | stat_underflow_pend)
2338                             // synchronous reset (from software) or exception.
2339                             begin
2340       1/1                     no_of_stored_bytes &lt;= 5'h00;
2341                             end
2342       1/1                else if (pfc_or_pause_frame_transmitting)
2343                             // store not used for tx of pause frames.
2344                             begin
2345       <font color = "red">0/1     ==>             no_of_stored_bytes &lt;= no_of_stored_bytes;</font>
2346                             end
2347       1/1                else if (start_frame)
2348                             // load new value at start of frame.
2349                             begin
2350       1/1                     no_of_stored_bytes &lt;= new_frame_bytes;
2351                             end
2352       1/1                else if (tx_r_valid &amp; last_read &amp; ~nibble_sel &amp; (data_type == TYPE_DATA))
2353                             // byte shift and load active at once, but last_read is blocking
2354                             // new data being loaded until next start_of_frame, so just shift.
2355                             begin
2356       <font color = "red">0/1     ==>             no_of_stored_bytes &lt;= no_of_stored_bytes - 5'h01;</font>
2357                             end
2358       1/1                else if (tx_r_valid &amp; ~last_read &amp; ~nibble_sel &amp; (data_type == TYPE_DATA))
2359                             // byte shift and load active at once, and last_read is not blocking
2360                             // new data being loaded, so shift &amp; load.
2361                             begin
2362       1/1                     no_of_stored_bytes &lt;= no_of_str_bytes_nxt[4:0] - 5'h01;
2363                             end
2364       1/1                else if (tx_r_valid &amp; ~last_read &amp; ((nibble_sel &amp; (data_type == TYPE_DATA)) | (data_type == TYPE_PREAMBLE) | (data_type == TYPE_HOLD)))
2365                             // no byte shift, but load active from tx fifo, and last_read is not
2366                             // blocking new data being loaded, so just load (10/100 mode only)
2367                             // also accommodate extra reads during pre-amble when doing single step update of the correction field
2368                             begin
2369       <font color = "red">0/1     ==>             no_of_stored_bytes &lt;= no_of_str_bytes_nxt[4:0];</font>
2370                             end
2371       1/1                else if (~tx_r_valid &amp; ~nibble_sel &amp; (data_type == TYPE_DATA) &amp; (no_of_stored_bytes != 5'h00))
2372                             // byte shift active, but no load from tx fifo, so just shift.
2373                             begin
2374       1/1                     no_of_stored_bytes    &lt;= no_of_stored_bytes - 5'h01;
2375                             end
2376                          else
2377                             // no byte shift or load from tx fifo.
2378                             begin
2379       1/1                     no_of_stored_bytes    &lt;= no_of_stored_bytes;
2380                             end
2381                       end
2382                    
2383                    
2384                       // calculate last data byte in transmit_data_buf
2385                       wire last_data_state_vld;
2386                       assign last_data_state_vld = (data_type == TYPE_DATA | data_type == TYPE_HOLD);
2387                       assign last_data =
2388                                 (last_data_state_vld &amp;
2389                                    (((no_of_stored_bytes &lt;= 5'h01) &amp; last_read &amp; ~nibble_sel &amp;
2390                                          ~pause_frame_transmitting &amp; ~pfc_frame_transmitting) |
2391                                     ((tx_pause_length == 6'h14) &amp; (pause_frame_transmitting)) |
2392                                     ((tx_pause_length == 6'h23) &amp; (pfc_frame_transmitting))));
2393                    
2394                    
2395                       // calculate next value for number of bytes stored in transmit_data_buf.
2396                       assign no_of_str_bytes_nxt = no_of_stored_bytes + no_of_valid_bytes;
2397                    
2398                    
2399                       // generate tx_r_flush_held and hold until buffer state machine has
2400                       // detected it.
2401                       always@(posedge tx_clk or negedge n_txreset)
2402                       begin
2403       1/1                if (~n_txreset)
2404                             // asynchronous reset.
2405       1/1                   tx_r_flush_held &lt;= 1'b0;
2406       1/1                else if (~en_transmit_sync | buffer_state_bufinit)
2407                             // synchronous reset (from software).
2408       1/1                   tx_r_flush_held &lt;= 1'b0;
2409       1/1                else if (tx_r_flushed)
2410                             // flushed signal returned from fifo interface.
2411       <font color = "red">0/1     ==>           tx_r_flush_held &lt;= 1'b1;</font>
2412       1/1                else if (buffer_state == R_BUF_RST2)
2413                             // clear flag once buffer state machine has detected the flush.
2414       <font color = "red">0/1     ==>           tx_r_flush_held &lt;= 1'b0;</font>
2415                          else
2416                             // else hold flag in its current state.
2417       1/1                   tx_r_flush_held &lt;= tx_r_flush_held;
2418                       end
2419                    
2420                       // control logic for fetching data from transmit fifo and placing in the
2421                       // input buffer stage of the gem_tx module.
2422                    
2423                       // synchronize tx_r_rd for output.
2424                       always@(posedge tx_clk or negedge n_txreset)
2425                       begin
2426       1/1                if (~n_txreset)
2427                             // asynchronous reset.
2428       1/1                   tx_r_rd &lt;= 1'b0;
2429                          else
2430                             // registered output.
2431       1/1                   tx_r_rd &lt;= tx_r_rd_int;
2432                       end
2433                    
2434                       // synchronous part of buffer state machine.
2435                       always@(posedge tx_clk or negedge n_txreset)
2436                       begin
2437       1/1                if (~n_txreset)
2438                             // asynchronous reset for buffer state machine.
2439       1/1                   buffer_state &lt;= R_BUF_INIT;
2440                          else
2441                             // state machine flip-flops.
2442       1/1                   buffer_state &lt;= buffer_state_next;
2443                       end
2444                    
2445                       // asynchronous next state decode for buffer state machine.
2446                       always@(*)
2447                       begin
2448                          // default values.
2449       1/1                tx_frame_ready  = 1'b0;
2450       1/1                tx_r_rd_int     = 1'b0;
2451       1/1                underflow       = 1'b0;
2452       1/1                err_underflow   = 1'b0;
2453                    
2454       1/1                if (~en_transmit_sync)
2455                             // synchronous reset for buffer state machine.
2456       1/1                   buffer_state_next = R_BUF_INIT;
2457       1/1                else if (coll_occured | stat_underflow_pend)
2458                             // state where the buffer control logic waits for the tx fifo to flush.
2459       <font color = "red">0/1     ==>           buffer_state_next = R_BUF_RST1;</font>
2460                          else
2461                             // decodes for next state of buffer state machine.
2462       1/1                   case (buffer_state)
2463                    
2464                                R_RD_PEND_INIT:
2465                                   // state used to wait for valid response from fifo
2466                                   // interface, indicating word is available.
2467                                   begin
2468       1/1                            if (tx_r_underflow)
2469                                         // underflow condition occurs which shouldn't
2470                                         // happen in a properly configured system. SOP has not
2471                                         // yet been read so goto flush state. This is impossible
2472                                         // when using the DMA.
2473       <font color = "red">0/1     ==>                       buffer_state_next = R_BUF_RST1;</font>
2474       1/1                            else if (tx_r_valid &amp; tx_r_err)
2475                                         begin
2476                                            // errored read, return to initialisation state.
2477       <font color = "red">0/1     ==>                          buffer_state_next = R_IDLE1;</font>
2478                                         end
2479       1/1                            else if (tx_r_valid &amp; tx_r_sop &amp; tx_r_eop)
2480                                         begin
2481                                            // first word in frame with sop and eop.
2482       <font color = "red">0/1     ==>                          tx_frame_ready = 1'b1;</font>
2483       <font color = "red">0/1     ==>                          buffer_state_next = R_FRAME_RDY_EOP;</font>
2484                                         end
2485       1/1                            else if (tx_r_valid &amp; tx_r_sop &amp; ~tx_r_eop)
2486                                         begin
2487                                            // first word in frame with sop.
2488       1/1                                  tx_frame_ready = 1'b1;
2489       1/1                                  buffer_state_next = R_FRAME_RDY;
2490                                         end
2491       1/1                            else if (tx_r_valid &amp; ~tx_r_sop)
2492                                         // no sop, so keep reading the fifo.
2493       <font color = "red">0/1     ==>                       buffer_state_next = R_BUF_INIT;</font>
2494                                      else
2495                                         // wait for tx_r_valid response.
2496       1/1                               buffer_state_next = R_RD_PEND_INIT;
2497                                   end
2498                    
2499                                R_FRAME_RDY_EOP:
2500                                   // state used to wait for start_frame from
2501                                   // main tx state machine (fifo transfer with
2502                                   // sop and eop in same word).
2503                                   begin
2504       <font color = "red">0/1     ==>                    tx_frame_ready = 1'b1;</font>
2505       <font color = "red">0/1     ==>                    if (start_frame &amp; ~pfc_or_pause_frame_transmitting)</font>
2506                                         // start frame detected, and only one
2507                                         // word transfered from fifo interface.
2508       <font color = "red">0/1     ==>                       buffer_state_next = R_BUF_INIT;</font>
2509                                      else
2510                                         // wait in current state for start frame.
2511       <font color = "red">0/1     ==>                       buffer_state_next = R_FRAME_RDY_EOP;</font>
2512                                   end
2513                    
2514                                R_FRAME_RDY:
2515                                   // state used to wait for start frame from main tx
2516                                   // state machine.
2517                                   begin
2518       1/1                            tx_frame_ready = 1'b1;
2519       1/1                            if (start_frame &amp; ~pfc_or_pause_frame_transmitting)
2520                                         // start frame detected, perform reads.
2521       1/1                               buffer_state_next = R_READ;
2522                                      else
2523       1/1                               buffer_state_next = R_FRAME_RDY;
2524                                   end
2525                    
2526                                R_READ:
2527                                   // state whilst frame in progress, read the transmit fifo whilst 4 or fewer bytes available
2528                                   // or 11 if PTP sync correction field needs modification.
2529                                   // also do extra reads during pre-amble when 32 bit data and single step update of the correction field
2530                                   begin
2531       1/1                            if (((no_of_stored_bytes &lt;= 5'b00100) | ((no_of_stored_bytes &lt;= 5'b01011) &amp; oss_correction_field_sync))
2532                                                            &amp; ((data_type == TYPE_DATA) | ((data_type == TYPE_PREAMBLE) &amp; oss_correction_field_sync)))
2533                                         begin
2534       1/1                                  tx_r_rd_int = 1'b1;
2535       1/1                                  buffer_state_next = R_RD_PEND;
2536                                         end
2537                                      else
2538                                         // wait for less than 4 bytes available in
2539                                         // the input buffer.
2540       1/1                               buffer_state_next = R_READ;
2541                                   end
2542                    
2543                                R_RD_PEND:
2544                                   // state waiting for r_valid response from fifo
2545                                   // interface.
2546                                   begin
2547       1/1                            if (tx_r_underflow)
2548                                         begin
2549       <font color = "red">0/1     ==>                          underflow = 1'b1;</font>
2550       <font color = "red">0/1     ==>                          buffer_state_next = R_BUF_RST1;</font>
2551                                         end
2552       1/1                            else if (tx_r_valid &amp; tx_r_err)
2553                                         begin
2554       <font color = "red">0/1     ==>                          underflow = 1'b1;</font>
2555       <font color = "red">0/1     ==>                          err_underflow = 1'b1;</font>
2556       <font color = "red">0/1     ==>                          buffer_state_next = R_IDLE1;</font>
2557                                         end
2558       1/1                            else if (tx_r_valid &amp; tx_r_eop)
2559                                         // last byte of frame being read.
2560       1/1                               buffer_state_next = R_BUF_INIT;
2561                                      // if you get two SOP's with no intervening EOP then force
2562                                      // under-run to error the frame and stop the state machine
2563                                      // locking up
2564       1/1                            else if (tx_r_valid &amp; tx_r_sop)
2565                                         begin
2566       <font color = "red">0/1     ==>                          underflow = 1'b1;</font>
2567       <font color = "red">0/1     ==>                          err_underflow = 1'b1;</font>
2568       <font color = "red">0/1     ==>                          buffer_state_next = R_IDLE1;</font>
2569                                         end
2570       1/1                            else if (tx_r_valid &amp; ~tx_r_eop)
2571                                         // more bytes to read as not tx_r_eop.
2572       1/1                               buffer_state_next = R_READ;
2573                                      else
2574                                         // wait for tx_r_valid.
2575       1/1                               buffer_state_next = R_RD_PEND;
2576                                   end
2577                    
2578                                R_IDLE1:
2579                                   // state at end frame.
2580                                   begin
2581       <font color = "red">0/1     ==>                    buffer_state_next = R_IDLE2;</font>
2582                                   end
2583                    
2584                                R_IDLE2:
2585                                   // state at end frame.
2586                                   begin
2587       <font color = "red">0/1     ==>                    buffer_state_next = R_BUF_INIT;</font>
2588                                   end
2589                    
2590                                R_BUF_RST1:
2591                                   // state used to wait for fifo flush to start.
2592                                   begin
2593       <font color = "red">0/1     ==>                    if (tx_r_flush_held &amp; ~fifo_underrun)</font>
2594                                         // hold until fifo is cleared.
2595       <font color = "red">0/1     ==>                       buffer_state_next = R_BUF_RST2;</font>
2596                                      else
2597                                         // wait in current state.
2598       <font color = "red">0/1     ==>                       buffer_state_next = R_BUF_RST1;</font>
2599                                   end
2600                    
2601                                R_BUF_RST2:
2602                                   // state used to wait while fifo flush takes place.
2603                                   begin
2604       <font color = "red">0/1     ==>                    if (~tx_r_flush_held)</font>
2605                                         // wait for tx_r_flushed to go inactive.
2606       <font color = "red">0/1     ==>                       buffer_state_next = R_BUF_INIT;</font>
2607                                      else
2608                                         // wait in current state.
2609       <font color = "red">0/1     ==>                       buffer_state_next = R_BUF_RST2;</font>
2610                                   end
2611                    
2612                                default: // R_BUF_INIT:
2613                                   // state from reset, wait for frame on fifo interface, indicated
2614                                   // by tx_r_data_rdy going high.
2615                                   begin
2616       1/1                            if (tx_r_data_rdy &amp; ~tx_byte_mode &amp;
2617                                                               (no_of_stored_bytes &lt;= 5'h04))
2618                                         // wait for tx_r_data_rdy and input buffer
2619                                         // has less than four bytes stored.
2620                                         begin
2621       1/1                                  buffer_state_next = R_RD_PEND_INIT;
2622       1/1                                  tx_r_rd_int = 1'b1;
2623                                         end
2624       1/1                            else if (tx_r_data_rdy &amp; tx_byte_mode &amp;
2625                                               (no_of_stored_bytes &lt;= 5'h05))
2626                                         // wait for tx_r_data_rdy and input buffer
2627                                         // has less than five bytes stored.
2628                                         begin
2629       <font color = "red">0/1     ==>                          buffer_state_next = R_RD_PEND_INIT;</font>
2630       <font color = "red">0/1     ==>                          tx_r_rd_int = 1'b1;</font>
2631                                         end
2632                                      else
2633                                         // hold in current state.
2634       1/1                               buffer_state_next = R_BUF_INIT;
2635                                   end
2636                             endcase
2637                       end
2638                    
2639                    
2640                       // decode when state is R_BUF_INIT. This is when the state machine does not
2641                       // indicate any other valid state.
2642                       assign buffer_state_bufinit = (buffer_state != R_RD_PEND_INIT) &amp;
2643                                                     (buffer_state != R_FRAME_RDY) &amp;
2644                                                     (buffer_state != R_FRAME_RDY_EOP) &amp;
2645                                                     (buffer_state != R_READ) &amp;
2646                                                     (buffer_state != R_RD_PEND) &amp;
2647                                                     (buffer_state != R_IDLE1) &amp;
2648                                                     (buffer_state != R_IDLE2) &amp;
2649                                                     (buffer_state != R_BUF_RST1) &amp;
2650                                                     (buffer_state != R_BUF_RST2);
2651                    
2652                    
2653                       // use last_read to empty input buffer once last word
2654                       // of frame has been read from transmit fifo.
2655                       // last_read is set either when EOP or SOP is read and held until
2656                       // start_frame is signalled. This prevents new data from a second frame
2657                       // being recognised in transmit_data_buf until ready to deal with second
2658                       // frame.
2659                       // one_read is used to signal an SOP and EOP read in same data word,
2660                       // and is used to prevent last_read being reset at start_frame.
2661                       always@(posedge tx_clk or negedge n_txreset)
2662                       begin
2663       1/1                if (~n_txreset)
2664                             // asynchronous reset.
2665                             begin
2666       1/1                      last_read &lt;= 1'b1;
2667       1/1                      one_read  &lt;= 1'b0;
2668                             end
2669       1/1                else if (~en_transmit_sync)
2670                             // synchronous reset (from software).
2671                             begin
2672       1/1                      last_read &lt;= 1'b1;
2673       1/1                      one_read  &lt;= 1'b0;
2674                             end
2675       1/1                else if (tx_r_valid &amp; tx_r_sop &amp; tx_r_eop &amp; ~tx_r_err)
2676                             // only one word to be read from fifo for frame.
2677                             begin
2678       <font color = "red">0/1     ==>              last_read &lt;= 1'b1;</font>
2679       <font color = "red">0/1     ==>              one_read  &lt;= 1'b1;</font>
2680                             end
2681       1/1                else if (tx_r_valid &amp; tx_r_sop &amp; ~tx_r_eop &amp; ~tx_r_err)
2682                             // more than one word to be read from fifo for frame.
2683                             begin
2684       1/1                      last_read &lt;= 1'b1;
2685       1/1                      one_read  &lt;= 1'b0;
2686                             end
2687       1/1                else if (tx_r_valid &amp; ~tx_r_sop &amp; tx_r_eop &amp; ~tx_r_err)
2688                             // last read from fifo indicated.
2689                             begin
2690       1/1                      last_read &lt;= 1'b1;
2691       1/1                      one_read  &lt;= 1'b0;
2692                             end
2693       1/1                else if (start_frame &amp; ~one_read)
2694                             // hold until start of next frame.
2695                             begin
2696       1/1                      last_read &lt;= 1'b0;
2697       1/1                      one_read  &lt;= 1'b0;
2698                             end
2699                          else
2700                             // else maintain value.
2701                             begin
2702       1/1                      last_read &lt;= last_read;
2703       1/1                      one_read  &lt;= one_read;
2704                             end
2705                       end
2706                    
2707                    
2708                       // multiplex between pause data and frame data from external
2709                       // fifo interface.
2710                       always@( * )
2711                       begin
2712       1/1                if (pause_frame_transmitting)
2713                             // 802.3 pause frame data.
2714                             begin
2715       <font color = "red">0/1     ==>              tx_r_frame_size_mux = 14'd0;  // Pause is not used with pre-emption. These will never be pre-empted</font>
2716       <font color = "red">0/1     ==>              case (tx_pause_length)</font>
2717       <font color = "red">0/1     ==>                 6'h01 : transmit_data_mux = {1'b1,8'h01};</font>
2718       <font color = "red">0/1     ==>                 6'h02 : transmit_data_mux = {1'b1,8'h80};</font>
2719       <font color = "red">0/1     ==>                 6'h03 : transmit_data_mux = {1'b1,8'hc2};</font>
2720       <font color = "red">0/1     ==>                 6'h04 : transmit_data_mux = {1'b0,8'h00};</font>
2721       <font color = "red">0/1     ==>                 6'h05 : transmit_data_mux = {1'b0,8'h00};</font>
2722       <font color = "red">0/1     ==>                 6'h06 : transmit_data_mux = {1'b1,8'h01};</font>
2723       <font color = "red">0/1     ==>                 6'h07 : transmit_data_mux = {spec_add1_par[0],spec_add1[7:0]};</font>
2724       <font color = "red">0/1     ==>                 6'h08 : transmit_data_mux = {spec_add1_par[1],spec_add1[15:8]};</font>
2725       <font color = "red">0/1     ==>                 6'h09 : transmit_data_mux = {spec_add1_par[2],spec_add1[23:16]};</font>
2726       <font color = "red">0/1     ==>                 6'h0a : transmit_data_mux = {spec_add1_par[3],spec_add1[31:24]};</font>
2727       <font color = "red">0/1     ==>                 6'h0b : transmit_data_mux = {spec_add1_par[4],spec_add1[39:32]};</font>
2728       <font color = "red">0/1     ==>                 6'h0c : transmit_data_mux = {spec_add1_par[5],spec_add1[47:40]};</font>
2729       <font color = "red">0/1     ==>                 6'h0d : transmit_data_mux = {1'b0,8'h88};</font>
2730       <font color = "red">0/1     ==>                 6'h0e : transmit_data_mux = {1'b1,8'h08};</font>
2731       <font color = "red">0/1     ==>                 6'h0f : transmit_data_mux = {1'b0,8'h00};</font>
2732       <font color = "red">0/1     ==>                 6'h10 : transmit_data_mux = {1'b1,8'h01};</font>
2733       <font color = "red">0/1     ==>                 6'h11 : transmit_data_mux =</font>
2734                                              (tx_pause_zero_held) ? {1'b0,8'h00} : {tx_pause_quant_par[1],tx_pause_quant[15:8]};
2735       <font color = "red">0/1     ==>                 6'h12 : transmit_data_mux =</font>
2736                                              (tx_pause_zero_held) ? {1'b0,8'h00} : {tx_pause_quant_par[0],tx_pause_quant[7:0]};
2737       <font color = "red">0/1     ==>                 default : transmit_data_mux = {1'b0,8'h00};</font>
2738                                endcase
2739                             end
2740       1/1                else if (pfc_frame_transmitting)
2741                             // PFC pause frame data.
2742                             begin
2743       <font color = "red">0/1     ==>              tx_r_frame_size_mux = 14'd0;  // Pause is not used with pre-emption. These will never be pre-empted</font>
2744       <font color = "red">0/1     ==>              case (tx_pause_length)</font>
2745       <font color = "red">0/1     ==>                 6'h01 : transmit_data_mux = {1'b1,8'h01};</font>
2746       <font color = "red">0/1     ==>                 6'h02 : transmit_data_mux = {1'b1,8'h80};</font>
2747       <font color = "red">0/1     ==>                 6'h03 : transmit_data_mux = {1'b1,8'hc2};</font>
2748       <font color = "red">0/1     ==>                 6'h04 : transmit_data_mux = {1'b0,8'h00};</font>
2749       <font color = "red">0/1     ==>                 6'h05 : transmit_data_mux = {1'b0,8'h00};</font>
2750       <font color = "red">0/1     ==>                 6'h06 : transmit_data_mux = {1'b1,8'h01};</font>
2751       <font color = "red">0/1     ==>                 6'h07 : transmit_data_mux = {spec_add1_par[0],spec_add1[7:0]};</font>
2752       <font color = "red">0/1     ==>                 6'h08 : transmit_data_mux = {spec_add1_par[1],spec_add1[15:8]};</font>
2753       <font color = "red">0/1     ==>                 6'h09 : transmit_data_mux = {spec_add1_par[2],spec_add1[23:16]};</font>
2754       <font color = "red">0/1     ==>                 6'h0a : transmit_data_mux = {spec_add1_par[3],spec_add1[31:24]};</font>
2755       <font color = "red">0/1     ==>                 6'h0b : transmit_data_mux = {spec_add1_par[4],spec_add1[39:32]};</font>
2756       <font color = "red">0/1     ==>                 6'h0c : transmit_data_mux = {spec_add1_par[5],spec_add1[47:40]};</font>
2757       <font color = "red">0/1     ==>                 6'h0d : transmit_data_mux = {1'b0,8'h88};</font>
2758       <font color = "red">0/1     ==>                 6'h0e : transmit_data_mux = {1'b1,8'h08};</font>
2759       <font color = "red">0/1     ==>                 6'h0f : transmit_data_mux = {1'b1,8'h01};</font>
2760       <font color = "red">0/1     ==>                 6'h10 : transmit_data_mux = {1'b1,8'h01};</font>
2761                                   6'h11 : // priority enable upper byte
2762       <font color = "red">0/1     ==>                         transmit_data_mux  = {1'b0,8'h00};</font>
2763                                   6'h12 : // priority enable lower byte
2764       <font color = "red">0/1     ==>                          transmit_data_mux = {tx_pfc_pri_held_par,tx_pfc_pri_held};</font>
2765                    
2766                                   6'h13 : //--- priority 0: timer0 upper byte ---
2767       <font color = "red">0/2     ==>                         if (tx_pfc_zero_held[0]) transmit_data_mux = {1'b0,8'h00};</font>
2768       <font color = "red">0/1     ==>                         else                     transmit_data_mux = {tx_pause_quant_par[1],tx_pause_quant[15:8]};</font>
2769                    
2770                                   6'h14 : //--- priority 0: timer0 lower byte ---
2771                                        // puase quantum controlled from register
2772       <font color = "red">0/2     ==>                         if (tx_pfc_zero_held[0]) transmit_data_mux = {1'b0,8'h00};</font>
2773       <font color = "red">0/1     ==>                         else                     transmit_data_mux = {tx_pause_quant_par[0],tx_pause_quant[7:0]};</font>
2774                    
2775                    
2776                                   6'h15 : //--- priority 1: timer1 upper byte ---
2777       <font color = "red">0/2     ==>                         if (tx_pfc_zero_held[1]) transmit_data_mux = {1'b0,8'h00};</font>
2778       <font color = "red">0/1     ==>                         else                     transmit_data_mux = {tx_pause_quant_par_p1[1],tx_pause_quant_p1[15:8]};</font>
2779                    
2780                                   6'h16 : //---- priority 1: timer1 lower byte  ---
2781       <font color = "red">0/2     ==>                         if (tx_pfc_zero_held[1]) transmit_data_mux = {1'b0,8'h00};</font>
2782       <font color = "red">0/1     ==>                         else                     transmit_data_mux = {tx_pause_quant_par_p1[0],tx_pause_quant_p1[7:0]};</font>
2783                    
2784                    
2785                                   6'h17 : //--- priority 2: timer2 upper byte ---
2786       <font color = "red">0/2     ==>                         if (tx_pfc_zero_held[2]) transmit_data_mux = {1'b0,8'h00};</font>
2787       <font color = "red">0/1     ==>                         else                     transmit_data_mux = {tx_pause_quant_par_p2[1],tx_pause_quant_p2[15:8]};</font>
2788                    
2789                                   6'h18 : //--- priority 2: timer2 lower byte ----
2790       <font color = "red">0/2     ==>                         if (tx_pfc_zero_held[2]) transmit_data_mux = {1'b0,8'h00};</font>
2791       <font color = "red">0/1     ==>                         else                     transmit_data_mux = {tx_pause_quant_par_p2[0],tx_pause_quant_p2[7:0]};</font>
2792                    
2793                                   6'h19 : //--- priority 3: timer3 upper byte ---
2794       <font color = "red">0/2     ==>                         if (tx_pfc_zero_held[3]) transmit_data_mux = {1'b0,8'h00};</font>
2795       <font color = "red">0/1     ==>                         else                     transmit_data_mux = {tx_pause_quant_par_p3[1],tx_pause_quant_p3[15:8]};</font>
2796                    
2797                                   6'h1a : //--- priority 3: timer3 lower byte ---
2798       <font color = "red">0/2     ==>                         if (tx_pfc_zero_held[3]) transmit_data_mux = {1'b0,8'h00};</font>
2799       <font color = "red">0/1     ==>                         else                     transmit_data_mux = {tx_pause_quant_par_p3[0],tx_pause_quant_p3[7:0]};</font>
2800                    
2801                                   6'h1b : //--- priority 4: timer4 upper byte ---
2802       <font color = "red">0/2     ==>                         if (tx_pfc_zero_held[4]) transmit_data_mux = {1'b0,8'h00};</font>
2803       <font color = "red">0/1     ==>                         else                     transmit_data_mux = {tx_pause_quant_par_p4[1],tx_pause_quant_p4[15:8]};</font>
2804                    
2805                                   6'h1c : //--- priority 4: timer5 lower byte ---
2806       <font color = "red">0/2     ==>                         if (tx_pfc_zero_held[4]) transmit_data_mux = {1'b0,8'h00};</font>
2807       <font color = "red">0/1     ==>                         else                     transmit_data_mux = {tx_pause_quant_par_p4[0],tx_pause_quant_p4[7:0]};</font>
2808                    
2809                                   6'h1d : //--- priority 5: timer5 upper byte ---
2810       <font color = "red">0/2     ==>                         if (tx_pfc_zero_held[5]) transmit_data_mux = {1'b0,8'h00};</font>
2811       <font color = "red">0/1     ==>                         else                     transmit_data_mux = {tx_pause_quant_par_p5[1],tx_pause_quant_p5[15:8]};</font>
2812                    
2813                                   6'h1e : //--- priority 5: timer5 lower byte ---
2814       <font color = "red">0/2     ==>                         if (tx_pfc_zero_held[5]) transmit_data_mux = {1'b0,8'h00};</font>
2815       <font color = "red">0/1     ==>                         else                     transmit_data_mux = {tx_pause_quant_par_p5[0],tx_pause_quant_p5[7:0]};</font>
2816                    
2817                                   6'h1f : //--- priority 6: timer6 upper byte ---
2818       <font color = "red">0/2     ==>                         if (tx_pfc_zero_held[6]) transmit_data_mux = {1'b0,8'h00};</font>
2819       <font color = "red">0/1     ==>                         else                     transmit_data_mux = {tx_pause_quant_par_p6[1],tx_pause_quant_p6[15:8]};</font>
2820                    
2821                                   6'h20 : //--- priority 6: timer6 lower byte ---
2822       <font color = "red">0/2     ==>                         if (tx_pfc_zero_held[6]) transmit_data_mux = {1'b0,8'h00};</font>
2823       <font color = "red">0/1     ==>                         else                     transmit_data_mux = {tx_pause_quant_par_p6[0],tx_pause_quant_p6[7:0]};</font>
2824                    
2825                                   6'h21 : //--- priority 7: timer7 upper byte ---
2826       <font color = "red">0/2     ==>                         if (tx_pfc_zero_held[7]) transmit_data_mux = {1'b0,8'h00};</font>
2827       <font color = "red">0/1     ==>                         else                     transmit_data_mux = {tx_pause_quant_par_p7[1],tx_pause_quant_p7[15:8]};</font>
2828                    
2829                                   6'h22 : //--- priority 7: timer7 lower byte ---
2830       <font color = "red">0/2     ==>                         if (tx_pfc_zero_held[7]) transmit_data_mux = {1'b0,8'h00};</font>
2831       <font color = "red">0/1     ==>                         else                     transmit_data_mux = {tx_pause_quant_par_p7[0],tx_pause_quant_p7[7:0]};</font>
2832                    
2833       <font color = "red">0/1     ==>                 default : transmit_data_mux = {1'b0,8'h00};</font>
2834                                endcase
2835                             end
2836                           else
2837                           begin
2838                             // normal frame data.
2839       1/1                   tx_r_frame_size_mux = tx_r_frame_size;
2840                    
2841       1/1                   if (p_edma_tsu == 1)
2842                             // or insert Timestamp for one step sync mode
2843                             begin
2844       1/1                      if (tx_ts_insert_ptp_v1 &amp; tsu_timer_safe_to_sample)  // version 1 has 8B TS
2845       <font color = "red">0/1     ==>                case (tx_ts_insert_count_ptp)</font>
2846       <font color = "red">0/1     ==>                  4'd0 : transmit_data_mux = {tsu_ptp_tx_ts_latched_par[7],tsu_ptp_tx_ts_latched[63:56]};</font>
2847       <font color = "red">0/1     ==>                  4'd1 : transmit_data_mux = {tsu_ptp_tx_ts_latched_par[6],tsu_ptp_tx_ts_latched[55:48]};</font>
2848       <font color = "red">0/1     ==>                  4'd2 : transmit_data_mux = {tsu_ptp_tx_ts_latched_par[5],tsu_ptp_tx_ts_latched[47:40]};</font>
2849       <font color = "red">0/1     ==>                  4'd3 : transmit_data_mux = {tsu_ptp_tx_ts_latched_par[4],tsu_ptp_tx_ts_latched[39:32]};</font>
2850       <font color = "red">0/1     ==>                  4'd4 : transmit_data_mux = {tsu_ptp_tx_ts_latched_par[3],tsu_ptp_tx_ts_latched[31:24]};</font>
2851       <font color = "red">0/1     ==>                  4'd5 : transmit_data_mux = {tsu_ptp_tx_ts_latched_par[2],tsu_ptp_tx_ts_latched[23:16]};</font>
2852       <font color = "red">0/1     ==>                  4'd6 : transmit_data_mux = {tsu_ptp_tx_ts_latched_par[1],tsu_ptp_tx_ts_latched[15: 8]};</font>
2853       <font color = "red">0/1     ==>                  default : transmit_data_mux = {tsu_ptp_tx_ts_latched_par[0],tsu_ptp_tx_ts_latched[ 7: 0]};</font>
2854                    
2855                                  endcase
2856                    
2857       1/1                      else if (tx_ts_insert_ptp_v2 &amp; tsu_timer_safe_to_sample)  // version 2 has 10B TS
2858       <font color = "red">0/1     ==>                case (tx_ts_insert_count_ptp)</font>
2859       <font color = "red">0/1     ==>                  4'd0  : transmit_data_mux = {tsu_ptp_tx_ts_latched_par[9],tsu_ptp_tx_ts_latched[79:72]};</font>
2860       <font color = "red">0/1     ==>                  4'd1  : transmit_data_mux = {tsu_ptp_tx_ts_latched_par[8],tsu_ptp_tx_ts_latched[71:64]};</font>
2861       <font color = "red">0/1     ==>                  4'd2  : transmit_data_mux = {tsu_ptp_tx_ts_latched_par[7],tsu_ptp_tx_ts_latched[63:56]};</font>
2862       <font color = "red">0/1     ==>                  4'd3  : transmit_data_mux = {tsu_ptp_tx_ts_latched_par[6],tsu_ptp_tx_ts_latched[55:48]};</font>
2863       <font color = "red">0/1     ==>                  4'd4  : transmit_data_mux = {tsu_ptp_tx_ts_latched_par[5],tsu_ptp_tx_ts_latched[47:40]};</font>
2864       <font color = "red">0/1     ==>                  4'd5  : transmit_data_mux = {tsu_ptp_tx_ts_latched_par[4],tsu_ptp_tx_ts_latched[39:32]};</font>
2865       <font color = "red">0/1     ==>                  4'd6  : transmit_data_mux = {tsu_ptp_tx_ts_latched_par[3],tsu_ptp_tx_ts_latched[31:24]};</font>
2866       <font color = "red">0/1     ==>                  4'd7  : transmit_data_mux = {tsu_ptp_tx_ts_latched_par[2],tsu_ptp_tx_ts_latched[23:16]};</font>
2867       <font color = "red">0/1     ==>                  4'd8  : transmit_data_mux = {tsu_ptp_tx_ts_latched_par[1],tsu_ptp_tx_ts_latched[15: 8]};</font>
2868       <font color = "red">0/1     ==>                  default  : transmit_data_mux = {tsu_ptp_tx_ts_latched_par[0],tsu_ptp_tx_ts_latched[ 7: 0]};</font>
2869                                  endcase
2870                    
2871       1/1                      else if (tx_ts_update_cor_fld)
2872       <font color = "red">0/1     ==>                case (tx_ts_insert_count_ptp)</font>
2873       <font color = "red">0/1     ==>                  4'd0 : transmit_data_mux = {correction_field_new_par[7],correction_field_new[63:56]};</font>
2874       <font color = "red">0/1     ==>                  4'd1 : transmit_data_mux = {correction_field_new_par[6],correction_field_new[55:48]};</font>
2875       <font color = "red">0/1     ==>                  4'd2 : transmit_data_mux = {correction_field_new_par[5],correction_field_new[47:40]};</font>
2876       <font color = "red">0/1     ==>                  4'd3 : transmit_data_mux = {correction_field_new_par[4],correction_field_new[39:32]};</font>
2877       <font color = "red">0/1     ==>                  4'd4 : transmit_data_mux = {correction_field_new_par[3],correction_field_new[31:24]};</font>
2878       <font color = "red">0/1     ==>                  4'd5 : transmit_data_mux = {correction_field_new_par[2],correction_field_new[23:16]};</font>
2879       <font color = "red">0/1     ==>                  4'd6 : transmit_data_mux = {correction_field_new_par[1],correction_field_new[15: 8]};</font>
2880       <font color = "red">0/1     ==>                  default : transmit_data_mux = {correction_field_new_par[0],correction_field_new[ 7: 0]};</font>
2881                                  endcase
2882                    
2883                                else
2884       1/1                        transmit_data_mux = {transmit_par_buf[0],transmit_data_buf[7:0]};
2885                             end
2886                             else
2887       <font color = "red">0/1     ==>              transmit_data_mux = {transmit_par_buf[0],transmit_data_buf[7:0]};</font>
2888                          end
2889                       end
2890                    
2891                    
2892                       // Load up transmit data buffer with 128 bits of new word transmit_data from the fifo interface.
2893                       // The location loaded depends on the number of bytes remaining in the buffer &quot;no_of_stored_bytes&quot;
2894                    
2895                       // declare a helper signal
2896                       wire [7:0] stored_bit_locn;
2897                       assign stored_bit_locn = (no_of_stored_bytes*8);
2898                       wire [7:0] stored_bit_locn_m1;
2899                       assign stored_bit_locn_m1 = ((no_of_stored_bytes-1)*8);
2900                       wire [4:0] no_of_stored_bytes_m1;
2901                       assign no_of_stored_bytes_m1 = (no_of_stored_bytes-5'd1);
2902                       always @*
2903                       begin : transmit_data_buf_new_block  // need to name block if local variables are declared
2904                       integer k1;
2905                       integer k1p;
2906       1/1                if (no_of_stored_bytes == 5'b00000)
2907                             begin
2908       1/1                      transmit_data_buf_new = {{(384-128){1'b0}},transmit_data[127:0]};
2909                             end
2910                          else
2911                             begin
2912                                // load up 128 new bits from transmit_data preserving location of unchanged bits
2913                    /*
2914                                for (k1=0; k1&lt;p_tx_buf_width; k1 = k1+1)
2915                                   if ((k1 &gt;= stored_bit_locn) &amp; (k1 &lt; stored_bit_locn + 128))) begin
2916                                      transmit_data_buf_new[k1] = transmit_data[k1-stored_bit_locn];
2917                                   end else begin
2918                                      transmit_data_buf_new[k1] = transmit_data_buf[k1];
2919                                   end
2920                    */
2921                                // load the new 128bits of transmit_data to the top of transmit_data_buf_new
2922                                // Note that no_of_stored_bytes is a 5 bit vector, which theoretically implies
2923                                // 31 bytes could be buffered. 31 bytes = 248 bits, but is stored in a 256bit vector called
2924                                // stored_bit_locn. Since 128bits are loaded,
2925                                // we need transmit_data_buf_new to be 384 bits wide ..
2926                                // Note that since the databuffer itself is p_tx_buf_width
2927                                // bits wide, which is 160 or 216 if TSU is defined, then we need to drop
2928                                // the upper bits of transmit_data_buf_new
2929       1/1                      transmit_data_buf_new = {{(384-p_tx_buf_width){1'b0}},transmit_data_buf};
2930       1/1                      for (k1=0; k1&lt;128; k1=k1+1)
2931       1/1                        transmit_data_buf_new[k1[6:0]+stored_bit_locn] = transmit_data[k1[6:0]];
2932                             end
2933                    
2934                          // shift the parity
2935       1/1                if (no_of_stored_bytes == 5'b00000)
2936                             begin
2937       1/1                      transmit_par_buf_new = {{((384/8)-16){1'b0}},transmit_par[15:0]};
2938                             end
2939                          else
2940                             begin
2941                                // load up 128 new bits from transmit_data preserving location of unchanged bits
2942                    /*
2943                                for (k1p=0; k1p&lt;(p_tx_buf_width/8); k1p = k1p+1)
2944                                   if ((k1p &gt;= (no_of_stored_bytes)) &amp; (k1p &lt; (no_of_stored_bytes + 16))) begin
2945                                      transmit_par_buf_new[k1p] = transmit_par[k1p-(no_of_stored_bytes)];
2946                                   end else begin
2947                                      transmit_par_buf_new[k1p] = transmit_par_buf[k1p];
2948                                   end
2949                    */
2950       1/1                      transmit_par_buf_new = {{(384/8-p_tx_buf_width/8){1'b0}},transmit_par_buf};
2951       1/1                      for (k1p=0; k1p&lt;16; k1p=k1p+1)
2952       1/1                        transmit_par_buf_new[k1p[3:0]+no_of_stored_bytes] = transmit_par[k1p[3:0]];
2953                             end
2954                       end
2955                    
2956                       // Load up transmit data buffer with 128 bits of new word transmit_data from the fifo interface, with a shift operation
2957                       // The location loaded depends on the number of bytes remaining in the buffer &quot;no_of_stored_bytes&quot;
2958                       always @*
2959                       begin : transmit_data_buf_new_sh_block  // need to name block if local cariables are declared
2960                       integer k2;
2961                       integer k2p;
2962       1/1                if (no_of_stored_bytes == 5'b00000)
2963                             begin
2964       1/1                      transmit_data_buf_new_shift = {{(384-128){1'b0}},transmit_data[127:0]};
2965                             end
2966                          else
2967                             begin
2968                                // load up 128 new bits from transmit_data byte shifting location of unchanged bits
2969                    /*
2970                                transmit_data_buf_new_shift[p_tx_buf_width-1:p_tx_buf_width-8] = 8'h00;
2971                                for (k2=0; k2&lt;p_tx_buf_width-8; k2 = k2+1)
2972                                   if ((k2 &gt;= stored_bit_locn_m1) &amp; (k2 &lt; (stored_bit_locn_m1 + 128))) begin
2973                                      transmit_data_buf_new_shift[k2] = transmit_data[k2-stored_bit_locn_m1];
2974                                   end else begin
2975                                      transmit_data_buf_new_shift[k2] = transmit_data_buf[k2+8];
2976                                   end
2977                    */
2978       1/1                      transmit_data_buf_new_shift = {{(384+8-p_tx_buf_width){1'b0}},transmit_data_buf[p_tx_buf_width-1:8]};
2979       1/1                      for (k2=0; k2&lt;128; k2=k2+1)
2980       1/1                        transmit_data_buf_new_shift[k2[6:0]+stored_bit_locn_m1] = transmit_data[k2[6:0]];
2981                             end
2982                    
2983                          // shift the parity
2984       1/1                if (no_of_stored_bytes == 5'b00000)
2985                             begin
2986       1/1                      transmit_par_buf_new_shift = {{(384/8-16){1'b0}},transmit_par[15:0]};
2987                             end
2988                          else
2989                             begin
2990                                // load up 128 new bits from transmit_data byte shifting location of unchanged bits
2991                    /*
2992                                transmit_par_buf_new_shift[p_tx_buf_width/8-1] = 1'b0;
2993                                for (k2p=0; k2p&lt;p_tx_buf_width/8-1; k2p = k2p+1)
2994                                   if ((k2p &gt;= ((no_of_stored_bytes-1))) &amp; (k2p &lt; ((no_of_stored_bytes-1) + 16))) begin
2995                                      transmit_par_buf_new_shift[k2p] = transmit_par[k2p-((no_of_stored_bytes-1))];
2996                                   end else begin
2997                                      transmit_par_buf_new_shift[k2p] = transmit_par_buf[k2p+1];
2998                                   end
2999                    */
3000       1/1                      transmit_par_buf_new_shift = {{((384+8)/8-p_tx_buf_width/8){1'b0}},transmit_par_buf[p_tx_buf_width/8-1:1]};
3001       1/1                      for (k2p=0; k2p&lt;16; k2p=k2p+1)
3002       1/1                        transmit_par_buf_new_shift[k2p[3:0]+no_of_stored_bytes_m1] = transmit_par[k2p[3:0]];
3003                             end
3004                       end
3005                    
3006                       always@(*)
3007                       begin
3008       1/1                if (tx_r_sop &amp; tx_r_valid &amp; ~nibble_sel &amp; (data_type == TYPE_DATA) &amp;
3009                                   ~pfc_or_pause_frame_transmitting) begin
3010                             // load up buffer with new word from fifo interface and perform
3011                             // byte shift at the same time. previous frame active and first
3012                             // word of next frame being loaded.
3013       <font color = "red">0/1     ==>           transmit_data_buf_nxt  = transmit_data_buf_new_shift[p_tx_buf_width-1:0];</font>
3014       <font color = "red">0/1     ==>           transmit_par_buf_nxt   = transmit_par_buf_new_shift[p_tx_buf_width/8-1:0];</font>
3015       1/1                end else if ((tx_r_sop | (data_type == TYPE_PREAMBLE | data_type == TYPE_HOLD)) &amp; tx_r_valid) begin
3016                             // load up buffer with new word from fifo interface. previous frame
3017                             // completed or previous frame active and no shift taking place or
3018                             // pause frame active during load.
3019                             // also accommodate extra reads during pre-amble when doing single step update of the correction field
3020       1/1                   transmit_data_buf_nxt  = transmit_data_buf_new[p_tx_buf_width-1:0];
3021       1/1                   transmit_par_buf_nxt   = transmit_par_buf_new[p_tx_buf_width/8-1:0];
3022       1/1                end else if (pfc_or_pause_frame_transmitting) begin
3023                             // pause frame being transmitted, hold values.
3024       <font color = "red">0/1     ==>           transmit_data_buf_nxt  = transmit_data_buf;</font>
3025       <font color = "red">0/1     ==>           transmit_par_buf_nxt   = transmit_par_buf;</font>
3026       1/1                end else if (start_frame) begin
3027                             // propagate any error that occurred with sop.
3028       1/1                   transmit_data_buf_nxt  = transmit_data_buf;
3029       1/1                   transmit_par_buf_nxt   = transmit_par_buf;
3030       1/1                end else if ((data_type == TYPE_DATA) &amp; ~nibble_sel &amp; ~tx_r_valid) begin
3031                             // shift buffer one byte location.
3032       1/1                   transmit_data_buf_nxt  = {8'h00,transmit_data_buf[p_tx_buf_width-1:8]};
3033       1/1                   transmit_par_buf_nxt   = {1'b0,transmit_par_buf[p_tx_buf_width/8-1:1]};
3034       1/1                end else if ((data_type == TYPE_DATA) &amp; ~nibble_sel &amp; tx_r_valid) begin
3035                             // load up buffer with new word from fifo interface and perform
3036                             // byte shift at the same time.
3037       1/1                   transmit_data_buf_nxt  = transmit_data_buf_new_shift[p_tx_buf_width-1:0];
3038       1/1                   transmit_par_buf_nxt   = transmit_par_buf_new_shift[p_tx_buf_width/8-1:0];
3039       1/1                end else if ((data_type == TYPE_DATA) &amp; nibble_sel &amp; tx_r_valid) begin
3040                             // load up buffer with new word from fifo interface, frame active.
3041       1/1                   transmit_data_buf_nxt  = transmit_data_buf_new[p_tx_buf_width-1:0];
3042       1/1                   transmit_par_buf_nxt   = transmit_par_buf_new[p_tx_buf_width/8-1:0];
3043                          end else begin
3044                             // else hold current values.
3045       1/1                   transmit_data_buf_nxt  = transmit_data_buf;
3046       1/1                   transmit_par_buf_nxt   = transmit_par_buf;
3047                          end
3048                       end
3049                    
3050                       // load tx_fifo data into transmit_data_buf when buffer contains
3051                       // contains four or less bytes or at the start of a new frame.
3052                       // also generate pause frame data, if pause frame transmission
3053                       // is in progress.
3054                       always@(posedge tx_clk or negedge n_txreset)
3055                       begin
3056       1/1                if (~n_txreset)
3057                             // asynchronous reset.
3058       1/1                   transmit_data_buf &lt;= {p_tx_buf_width{1'b0}};
3059       1/1                else if (~en_transmit_sync)
3060                             // synchronous reset (from software).
3061       1/1                   transmit_data_buf &lt;= {p_tx_buf_width{1'b0}};
3062                          else
3063                             // load up buffer with new word from fifo interface and perform
3064                             // byte shift at the same time. previous frame active and first
3065                             // word of next frame being loaded.
3066       1/1                   transmit_data_buf &lt;= transmit_data_buf_nxt;
3067                       end
3068                    
3069                       generate if (p_edma_asf_dap_prot == 1) begin : gen_transmit_par_buf
3070                         reg  [p_tx_buf_width/8-1:0]  transmit_par_buf_r;
3071                         always@(posedge tx_clk or negedge n_txreset)
3072                         begin
3073                            if (~n_txreset)
3074                               transmit_par_buf_r  &lt;= {p_tx_buf_width/8{1'b0}};
3075                            else if (~en_transmit_sync)
3076                               transmit_par_buf_r  &lt;= {p_tx_buf_width/8{1'b0}};
3077                            else
3078                               transmit_par_buf_r  &lt;= transmit_par_buf_nxt;
3079                         end
3080                         assign transmit_par_buf = transmit_par_buf_r;
3081                       end else begin : gen_no_transmit_par_buf
3082                         assign transmit_par_buf = {p_tx_buf_width/8{1'b0}};
3083                       end
3084                       endgenerate
3085                    
3086                       // counts out nibbles to be transmitted from transmit_data.
3087                       always@(posedge tx_clk or negedge n_txreset)
3088                       begin
3089       1/1                if (~n_txreset)
3090                             // asynchronous reset.
3091       1/1                   nibble_sel &lt;= 1'b0;
3092       1/1                else if (((data_type == TYPE_SFD) | (data_type == TYPE_DATA) |
3093                                   (data_type == TYPE_JAM) | (data_type == TYPE_CRC) |
3094                                   (data_type == TYPE_FILL))
3095                                    &amp; ~tx_byte_mode)
3096                             // nibble mode, nibble select inverted every clock cycle.
3097       1/1                   nibble_sel &lt;= ~nibble_sel;
3098                          else
3099                             // tx not transmitting data or tx_byte_mode
3100       1/1                   nibble_sel &lt;= 1'b0;
3101                       end
3102                    
3103                    
3104                       // load txd_next depending on data_type and mode (10/100 or tx_byte_mode).
3105                       always@(*)
3106                       begin
3107       1/1                if (bp_active)
3108                            begin
3109       <font color = "red">0/1     ==>            txd_next[7:0] = 8'b11011101;</font>
3110       <font color = "red">0/1     ==>            txd_next[8]   = 1'b0;</font>
3111       <font color = "red">0/1     ==>            tx_er_next    = 1'b0;</font>
3112                            end
3113                          else
3114       1/1                if (tx_byte_mode) // tx_byte_mode.
3115       <font color = "red">0/1     ==>            case (data_type)</font>
3116                                 TYPE_DATA:                // 0000.
3117                                    begin
3118       <font color = "red">0/1     ==>                     txd_next[7:0]  = transmit_data_mux[7:0];</font>
3119       <font color = "red">0/1     ==>                     txd_next[8]    = transmit_data_mux[8];</font>
3120       <font color = "red">0/1     ==>                     tx_er_next     = fifo_underrun;</font>
3121                                    end
3122                                 TYPE_CRC:                 // 0001.
3123                                    begin
3124       <font color = "red">0/1     ==>                     txd_next[7:0]  = {~crc[24],~crc[25],~crc[26],~crc[27],</font>
3125                                                        ~crc[28],~crc[29],~crc[30],~crc[31]};
3126       <font color = "red">0/1     ==>                     txd_next[8]    = crc_24_31_par;</font>
3127       <font color = "red">0/1     ==>                     tx_er_next     = 1'b0;</font>
3128                                    end
3129                                 TYPE_PREAMBLE:            // 0010.
3130                                    begin
3131       <font color = "red">0/1     ==>                     txd_next[7:0]  = 8'h55;</font>
3132       <font color = "red">0/1     ==>                     txd_next[8]    = 1'b0;</font>
3133       <font color = "red">0/1     ==>                     tx_er_next     = fifo_underrun;</font>
3134                                    end
3135                                 TYPE_SFD:                 // 0011.
3136                                    begin
3137       <font color = "red">0/1     ==>                     txd_next[7:0]  = 8'hd5;</font>
3138       <font color = "red">0/1     ==>                     txd_next[8]    = 1'b1;</font>
3139       <font color = "red">0/1     ==>                     tx_er_next     = fifo_underrun;</font>
3140                                    end
3141                                 TYPE_JAM:                 // 0100.
3142                                    begin
3143       <font color = "red">0/1     ==>                     txd_next[7:0]  = transmit_data_mux[7:0];</font>
3144       <font color = "red">0/1     ==>                     txd_next[8]    = transmit_data_mux[8];</font>
3145       <font color = "red">0/1     ==>                     tx_er_next     = fifo_underrun;</font>
3146                                    end
3147                                 TYPE_CARRIER:             // 0101.
3148                                    begin
3149       <font color = "red">0/1     ==>                     txd_next[7:0]  = 8'h0f;</font>
3150       <font color = "red">0/1     ==>                     txd_next[8]    = 1'b0;</font>
3151       <font color = "red">0/1     ==>                     tx_er_next     = 1'b1;</font>
3152                                    end
3153                                 TYPE_FILL:                // 0110.
3154                                    begin
3155       <font color = "red">0/1     ==>                     txd_next[7:0]  = 8'h00;</font>
3156       <font color = "red">0/1     ==>                     txd_next[8]    = 1'b0;</font>
3157       <font color = "red">0/1     ==>                     tx_er_next     = 1'b0;</font>
3158                                    end
3159                                 TYPE_BURST_IFG:           // 0111.
3160                                    begin
3161       <font color = "red">0/1     ==>                     txd_next[7:0]  = 8'h0f;</font>
3162       <font color = "red">0/1     ==>                     txd_next[8]    = 1'b0;</font>
3163       <font color = "red">0/1     ==>                     tx_er_next     = 1'b1;</font>
3164                                    end
3165                                 TYPE_JAM_CE:              // 1001.
3166                                    begin
3167       <font color = "red">0/1     ==>                     txd_next[7:0]  = 8'h1f;</font>
3168       <font color = "red">0/1     ==>                     txd_next[8]    = 1'b1;</font>
3169       <font color = "red">0/1     ==>                     tx_er_next     = 1'b1;</font>
3170                                    end
3171                                 TYPE_HOLD:
3172                                    begin
3173       <font color = "red">0/1     ==>                     txd_next[7:0]  = txd;</font>
3174       <font color = "red">0/1     ==>                     txd_next[8]    = txd_par;</font>
3175       <font color = "red">0/1     ==>                     tx_er_next     = tx_er;</font>
3176                                    end
3177                                 default: // TYPE_IDLE (1000)
3178                                    begin
3179       <font color = "red">0/1     ==>                     txd_next[7:0]  = 8'h00;</font>
3180       <font color = "red">0/1     ==>                     txd_next[8]    = 1'b0;</font>
3181       <font color = "red">0/1     ==>                     tx_er_next     = 1'b0;</font>
3182                                    end
3183                              endcase
3184                          else // 10/100 mode.
3185       1/1                    case (data_type)
3186                                 TYPE_DATA:                // 0000.
3187                                    begin
3188       1/1                             tx_er_next     = fifo_underrun;
3189       1/1                             if (nibble_sel) begin
3190       1/1                                txd_next[7:0]  = {4'h0,transmit_data_mux[3:0]};
3191       1/1                                txd_next[8]    = transmit_par_mux_3_0;
3192                                       end else begin
3193       1/1                                txd_next[7:0]  = {4'h0,transmit_data_mux[7:4]};
3194       1/1                                txd_next[8]    = transmit_par_mux_7_4;
3195                                       end
3196                                    end
3197                                 TYPE_CRC:                 // 0001.
3198                                    begin
3199       1/1                             txd_next[7:0]  = {4'h0,~crc[28],~crc[29],~crc[30],~crc[31]};
3200       1/1                             txd_next[8]    = crc_28_31_par;
3201       1/1                             tx_er_next     = 1'b0;
3202                                    end
3203                                 TYPE_PREAMBLE:            // 0010.
3204                                    begin
3205       1/1                             txd_next[7:0]  = 8'h05;
3206       1/1                             txd_next[8]    = 1'b0;
3207       1/1                             tx_er_next     = fifo_underrun;
3208                                    end
3209                                 TYPE_SFD:                 // 0011.
3210                                    begin
3211       1/1                             txd_next[7:0]  = 8'h0d;
3212       1/1                             txd_next[8]    = 1'b1;
3213       1/1                             tx_er_next     = fifo_underrun;
3214                                    end
3215                                 TYPE_JAM:                 // 0100.
3216                                    begin
3217       <font color = "red">0/1     ==>                     txd_next[7:0]  = {4'h0,transmit_data_mux[3:0]};</font>
3218       <font color = "red">0/1     ==>                     txd_next[8]    = transmit_par_mux_3_0;</font>
3219       <font color = "red">0/1     ==>                     tx_er_next     = fifo_underrun;</font>
3220                                    end
3221                                 TYPE_FILL:                // 0110.
3222                                    begin
3223       1/1                             txd_next[7:0]  = 8'h00;
3224       1/1                             txd_next[8]    = 1'b0;
3225       1/1                             tx_er_next     = 1'b0;
3226                                    end
3227                                 TYPE_HOLD:
3228                                    begin
3229       <font color = "red">0/1     ==>                     txd_next[7:0]  = txd;</font>
3230       <font color = "red">0/1     ==>                     txd_next[8]    = txd_par;</font>
3231       <font color = "red">0/1     ==>                     tx_er_next     = tx_er;</font>
3232                                    end
3233                                 default:
3234                                    begin
3235                                       // Default is used to catch TYPE_IDLE (1000) and types
3236                                       // which are not valid in 10/100 mode (TYPE_CARRIER,
3237                                       // TYPE_BURST_IFG and TYPE_JAM_CE)
3238       1/1                             txd_next[7:0]  = 8'h00;
3239       1/1                             txd_next[8]    = 1'b0;
3240       1/1                             tx_er_next     = 1'b0;
3241                                    end
3242                              endcase
3243                       end
3244                    
3245                    
3246                       // count down for preamble (7 bytes or 15 nibbles).
3247                       always@(posedge tx_clk or negedge n_txreset)
3248                       begin
3249       1/1                if (~n_txreset)
3250                             // asynchronous reset.
3251       1/1                   preamble_cnt &lt;= 4'he;
3252       1/1                else if (~en_transmit_sync)
3253                             // synchronous reset (from software).
3254       1/1                   preamble_cnt &lt;= 4'he;
3255       1/1                else if (~txd_rdy)
3256       <font color = "red">0/1     ==>           preamble_cnt &lt;= preamble_cnt;</font>
3257       1/1                else if (tx_en_next &amp; (preamble_cnt != 4'h0))
3258                             // decrement preamble counter.
3259       1/1                   preamble_cnt &lt;= preamble_cnt - 4'h1;
3260       1/1                else if (tx_en_next &amp; (preamble_cnt == 4'h0))
3261                             // once zero, hold value.
3262       1/1                   preamble_cnt &lt;= preamble_cnt;
3263       1/1                else if (tx_byte_mode)
3264                             // tx_byte_mode, count for 7 bytes
3265       <font color = "red">0/1     ==>           preamble_cnt &lt;= 4'h6;</font>
3266                          else
3267                             // 10/100 mode, count for 15 nibbles.
3268       1/1                   preamble_cnt &lt;= 4'he;
3269                       end
3270                    
3271                    
3272                       // last_preamble goes to the transmit state machine to signal
3273                       // end of the 7 bytes of preamble.
3274                       assign last_preamble = (preamble_cnt == 4'h0);
3275                    
3276                       // count interframe gap. Interframe gap lasts 96 bit times.
3277                       // This counter will count in nibbles (4-bits). If crs becomes
3278                       // active in first 32 (was 64) bit times then reset interframe_cnt
3279                       // and defer. If crs goes active in last 64 (was 32) bit time then don't defer.
3280                       // gate crs_sync with ~int_end_frame (last 4 tx_clks) to stop deference
3281                       // to crs produced by own transmitted frames.
3282                       always@(posedge tx_clk or negedge n_txreset)
3283                       begin
3284       1/1                if (~n_txreset)
3285                             // asynchronous reset.
3286       1/1                   interframe_cnt &lt;= 8'd0;
3287       1/1                else if (~en_transmit_sync)
3288                             // synchronous reset.
3289       1/1                   interframe_cnt &lt;= 8'd0;
3290       1/1                else if ((~interframe_cnt[4] &amp; ~interframe_cnt[3] &amp; crs_sync &amp; ~int_end_frame &amp; first_frame)
3291                                                     | start_ifg)
3292                             // reset counter at start of ifg or when crs is detected during
3293                             // first 32-bit (was 64) times of ifg. crs does not reset count when bursting
3294                             // or during last four clock cycles after tx_en goes low (as you
3295                             // don't want to defer to your own transmission).
3296       1/1                   interframe_cnt &lt;= 8'd0;
3297       1/1                else if (ifg_cnt_active | (interframe_cnt == 8'd0))
3298                             // interframe gap count active.
3299       1/1                   interframe_cnt &lt;= interframe_cnt[6:0] + {6'd0,tx_byte_mode,~tx_byte_mode};
3300                          else
3301                             // interframe gap counter reached 96-bit times. (or 192 or 256 bit times)
3302       1/1                   interframe_cnt &lt;= interframe_cnt;
3303                       end
3304                    
3305                       // check for completion of interframe_cnt
3306                       // assign ifg_cnt_active = interframe_cnt &lt; (min_ifg * 8);
3307                       // and do look ahead to be sure timing is not compromised
3308                       // note interframe_cnt counts nibbles rather than bytes
3309                       always@(posedge tx_clk or negedge n_txreset)
3310                       begin
3311       1/1                if (~n_txreset)
3312       1/1                   ifg_cnt_active &lt;= 1'b1;
3313                          else
3314       1/1                   ifg_cnt_active &lt;= (interframe_cnt &lt; ((min_ifg * 8) - {6'd0,tx_byte_mode,~tx_byte_mode}));
3315                       end
3316                    
3317                       assign interframe_gap = ifg_cnt_active | ipg_stretch | (interframe_cnt == 8'd0);
3318                    
3319                    
3320                       // calculate stretch size. Although stretch_size counts nibbles in 10/100
3321                       // mode and octets in gigabit mode we still end up with the IPG being
3322                       // a multiple of the previous frames length including preamble. The
3323                       // multiple will be (stretch_ratio[7:0])/(stretch_ratio[15:8]+1)
3324                       // we need the &quot;+1&quot; to prevent divide by zero
3325                       wire [24:0] stretch_size_p;
3326                       assign stretch_size_p = stretch_size + {16'h0000,stretch_ratio[7:0]};
3327                       always@(posedge tx_clk or negedge n_txreset)
3328                       begin
3329       1/1                if (~n_txreset)
3330                             begin
3331                                // asynchronous reset.
3332       1/1                      stretch_size  &lt;= 24'h000000;
3333       1/1                      stretch_count &lt;= 8'h00;
3334       1/1                      ipg_stretch &lt;= 1'b0;
3335                             end
3336       1/1                else if (full_duplex &amp; stretch_enable &amp; (data_type != TYPE_IDLE) &amp;
3337                                                           (stretch_count == 8'h00))
3338                             begin
3339                                // only increment stretch size when stretch_count is zero
3340                                // and transmitting
3341       <font color = "red">0/1     ==>              stretch_size &lt;= stretch_size_p[23:0];</font>
3342       <font color = "red">0/1     ==>              stretch_count &lt;= stretch_ratio[15:8];</font>
3343                             end
3344       1/1                else if (full_duplex &amp; stretch_enable &amp; (data_type != TYPE_IDLE))
3345                             begin
3346       <font color = "red">0/1     ==>              stretch_count &lt;= stretch_count - 8'h01;</font>
3347                             end
3348       1/1                else if (stretch_size != 24'h000000)
3349                             begin
3350       <font color = "red">0/1     ==>              stretch_size &lt;= stretch_size - 24'h000001;</font>
3351       <font color = "red">0/1     ==>              if (stretch_size == 24'h000001)</font>
3352       <font color = "red">0/1     ==>                 ipg_stretch &lt;= 1'b0;</font>
3353                                else
3354       <font color = "red">0/1     ==>                 ipg_stretch &lt;= 1'b1;</font>
3355                             end
3356                          else
3357                             begin
3358       1/1                      ipg_stretch &lt;= 1'b0;
3359                                // don't reset stretch_count so mod can be carried over to
3360                                // next frame
3361                             end
3362                       end
3363                    
3364                    
3365                       // count tx_frame_length and use it to generate within_60bytes and
3366                       // within_512bytes indications for transmit state machine.
3367                       // also used for statistics generation - tx bytes transmitted.
3368                       // frame length including padding and carrier extension.
3369                       always@(posedge tx_clk or negedge n_txreset)
3370                       begin
3371       1/1                if (~n_txreset)
3372                             // asynchronous reset.
3373       1/1                   tx_frame_length &lt;= 14'h0000;
3374       1/1                else if (data_type == TYPE_HOLD)
3375       <font color = "red">0/1     ==>           tx_frame_length &lt;= tx_frame_length;</font>
3376       1/1                else if (tx_byte_mode &amp; ((tx_en_next &amp; ((data_type == TYPE_SFD) |
3377                                  (data_type == TYPE_DATA) | (data_type == TYPE_FILL) |
3378                                  (data_type == TYPE_CRC))) | (tx_er_next &amp;
3379                                  (data_type == TYPE_CARRIER))))
3380                             // increment count when in sfd, data, fill, crc and carrier data types.
3381                             // the count is generated in terms of bytes, and in tx_byte_mode this
3382                             // increments every clock cycle during frame transmission.
3383                             begin
3384       <font color = "red">0/1     ==>              if (tx_frame_length == 14'h3fff)</font>
3385                                   // stop count rolling over.
3386       <font color = "red">0/1     ==>                 tx_frame_length &lt;= tx_frame_length;</font>
3387                                else
3388       <font color = "red">0/1     ==>                 tx_frame_length &lt;= tx_frame_length_nxt;</font>
3389                             end
3390       1/1                else if (tx_en_next &amp; ((data_type == TYPE_SFD) | (data_type == TYPE_DATA)
3391                                   | (data_type == TYPE_FILL) | (data_type == TYPE_CRC)))
3392                             // increment count when in sfd, data, fill and crc data types.
3393                             // the count is generated in terms of bytes, and in 10/100 mode this
3394                             // increments every other clock cycle during frame transmission.
3395       1/1                   if (nibble_sel &amp; ~(tx_frame_length == 14'h3fff))
3396       1/1                      tx_frame_length &lt;= tx_frame_length_nxt;
3397                             else
3398       1/1                      tx_frame_length &lt;= tx_frame_length;
3399       1/1                else if (tx_en_next)
3400                             // reset counters at start of frame.
3401       1/1                   tx_frame_length &lt;= 14'h0000;
3402                          else
3403                             // hold count values until start of frame.
3404       1/1                   tx_frame_length &lt;= tx_frame_length;
3405                       end
3406                    
3407                       // tx_frame_length for pause frame
3408                       always@(posedge tx_clk or negedge n_txreset)
3409                       begin
3410       1/1                if (~n_txreset)
3411                             // asynchronous reset.
3412       1/1                   tx_pause_length &lt;= 6'h00;
3413                          else
3414       1/1                   tx_pause_length &lt;= tx_frame_length_nxt[5:0];
3415                       end
3416                    
3417                       // frame length count adder.
3418                       assign tx_frame_length_nxt = tx_frame_length + 14'h0001;
3419                    
3420                       // used for inserting pad (fill) into tx frames when the frame is less
3421                       // than 64 bytes (60 bytes + 4 bytes crc).
3422                       assign within_60bytes = tx_frame_length &lt; 14'h003c;
3423                    
3424                    
3425                       // used for carrier extension when the frame size is less than 512 bytes.
3426                       assign within_512bytes = tx_frame_length &lt; 14'h0200;
3427                    
3428                    
3429                       // count for burst limit when operating in gigabit, half duplex mode. count
3430                       // is in terms of transmitted bytes from the start of preamble for the
3431                       // first frame of the burst.
3432                       // it is also used for late collision threshold in both 10/100 and gigabit
3433                       // modes.
3434                       always@(posedge tx_clk or negedge n_txreset)
3435                       begin
3436       1/1                if (~n_txreset)
3437                             // asynchronous reset, count starts at 12 bytes, as burst limit is
3438                             // calculated such that byte count should not exceed 8192 bytes at
3439                             // start of frame, but bursting decision must be made at end of
3440                             // frame.
3441       1/1                   burst_length &lt;= 14'h000C;
3442       1/1                else if ((data_type == TYPE_PREAMBLE) | (data_type == TYPE_SFD) |
3443                                   (data_type == TYPE_DATA) | (data_type == TYPE_FILL) |
3444                                   (data_type == TYPE_CRC) | (data_type == TYPE_CARRIER) |
3445                                   (data_type == TYPE_JAM) | (data_type == TYPE_JAM_CE) |
3446                                   ((data_type == TYPE_BURST_IFG) &amp; gigabit &amp; ~full_duplex))
3447                             // increment count when in preamble, sfd, data, fill, crc,
3448                             // carrier extension, burst_ifg, jam and jam_ce data types
3449                             // count is in terms of bytes.
3450                             begin
3451       1/1                      if (burst_length == 14'h3fff)
3452                                   // stop count rolling over.
3453       <font color = "red">0/1     ==>                 burst_length &lt;= burst_length;</font>
3454                                else
3455       1/1                         burst_length &lt;= burst_length + 14'h0001;
3456                             end
3457                          else
3458                             // count reset to 12 bytes.
3459       1/1                   burst_length &lt;= 14'h000C;
3460                       end
3461                    
3462                       // used for burst limit (8192 bytes) in gigabit mode, half duplex.
3463                       assign within_burst_limit = burst_length &lt; 14'h2000;
3464                    
3465                       // late collision threshold is slot time (either 512 bit times [10/100] or
3466                       // 4096 bit times [gigabit mode]) and is measured from the start of preamble.
3467                       // the col input is double synchronised so logic needs to allow three
3468                       // clocks to account for this.
3469                       // burst_length  count starts at 0x000C so add this on.
3470                       // Final decode for gigabit mode is (512 + 12 + 3 = 527 byte clocks).
3471                       // Final decode for 10/100 mode is  (128 + 12 + 3 = 143 nibble clocks)
3472                       assign late_col_threshold = (gigabit) ?
3473                                                    burst_length &lt; 14'h020f : // 512 + 12 + 3 = 527.
3474                                                    burst_length &lt; 14'h008f;  // 128 + 12 + 3 = 143.
3475                    
3476                    
3477                       // Synchronise and then detect a rising edge on spec_add1_active.
3478                       // This is used for initialising the random counter.
3479                       edma_sync_toggle_detect i_edma_sync_toggle_detect_spec_add1_active (
3480                          .clk(tx_clk),
3481                          .reset_n(n_txreset),
3482                          .din(spec_add1_active),
3483                          .rise_edge(spec_add1_act_le),
3484                          .fall_edge(),
3485                          .any_edge());
3486                    
3487                    
3488                       // Define when random PRBS is to update. This is controlled by a parameter
3489                       // to be either free running or to update only when a backoff occurs.
3490                       // In the later case retry_test is used for test purposes to ensure
3491                       // all PRBS values are exercised for code-coverage.
3492                       assign random_update = (load_backoff &amp;&amp; !last_attempt) || retry_test_sync1;
3493                    
3494                    
3495                       // Collision handling stuff follows
3496                       // Generate random number for use in generating backoff after a collision.
3497                       // Counter is initialised with the specific address 1 value to make
3498                       // it unique for each MAC, and hence reduce the chance of two MAC getting
3499                       // locked together.
3500                       // Cycle through all 1024 combinations in a pseudo-random sequence.
3501                       // Only increment when random_update is active. Also make sure zero
3502                       // combination is reached by forcing this between the 55 and ab conditions.
3503                       // random is exclusive OR'ed with transmit data to make it more likely that
3504                       // different MAC's on the same network will cycle through different
3505                       // sequences.
3506                       always@(posedge tx_clk or negedge n_txreset)
3507                       begin
3508       1/1                if (~n_txreset)
3509       1/1                   random1 &lt;= 16'hffff;
3510       1/1                else if (spec_add1_act_le)
3511       1/1                   random1 &lt;= spec_add1[47:32];
3512       1/1                else if (random_update &amp; random1 == 16'had62)
3513       <font color = "red">0/1     ==>           random1 &lt;= 16'h0000;</font>
3514       1/1                else if (random_update &amp; random1 == 16'h0000)
3515       <font color = "red">0/1     ==>           random1 &lt;= 16'h78b5;</font>
3516       1/1                else if (random_update)
3517                          begin
3518       <font color = "red">0/1     ==>          random1[0]  &lt;= random1[8];</font>
3519       <font color = "red">0/1     ==>          random1[1]  &lt;= random1[9];</font>
3520       <font color = "red">0/1     ==>          random1[2]  &lt;= random1[10];</font>
3521       <font color = "red">0/1     ==>          random1[3]  &lt;= random1[11] ^ random1[8];</font>
3522       <font color = "red">0/1     ==>          random1[4]  &lt;= random1[12] ^ random1[9] ^ random1[8];</font>
3523       <font color = "red">0/1     ==>          random1[5]  &lt;= random1[13] ^ random1[10]</font>
3524                                          ^ random1[9]  ^ random1[8];
3525       <font color = "red">0/1     ==>          random1[6]  &lt;= random1[14] ^ random1[11]</font>
3526                                          ^ random1[10] ^ random1[9];
3527       <font color = "red">0/1     ==>          random1[7]  &lt;= random1[15] ^ random1[12]</font>
3528                                          ^ random1[11] ^ random1[10];
3529       <font color = "red">0/1     ==>          random1[8]  &lt;= random1[0] ^ random1[13] ^ random1[12]</font>
3530                                          ^ random1[11];
3531       <font color = "red">0/1     ==>          random1[9]  &lt;= random1[1] ^ random1[14] ^ random1[13]</font>
3532                                          ^ random1[12];
3533       <font color = "red">0/1     ==>          random1[10] &lt;= random1[2] ^ random1[15]</font>
3534                                          ^ random1[14] ^ random1[13];
3535       <font color = "red">0/1     ==>          random1[11] &lt;= random1[3] ^ random1[15]</font>
3536                                          ^ random1[14];
3537       <font color = "red">0/1     ==>          random1[12] &lt;= random1[4] ^ random1[15];</font>
3538       <font color = "red">0/1     ==>          random1[13] &lt;= random1[5];</font>
3539       <font color = "red">0/1     ==>          random1[14] &lt;= random1[6];</font>
3540       <font color = "red">0/1     ==>          random1[15] &lt;= random1[7];</font>
3541                          end
3542                          else
3543       1/1                   random1 &lt;= random1;
3544                       end
3545                    
3546                       // track 1st LFSR
3547                       wire [10:0] random1cnt_c;
3548                       assign random1cnt_c = random1cnt[9:0] + random_update;
3549                       always@(posedge tx_clk or negedge n_txreset)
3550                       begin
3551       1/1                if (~n_txreset)
3552                          begin
3553       1/1                  random1cnt &lt;= 10'd0;
3554       1/1                  shiftrnd1 &lt;= 4'h0;
3555                          end
3556                          else
3557                          begin
3558       1/1                  random1cnt &lt;= random1cnt_c[9:0];
3559       1/1                  if (&amp;random1cnt[9:0])
3560                            begin
3561       <font color = "red">0/1     ==>            if (shiftrnd1 == 4'd6)</font>
3562       <font color = "red">0/1     ==>              shiftrnd1 &lt;= 4'h0;</font>
3563                              else
3564       <font color = "red">0/1     ==>              shiftrnd1 &lt;= shiftrnd1 + 4'h1;</font>
3565                            end
                        MISSING_ELSE
3566                          end
3567                       end
3568                    
3569                       // increment 2nd LFSR on 1st LFSR rollover
3570                       assign random2_update = random_update &amp; (&amp;random1cnt);
3571                    
3572                       always@(posedge tx_clk or negedge n_txreset)
3573                       begin
3574       1/1                if (~n_txreset)
3575       1/1                   random2 &lt;= 16'hffff;
3576       1/1                else if (spec_add1_act_le)
3577       1/1                   random2 &lt;= {6'h00,spec_add1[19:10]};
3578                    //      else if (random2_update &amp; random2 == 16'had62)
3579                    //         random2 &lt;= 16'h0000;
3580                    //      else if (random2_update &amp; random2 == 16'h0000)
3581                    //         random2 &lt;= 16'h78b5;
3582       1/1                else if (random2_update)
3583                             begin
3584       <font color = "red">0/1     ==>                                     random2[0]  &lt;= random2[8];</font>
3585       <font color = "red">0/1     ==>                                     random2[1]  &lt;= random2[9];</font>
3586       <font color = "red">0/1     ==>                                     random2[2]  &lt;= random2[10];</font>
3587       <font color = "red">0/1     ==>                                     random2[3]  &lt;= random2[11] ^ random2[8];</font>
3588       <font color = "red">0/1     ==>                                     random2[4]  &lt;= random2[12] ^ random2[9] ^ random2[8];</font>
3589       <font color = "red">0/1     ==>                                     random2[5]  &lt;= random2[13] ^ random2[10]</font>
3590                                                                     ^ random2[9]  ^ random2[8];
3591       <font color = "red">0/1     ==>                                     random2[6]  &lt;= random2[14] ^ random2[11]</font>
3592                                                                     ^ random2[10] ^ random2[9];
3593       <font color = "red">0/1     ==>                                     random2[7]  &lt;= random2[15] ^ random2[12]</font>
3594                                                                     ^ random2[11] ^ random2[10];
3595       <font color = "red">0/1     ==>                                     random2[8]  &lt;= random2[0] ^ random2[13] ^ random2[12]</font>
3596                                                                     ^ random2[11];
3597       <font color = "red">0/1     ==>                                     random2[9]  &lt;= random2[1] ^ random2[14] ^ random2[13]</font>
3598                                                                     ^ random2[12];
3599       <font color = "red">0/1     ==>                                     random2[10] &lt;= random2[2] ^ random2[15]</font>
3600                                                                     ^ random2[14] ^ random2[13];
3601       <font color = "red">0/1     ==>                                     random2[11] &lt;= random2[3] ^ random2[15]</font>
3602                                                                     ^ random2[14];
3603       <font color = "red">0/1     ==>                                     random2[12] &lt;= random2[4] ^ random2[15];</font>
3604       <font color = "red">0/1     ==>                                     random2[13] &lt;= random2[5];</font>
3605       <font color = "red">0/1     ==>                                     random2[14] &lt;= random2[6];</font>
3606       <font color = "red">0/1     ==>                                     random2[15] &lt;= random2[7];</font>
3607                             end
3608                          else
3609       1/1                   random2 &lt;= random2;
3610                       end
3611                    
3612                      assign random1_sft =  shiftrnd1 == 4'd0 ? random1[9:0] :
3613                                            shiftrnd1 == 4'd1 ? random1[10:1] :
3614                                            shiftrnd1 == 4'd2 ? random1[11:2] :
3615                                            shiftrnd1 == 4'd3 ? random1[12:3] :
3616                                            shiftrnd1 == 4'd4 ? random1[13:4] :
3617                                            shiftrnd1 == 4'd5 ? random1[14:5] :
3618                                                                random1[15:6];
3619                    
3620                      assign random = random1_sft[9:0] ^ random2[9:0];
3621                    
3622                       // count number of attempts to transmit
3623                       always@(posedge tx_clk or negedge n_txreset)
3624                       begin
3625       1/1                if (~n_txreset)
3626                             // asynchronous reset.
3627       1/1                   attempts &lt;= 4'h0;
3628       1/1                else if (~en_transmit_sync)
3629                             // synchronous reset (from software).
3630       1/1                   attempts &lt;= 4'h0;
3631       1/1                else if (load_backoff)
3632                             // increment attempts counter.
3633       <font color = "red">0/1     ==>           attempts &lt;= attempts + 4'h1;</font>
3634       1/1                else if (end_frame)
3635                             // clear attempts counter at end of frame.
3636       1/1                   attempts &lt;= 4'h0;
3637                          else
3638                             // else maintain count value.
3639       1/1                   attempts &lt;= attempts;
3640                       end
3641                    
3642                    
3643                       // the last attempt is the 16th attempt
3644                       assign last_attempt = (attempts == 4'hf);
3645                    
3646                    
3647                       assign backoff_start = ((retry_test_sync1) ? 10'h001 : random );
3648                    
3649                    
3650                       // load backoff_cnt and count down to zero. backoff_cnt is initially
3651                       // an integer number of slot times (64 bytes in 10/100 or 512 bytes in
3652                       // gigabit mode).
3653                       // The number of slot times is a random number whose range increases
3654                       // depending on the number of collisions that have occurred.
3655                       // backoff_cnt counts in terms of nibbles.
3656                       always@(posedge tx_clk or negedge n_txreset)
3657                       begin
3658       1/1                if (~n_txreset)
3659                             // asynchronous reset.
3660       1/1                   backoff_cnt &lt;= 19'h00000;
3661       1/1                else if (~en_transmit_sync)
3662                             // synchronous reset (from software).
3663       1/1                   backoff_cnt &lt;= 19'h00000;
3664       1/1                else if (load_backoff)
3665                             // collision occurred and backoff counter is loaded. backoff is
3666                             // calculated with random number and time exponentially increases
3667                             // (base 2) with each backoff attempt as per ieee802.3.
3668                             // Note that if attemps is already 15, backoff_cnt will not be loaded.
3669       <font color = "red">0/1     ==>           case ({tx_byte_mode,attempts})</font>
3670                                // 10/100 mode, slot time = 64 bytes, count in nibbles.
3671       <font color = "red">0/1     ==>              5'b0_0000: backoff_cnt &lt;= {11'h000, backoff_start[0],   7'h00};</font>
3672       <font color = "red">0/1     ==>              5'b0_0001: backoff_cnt &lt;= {10'h000, backoff_start[1:0], 7'h00};</font>
3673       <font color = "red">0/1     ==>              5'b0_0010: backoff_cnt &lt;= { 9'h000, backoff_start[2:0], 7'h00};</font>
3674       <font color = "red">0/1     ==>              5'b0_0011: backoff_cnt &lt;= { 8'h00,  backoff_start[3:0], 7'h00};</font>
3675       <font color = "red">0/1     ==>              5'b0_0100: backoff_cnt &lt;= { 7'h00,  backoff_start[4:0], 7'h00};</font>
3676       <font color = "red">0/1     ==>              5'b0_0101: backoff_cnt &lt;= { 6'h00,  backoff_start[5:0], 7'h00};</font>
3677       <font color = "red">0/1     ==>              5'b0_0110: backoff_cnt &lt;= { 5'h00,  backoff_start[6:0], 7'h00};</font>
3678       <font color = "red">0/1     ==>              5'b0_0111: backoff_cnt &lt;= { 4'h0,   backoff_start[7:0], 7'h00};</font>
3679       <font color = "red">0/1     ==>              5'b0_1000: backoff_cnt &lt;= { 3'b000, backoff_start[8:0], 7'h00};</font>
3680       <font color = "red">0/1     ==>              5'b0_1001: backoff_cnt &lt;= { 2'b00,  backoff_start,      7'h00};</font>
3681       <font color = "red">0/1     ==>              5'b0_1010: backoff_cnt &lt;= { 2'b00,  backoff_start,      7'h00};</font>
3682       <font color = "red">0/1     ==>              5'b0_1011: backoff_cnt &lt;= { 2'b00,  backoff_start,      7'h00};</font>
3683       <font color = "red">0/1     ==>              5'b0_1100: backoff_cnt &lt;= { 2'b00,  backoff_start,      7'h00};</font>
3684       <font color = "red">0/1     ==>              5'b0_1101: backoff_cnt &lt;= { 2'b00,  backoff_start,      7'h00};</font>
3685       <font color = "red">0/1     ==>              5'b0_1110: backoff_cnt &lt;= { 2'b00,  backoff_start,      7'h00};</font>
3686                                // tx_byte_mode, slot time = 64 bytes, count in bytes.
3687       <font color = "red">0/1     ==>              5'b1_0000: backoff_cnt &lt;= {12'h000, backoff_start[0],   6'h00};</font>
3688       <font color = "red">0/1     ==>              5'b1_0001: backoff_cnt &lt;= {11'h000, backoff_start[1:0], 6'h00};</font>
3689       <font color = "red">0/1     ==>              5'b1_0010: backoff_cnt &lt;= {10'h000, backoff_start[2:0], 6'h00};</font>
3690       <font color = "red">0/1     ==>              5'b1_0011: backoff_cnt &lt;= { 9'h000, backoff_start[3:0], 6'h00};</font>
3691       <font color = "red">0/1     ==>              5'b1_0100: backoff_cnt &lt;= { 8'h00,  backoff_start[4:0], 6'h00};</font>
3692       <font color = "red">0/1     ==>              5'b1_0101: backoff_cnt &lt;= { 7'h00,  backoff_start[5:0], 6'h00};</font>
3693       <font color = "red">0/1     ==>              5'b1_0110: backoff_cnt &lt;= { 6'h00,  backoff_start[6:0], 6'h00};</font>
3694       <font color = "red">0/1     ==>              5'b1_0111: backoff_cnt &lt;= { 5'h00,  backoff_start[7:0], 6'h00};</font>
3695       <font color = "red">0/1     ==>              5'b1_1000: backoff_cnt &lt;= { 4'h0,   backoff_start[8:0], 6'h00};</font>
3696       <font color = "red">0/1     ==>              5'b1_1001: backoff_cnt &lt;= { 3'b000, backoff_start,      6'h00};</font>
3697       <font color = "red">0/1     ==>              5'b1_1010: backoff_cnt &lt;= { 3'b000, backoff_start,      6'h00};</font>
3698       <font color = "red">0/1     ==>              5'b1_1011: backoff_cnt &lt;= { 3'b000, backoff_start,      6'h00};</font>
3699       <font color = "red">0/1     ==>              5'b1_1100: backoff_cnt &lt;= { 3'b000, backoff_start,      6'h00};</font>
3700       <font color = "red">0/1     ==>              5'b1_1101: backoff_cnt &lt;= { 3'b000, backoff_start,      6'h00};</font>
3701                                default: //5'b1_1110
3702       <font color = "red">0/1     ==>                         backoff_cnt &lt;= { 3'b000, backoff_start,      6'h00};</font>
3703                                // tx_byte_mode, slot time = 512 bytes, count in bytes.
3704                                // 5'b1_0000: backoff_cnt &lt;= {9'h000,  backoff_start[0],   9'h000};
3705                                // 5'b1_0001: backoff_cnt &lt;= {8'h00,   backoff_start[1:0], 9'h000};
3706                                // 5'b1_0010: backoff_cnt &lt;= {7'h00,   backoff_start[2:0], 9'h000};
3707                                // 5'b1_0011: backoff_cnt &lt;= {6'h00,   backoff_start[3:0], 9'h000};
3708                                // 5'b1_0100: backoff_cnt &lt;= {5'h00,   backoff_start[4:0], 9'h000};
3709                                // 5'b1_0101: backoff_cnt &lt;= {4'h0,    backoff_start[5:0], 9'h000};
3710                                // 5'b1_0110: backoff_cnt &lt;= {3'b000,  backoff_start[6:0], 9'h000};
3711                                // 5'b1_0111: backoff_cnt &lt;= {2'b00,   backoff_start[7:0], 9'h000};
3712                                // 5'b1_1000: backoff_cnt &lt;= {1'b0,    backoff_start[8:0], 9'h000};
3713                                // 5'b1_1001: backoff_cnt &lt;= {         backoff_start,      9'h000};
3714                                // 5'b1_1010: backoff_cnt &lt;= {         backoff_start,      9'h000};
3715                                // 5'b1_1011: backoff_cnt &lt;= {         backoff_start,      9'h000};
3716                                // 5'b1_1100: backoff_cnt &lt;= {         backoff_start,      9'h000};
3717                                // 5'b1_1101: backoff_cnt &lt;= {         backoff_start,      9'h000};
3718                                // default: //5'b1_1110
3719                                //            backoff_cnt &lt;= {         backoff_start,      9'h000};
3720                             endcase
3721       1/1                else if (backoff)
3722                             // decrement backoff counter until zero.
3723       <font color = "red">0/1     ==>           backoff_cnt &lt;= backoff_cnt - 19'h00001;</font>
3724                          else
3725                             // hold backoff counter at zero.
3726       1/1                   backoff_cnt &lt;= backoff_cnt;
3727                       end
3728                    
3729                    
3730                       // set while doing backoff (ie while backoff_cnt counts down to zero)
3731                       assign backoff = (backoff_cnt != 19'h00000);
3732                    
3733                    
3734                       // count jam down to zero. start_jam comes from the transmit state
3735                       // machine. jam is an input to it.
3736                       always@(posedge tx_clk or negedge n_txreset)
3737                       begin
3738       1/1                if (~n_txreset)
3739                             // asynchronous reset.
3740       1/1                   jam_cnt &lt;= 3'b000;
3741       1/1                else if (~en_transmit_sync)
3742                             // synchronous reset (from software).
3743       1/1                   jam_cnt &lt;= 3'b000;
3744       1/1                else if ((start_jam) &amp; tx_byte_mode)
3745                             // load jam count in gigabit mode.
3746       <font color = "red">0/1     ==>           jam_cnt &lt;= 3'h3;</font>
3747       1/1                else if ((start_jam) &amp; ~tx_byte_mode)
3748                             // load jam count in 10/100 mode.
3749       <font color = "red">0/1     ==>           jam_cnt &lt;= 3'h7;</font>
3750       1/1                else if (jam)
3751                             // decrement jam count until zero.
3752       <font color = "red">0/1     ==>           jam_cnt &lt;= jam_cnt - 3'h1;</font>
3753                          else
3754                             // hold jam count at zero.
3755       1/1                   jam_cnt &lt;= jam_cnt;
3756                       end
3757                    
3758                    
3759                       // jam goes to the transmit state machine
3760                       assign jam = (jam_cnt != 3'b000);
3761                    
3762                    
3763                       // crc generation logic follows.
3764                       // count down crc_cnt.
3765                       always@(posedge tx_clk or negedge n_txreset)
3766                       begin
3767       1/1                if (~n_txreset)
3768                             // asynchronous reset.
3769       1/1                   crc_cnt &lt;= 3'b111;
3770       1/1                else if (data_type == TYPE_CRC)
3771                             // crc active, count out period.
3772       1/1                   crc_cnt &lt;= crc_cnt - 3'h1;
3773       1/1                else if (tx_byte_mode)
3774                             // tx_byte_mode, count in bytes.
3775       <font color = "red">0/1     ==>           crc_cnt &lt;= 3'b011;</font>
3776                          else
3777                             // 10/100 mode, count in nibbles.
3778       1/1                   crc_cnt &lt;= 3'b111;
3779                       end
3780                    
3781                    
3782                       // high for a single cycle at the end of CRC generation.
3783                       // needs to be low when mac_tx_state enters CRC state.
3784                       assign last_crc = (crc_cnt == 3'b000);
3785                    
3786                    
3787                       // generate crc
3788                       gem_stripe i_str_tx_0(.din(txd_next[0]),
3789                                                      .stripe_in(crc),
3790                                                      .stripe_out(tx_stripe_out0));
3791                       gem_stripe i_str_tx_1(.din(txd_next[1]),
3792                                                      .stripe_in(tx_stripe_out0),
3793                                                      .stripe_out(tx_stripe_out1));
3794                       gem_stripe i_str_tx_2(.din(txd_next[2]),
3795                                                      .stripe_in(tx_stripe_out1),
3796                                                      .stripe_out(tx_stripe_out2));
3797                       gem_stripe i_str_tx_3(.din(txd_next[3]),
3798                                                      .stripe_in(tx_stripe_out2),
3799                                                      .stripe_out(tx_stripe_out3));
3800                       gem_stripe i_str_tx_4(.din(txd_next[4]),
3801                                                      .stripe_in(tx_stripe_out3),
3802                                                      .stripe_out(tx_stripe_out4));
3803                       gem_stripe i_str_tx_5(.din(txd_next[5]),
3804                                                      .stripe_in(tx_stripe_out4),
3805                                                      .stripe_out(tx_stripe_out5));
3806                       gem_stripe i_str_tx_6(.din(txd_next[6]),
3807                                                      .stripe_in(tx_stripe_out5),
3808                                                      .stripe_out(tx_stripe_out6));
3809                       gem_stripe i_str_tx_7(.din(txd_next[7]),
3810                                                      .stripe_in(tx_stripe_out6),
3811                                                      .stripe_out(tx_stripe_out7));
3812                    
3813                       // crc register and control.
3814                       always@(posedge tx_clk or negedge n_txreset)
3815                       begin
3816       1/1                if (~n_txreset)
3817                             // asynchronous reset.
3818       1/1                   crc &lt;= 32'hffffffff;
3819       1/1                else if (tx_en_next &amp; ((data_type == TYPE_DATA) | (data_type == TYPE_FILL)))
3820                              // data type is data or fill.
3821                             begin
3822       1/1                   if (tx_byte_mode)
3823                                // tx_byte_mode.
3824       <font color = "red">0/1     ==>              crc &lt;= tx_stripe_out7;</font>
3825                             else
3826                                // 10/100 mode.
3827       1/1                      crc &lt;= tx_stripe_out3;
3828                             end
3829       1/1                else if (tx_en_next &amp; (data_type == TYPE_CRC))
3830                             // data type is crc.
3831                             begin
3832       1/1                   if (tx_byte_mode)
3833                                // tx_byte_mode.
3834       <font color = "red">0/1     ==>              crc &lt;= {crc[23:0],8'h00};</font>
3835                             else
3836                                // 10/100 mode.
3837       1/1                      crc &lt;= {crc[27:0],4'h0};
3838                             end
3839       1/1                else if (data_type != TYPE_HOLD)
3840                             // reset crc generator.
3841       1/1                   crc &lt;= 32'hffffffff;
                   <font color = "red">==>  MISSING_ELSE</font>
3842                       end
3843                    
3844                    
3845                       // Signal generation for statistics reporting follows
3846                    
3847                       // generate multicast match for statistics recording.
3848                       // lsb of destination address indicates multicast.
3849                       always@(posedge tx_clk or negedge n_txreset)
3850                       begin
3851       1/1                if (~n_txreset)
3852                             // asynchronous reset.
3853       1/1                   multicast_match &lt;= 1'b0;
3854       1/1                else if (start_frame)
3855                             // clear statistic at start of frame.
3856       1/1                   multicast_match &lt;= 1'b0;
3857       1/1                else if ((tx_frame_length[13:0] == 14'h0001) &amp; (transmit_data_buf[0])
3858                                    &amp; ~nibble_sel)
3859                             // set statistic for lowest bit of destination address.
3860       1/1                   multicast_match &lt;= 1'b1;
3861                          else
3862                             // else hold value of statistic.
3863       1/1                   multicast_match &lt;= multicast_match;
3864                       end
3865                    
3866                    
3867                       // generate broadcast match for statistics recording.
3868                       // destination address of all 1's indicates broadcast.
3869                       always@(posedge tx_clk or negedge n_txreset)
3870                       begin
3871       1/1                if (~n_txreset)
3872                             // asynchronous reset.
3873       1/1                   broadcast_match &lt;= 1'b0;
3874       1/1                else if (start_frame)
3875                             // clear statistic at start of frame.
3876       1/1                   broadcast_match &lt;= 1'b0;
3877       1/1                else if ((tx_frame_length[13:0] == 14'h0001) &amp;
3878                              (transmit_data_buf[7:0] == 8'hff) &amp; ~nibble_sel)
3879                             // check for destination address all 1's.
3880       <font color = "red">0/1     ==>           broadcast_match &lt;= 1'b1;</font>
3881       1/1                else if ((tx_frame_length[13:0] &lt; 14'h0007) &amp;
3882                                  (tx_frame_length[13:0] != 14'h0000) &amp;
3883                                   (broadcast_match) &amp; ~nibble_sel)
3884                             begin
3885                             // check for destination address all 1's.
3886       <font color = "red">0/1     ==>              if (transmit_data_buf[7:0] == 8'hff)</font>
3887       <font color = "red">0/1     ==>                 broadcast_match &lt;= broadcast_match;</font>
3888                                else
3889       <font color = "red">0/1     ==>                 broadcast_match &lt;= 1'b0;</font>
3890                             end
3891                          else
3892                             // else hold value of statistic.
3893       1/1                   broadcast_match &lt;= broadcast_match;
3894                       end
3895                    
3896                    
3897                       // generate single collision tx frame statistics
3898                       always@(posedge tx_clk or negedge n_txreset)
3899                       begin
3900       1/1                if (~n_txreset)
3901                             // asynchronous reset.
3902       1/1                   single_collision &lt;= 1'b0;
3903       1/1                else if (~en_transmit_sync)
3904                             // synchronous reset (from software).
3905       1/1                   single_collision &lt;= 1'b0;
3906       1/1                else if (end_frame)
3907                             // clear statistic at end of frame.
3908       1/1                   single_collision &lt;= 1'b0;
3909       1/1                else if (coll_occured &amp; ~multi_collision)
3910                             // toggle single collision, unless multi collision set.
3911       <font color = "red">0/1     ==>           single_collision &lt;= ~single_collision;</font>
3912                          else
3913                             // else hold value of statistic.
3914       1/1                   single_collision &lt;= single_collision;
3915                       end
3916                    
3917                    
3918                       // generate multiple collision tx frame statistics
3919                       always@(posedge tx_clk or negedge n_txreset)
3920                       begin
3921       1/1                if (~n_txreset)
3922                             // asynchronous reset.
3923       1/1                   multi_collision &lt;= 1'b0;
3924       1/1                else if (~en_transmit_sync)
3925                             // synchronous reset (from software).
3926       1/1                   multi_collision &lt;= 1'b0;
3927       1/1                else if (end_frame)
3928                             // clear statistic at end of frame.
3929       1/1                   multi_collision &lt;= 1'b0;
3930       1/1                else if (coll_occured &amp; single_collision)
3931                             // set multi collision on second collision.
3932       <font color = "red">0/1     ==>           multi_collision &lt;= 1'b1;</font>
3933                          else
3934                             // else hold value of statistic.
3935       1/1                   multi_collision &lt;= multi_collision;
3936                       end
3937                    
3938                    
3939                       // generate late collision tx frame statistics
3940                       always@(posedge tx_clk or negedge n_txreset)
3941                       begin
3942       1/1                if (~n_txreset)
3943                             // asynchronous reset.
3944       1/1                   late_collision &lt;= 1'b0;
3945       1/1                else if (~en_transmit_sync)
3946                             // synchronous reset (from software).
3947       1/1                   late_collision &lt;= 1'b0;
3948       1/1                else if (end_frame)
3949                             // clear statistic at end of frame.
3950       1/1                   late_collision &lt;= 1'b0;
3951       1/1                else if (coll_occured &amp; ~late_col_threshold)
3952                             // set statistic for late collision, regardless
3953                             // of whether 10/100 mode or gigabit mode.
3954       <font color = "red">0/1     ==>           late_collision &lt;= 1'b1;</font>
3955                          else
3956                             // else hold value of statistic.
3957       1/1                   late_collision &lt;= late_collision;
3958                       end
3959                    
3960                       assign late_collision_gig = late_collision &amp;&amp; gigabit;
3961                    
3962                    
3963                       // set deferred when frame transmission has been deferred.
3964                       // this signal is used for tx frame statistics, and is only
3965                       // recorded when the frame doesn't experience a collision.
3966                       always@(posedge tx_clk or negedge n_txreset)
3967                       begin
3968       1/1                if (~n_txreset)
3969                             // asynchronous reset.
3970       1/1                   deferred &lt;= 1'b0;
3971       1/1                else if (~en_transmit_sync)
3972                             // synchronous reset (from software).
3973       1/1                   deferred &lt;= 1'b0;
3974       1/1                else if (end_frame | coll_occured)
3975                             // clear statistic at end of frame.
3976       1/1                   deferred &lt;= 1'b0;
3977       1/1                else if (~interframe_cnt[4] &amp; crs_sync &amp; ~int_end_frame &amp; first_ifg &amp;
3978                                   frame_ready)
3979                             // set statistic if defferal occurs prior to frame transmission.
3980       <font color = "red">0/1     ==>           deferred &lt;= 1'b1;</font>
3981                          else
3982                             // else hold value of statistic.
3983       1/1                   deferred &lt;= deferred;
3984                       end
3985                    
3986                    
3987                       // generate crs failure statistics
3988                       // assert crs_seen if crs is seen during frame transmission
3989                       always@(posedge tx_clk or negedge n_txreset)
3990                       begin
3991       1/1                if (~n_txreset)
3992                             // asynchronous reset.
3993       1/1                   crs_seen &lt;= 1'b0;
3994       1/1                else if (~en_transmit_sync)
3995                             // synchronous reset (from software).
3996       1/1                   crs_seen &lt;= 1'b0;
3997       1/1                else if (~tx_en_next &amp; ~(gigabit &amp; ~full_duplex))
3998                             // clear outside frame transmission in 10/100 mode.
3999       1/1                   crs_seen &lt;= 1'b0;
4000       1/1                else if (~tx_er_next &amp; ~tx_en_next &amp; gigabit &amp; ~full_duplex)
4001                             // clear outside frame transmission in gigabit mode.
4002       <font color = "red">0/1     ==>           crs_seen &lt;= 1'b0;</font>
4003       1/1                else if (crs_sync)
4004                             // frame active and crs detected.
4005       1/1                   crs_seen &lt;= 1'b1;
4006                          else
4007                             // else hold value.
4008       1/1                   crs_seen &lt;= crs_seen;
4009                       end
4010                    
4011                       // assert crs_deasserted if crs is deasserted after it has been seen
4012                       // during frame transmission
4013                       always@(posedge tx_clk or negedge n_txreset)
4014                       begin
4015       1/1                if (~n_txreset)
4016                             // asynchronous reset.
4017       1/1                   crs_deasserted &lt;= 1'b0;
4018       1/1                else if (~en_transmit_sync)
4019                             // synchronous reset (from software).
4020       1/1                   crs_deasserted &lt;= 1'b0;
4021       1/1                else if (end_frame | coll_occured)
4022                             // clear statistic at end of frame.
4023       1/1                   crs_deasserted &lt;= 1'b0;
4024       1/1                else if (crs_seen &amp; (data_type != TYPE_IDLE) &amp; ~crs_sync)
4025                             // crs was asserted and the deasserted within frame tx.
4026       <font color = "red">0/1     ==>           crs_deasserted &lt;= 1'b1;</font>
4027                          else
4028                             // else hold value.
4029       1/1                   crs_deasserted &lt;= crs_deasserted;
4030                       end
4031                    
4032                    
4033                       // assert crs_failure if crs not seen during transmission or if crs
4034                       // deasserted in a tranmsit frame without collision.
4035                       assign crs_failure = ~crs_seen | crs_deasserted;
4036                    
4037                    
4038                       // need to extend int_end_frame to mask deference statistics signal
4039                       // so that the defer statistics won't increment for back to back frames
4040                       always@(posedge tx_clk or negedge n_txreset)
4041                       begin
4042       1/1                if (~n_txreset)
4043                             // asynchronous reset.
4044                             begin
4045       1/1                      int_end_frame           &lt;= 1'b0;
4046       1/1                      int_end_frame_cnt[1:0]  &lt;= 2'b00;
4047                             end
4048       1/1                else if (~en_transmit_sync)
4049                             // synchronous reset (from software).
4050                             begin
4051       1/1                      int_end_frame           &lt;= 1'b0;
4052       1/1                      int_end_frame_cnt[1:0]  &lt;= 2'b00;
4053                             end
4054       1/1                else if (end_frame)
4055                             // trigger four clock count at end of frame.
4056                             begin
4057       1/1                      int_end_frame           &lt;= 1'b1;
4058       1/1                      int_end_frame_cnt[1:0]  &lt;= 2'b11;
4059                             end
4060       1/1                else if (int_end_frame_cnt != 2'b00)
4061                             // count until zero.
4062                             begin
4063       1/1                      int_end_frame           &lt;= 1'b1;
4064       1/1                      int_end_frame_cnt[1:0]  &lt;= int_end_frame_cnt - 2'b01;
4065                             end
4066                          else
4067                             // hold count at zero.
4068                             begin
4069       1/1                      int_end_frame           &lt;= 1'b0;
4070       1/1                      int_end_frame_cnt[1:0]  &lt;= 2'b00;
4071                             end
4072                       end
4073                    
4074                    
4075                       // status signals passed to dma for status write back at end of frame.
4076                       // handshaking is used to transfer the status signals from the tx_clk
4077                       // domain to the hclk domain. dma_status_edge is a one clock wide edge
4078                       // detect of dma_status_taken, and is used to clear the status outputs
4079                       // once recorded in the hclk domain.
4080                       always@(posedge tx_clk or negedge n_txreset)
4081                       begin
4082       1/1                if (~n_txreset)
4083                             // asynchronous reset.
4084                             begin
4085       1/1                      dma_tx_end_frame       &lt;= 1'b0;
4086       1/1                      dma_tx_end_tog         &lt;= 1'b0;
4087       1/1                      too_many_retries       &lt;= 1'b0;
4088       1/1                      underflow_frame        &lt;= 1'b0;
4089       1/1                      late_coll_occured      &lt;= 1'b0;
4090                             end
4091       1/1                else if (~en_transmit_sync)
4092                             // synchronous reset (from software).
4093                             begin
4094       1/1                      dma_tx_end_frame       &lt;= 1'b0;
4095       1/1                      dma_tx_end_tog         &lt;= dma_tx_end_tog;
4096       1/1                      too_many_retries       &lt;= 1'b0;
4097       1/1                      underflow_frame        &lt;= 1'b0;
4098       1/1                      late_coll_occured      &lt;= 1'b0;
4099                             end
4100       1/1                else if (late_col_pending &amp; ~dma_eof_noack &amp; ~pclksync_eof_noack)
4101                             // late collision pending, reported once status writeback has
4102                             // completed.
4103                             begin
4104       <font color = "red">0/1     ==>              dma_tx_end_frame       &lt;= 1'b1;</font>
4105       <font color = "red">0/1     ==>              dma_tx_end_tog         &lt;= ~dma_tx_end_tog;</font>
4106       <font color = "red">0/1     ==>              too_many_retries       &lt;= 1'b0;</font>
4107       <font color = "red">0/1     ==>              underflow_frame        &lt;= 1'b0;</font>
4108       <font color = "red">0/1     ==>              late_coll_occured      &lt;= 1'b1;</font>
4109                             end
4110       1/1                else if (end_frame &amp; ~pfc_or_pause_frame_transmitting &amp; ~dma_eof_noack
4111                                   &amp; ~pclksync_eof_noack)
4112                             // set status signals for the dma at end of frame, no
4113                             // previous status writeback in progress (and not a pause
4114                             // frame).
4115                             begin
4116       1/1                      dma_tx_end_frame       &lt;= 1'b1;
4117       1/1                      dma_tx_end_tog         &lt;= ~dma_tx_end_tog;
4118       1/1                      too_many_retries       &lt;= excess_coll;
4119       1/1                      underflow_frame        &lt;= fifo_underrun;
4120       1/1                      late_coll_occured      &lt;= ~fifo_underrun &amp; ~excess_coll &amp; late_collision_gig;
4121                             end
4122       1/1                else if (stat_underflow_pend &amp; ~dma_eof_noack &amp; ~pclksync_eof_noack &amp;
4123                                   ~stat_underflow_ack)
4124                             // status writeback error pending and previous acknowledge
4125                             // completed. generate underflow condition, and output with
4126                             // a toggle of dma_tx_end_tog.
4127                             begin
4128       <font color = "red">0/1     ==>              dma_tx_end_frame       &lt;= 1'b1;</font>
4129       <font color = "red">0/1     ==>              dma_tx_end_tog         &lt;= ~dma_tx_end_tog;</font>
4130       <font color = "red">0/1     ==>              too_many_retries       &lt;= 1'b0;</font>
4131       <font color = "red">0/1     ==>              underflow_frame        &lt;= 1'b1;</font>
4132       <font color = "red">0/1     ==>              late_coll_occured      &lt;= 1'b0;</font>
4133                             end
4134       1/1                else if (~dma_status_edge &amp; dma_tx_end_frame)
4135                             // wait for status to be taken by dma.
4136                             begin
4137       1/1                      dma_tx_end_frame       &lt;= 1'b1;
4138       1/1                      dma_tx_end_tog         &lt;= dma_tx_end_tog;
4139       1/1                      too_many_retries       &lt;= too_many_retries;
4140       1/1                      underflow_frame        &lt;= underflow_frame;
4141       1/1                      late_coll_occured      &lt;= late_coll_occured;
4142                             end
4143                          else
4144                             // clear status once status taken by dma.
4145                             begin
4146       1/1                      dma_tx_end_frame       &lt;= 1'b0;
4147       1/1                      dma_tx_end_tog         &lt;= dma_tx_end_tog;
4148       1/1                      too_many_retries       &lt;= 1'b0;
4149       1/1                      underflow_frame        &lt;= 1'b0;
4150       1/1                      late_coll_occured      &lt;= 1'b0;
4151                             end
4152                       end
4153                    
4154                    
4155                       // detect when end_frame has occurred, but
4156                       // gem_pclk_sync block has not acknowledged.
4157                       always@(posedge tx_clk or negedge n_txreset)
4158                       begin
4159       1/1                if (~n_txreset)
4160                             // asynchronous reset.
4161       1/1                   pclksync_eof_noack     &lt;= 1'b0;
4162       1/1                else if (~en_transmit_sync)
4163                             // synchronous reset (from software).
4164       1/1                   pclksync_eof_noack     &lt;= 1'b0;
4165       1/1                else if (end_frame &amp; ~pclksync_eof_noack &amp; ~dma_eof_noack &amp;
4166                                   ~late_collision_gig)
4167                             // set flag once end of frame has occurred.
4168       1/1                   pclksync_eof_noack     &lt;= 1'b1;
4169       1/1                else if (tx_status_edge)
4170                             // clear flag once acknowledged by gem_pclk_sync.
4171       1/1                   pclksync_eof_noack     &lt;= 1'b0;
4172                          else
4173                             // maintain value
4174       1/1                   pclksync_eof_noack     &lt;= pclksync_eof_noack;
4175                       end
4176                    
4177                    
4178                       // detect when end_frame has occurred, but
4179                       // dma block has not acknowledged.
4180                       always@(posedge tx_clk or negedge n_txreset)
4181                       begin
4182       1/1                if (~n_txreset)
4183                             // asynchronous reset.
4184       1/1                   dma_eof_noack          &lt;= 1'b0;
4185       1/1                else if (~en_transmit_sync)
4186                             // synchronous reset (from software).
4187       1/1                   dma_eof_noack          &lt;= 1'b0;
4188       1/1                else if (end_frame &amp; ~pclksync_eof_noack &amp; ~dma_eof_noack &amp;
4189                                   ~pfc_or_pause_frame_transmitting &amp; ~late_collision_gig)
4190                             // set flag once end of frame has occurred.
4191       1/1                   dma_eof_noack          &lt;= 1'b1;
4192       1/1                else if (dma_status_edge)
4193                             // clear flag once acknowledged by dma.
4194       1/1                   dma_eof_noack          &lt;= 1'b0;
4195                          else
4196                             // maintain value
4197       1/1                   dma_eof_noack          &lt;= dma_eof_noack;
4198                       end
4199                    
4200                    
4201                       // generate underflow pending both dma &amp; reg interface
4202                       // have not acknowledged the previous frame's status
4203                       // when a second frame completes (for short frames
4204                       // where a system error condition has occurred).
4205                       always@(posedge tx_clk or negedge n_txreset)
4206                       begin
4207       1/1                if (~n_txreset)
4208                             // asynchronous reset.
4209       1/1                   stat_underflow_pend   &lt;= 1'b0;
4210       1/1                else if (~en_transmit_sync)
4211                             // synchronous reset (from software).
4212       1/1                   stat_underflow_pend   &lt;= 1'b0;
4213       1/1                else if (end_frame &amp; ~late_collision_gig &amp;
4214                                  ((~pfc_or_pause_frame_transmitting &amp; dma_eof_noack) |
4215                                   pclksync_eof_noack))
4216                             // set flag if end of frame and previous not
4217                             // acknowledged by the dma or gem_pclk_sync blocks.
4218       <font color = "red">0/1     ==>           stat_underflow_pend   &lt;= 1'b1;</font>
4219       1/1                else if (stat_underflow_ack)
4220                             // clear flag once output to dma.
4221       <font color = "red">0/1     ==>           stat_underflow_pend   &lt;= 1'b0;</font>
4222                          else
4223                             // maintain value
4224       1/1                   stat_underflow_pend   &lt;= stat_underflow_pend;
4225                       end
4226                    
4227                    
4228                       // assert collision_int when coll_occurred and
4229                       // hold until it is output to the dma.
4230                       always@(posedge tx_clk or negedge n_txreset)
4231                       begin
4232       1/1                if (~n_txreset)
4233                             // asynchronous reset.
4234       1/1                   collision_int &lt;= 1'b0;
4235       1/1                else if (~en_transmit_sync)
4236                             // synchronous reset (from software).
4237       1/1                   collision_int &lt;= 1'b0;
4238       1/1                else if (coll_occured &amp; gigabit &amp; late_col_threshold &amp; ~last_attempt)
4239                             // do not set collision_int in gigabit mode if
4240                             // it is a late collision.
4241       <font color = "red">0/1     ==>           collision_int &lt;= 1'b1;</font>
4242       1/1                else if (coll_occured &amp; ~gigabit &amp; ~last_attempt)
4243                             // both collisions and late collision set this signal
4244                             // in 10/100 mode.
4245       <font color = "red">0/1     ==>           collision_int &lt;= 1'b1;</font>
4246       1/1                else if (collision_occured)
4247                             // clear status once status is passed to dma.
4248       <font color = "red">0/1     ==>           collision_int &lt;= 1'b0;</font>
4249                          else
4250                             // else hold value.
4251       1/1                   collision_int &lt;= collision_int;
4252                       end
4253                    
4254                    
4255                       // assert collision_occured when collision_int and
4256                       // hold until acknowledged by dma block.
4257                       always@(posedge tx_clk or negedge n_txreset)
4258                       begin
4259       1/1                if (~n_txreset)
4260                             // asynchronous reset.
4261       1/1                   collision_occured &lt;= 1'b0;
4262       1/1                else if (~en_transmit_sync)
4263                             // synchronous reset (from software).
4264       1/1                   collision_occured &lt;= 1'b0;
4265       1/1                else if (collision_int &amp; ~dma_eof_noack &amp; ~pclksync_eof_noack)
4266                             // only set this output once previous frame has been acknowledged.
4267       <font color = "red">0/1     ==>           collision_occured &lt;= 1'b1;</font>
4268       1/1                else if (dma_status_edge)
4269                             // clear status once it has been taken by dma.
4270       1/1                   collision_occured &lt;= 1'b0;
4271                          else
4272                             // else hold value.
4273       1/1                   collision_occured &lt;= collision_occured;
4274                       end
4275                    
4276                    
4277                       // status signal for bytes transmitted in frame, passed to gem_reg_top
4278                       // block and used to generate transmitted octets count.
4279                       // handshaking is used to transfer the status signal from the tx_clk
4280                       // domain to the pclk domain. tx_status_edge is a one clock wide edge
4281                       // detect of tx_status_taken, and is used to clear the statistic once
4282                       // recorded in the pclk domain.
4283                       always@(posedge tx_clk or negedge n_txreset)
4284                       begin
4285       1/1                if (~n_txreset)
4286                             // asynchronous reset.
4287       1/1                   tx_bytes_in_frame &lt;= 14'h0000;
4288       1/1                else if (~en_transmit_sync)
4289                             // synchronous reset (from software).
4290       1/1                   tx_bytes_in_frame &lt;= 14'h0000;
4291       1/1                else if (end_data_frame &amp; ~dma_eof_noack &amp; ~pclksync_eof_noack)
4292                             // gem_tx_psync module determines where byte count is for
4293                             // a successfully transmitted frame using tx_frame_txed_ok.
4294       1/1                   tx_bytes_in_frame  &lt;= tx_frame_length;
4295       1/1                else if (~tx_status_edge)
4296                             // wait for statistics to be taken.
4297       1/1                   tx_bytes_in_frame  &lt;= tx_bytes_in_frame;
4298                          else
4299                             // else clear counter.
4300       1/1                   tx_bytes_in_frame &lt;= 14'h0000;
4301                       end
4302                    
4303                    
4304                       // logic to hold a late collision, if it occurs during the
4305                       // status writeback period.
4306                       always@(posedge tx_clk or negedge n_txreset)
4307                       begin
4308       1/1                if (~n_txreset)
4309                             // asynchronous reset.
4310       1/1                   late_col_pending &lt;= 1'b0;
4311       1/1                else if (~en_transmit_sync)
4312                             // synchronous reset (from software).
4313       1/1                   late_col_pending &lt;= 1'b0;
4314       1/1                else if (late_collision_gig &amp; end_frame &amp; (dma_eof_noack |
4315                                   pclksync_eof_noack))
4316                             // writeback in progress and late collision has occurred.
4317       <font color = "red">0/1     ==>           late_col_pending &lt;= 1'b1;</font>
4318       1/1                else if (late_col_pending &amp; ~dma_eof_noack &amp; ~pclksync_eof_noack)
4319                             // writeback complete, so late collision may be reported.
4320       <font color = "red">0/1     ==>           late_col_pending &lt;= 1'b0;</font>
4321                          else
4322                             // hold current state.
4323       1/1                   late_col_pending &lt;= late_col_pending;
4324                       end
4325                    
4326                    
4327                       // status signals passed to gem_reg_top block for statistics recording at
4328                       // the end of frame.
4329                       // handshaking is used to transfer the status signals from the tx_clk
4330                       // domain to the pclk domain. tx_status_edge is a one clock wide edge
4331                       // detect of tx_status_taken, and is used to clear the statistics once
4332                       // recorded in the pclk domain.
4333                       always@(posedge tx_clk or negedge n_txreset)
4334                       begin
4335       1/1                if (~n_txreset)
4336                             // asynchronous reset.
4337                             begin
4338       1/1                      tx_end_frame           &lt;= 1'b0;
4339       1/1                      tx_end_tog             &lt;= 1'b0;
4340       1/1                      stat_underflow_ack     &lt;= 1'b0;
4341       1/1                      tx_pause_frame_txed    &lt;= 1'b0;
4342       1/1                      tx_pfc_pause_frame_txed&lt;= 1'b0;
4343       1/1                      tx_broadcast_frame     &lt;= 1'b0;
4344       1/1                      tx_multicast_frame     &lt;= 1'b0;
4345       1/1                      tx_frame_txed_ok       &lt;= 1'b0;
4346       1/1                      tx_single_coll_frame   &lt;= 1'b0;
4347       1/1                      tx_multi_coll_frame    &lt;= 1'b0;
4348       1/1                      tx_deferred_tx_frame   &lt;= 1'b0;
4349       1/1                      tx_late_coll_frame     &lt;= 1'b0;
4350       1/1                      tx_crs_error_frame     &lt;= 1'b0;
4351       1/1                      tx_too_many_retries    &lt;= 1'b0;
4352       1/1                      tx_underflow_frame     &lt;= 1'b0;
4353                             end
4354       1/1                else if (~en_transmit_sync)
4355                             // synchronous reset (from software).
4356                             begin
4357       1/1                      tx_end_frame           &lt;= 1'b0;
4358       1/1                      tx_end_tog             &lt;= tx_end_tog;
4359       1/1                      stat_underflow_ack     &lt;= 1'b0;
4360       1/1                      tx_pause_frame_txed    &lt;= 1'b0;
4361       1/1                      tx_pfc_pause_frame_txed&lt;= 1'b0;
4362       1/1                      tx_broadcast_frame     &lt;= 1'b0;
4363       1/1                      tx_multicast_frame     &lt;= 1'b0;
4364       1/1                      tx_frame_txed_ok       &lt;= 1'b0;
4365       1/1                      tx_single_coll_frame   &lt;= 1'b0;
4366       1/1                      tx_multi_coll_frame    &lt;= 1'b0;
4367       1/1                      tx_deferred_tx_frame   &lt;= 1'b0;
4368       1/1                      tx_late_coll_frame     &lt;= 1'b0;
4369       1/1                      tx_crs_error_frame     &lt;= 1'b0;
4370       1/1                      tx_too_many_retries    &lt;= 1'b0;
4371       1/1                      tx_underflow_frame     &lt;= 1'b0;
4372                             end
4373       1/1                else if (late_col_pending &amp; ~dma_eof_noack &amp; ~pclksync_eof_noack)
4374                             // late collision pending, reported once status writeback has
4375                             // completed.
4376                             begin
4377       <font color = "red">0/1     ==>              tx_end_frame           &lt;= 1'b1;</font>
4378       <font color = "red">0/1     ==>              tx_end_tog             &lt;= ~tx_end_tog;</font>
4379       <font color = "red">0/1     ==>              stat_underflow_ack     &lt;= 1'b1;</font>
4380       <font color = "red">0/1     ==>              tx_pause_frame_txed    &lt;= 1'b0;</font>
4381       <font color = "red">0/1     ==>              tx_pfc_pause_frame_txed&lt;= 1'b0;</font>
4382       <font color = "red">0/1     ==>              tx_broadcast_frame     &lt;= 1'b0;</font>
4383       <font color = "red">0/1     ==>              tx_multicast_frame     &lt;= 1'b0;</font>
4384       <font color = "red">0/1     ==>              tx_frame_txed_ok       &lt;= 1'b0;</font>
4385       <font color = "red">0/1     ==>              tx_single_coll_frame   &lt;= 1'b0;</font>
4386       <font color = "red">0/1     ==>              tx_multi_coll_frame    &lt;= 1'b0;</font>
4387       <font color = "red">0/1     ==>              tx_deferred_tx_frame   &lt;= 1'b0;</font>
4388       <font color = "red">0/1     ==>              tx_late_coll_frame     &lt;= 1'b1;</font>
4389       <font color = "red">0/1     ==>              tx_crs_error_frame     &lt;= 1'b0;</font>
4390       <font color = "red">0/1     ==>              tx_too_many_retries    &lt;= 1'b0;</font>
4391       <font color = "red">0/1     ==>              tx_underflow_frame     &lt;= 1'b0;</font>
4392                             end
4393       1/1                else if (end_frame &amp; ~pfc_or_pause_frame_transmitting &amp;
4394                                   ~dma_eof_noack &amp; ~pclksync_eof_noack)
4395                             // set statistics outputs for non pause frame.
4396                             begin
4397       1/1                      tx_end_frame           &lt;= 1'b1;
4398       1/1                      tx_end_tog             &lt;= ~tx_end_tog;
4399       1/1                      stat_underflow_ack     &lt;= 1'b0;
4400       1/1                      tx_pause_frame_txed    &lt;= 1'b0;
4401       1/1                      tx_pfc_pause_frame_txed&lt;= 1'b0;
4402       1/1                      tx_broadcast_frame     &lt;= ~fifo_underrun &amp; ~excess_coll &amp;
4403                                                          broadcast_match &amp;
4404                                                           ~late_collision_gig;
4405       1/1                      tx_multicast_frame     &lt;= ~fifo_underrun &amp; ~excess_coll &amp;
4406                                                          multicast_match &amp; ~broadcast_match &amp;
4407                                                           ~late_collision_gig;
4408       1/1                      tx_frame_txed_ok       &lt;= ~fifo_underrun &amp; ~excess_coll &amp;
4409                                                           ~late_collision_gig;
4410       1/1                      tx_single_coll_frame   &lt;= ~fifo_underrun &amp; ~excess_coll &amp;
4411                                                           single_collision &amp;
4412                                                           ~late_collision_gig;
4413       1/1                      tx_multi_coll_frame    &lt;= ~fifo_underrun &amp; ~excess_coll &amp;
4414                                                           multi_collision &amp;
4415                                                           ~late_collision_gig;
4416       1/1                      tx_deferred_tx_frame   &lt;= ~fifo_underrun &amp; deferred;
4417       1/1                      tx_late_coll_frame     &lt;= ~fifo_underrun &amp; ~excess_coll &amp;
4418                                                           late_collision;
4419       1/1                      tx_crs_error_frame     &lt;= ~fifo_underrun &amp; crs_failure &amp;
4420                                                           ~full_duplex;
4421       1/1                      tx_too_many_retries    &lt;= excess_coll;
4422                    
4423                                // Underflow caused by reading tx_r_err from FIFO should not raise
4424                                // an exception when in exposed FIFO interface configuration.
4425       1/1                      if (p_edma_ext_fifo_interface == 1)
4426       <font color = "red">0/1     ==>                tx_underflow_frame   &lt;= fifo_underrun &amp; ~fifo_err_underrun;</font>
4427       1/1                      else if (p_edma_host_if_soft_select == 1 &amp;&amp; soft_config_fifo_en)
4428       <font color = "red">0/1     ==>                tx_underflow_frame  &lt;= fifo_underrun &amp; ~fifo_err_underrun;</font>
4429                                else
4430       1/1                        tx_underflow_frame    &lt;= fifo_underrun | fifo_err_underrun;
4431                             end
4432       1/1                else if (end_frame &amp; pause_frame_transmitting &amp; ~dma_eof_noack
4433                                   &amp; ~pclksync_eof_noack)
4434                             // set statistics outputs for 802.3 pause frame.
4435                             begin
4436       <font color = "red">0/1     ==>              tx_end_frame           &lt;= 1'b1;</font>
4437       <font color = "red">0/1     ==>              tx_end_tog             &lt;= ~tx_end_tog;</font>
4438       <font color = "red">0/1     ==>              stat_underflow_ack     &lt;= 1'b0;</font>
4439       <font color = "red">0/1     ==>              tx_pause_frame_txed    &lt;= 1'b1;</font>
4440       <font color = "red">0/1     ==>              tx_pfc_pause_frame_txed&lt;= 1'b0;</font>
4441       <font color = "red">0/1     ==>              tx_broadcast_frame     &lt;= 1'b0;</font>
4442       <font color = "red">0/1     ==>              tx_multicast_frame     &lt;= 1'b0;</font>
4443       <font color = "red">0/1     ==>              tx_frame_txed_ok       &lt;= 1'b0;</font>
4444       <font color = "red">0/1     ==>              tx_single_coll_frame   &lt;= 1'b0;</font>
4445       <font color = "red">0/1     ==>              tx_multi_coll_frame    &lt;= 1'b0;</font>
4446       <font color = "red">0/1     ==>              tx_deferred_tx_frame   &lt;= 1'b0;</font>
4447       <font color = "red">0/1     ==>              tx_late_coll_frame     &lt;= 1'b0;</font>
4448       <font color = "red">0/1     ==>              tx_crs_error_frame     &lt;= 1'b0;</font>
4449       <font color = "red">0/1     ==>              tx_too_many_retries    &lt;= 1'b0;</font>
4450       <font color = "red">0/1     ==>              tx_underflow_frame     &lt;= 1'b0;</font>
4451                             end
4452       1/1                else if (end_frame &amp; pfc_frame_transmitting &amp; ~dma_eof_noack
4453                                   &amp; ~pclksync_eof_noack)
4454                             // set statistics outputs for PFC pause frame.
4455                             begin
4456       <font color = "red">0/1     ==>              tx_end_frame           &lt;= 1'b1;</font>
4457       <font color = "red">0/1     ==>              tx_end_tog             &lt;= ~tx_end_tog;</font>
4458       <font color = "red">0/1     ==>              stat_underflow_ack     &lt;= 1'b0;</font>
4459       <font color = "red">0/1     ==>              tx_pause_frame_txed    &lt;= 1'b0;</font>
4460       <font color = "red">0/1     ==>              tx_pfc_pause_frame_txed&lt;= 1'b1;</font>
4461       <font color = "red">0/1     ==>              tx_broadcast_frame     &lt;= 1'b0;</font>
4462       <font color = "red">0/1     ==>              tx_multicast_frame     &lt;= 1'b0;</font>
4463       <font color = "red">0/1     ==>              tx_frame_txed_ok       &lt;= 1'b0;</font>
4464       <font color = "red">0/1     ==>              tx_single_coll_frame   &lt;= 1'b0;</font>
4465       <font color = "red">0/1     ==>              tx_multi_coll_frame    &lt;= 1'b0;</font>
4466       <font color = "red">0/1     ==>              tx_deferred_tx_frame   &lt;= 1'b0;</font>
4467       <font color = "red">0/1     ==>              tx_late_coll_frame     &lt;= 1'b0;</font>
4468       <font color = "red">0/1     ==>              tx_crs_error_frame     &lt;= 1'b0;</font>
4469       <font color = "red">0/1     ==>              tx_too_many_retries    &lt;= 1'b0;</font>
4470       <font color = "red">0/1     ==>              tx_underflow_frame     &lt;= 1'b0;</font>
4471                             end
4472       1/1                else if (stat_underflow_pend &amp; ~dma_eof_noack &amp; ~pclksync_eof_noack &amp;
4473                                   ~stat_underflow_ack)
4474                             // report underrun due to status writeback not completing prior to
4475                             // a second end of frame. this condition should only occur when a short
4476                             // frame is pushed through the mac (with tx_no_crc set, hence no pad).
4477                             begin
4478       <font color = "red">0/1     ==>              tx_end_frame           &lt;= 1'b1;</font>
4479       <font color = "red">0/1     ==>              tx_end_tog             &lt;= ~tx_end_tog;</font>
4480       <font color = "red">0/1     ==>              stat_underflow_ack     &lt;= 1'b1;</font>
4481       <font color = "red">0/1     ==>              tx_pause_frame_txed    &lt;= 1'b0;</font>
4482       <font color = "red">0/1     ==>              tx_pfc_pause_frame_txed&lt;= 1'b0;</font>
4483       <font color = "red">0/1     ==>              tx_broadcast_frame     &lt;= 1'b0;</font>
4484       <font color = "red">0/1     ==>              tx_multicast_frame     &lt;= 1'b0;</font>
4485       <font color = "red">0/1     ==>              tx_frame_txed_ok       &lt;= 1'b0;</font>
4486       <font color = "red">0/1     ==>              tx_single_coll_frame   &lt;= 1'b0;</font>
4487       <font color = "red">0/1     ==>              tx_multi_coll_frame    &lt;= 1'b0;</font>
4488       <font color = "red">0/1     ==>              tx_deferred_tx_frame   &lt;= 1'b0;</font>
4489       <font color = "red">0/1     ==>              tx_late_coll_frame     &lt;= 1'b0;</font>
4490       <font color = "red">0/1     ==>              tx_crs_error_frame     &lt;= 1'b0;</font>
4491       <font color = "red">0/1     ==>              tx_too_many_retries    &lt;= 1'b0;</font>
4492       <font color = "red">0/1     ==>              tx_underflow_frame     &lt;= 1'b1;</font>
4493                             end
4494       1/1                else if (~tx_status_edge &amp; tx_end_frame)
4495                             // hold statistics outputs until taken by
4496                             // registers block.
4497                             begin
4498       1/1                      tx_end_frame           &lt;= 1'b1;
4499       1/1                      tx_end_tog             &lt;= tx_end_tog;
4500       1/1                      stat_underflow_ack     &lt;= stat_underflow_ack;
4501       1/1                      tx_pause_frame_txed    &lt;= tx_pause_frame_txed;
4502       1/1                      tx_pfc_pause_frame_txed&lt;= tx_pfc_pause_frame_txed;
4503       1/1                      tx_broadcast_frame     &lt;= tx_broadcast_frame;
4504       1/1                      tx_multicast_frame     &lt;= tx_multicast_frame;
4505       1/1                      tx_frame_txed_ok       &lt;= tx_frame_txed_ok;
4506       1/1                      tx_single_coll_frame   &lt;= tx_single_coll_frame;
4507       1/1                      tx_multi_coll_frame    &lt;= tx_multi_coll_frame;
4508       1/1                      tx_deferred_tx_frame   &lt;= tx_deferred_tx_frame;
4509       1/1                      tx_late_coll_frame     &lt;= tx_late_coll_frame;
4510       1/1                      tx_crs_error_frame     &lt;= tx_crs_error_frame;
4511       1/1                      tx_too_many_retries    &lt;= tx_too_many_retries;
4512       1/1                      tx_underflow_frame     &lt;= tx_underflow_frame;
4513                             end
4514                          else
4515                             // clear statistics outputs once taken by
4516                             // registers block.
4517                             begin
4518       1/1                      tx_end_frame           &lt;= 1'b0;
4519       1/1                      tx_end_tog             &lt;= tx_end_tog;
4520       1/1                      stat_underflow_ack     &lt;= 1'b0;
4521       1/1                      tx_pause_frame_txed    &lt;= 1'b0;
4522       1/1                      tx_pfc_pause_frame_txed&lt;= 1'b0;
4523       1/1                      tx_broadcast_frame     &lt;= 1'b0;
4524       1/1                      tx_multicast_frame     &lt;= 1'b0;
4525       1/1                      tx_frame_txed_ok       &lt;= 1'b0;
4526       1/1                      tx_single_coll_frame   &lt;= 1'b0;
4527       1/1                      tx_multi_coll_frame    &lt;= 1'b0;
4528       1/1                      tx_deferred_tx_frame   &lt;= 1'b0;
4529       1/1                      tx_late_coll_frame     &lt;= 1'b0;
4530       1/1                      tx_crs_error_frame     &lt;= 1'b0;
4531       1/1                      tx_too_many_retries    &lt;= 1'b0;
4532       1/1                      tx_underflow_frame     &lt;= 1'b0;
4533                             end
4534                       end
4535                    
4536                    
4537                       // assert tx_coll_occured when coll_occured and
4538                       // hold until acknowledged by register block.
4539                       always@(posedge tx_clk or negedge n_txreset)
4540                       begin
4541       1/1                if (~n_txreset)
4542                             // asynchronous reset.
4543       1/1                   tx_coll_occured &lt;= 1'b0;
4544       1/1                else if (~en_transmit_sync)
4545                             // synchronous reset (from software).
4546       1/1                   tx_coll_occured &lt;= 1'b0;
4547       1/1                else if (collision_int &amp; ~dma_eof_noack &amp; ~pclksync_eof_noack)
4548                             // collision occurred and status/statistics update from
4549                             // previous frame complete.
4550       <font color = "red">0/1     ==>           tx_coll_occured &lt;= 1'b1;</font>
4551       1/1                else if (tx_status_edge)
4552                             // clear status once it has been taken by registers block.
4553       1/1                   tx_coll_occured &lt;= 1'b0;
4554                          else
4555                             // else hold value.
4556       1/1                   tx_coll_occured &lt;= tx_coll_occured;
4557                       end
4558                    
4559                    
4560                       // IEEE 1588
4561                       // drive sof_tx
4562                       // assert at start of frame, de-assert at end of frame
4563                       always@(posedge tx_clk or negedge n_txreset)
4564                         begin
4565       1/1                if (~n_txreset)
4566                             begin
4567       1/1                      sof_tx &lt;= 1'b0;
4568                             end
4569       1/1                else if (~tx_en | ~en_transmit_sync)
4570                             begin
4571       1/1                      sof_tx &lt;= 1'b0;
4572                             end
4573       1/1                else if (data_type == TYPE_SFD)
4574                             begin
4575       1/1                      sof_tx &lt;= 1'b1;
4576                             end
                        MISSING_ELSE
4577                         end
4578                    
4579                    
4580                       // Transmit Decode State Machine (synchronous part)
4581                       always@(posedge tx_clk or negedge n_txreset)
4582                         begin
4583       1/1                if (~n_txreset)
4584                             begin
4585       1/1                      tx_dec_state    &lt;= TX_DEC_IDLE;
4586       1/1                      en_tx_ptp_count &lt;= 1'b0;
4587                             end
4588                          // stop at end of frame or if not PTP event frame
4589       1/1                else if (~tx_en | ~en_transmit_sync)
4590                             begin
4591       1/1                      tx_dec_state    &lt;= TX_DEC_IDLE;
4592       1/1                      en_tx_ptp_count &lt;= 1'b0;
4593                             end
4594                          else
4595                             begin
4596       1/1                      tx_dec_state    &lt;= tx_dec_state_nxt;
4597       1/1                      en_tx_ptp_count &lt;= en_tx_ptp_count_nxt;
4598                             end
4599                         end
4600                    
4601                      wire tx_buf_89bcd;  // Create a useful signal for use later on - used for detecting PTP general messages
4602                      wire tx_buf_234;    // Create a useful signal for use later on - used for detecting PTP general messages
4603                      wire general_frame_tx_dec;  // Create a useful signal for use later on - used for detecting PTP general messages
4604                      wire ptp_primary_nunicast;    // Create a useful signal for use later on - PTP primary version 1, not unicast on last byte of dest add
4605                      wire ptp_pri_final_general_chk;    // Create a useful signal for use later on - detect General 1588 Messages
4606                      wire ptp_peer_final_general_chk;    // Create a useful signal for use later on - detect General 1588 Messages
4607                      assign tx_buf_89bcd =  (transmit_data_buf[3:0] == 4'h8)
4608                                            |(transmit_data_buf[3:0] == 4'h9)
4609                                            |(transmit_data_buf[3:0] == 4'hb)
4610                                            |(transmit_data_buf[3:0] == 4'hc)
4611                                            |(transmit_data_buf[3:0] == 4'hd);
4612                    
4613                      assign  tx_buf_234 =  ((transmit_data_buf[3:0] == 4'h2)   // ptp_delay_req for ptp version 1
4614                                            |(transmit_data_buf[3:0] == 4'h3)   // ptp_followup for ptp version 1
4615                                            |(transmit_data_buf[3:0] == 4'h4)); // ptp_management for ptp version 1
4616                    
4617                      assign general_frame_tx_dec =  general_frame_tx &amp; tx_buf_89bcd;
4618                       // PTP primary version 1, not unicast on last byte of dest add
4619                      assign ptp_primary_nunicast =  ~ptp_unicast &amp;
4620                                                    ((transmit_data_buf[7:0] == 8'h82) |
4621                                                     (transmit_data_buf[7:0] == 8'h83) |
4622                                                     (transmit_data_buf[7:0] == 8'h84));
4623                    
4624                      assign ptp_pri_final_general_chk = general_frame_tx &amp; (tx_buf_89bcd |(ptp_unicast &amp; (transmit_data_buf[3:0] == 4'ha)));
4625                      assign ptp_peer_final_general_chk = general_frame_tx &amp; transmit_data_buf[3:0] == 4'ha;// Pdelay_Resp_Follow_Up
4626                    
4627                       // Transmit Decode State Machine (asynchronous part)
4628                       always@(*)
4629                       begin
4630                    
4631                          // defaults for next value is current value
4632       1/1                en_tx_ptp_count_nxt            = en_tx_ptp_count;
4633       1/1                sync_frame_tx_nxt              = sync_frame_tx;
4634       1/1                delay_req_tx_nxt               = delay_req_tx;
4635       1/1                pdelay_req_tx_nxt              = pdelay_req_tx;
4636       1/1                pdelay_resp_tx_nxt             = pdelay_resp_tx;
4637       1/1                general_frame_tx_nxt           = general_frame_tx;
4638       1/1                ptp_ver_1_nxt                  = ptp_ver_1;
4639       1/1                ptp_ver_2_nxt                  = ptp_ver_2;
4640       1/1                ptp_unicast_nxt                = ptp_unicast;
4641       1/1                ptp_timestamp_position         = 7'h7f;
4642       1/1                ptp_timestamp_position_cap     = 1'b0;
4643       1/1                ptp_timestamp_position_cap_v1  = 1'b0;
4644                    
4645                          // decode current state
4646       1/1                case (tx_dec_state)
4647                    
4648                             TX_DEC_START : // decode PTP Multicast MAC addresses or IPv4/IPV6 Ethertype
4649                                begin
4650                                   // Multicast MAC addresses part1
4651       1/1                         if (tx_ptp_count == 7'b0000000)
4652                                      begin
4653                                         // address part1 01
4654       1/1                               if (transmit_data_buf[7:0] == 8'h01 &amp; (data_type == TYPE_DATA))
4655                                            begin
4656       1/1                                     tx_dec_state_nxt = TX_DEC_PTP_1;
4657                                            end
4658                                         else
4659                                            begin
4660       1/1                                     tx_dec_state_nxt = TX_DEC_START;
4661                                            end
4662                                      end
4663                                   // Ethertype needs IPv4, IPv6 or VLAN type ID
4664       1/1                         else if (tx_ptp_count == 7'b0001100)
4665                                      begin
4666                                         // IPv6
4667       1/1                               if (transmit_data_buf[7:0] == 8'h86)
4668                                            begin
4669       <font color = "red">0/1     ==>                             tx_dec_state_nxt = TX_DEC_IPV6_1;</font>
4670                                            end
4671                                         // IPv4
4672       1/1                               else if (transmit_data_buf[7:0] == 8'h08)
4673                                            begin
4674       1/1                                     tx_dec_state_nxt = TX_DEC_IPV4_1;
4675                                            end
4676                                         // VLAN
4677       1/1                               else if (transmit_data_buf[7:0] == 8'h81)
4678                                            begin
4679       <font color = "red">0/1     ==>                             tx_dec_state_nxt = TX_DEC_START;</font>
4680                                            end
4681                                         else
4682                                            begin
4683       1/1                                     tx_dec_state_nxt = TX_DEC_IDLE;
4684                                            end
4685                                      end
4686                                   // VLAN
4687       1/1                         else if (tx_ptp_count == 7'b0001101)
4688                                      begin
4689                                         // VLAN
4690       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h00)</font>
4691                                            begin
4692       <font color = "red">0/1     ==>                             tx_dec_state_nxt = TX_DEC_START;</font>
4693                                            end
4694                                         else
4695                                            begin
4696       <font color = "red">0/1     ==>                             tx_dec_state_nxt = TX_DEC_IDLE;</font>
4697                                            end
4698                                      end
4699                                   // VLAN, Ethertype needs IPv4 or IPv6 type ID
4700       1/1                         else if (tx_ptp_count == 7'b0010000)
4701                                      begin
4702                                         // IPv6
4703       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h86)</font>
4704                                            begin
4705       <font color = "red">0/1     ==>                             tx_dec_state_nxt = TX_DEC_VIPV6_1;</font>
4706                                            end
4707                                         // IPv4
4708       <font color = "red">0/1     ==>                       else if (transmit_data_buf[7:0] == 8'h08)</font>
4709                                            begin
4710       <font color = "red">0/1     ==>                             tx_dec_state_nxt = TX_DEC_VIPV4_1;</font>
4711                                            end
4712                                         else
4713                                            begin
4714       <font color = "red">0/1     ==>                             tx_dec_state_nxt = TX_DEC_IDLE;</font>
4715                                            end
4716                                      end
4717                                   else
4718                                      begin
4719       1/1                               tx_dec_state_nxt     = TX_DEC_START;
4720                                      end
4721                                end
4722                    
4723                             TX_DEC_PTP_1 : // decode Ethernet PTP
4724                                begin
4725       1/1                         case (tx_ptp_count)
4726                    
4727                                   7'b0000001 : // Multicast MAC addresses part2
4728                                      begin
4729                                         // address part2 1b
4730       1/1                               if (transmit_data_buf[7:0] == 8'h1b)
4731       <font color = "red">0/1     ==>                          tx_dec_state_nxt = TX_DEC_PTP_1;</font>
4732                                         // address part2 80
4733       1/1                               else if (transmit_data_buf[7:0] == 8'h80)
4734       <font color = "red">0/1     ==>                          tx_dec_state_nxt = TX_DEC_PTP_2;</font>
4735                                         else
4736       1/1                                  tx_dec_state_nxt = TX_DEC_START;
4737                                      end
4738                    
4739                                   7'b0000010 : // Multicast MAC addresses part3
4740                                      begin
4741                                         // address part3 19
4742       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h19)</font>
4743       <font color = "red">0/1     ==>                          tx_dec_state_nxt = TX_DEC_PTP_1;</font>
4744                                         else
4745       <font color = "red">0/1     ==>                          tx_dec_state_nxt = TX_DEC_START;</font>
4746                                      end
4747                    
4748                                   7'b0000011 : // Multicast MAC addresses part4
4749                                      begin
4750                                         // address part3 00
4751       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h00)</font>
4752       <font color = "red">0/1     ==>                          tx_dec_state_nxt = TX_DEC_PTP_1;</font>
4753                                         else
4754       <font color = "red">0/1     ==>                          tx_dec_state_nxt = TX_DEC_START;</font>
4755                                      end
4756                    
4757                                   7'b0000100 : // Multicast  MAC addresses part5
4758                                      begin
4759                                         // address part5 00
4760       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h00)</font>
4761       <font color = "red">0/1     ==>                          tx_dec_state_nxt = TX_DEC_PTP_1;</font>
4762                                         // invalid - wait for next frame
4763                                         else
4764       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
4765                                       end
4766                    
4767                                   7'b0000101 : // Multicast  MAC addresses part6
4768                                      begin
4769                                         // address part6 00
4770       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h00)</font>
4771       <font color = "red">0/1     ==>                          tx_dec_state_nxt = TX_DEC_PTP_1;</font>
4772                                         // invalid - wait for next frame
4773                                         else
4774       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
4775                                       end
4776                    
4777                                   7'b0001100 : // Ethertype1 PTP
4778                                      begin
4779       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h88)</font>
4780       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_PTP_1;</font>
4781       <font color = "red">0/1     ==>                       else if (transmit_data_buf[7:0] == 8'h81)</font>
4782       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VPTP_1;</font>
4783                                         // invalid - wait for next frame
4784                                         else
4785       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
4786                                       end
4787                    
4788                                   7'b0001101 : // Ethertype2 PTP
4789                                      begin
4790       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'hf7)</font>
4791       <font color = "red">0/1     ==>                         tx_dec_state_nxt  = TX_DEC_PTP_1;</font>
4792                                         // invalid - wait for next frame
4793                                         else
4794       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
4795                                       end
4796                    
4797                                   7'b0001110 : // messageType
4798                                      begin
4799                                         // sync frame
4800       <font color = "red">0/1     ==>                       if (transmit_data_buf[3:0] == 4'h0)</font>
4801                                            begin
4802       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_PTP_1;</font>
4803       <font color = "red">0/1     ==>                             sync_frame_tx_nxt = 1'b1;</font>
4804       <font color = "red">0/1     ==>                             ptp_timestamp_position = tx_ptp_count;</font>
4805       <font color = "red">0/1     ==>                             ptp_timestamp_position_cap   = 1'b1;</font>
4806                                            end
4807                                         // delay_req frame
4808       <font color = "red">0/1     ==>                       else if (transmit_data_buf[3:0] == 4'h1)</font>
4809                                           begin
4810       <font color = "red">0/1     ==>                           tx_dec_state_nxt  = TX_DEC_PTP_1;</font>
4811       <font color = "red">0/1     ==>                           delay_req_tx_nxt  = 1'b1;</font>
4812                                           end
4813                                         // detect General 1588 Messages then wait for next frame and also if
4814                                         // invalid - wait for next frame
4815                                         else
4816                                         begin
4817       <font color = "red">0/1     ==>                         general_frame_tx_nxt =  tx_buf_89bcd;</font>
4818       <font color = "red">0/1     ==>                         tx_dec_state_nxt  = TX_DEC_IDLE;</font>
4819                                         end
4820                                      end
4821                    
4822                    
4823                                   7'b0110000 : // timestamp start position is 34B after messageType
4824                                      begin
4825       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_PTP_1;</font>
4826                                      end
4827                    
4828                                   7'b0111001 : // timestamp end position is 9B after timestamp start
4829                                      begin
4830                                         // this will stop tx_ptp_count after TS finished
4831       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_IDLE;</font>
4832                                      end
4833                    
4834                                   default :
4835                                      begin
4836       1/1                               tx_dec_state_nxt  = TX_DEC_PTP_1;
4837                                      end
4838                    
4839                                   endcase
4840                                end
4841                    
4842                             TX_DEC_PTP_2 : // decode Ethertype PTP
4843                                begin
4844       <font color = "red">0/1     ==>                 case (tx_ptp_count)</font>
4845                    
4846                                   7'b0000001 : // Multicast MAC addresses part2
4847                                      begin
4848                                         // address part2 80 - must be 80 as this can only
4849                                         // happen in 10/100 mode where data is transferred
4850                                         // in nibbles - this is just the 2nd half of the data
4851                                         // that we already decoded in TX_DEC_PTP_1
4852                                         //if (transmit_data_buf[7:0] == 8'h80)
4853       <font color = "red">0/1     ==>                          tx_dec_state_nxt = TX_DEC_PTP_2;</font>
4854                                         //else
4855                                         //   tx_dec_state_nxt = TX_DEC_START;
4856                                      end
4857                    
4858                                   7'b0000010 : // Multicast MAC addresses part3
4859                                      begin
4860                                         // address part3 c2
4861       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'hc2)</font>
4862       <font color = "red">0/1     ==>                          tx_dec_state_nxt = TX_DEC_PTP_2;</font>
4863                                         else
4864       <font color = "red">0/1     ==>                          tx_dec_state_nxt = TX_DEC_START;</font>
4865                                      end
4866                    
4867                                   7'b0000011 : // Multicast MAC addresses part4
4868                                      begin
4869                                         // address part3 00
4870       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h00)</font>
4871       <font color = "red">0/1     ==>                          tx_dec_state_nxt = TX_DEC_PTP_2;</font>
4872                                         else
4873       <font color = "red">0/1     ==>                          tx_dec_state_nxt = TX_DEC_START;</font>
4874                                      end
4875                    
4876                                   7'b0000100 : // Multicast  MAC addresses part5
4877                                      begin
4878                                         // address part5 00
4879       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h00)</font>
4880       <font color = "red">0/1     ==>                          tx_dec_state_nxt = TX_DEC_PTP_2;</font>
4881                                         // invalid - wait for next frame
4882                                         else
4883       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
4884                                       end
4885                    
4886                                   7'b0000101 : // Multicast  MAC addresses part6
4887                                      begin
4888                                         // address part6 0e
4889       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h0e)</font>
4890       <font color = "red">0/1     ==>                          tx_dec_state_nxt = TX_DEC_PTP_2;</font>
4891                                         // invalid - wait for next frame
4892                                         else
4893       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
4894                                       end
4895                    
4896                                   7'b0001100 : // Ethertype1 PTP
4897                                      begin
4898       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h88)</font>
4899       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_PTP_2;</font>
4900       <font color = "red">0/1     ==>                       else if (transmit_data_buf[7:0] == 8'h81)</font>
4901       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VPTP_2;</font>
4902                                         // invalid - wait for next frame
4903                                         else
4904       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
4905                                       end
4906                    
4907                                   7'b0001101 : // Ethertype2 PTP
4908                                      begin
4909       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'hf7)</font>
4910       <font color = "red">0/1     ==>                         tx_dec_state_nxt  = TX_DEC_PTP_2;</font>
4911                                         // invalid - wait for next frame
4912                                         else
4913       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
4914                                       end
4915                    
4916                                   7'b0001110 : // messageType
4917                                      begin
4918                                         // sync frame detection for 801.AS
4919       <font color = "red">0/1     ==>                       if (transmit_data_buf[3:0] == 4'h0)</font>
4920                                            begin
4921       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_PTP_2;</font>
4922       <font color = "red">0/1     ==>                             sync_frame_tx_nxt = 1'b1;</font>
4923       <font color = "red">0/1     ==>                             ptp_timestamp_position = tx_ptp_count;</font>
4924       <font color = "red">0/1     ==>                             ptp_timestamp_position_cap   = 1'b1;</font>
4925                                            end
4926                                         // pdelay_req frame
4927       <font color = "red">0/1     ==>                       else if (transmit_data_buf[3:0] == 4'h2)</font>
4928                                            begin
4929       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_PTP_2;</font>
4930       <font color = "red">0/1     ==>                             pdelay_req_tx_nxt = 1'b1;</font>
4931                                            end
4932                                         // pdelay_resp
4933       <font color = "red">0/1     ==>                       else if (transmit_data_buf[3:0] == 4'h3)</font>
4934                                            begin
4935       <font color = "red">0/1     ==>                             tx_dec_state_nxt   = TX_DEC_PTP_2;</font>
4936       <font color = "red">0/1     ==>                             pdelay_resp_tx_nxt = 1'b1;</font>
4937                                            end
4938                                         // detect General 1588 Messages then wait for next frame and also if
4939                                         // invalid - wait for next frame
4940                                         // only detect Pdelay general message for 1588 but add Follow_Up for 802.1AS
4941                                         else
4942                                         begin
4943       <font color = "red">0/1     ==>                         general_frame_tx_nxt =  ((transmit_data_buf[3:0] == 4'h8)   // Follow_Up (for 802.1AS)</font>
4944                                                                   |(transmit_data_buf[3:0] == 4'ha)   // Pdelay_Resp_Follow_Up
4945                                                                   |(transmit_data_buf[3:0] == 4'hb)   // Announce (for 802.1AS)
4946                                                                   |(transmit_data_buf[3:0] == 4'hc)); // Signalling (for 802.1AS)
4947       <font color = "red">0/1     ==>                         tx_dec_state_nxt  = TX_DEC_IDLE;</font>
4948                                         end
4949                                      end
4950                    
4951                                   7'b0110000 : // timestamp start position is 34B after messageType
4952                                      begin
4953       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_PTP_2;</font>
4954                                      end
4955                    
4956                                   7'b0111001 : // timestamp end position is 9B after timestamp start
4957                                      begin
4958                                         // this will stop tx_ptp_count after TS finished
4959       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_IDLE;</font>
4960                                      end
4961                    
4962                                   default :
4963                                      begin
4964       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_PTP_2;</font>
4965                                      end
4966                    
4967                                   endcase
4968                                end
4969                    
4970                             TX_DEC_VPTP_1 : // decode Ethernet PTP
4971                                begin
4972       <font color = "red">0/1     ==>                 case (tx_ptp_count)</font>
4973                    
4974                                   7'b0001101 : // VLAN
4975                                      begin
4976       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h00)</font>
4977       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VPTP_1;</font>
4978                                         // invalid - wait for next frame
4979                                         else
4980       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
4981                                       end
4982                    
4983                                   7'b0010000 : // Ethertype1 PTP
4984                                      begin
4985       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h88)</font>
4986       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VPTP_1;</font>
4987                                         // invalid - wait for next frame
4988                                         else
4989       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
4990                                       end
4991                    
4992                                   7'b0010001 : // Ethertype2 PTP
4993                                      begin
4994       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'hf7)</font>
4995       <font color = "red">0/1     ==>                         tx_dec_state_nxt  = TX_DEC_VPTP_1;</font>
4996                                         // invalid - wait for next frame
4997                                         else
4998       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
4999                                       end
5000                    
5001                                   7'b0010010 : // messageType
5002                                      begin
5003                                         // sync frame
5004       <font color = "red">0/1     ==>                       if (transmit_data_buf[3:0] == 4'h0)</font>
5005                                            begin
5006       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_VPTP_1;</font>
5007       <font color = "red">0/1     ==>                             sync_frame_tx_nxt = 1'b1;</font>
5008       <font color = "red">0/1     ==>                             ptp_timestamp_position = tx_ptp_count;</font>
5009       <font color = "red">0/1     ==>                             ptp_timestamp_position_cap   = 1'b1;</font>
5010                                            end
5011                                         // delay_req frame
5012       <font color = "red">0/1     ==>                       else if (transmit_data_buf[3:0] == 4'h1)</font>
5013                                            begin
5014       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_VPTP_1;</font>
5015       <font color = "red">0/1     ==>                             delay_req_tx_nxt  = 1'b1;</font>
5016                                            end
5017                                         // detect General 1588 Messages then wait for next frame and also if
5018                                         // invalid - wait for next frame
5019                                         else
5020                                         begin
5021       <font color = "red">0/1     ==>                         general_frame_tx_nxt =  tx_buf_89bcd;</font>
5022       <font color = "red">0/1     ==>                         tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5023                                         end
5024                                      end
5025                    
5026                                   7'b0110100 : // timestamp start position is 34B after messageType
5027                                      begin
5028       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_VPTP_1;</font>
5029                                      end
5030                    
5031                                   7'b0111101 : // timestamp end position is 9B after timestamp start
5032                                      begin
5033                                         // this will stop tx_ptp_count after TS finished
5034       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5035                                      end
5036                    
5037                                   default :
5038                                      begin
5039       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_VPTP_1;</font>
5040                                      end
5041                    
5042                                   endcase
5043                                end
5044                    
5045                             TX_DEC_VPTP_2 : // decode Ethertype PTP
5046                                begin
5047       <font color = "red">0/1     ==>                 case (tx_ptp_count)</font>
5048                    
5049                                   7'b0001101 : // VLAN
5050                                      begin
5051       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h00)</font>
5052       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VPTP_2;</font>
5053                                         // invalid - wait for next frame
5054                                         else
5055       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5056                                       end
5057                    
5058                                   7'b0010000 : // Ethertype1 PTP
5059                                      begin
5060       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h88)</font>
5061       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VPTP_2;</font>
5062                                         // invalid - wait for next frame
5063                                         else
5064       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5065                                       end
5066                    
5067                                   7'b0010001 : // Ethertype2 PTP
5068                                      begin
5069       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'hf7)</font>
5070       <font color = "red">0/1     ==>                         tx_dec_state_nxt  = TX_DEC_VPTP_2;</font>
5071                                         // invalid - wait for next frame
5072                                         else
5073       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5074                                       end
5075                    
5076                                   7'b0010010 : // messageType
5077                                      begin  // Sync frame for 802.1AS is not supported with VLAN tag
5078                                             // so sync frame decode has been removed from this state
5079                                         // pdelay_req frame
5080       <font color = "red">0/1     ==>                       if (transmit_data_buf[3:0] == 4'h2)</font>
5081                                            begin
5082       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_VPTP_2;</font>
5083       <font color = "red">0/1     ==>                             pdelay_req_tx_nxt = 1'b1;</font>
5084                                            end
5085                                         // pdelay_resp
5086       <font color = "red">0/1     ==>                       else if (transmit_data_buf[3:0] == 4'h3)</font>
5087                                            begin
5088       <font color = "red">0/1     ==>                             tx_dec_state_nxt   = TX_DEC_VPTP_2;</font>
5089       <font color = "red">0/1     ==>                             pdelay_resp_tx_nxt = 1'b1;</font>
5090                                            end
5091                                         // detect General 1588 Messages then wait for next frame and also if
5092                                         // invalid - wait for next frame
5093                                         else
5094                                         begin
5095       <font color = "red">0/1     ==>                         general_frame_tx_nxt =  (transmit_data_buf[3:0] == 4'ha);   // Pdelay_Resp_Follow_Up</font>
5096       <font color = "red">0/1     ==>                         tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5097                                         end
5098                                      end
5099                    
5100                                   7'b0110100 : // timestamp start position is 34B after messageType
5101                                      begin
5102       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_VPTP_2;</font>
5103                                      end
5104                    
5105                                   7'b0111101 : // timestamp end position is 9B after timestamp start
5106                                      begin
5107                                         // this will stop tx_ptp_count after TS finished
5108       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5109                                      end
5110                    
5111                                   default :
5112                                      begin
5113       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_VPTP_2;</font>
5114                                      end
5115                    
5116                                   endcase
5117                                end
5118                    
5119                             TX_DEC_IPV4_1 : // decode IPv4
5120                                begin
5121       1/1                         case (tx_ptp_count)
5122                                   7'b0001101 : // Ethertype IPv4
5123                                      begin
5124       1/1                               if (transmit_data_buf[7:0] == 8'h00)
5125       1/1                                  tx_dec_state_nxt  = TX_DEC_IPV4_1;
5126                                         // invalid - wait for next frame
5127                                         else
5128       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5129                                       end
5130                    
5131                                   7'b0010111 : // UDP protocol
5132                                      begin
5133       1/1                               if (transmit_data_buf[7:0] == 8'h11)
5134       1/1                                  tx_dec_state_nxt  = TX_DEC_IPV4_1;
5135                                         // invalid - wait for next frame
5136                                         else
5137       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5138                                       end
5139                    
5140                                   7'b0011110 : // IP multicast address 1
5141                                      begin
5142                                         // PTP primary and peer
5143       1/1                               if (transmit_data_buf[7:0] == 8'he0)
5144                                            begin
5145       1/1                                     tx_dec_state_nxt  = TX_DEC_IPV4_1;
5146       1/1                                     if (ptp_unicast_ena_sync &amp;
5147                                                   (transmit_data_buf[7:0] == tx_ptp_unicast[31:24]))
5148       <font color = "red">0/1     ==>                                ptp_unicast_nxt   = 1'b1;</font>
                        MISSING_ELSE
5149                                            end
5150                                         // PTP unicast
5151       <font color = "red">0/1     ==>                       else if (ptp_unicast_ena_sync &amp;</font>
5152                                                  (transmit_data_buf[7:0] == tx_ptp_unicast[31:24]))
5153                                            begin
5154       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_IPV4_1;</font>
5155       <font color = "red">0/1     ==>                             ptp_unicast_nxt   = 1'b1;</font>
5156                                            end
5157                                         // invalid - wait for next frame
5158                                         else
5159       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5160                                      end
5161                    
5162                                   7'b0011111 : // IP multicast address 2
5163                                      begin
5164                                         // PTP primary and peer, not unicast
5165       1/1                               if (~ptp_unicast &amp; (transmit_data_buf[7:0] == 8'h00))
5166       1/1                                  tx_dec_state_nxt  = TX_DEC_IPV4_1;
5167                                         // PTP unicast
5168       <font color = "red">0/1     ==>                       else if (ptp_unicast &amp;</font>
5169                                                  (transmit_data_buf[7:0] == tx_ptp_unicast[23:16]))
5170                                            begin
5171       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_IPV4_1;</font>
5172       <font color = "red">0/1     ==>                             ptp_unicast_nxt   = 1'b1;</font>
5173                                            end
5174                                         // invalid - wait for next frame
5175                                         else
5176       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5177                                      end
5178                    
5179                                   7'b0100000 : // IP multicast address 3
5180                                      begin
5181                                         // PTP primary, not unicast
5182       1/1                               if (~ptp_unicast &amp; (transmit_data_buf[7:0] == 8'h01))
5183       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IPV4_2;</font>
5184                                         // peer delay, not unicast
5185       1/1                               else if (~ptp_unicast &amp; (transmit_data_buf[7:0] == 8'h00))
5186       1/1                                  tx_dec_state_nxt  = TX_DEC_IPV4_3;
5187                                         // PTP unicast
5188       <font color = "red">0/1     ==>                       else if (ptp_unicast &amp;</font>
5189                                                  (transmit_data_buf[7:0] == tx_ptp_unicast[15:8]))
5190                                            begin
5191       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_IPV4_2;</font>
5192       <font color = "red">0/1     ==>                             ptp_unicast_nxt   = 1'b1;</font>
5193                                            end
5194                                         // invalid - wait for next frame
5195                                         else
5196       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5197                                      end
5198                    
5199                                   default :
5200                                      begin
5201       1/1                               tx_dec_state_nxt  = TX_DEC_IPV4_1;
5202                                      end
5203                    
5204                                   endcase
5205                                end
5206                    
5207                             TX_DEC_IPV4_2 : // decode IPv4 PTP primary version 1 and 2
5208                                begin
5209       <font color = "red">0/1     ==>                 case (tx_ptp_count)</font>
5210                    
5211                                   7'b0100001 : // IP multicast address 4
5212                                      begin
5213                                         // PTP primary version 1 and 2 possible, not unicast
5214       <font color = "red">0/1     ==>                       if (~ptp_unicast &amp; (transmit_data_buf[7:0] == 8'h81))</font>
5215                                            begin
5216       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_IPV4_2;</font>
5217       <font color = "red">0/1     ==>                             ptp_ver_1_nxt     = 1'b1;</font>
5218       <font color = "red">0/1     ==>                             ptp_ver_2_nxt     = 1'b1;</font>
5219                                            end
5220                                         // PTP primary version 1, not unicast
5221       <font color = "red">0/1     ==>                       else if (ptp_primary_nunicast)</font>
5222                                            begin
5223       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_IPV4_2;</font>
5224       <font color = "red">0/1     ==>                             ptp_ver_1_nxt     = 1'b1;</font>
5225                                            end
5226                                         // PTP unicast
5227       <font color = "red">0/1     ==>                       else if (ptp_unicast &amp;</font>
5228                                                  (transmit_data_buf[7:0] == tx_ptp_unicast[7:0]))
5229                                            begin
5230       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_IPV4_2;</font>
5231       <font color = "red">0/1     ==>                             ptp_unicast_nxt   = 1'b1;</font>
5232       <font color = "red">0/1     ==>                             ptp_ver_2_nxt     = 1'b1;</font>
5233                                            end
5234                                         // invalid - wait for next frame
5235                                         else
5236       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5237                                      end
5238                    
5239                                   7'b0100100 : // UDP destination port 1
5240                                      begin
5241       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h01)</font>
5242       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IPV4_2;</font>
5243                                         // invalid - wait for next frame
5244                                         else
5245       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5246                                       end
5247                    
5248                                   7'b0100101 : // UDP destination port 2
5249                                      begin
5250       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h3f)</font>
5251                                            begin
5252       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_IPV4_2;</font>
5253       <font color = "red">0/1     ==>                             general_frame_tx_nxt = 1'b0;</font>
5254                                            end
5255       <font color = "red">0/1     ==>                       else if (transmit_data_buf[7:0] == 8'h40)</font>
5256                                            begin
5257       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_IPV4_2;</font>
5258       <font color = "red">0/1     ==>                             general_frame_tx_nxt = 1'b1;</font>
5259                                            end
5260                    
5261                                         // invalid - wait for next frame
5262                                         else
5263       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5264                                       end
5265                    
5266                                   7'b0101010 : // versionPTP and messageType in PTP version 2
5267                                      begin
5268                                         // correct address and versionPTP for version 2
5269                               //          if (ptp_ver_2 &amp; transmit_data_buf [15:8] == 8'h02)
5270       <font color = "red">0/1     ==>                       if (ptp_ver_2 &amp; transmit_data_buf [11:8] == 4'h2)</font>
5271                                            begin
5272       <font color = "red">0/1     ==>                             ptp_ver_1_nxt  = 1'b0;</font>
5273                                               // sync frame
5274       <font color = "red">0/1     ==>                             if (~general_frame_tx &amp; transmit_data_buf[3:0] == 4'h0)</font>
5275                                                  begin
5276       <font color = "red">0/1     ==>                                   tx_dec_state_nxt  = TX_DEC_IPV4_2;</font>
5277       <font color = "red">0/1     ==>                                   sync_frame_tx_nxt = 1'b1;</font>
5278       <font color = "red">0/1     ==>                                   ptp_timestamp_position = tx_ptp_count;</font>
5279       <font color = "red">0/1     ==>                                   ptp_timestamp_position_cap   = 1'b1;</font>
5280                                                  end
5281                                               // delay_req frame
5282       <font color = "red">0/1     ==>                             else if (~general_frame_tx &amp; transmit_data_buf[3:0] == 4'h1)</font>
5283                                                  begin
5284       <font color = "red">0/1     ==>                                   tx_dec_state_nxt  = TX_DEC_IPV4_2;</font>
5285       <font color = "red">0/1     ==>                                   delay_req_tx_nxt  = 1'b1;</font>
5286                                                  end
5287                                               // unicast pdelay req frame
5288       <font color = "red">0/1     ==>                             else if (ptp_unicast &amp; ~general_frame_tx &amp; transmit_data_buf[3:0] == 4'h2)</font>
5289                                                  begin
5290       <font color = "red">0/1     ==>                                   tx_dec_state_nxt  = TX_DEC_IPV4_2;</font>
5291       <font color = "red">0/1     ==>                                   pdelay_req_tx_nxt = 1'b1;</font>
5292                                                  end
5293                                               // unicast pdelay_req frame
5294       <font color = "red">0/1     ==>                             else if (ptp_unicast &amp; ~general_frame_tx &amp; transmit_data_buf[3:0] == 4'h3)</font>
5295                                                  begin
5296       <font color = "red">0/1     ==>                                   tx_dec_state_nxt   = TX_DEC_IPV4_2;</font>
5297       <font color = "red">0/1     ==>                                   pdelay_resp_tx_nxt = 1'b1;</font>
5298                                                  end
5299                                               // detect General 1588 Messages then wait for next frame and also if
5300                                               // invalid - wait for next frame
5301                                               else
5302                                               begin
5303       <font color = "red">0/1     ==>                               general_frame_tx_nxt =  ptp_pri_final_general_chk;</font>
5304       <font color = "red">0/1     ==>                               tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5305                                               end
5306                                             end
5307                                         // correct address and versionPTP for version 1
5308                              //           else if (transmit_data_buf [15:8] == 8'h01) // ptp_ver_1 has to be 1 here ..
5309       <font color = "red">0/1     ==>                       else if (transmit_data_buf [11:8] == 4'h1) // ptp_ver_1 has to be 1 here ..</font>
5310                                            begin
5311       <font color = "red">0/1     ==>                             ptp_ver_2_nxt  = 1'b0;</font>
5312       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_IPV4_2;</font>
5313                                            end
5314                                         // invalid - wait for next frame
5315                                         else
5316       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5317                                      end
5318                    
5319                                   7'b1001010 : // control in PTP version 1
5320                                      begin
5321                                         // correct address and versionPTP for version 1
5322       <font color = "red">0/1     ==>                       if (ptp_ver_1)</font>
5323                                            begin
5324                                               // sync frame
5325       <font color = "red">0/1     ==>                             if (~general_frame_tx &amp; transmit_data_buf[3:0] == 4'h0)</font>
5326                                                  begin
5327       <font color = "red">0/1     ==>                                   tx_dec_state_nxt  = TX_DEC_IPV4_2;</font>
5328       <font color = "red">0/1     ==>                                   sync_frame_tx_nxt = 1'b1;</font>
5329       <font color = "red">0/1     ==>                                   ptp_timestamp_position = tx_ptp_count;</font>
5330       <font color = "red">0/1     ==>                                   ptp_timestamp_position_cap_v1   = 1'b1;</font>
5331                                                  end
5332                                               // delay_req frame
5333       <font color = "red">0/1     ==>                             else if (~general_frame_tx &amp; transmit_data_buf[3:0] == 4'h1)</font>
5334                                                  begin
5335       <font color = "red">0/1     ==>                                   tx_dec_state_nxt  = TX_DEC_IPV4_2;</font>
5336       <font color = "red">0/1     ==>                                   delay_req_tx_nxt   = 1'b1;</font>
5337                                                  end
5338                                               // detect General 1588 Messages then wait for next frame and also if
5339                                               // invalid - wait for next frame
5340                                              else
5341                                               begin
5342       <font color = "red">0/1     ==>                               general_frame_tx_nxt =  general_frame_tx &amp; tx_buf_234;</font>
5343       <font color = "red">0/1     ==>                                tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5344                                               end
5345                                             end
5346                                         // invalid - wait for next frame
5347                                         else
5348       <font color = "red">0/1     ==>                         if (sync_frame_tx_nxt) // ptp_ver_2 must be set here ...</font>
5349       <font color = "red">0/1     ==>                           tx_dec_state_nxt  = TX_DEC_IPV4_2;</font>
5350                                           else
5351       <font color = "red">0/1     ==>                           tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5352                    
5353                                      end
5354                    
5355                    
5356                                   7'b1001100 : // timestamp start position is 34B after messageType for ptp verson 2
5357                                      begin
5358       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_IPV4_2;</font>
5359                                      end
5360                    
5361                                   7'b1010010 : // timestamp start position is 8B after control for ptp verson 1
5362                                      begin
5363       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_IPV4_2;</font>
5364                                      end
5365                    
5366                                   7'b1010101 : // timestamp end position is 9B after timestamp start
5367                                      begin
5368                                         // this will stop tx_ptp_count after TS finished for ptp verson 2
5369                                         // but need to wait longer for ptp v1
5370       <font color = "red">0/1     ==>                       if (ptp_ver_1 == 1'b1)</font>
5371       <font color = "red">0/1     ==>                         tx_dec_state_nxt  = TX_DEC_IPV4_2;</font>
5372                                         else
5373       <font color = "red">0/1     ==>                        tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5374                                      end
5375                    
5376                                   7'b1011001 : // timestamp end position is 7B after timestamp start for ptp verson 1
5377                                      begin
5378       <font color = "red">0/1     ==>                      tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5379                                      end
5380                    
5381                    
5382                                   default :
5383                                      begin
5384       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_IPV4_2;</font>
5385                                      end
5386                    
5387                                   endcase
5388                                end
5389                    
5390                             TX_DEC_IPV4_3 : // decode IPv4 PTP pdelay
5391                                begin
5392       1/1                         case (tx_ptp_count)
5393                    
5394                                   7'b0100001 : // IP multicast address 4
5395                                      begin
5396                                         // PTP peer
5397       1/1                               if (transmit_data_buf[7:0] == 8'h6b)
5398       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IPV4_3;</font>
5399                                         // invalid - wait for next frame
5400                                         else
5401       1/1                                  tx_dec_state_nxt  = TX_DEC_IDLE;
5402                                      end
5403                    
5404                                   7'b0100100 : // UDP destination port 1
5405                                      begin
5406       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h01)</font>
5407       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IPV4_3;</font>
5408                                         // invalid - wait for next frame
5409                                         else
5410       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5411                                       end
5412                    
5413                                   7'b0100101 : // UDP destination port 2
5414                                      begin
5415       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h3f)</font>
5416                                            begin
5417       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_IPV4_3;</font>
5418       <font color = "red">0/1     ==>                             general_frame_tx_nxt = 1'b0;</font>
5419                                            end
5420       <font color = "red">0/1     ==>                       else if (transmit_data_buf[7:0] == 8'h40)</font>
5421                                            begin
5422       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_IPV4_3;</font>
5423       <font color = "red">0/1     ==>                             general_frame_tx_nxt = 1'b1;</font>
5424                                            end
5425                                         // invalid - wait for next frame
5426                                         else
5427       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5428                                       end
5429                    
5430                                   7'b0101010 : // messageType
5431                                      begin
5432                                         // pdelay_req frame
5433       <font color = "red">0/1     ==>                       if (~general_frame_tx &amp; transmit_data_buf[3:0] == 4'h2)</font>
5434                                            begin
5435       <font color = "red">0/1     ==>                             tx_dec_state_nxt   = TX_DEC_IPV4_3;</font>
5436       <font color = "red">0/1     ==>                             pdelay_req_tx_nxt  = 1'b1;</font>
5437                                            end
5438                                         // pdelay_resp frame
5439       <font color = "red">0/1     ==>                       else if (~general_frame_tx &amp; transmit_data_buf[3:0] == 4'h3)</font>
5440                                            begin
5441       <font color = "red">0/1     ==>                             tx_dec_state_nxt   = TX_DEC_IPV4_3;</font>
5442       <font color = "red">0/1     ==>                             pdelay_resp_tx_nxt = 1'b1;</font>
5443                                            end
5444                                         // detect General 1588 Messages then wait for next frame and also if
5445                                         // invalid - wait for next frame
5446                                         else
5447                                         begin
5448       <font color = "red">0/1     ==>                         general_frame_tx_nxt =  ptp_peer_final_general_chk; // Pdelay_Resp_Follow_Up</font>
5449       <font color = "red">0/1     ==>                         tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5450                                         end
5451                                      end
5452                    
5453                                   default :
5454                                      begin
5455       1/1                               tx_dec_state_nxt  = TX_DEC_IPV4_3;
5456                                      end
5457                    
5458                                   endcase
5459                                end
5460                    
5461                             TX_DEC_IPV6_1 : // decode IPv6
5462                                begin
5463       <font color = "red">0/1     ==>                 case (tx_ptp_count)</font>
5464                                   7'b0001101 : // Ethertype IPv6
5465                                      begin
5466       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'hdd)</font>
5467       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IPV6_1;</font>
5468                                         // invalid - wait for next frame
5469                                         else
5470       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5471                                       end
5472                    
5473                                   7'b0010100 : // UDP protocol 1
5474                                      begin
5475       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h11)</font>
5476       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IPV6_1;</font>
5477                                         // invalid - wait for next frame
5478                                         else
5479       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5480                                       end
5481                    
5482                                   7'b0100110 : // IP multicast address part 1
5483                                      begin
5484                                         // PTP primary and peer delay
5485       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'hff)</font>
5486       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IPV6_2;</font>
5487                                         // invalid - wait for next frame
5488                                         else
5489       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5490                                      end
5491                    
5492                                   default :
5493                                      begin
5494       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_IPV6_1;</font>
5495                                      end
5496                    
5497                                   endcase
5498                                end
5499                    
5500                             TX_DEC_IPV6_2 : // decode IPv6 PTP primary
5501                                begin
5502       <font color = "red">0/1     ==>                 case (tx_ptp_count)</font>
5503                    
5504                                   7'b0100111 : // IP multicast address part 2
5505                                      begin
5506                                         // PTP primary or peer delay
5507       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h02)</font>
5508       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IPV6_3;</font>
5509                                         // PTP primary
5510                                         else
5511       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IPV6_2;</font>
5512                                      end
5513                    
5514                                   7'b0101000, 7'b0101001, 7'b0101010, 7'b0101011, 7'b0101100,
5515                                   7'b0101101, 7'b0101110, 7'b0101111, 7'b0110000, 7'b0110001,
5516                                   7'b0110010, 7'b0110011 : // IP multicast address part
5517                                      begin
5518                                         // PTP primary
5519       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h00)</font>
5520       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IPV6_2;</font>
5521                                         // invalid - wait for next frame
5522                                         else
5523       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5524                                      end
5525                    
5526                                   7'b0110100 : // IP multicast address
5527                                      begin
5528                                         // PTP primary
5529       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h01)</font>
5530       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IPV6_2;</font>
5531                                         else
5532       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5533                                      end
5534                    
5535                                   7'b0110101 : // IP multicast address
5536                                      begin
5537                                         // PTP primary
5538       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h81)</font>
5539       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IPV6_2;</font>
5540                                         else
5541       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5542                                      end
5543                    
5544                                   7'b0111000 : // UDP destination port 1
5545                                      begin
5546       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h01)</font>
5547       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IPV6_2;</font>
5548                                         // invalid - wait for next frame
5549                                         else
5550       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5551                                       end
5552                    
5553                                   7'b0111001 : // UDP destination port 2
5554                                      begin
5555       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h3f)</font>
5556                                            begin
5557       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_IPV6_2;</font>
5558       <font color = "red">0/1     ==>                             general_frame_tx_nxt = 1'b0;</font>
5559                                            end
5560       <font color = "red">0/1     ==>                       else if (transmit_data_buf[7:0] == 8'h40)</font>
5561                                            begin
5562       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_IPV6_2;</font>
5563       <font color = "red">0/1     ==>                             general_frame_tx_nxt = 1'b1;</font>
5564                                            end
5565                                         // invalid - wait for next frame
5566                                         else
5567       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5568                                       end
5569                    
5570                                   7'b0111110 : // messageType
5571                                      begin
5572                                         // Sync frame
5573       <font color = "red">0/1     ==>                       if (~general_frame_tx &amp; transmit_data_buf[3:0] == 4'h0)</font>
5574                                            begin
5575       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_IPV6_2;</font>
5576       <font color = "red">0/1     ==>                             sync_frame_tx_nxt = 1'b1;</font>
5577       <font color = "red">0/1     ==>                             ptp_timestamp_position = tx_ptp_count;</font>
5578       <font color = "red">0/1     ==>                             ptp_timestamp_position_cap   = 1'b1;</font>
5579                                            end
5580                                         // delay_req frame
5581       <font color = "red">0/1     ==>                       else if (~general_frame_tx &amp; transmit_data_buf[3:0] == 4'h1)</font>
5582                                            begin
5583       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_IPV6_2;</font>
5584       <font color = "red">0/1     ==>                             delay_req_tx_nxt  = 1'b1;</font>
5585                                            end
5586                                         // detect General 1588 Messages then wait for next frame and also if
5587                                         // invalid - wait for next frame
5588                                         else
5589                                         begin
5590       <font color = "red">0/1     ==>                         general_frame_tx_nxt =  general_frame_tx_dec;</font>
5591       <font color = "red">0/1     ==>                         tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5592                                         end
5593                                      end
5594                    
5595                                   7'b1100000 : // timestamp start position is 34B after messageType
5596                                      begin
5597       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_IPV6_2;</font>
5598                                      end
5599                    
5600                                   7'b1101001 : // timestamp end position is 9B after timestamp start
5601                                      begin
5602                                         // this will stop tx_ptp_count after TS finished
5603       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5604                                      end
5605                    
5606                                    default :
5607                                      begin
5608       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_IPV6_2;</font>
5609                                      end
5610                    
5611                                   endcase
5612                                end
5613                    
5614                             TX_DEC_IPV6_3 : // decode IPv6 PTP pdelay
5615                                begin
5616       <font color = "red">0/1     ==>                 case (tx_ptp_count)</font>
5617                    
5618                                   7'b0101000, 7'b0101001, 7'b0101010, 7'b0101011, 7'b0101100,
5619                                   7'b0101101, 7'b0101110, 7'b0101111, 7'b0110000, 7'b0110001,
5620                                   7'b0110010, 7'b0110011 : // IP multicast address part
5621                                      begin
5622                                         // PTP primary
5623       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h00)</font>
5624       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IPV6_3;</font>
5625                                         // invalid - wait for next frame
5626                                         else
5627       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5628                                      end
5629                    
5630                                   7'b0110100 : // IP multicast address
5631                                      begin
5632                                         // PTP pdelay
5633       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h00)</font>
5634       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IPV6_3;</font>
5635                                         // PTP primary
5636       <font color = "red">0/1     ==>                       else if (transmit_data_buf[7:0] == 8'h01)</font>
5637       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IPV6_2;</font>
5638                                         else
5639       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5640                                      end
5641                    
5642                                   7'b0110101 : // IP multicast address
5643                                      begin
5644                                         // PTP primary
5645       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h6b)</font>
5646       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IPV6_3;</font>
5647                                         else
5648       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5649                                      end
5650                    
5651                                   7'b0111000 : // UDP destination port 1
5652                                      begin
5653       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h01)</font>
5654       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IPV6_3;</font>
5655                                         // invalid - wait for next frame
5656                                         else
5657       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5658                                       end
5659                    
5660                                   7'b0111001 : // UDP destination port 2
5661                                      begin
5662       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h3f)</font>
5663                                            begin
5664       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_IPV6_3;</font>
5665       <font color = "red">0/1     ==>                             general_frame_tx_nxt = 1'b0;</font>
5666                                            end
5667       <font color = "red">0/1     ==>                       else if (transmit_data_buf[7:0] == 8'h40)</font>
5668                                            begin
5669       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_IPV6_3;</font>
5670       <font color = "red">0/1     ==>                             general_frame_tx_nxt = 1'b1;</font>
5671                                            end
5672                                         // invalid - wait for next frame
5673                                         else
5674       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5675                                       end
5676                    
5677                                   7'b0111110 : // messageType
5678                                      begin
5679                                         // pdelay_req frame
5680       <font color = "red">0/1     ==>                       if (~general_frame_tx &amp; transmit_data_buf[3:0] == 4'h2)</font>
5681                                            begin
5682       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_IPV6_3;</font>
5683       <font color = "red">0/1     ==>                             pdelay_req_tx_nxt = 1'b1;</font>
5684                                            end
5685                                         // pdelay_resp frame
5686       <font color = "red">0/1     ==>                       else if (~general_frame_tx &amp; transmit_data_buf[3:0] == 4'h3)</font>
5687                                            begin
5688       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_IPV6_3;</font>
5689       <font color = "red">0/1     ==>                             pdelay_resp_tx_nxt   = 1'b1;</font>
5690                                            end
5691                                         // detect General 1588 Messages then wait for next frame and also if
5692                                         // invalid - wait for next frame
5693                                         else
5694                                         begin
5695       <font color = "red">0/1     ==>                         general_frame_tx_nxt =  ptp_peer_final_general_chk; // Pdelay_Resp_Follow_Up</font>
5696       <font color = "red">0/1     ==>                         tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5697                                         end
5698                                      end
5699                    
5700                                   default :
5701                                      begin
5702       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_IPV6_3;</font>
5703                                      end
5704                    
5705                                   endcase
5706                                end
5707                    
5708                             TX_DEC_VIPV4_1 : // decode IPv4
5709                                begin
5710       <font color = "red">0/1     ==>                 case (tx_ptp_count)</font>
5711                                   7'b0010001 : // Ethertype IPv4
5712                                      begin
5713       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h00)</font>
5714       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VIPV4_1;</font>
5715                                         // invalid - wait for next frame
5716                                         else
5717       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5718                                       end
5719                    
5720                                   7'b0011011 : // UDP protocol
5721                                      begin
5722       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h11)</font>
5723       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VIPV4_1;</font>
5724                                         // invalid - wait for next frame
5725                                         else
5726       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5727                                       end
5728                    
5729                                   7'b0100010 : // IP multicast address 1
5730                                      begin
5731                                         // PTP primary and peer
5732       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'he0)</font>
5733                                            begin
5734       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_VIPV4_1;</font>
5735       <font color = "red">0/1     ==>                             if (ptp_unicast_ena_sync &amp;</font>
5736                                                   (transmit_data_buf[7:0] == tx_ptp_unicast[31:24]))
5737       <font color = "red">0/1     ==>                                ptp_unicast_nxt   = 1'b1;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
5738                                            end
5739                                         // PTP unicast
5740       <font color = "red">0/1     ==>                       else if (ptp_unicast_ena_sync &amp;</font>
5741                                                  (transmit_data_buf[7:0] == tx_ptp_unicast[31:24]))
5742                                            begin
5743       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_VIPV4_1;</font>
5744       <font color = "red">0/1     ==>                             ptp_unicast_nxt   = 1'b1;</font>
5745                                            end
5746                                         // invalid - wait for next frame
5747                                         else
5748       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5749                                      end
5750                    
5751                                   7'b0100011 : // IP multicast address 2
5752                                      begin
5753                                         // PTP primary and peer, not unicast
5754       <font color = "red">0/1     ==>                       if (~ptp_unicast &amp; (transmit_data_buf[7:0] == 8'h00))</font>
5755       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VIPV4_1;</font>
5756                                         // PTP unicast
5757       <font color = "red">0/1     ==>                       else if (ptp_unicast &amp;</font>
5758                                                  (transmit_data_buf[7:0] == tx_ptp_unicast[23:16]))
5759                                            begin
5760       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_VIPV4_1;</font>
5761       <font color = "red">0/1     ==>                             ptp_unicast_nxt   = 1'b1;</font>
5762                                            end
5763                                         // invalid - wait for next frame
5764                                         else
5765       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5766                                      end
5767                    
5768                                   7'b0100100 : // IP multicast address 3
5769                                      begin
5770                                         // PTP primary, not unicast
5771       <font color = "red">0/1     ==>                       if (~ptp_unicast &amp; (transmit_data_buf[7:0] == 8'h01))</font>
5772       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VIPV4_2;</font>
5773                                         // peer delay, not unicast
5774       <font color = "red">0/1     ==>                       else if (~ptp_unicast &amp; (transmit_data_buf[7:0] == 8'h00))</font>
5775       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VIPV4_3;</font>
5776                                         // PTP unicast
5777       <font color = "red">0/1     ==>                       else if (ptp_unicast &amp;</font>
5778                                                  (transmit_data_buf[7:0] == tx_ptp_unicast[15:8]))
5779                                            begin
5780       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_VIPV4_2;</font>
5781       <font color = "red">0/1     ==>                             ptp_unicast_nxt   = 1'b1;</font>
5782                                            end
5783                                         // invalid - wait for next frame
5784                                         else
5785       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5786                                      end
5787                    
5788                                   default :
5789                                      begin
5790       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_VIPV4_1;</font>
5791                                      end
5792                    
5793                                   endcase
5794                                end
5795                    
5796                             TX_DEC_VIPV4_2 : // decode IPv4 PTP primary version 1 and 2
5797                                begin
5798       <font color = "red">0/1     ==>                 case (tx_ptp_count)</font>
5799                    
5800                                   7'b0100101 : // IP multicast address 4
5801                                      begin
5802                                         // PTP primary version 1 and 2 possible, not unicast
5803       <font color = "red">0/1     ==>                       if (~ptp_unicast &amp; (transmit_data_buf[7:0] == 8'h81))</font>
5804                                            begin
5805       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_VIPV4_2;</font>
5806       <font color = "red">0/1     ==>                             ptp_ver_1_nxt     = 1'b1;</font>
5807       <font color = "red">0/1     ==>                             ptp_ver_2_nxt     = 1'b1;</font>
5808                                            end
5809                                         // PTP primary version 1, not unicast
5810       <font color = "red">0/1     ==>                       else if (ptp_primary_nunicast)</font>
5811                                            begin
5812       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_VIPV4_2;</font>
5813       <font color = "red">0/1     ==>                             ptp_ver_1_nxt     = 1'b1;</font>
5814                                            end
5815                                         // PTP unicast
5816       <font color = "red">0/1     ==>                       else if (ptp_unicast &amp;</font>
5817                                                  (transmit_data_buf[7:0] == tx_ptp_unicast[7:0]))
5818                                            begin
5819       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_VIPV4_2;</font>
5820       <font color = "red">0/1     ==>                             ptp_unicast_nxt   = 1'b1;</font>
5821       <font color = "red">0/1     ==>                             ptp_ver_2_nxt     = 1'b1;</font>
5822                                            end
5823                                         // invalid - wait for next frame
5824                                         else
5825       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5826                                      end
5827                    
5828                                   7'b0101000 : // UDP destination port 1
5829                                      begin
5830       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h01)</font>
5831       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VIPV4_2;</font>
5832                                         // invalid - wait for next frame
5833                                         else
5834       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5835                                       end
5836                    
5837                                   7'b0101001 : // UDP destination port 2
5838                                      begin
5839       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h3f)</font>
5840                                            begin
5841       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_VIPV4_2;</font>
5842       <font color = "red">0/1     ==>                             general_frame_tx_nxt = 1'b0;</font>
5843                                            end
5844       <font color = "red">0/1     ==>                       else if (transmit_data_buf[7:0] == 8'h40)</font>
5845                                            begin
5846       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_VIPV4_2;</font>
5847       <font color = "red">0/1     ==>                             general_frame_tx_nxt = 1'b1;</font>
5848                                            end
5849                                         // invalid - wait for next frame
5850                                         else
5851       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5852                                       end
5853                    
5854                                   7'b0101110 : // versionPTP and messageType in PTP version 2
5855                                      begin
5856                                         // correct address and versionPTP for version 2
5857                               //          if (ptp_ver_2 &amp; transmit_data_buf [15:8] == 8'h02)
5858       <font color = "red">0/1     ==>                       if (ptp_ver_2 &amp; transmit_data_buf [11:8] == 4'h2)</font>
5859                                            begin
5860       <font color = "red">0/1     ==>                             ptp_ver_1_nxt  = 1'b0;</font>
5861                                               // sync frame
5862       <font color = "red">0/1     ==>                             if (~general_frame_tx &amp; transmit_data_buf[3:0] == 4'h0)</font>
5863                                                  begin
5864       <font color = "red">0/1     ==>                                   tx_dec_state_nxt  = TX_DEC_VIPV4_2;</font>
5865       <font color = "red">0/1     ==>                                   sync_frame_tx_nxt = 1'b1;</font>
5866       <font color = "red">0/1     ==>                                   ptp_timestamp_position = tx_ptp_count;</font>
5867       <font color = "red">0/1     ==>                                   ptp_timestamp_position_cap   = 1'b1;</font>
5868                                                  end
5869                                               // delay_req frame
5870       <font color = "red">0/1     ==>                             else if (~general_frame_tx &amp; transmit_data_buf[3:0] == 4'h1)</font>
5871                                                  begin
5872       <font color = "red">0/1     ==>                                   tx_dec_state_nxt  = TX_DEC_VIPV4_2;</font>
5873       <font color = "red">0/1     ==>                                   delay_req_tx_nxt  = 1'b1;</font>
5874                                                  end
5875                                               // unicast pdelay req frame
5876       <font color = "red">0/1     ==>                             else if (~general_frame_tx &amp; ptp_unicast &amp; transmit_data_buf[3:0] == 4'h2)</font>
5877                                                  begin
5878       <font color = "red">0/1     ==>                                   tx_dec_state_nxt  = TX_DEC_VIPV4_2;</font>
5879       <font color = "red">0/1     ==>                                   pdelay_req_tx_nxt = 1'b1;</font>
5880                                                  end
5881                                               // unicast pdelay_req frame
5882       <font color = "red">0/1     ==>                             else if (~general_frame_tx &amp; ptp_unicast &amp; transmit_data_buf[3:0] == 4'h3)</font>
5883                                                  begin
5884       <font color = "red">0/1     ==>                                   tx_dec_state_nxt   = TX_DEC_VIPV4_2;</font>
5885       <font color = "red">0/1     ==>                                   pdelay_resp_tx_nxt = 1'b1;</font>
5886                                                  end
5887                                               // detect General 1588 Messages then wait for next frame and also if
5888                                               // invalid - wait for next frame
5889                                               else
5890                                               begin
5891       <font color = "red">0/1     ==>                               general_frame_tx_nxt = ptp_pri_final_general_chk;</font>
5892       <font color = "red">0/1     ==>                               tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5893                                               end
5894                                             end
5895                                         // correct address and versionPTP for version 1
5896                                 //        else if (transmit_data_buf [15:8] == 8'h01) // ptp_ver_1 must be set in here ...
5897       <font color = "red">0/1     ==>                       else if (transmit_data_buf [11:8] == 4'h1) // ptp_ver_1 must be set in here ...</font>
5898                                            begin
5899       <font color = "red">0/1     ==>                             ptp_ver_2_nxt  = 1'b0;</font>
5900       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_VIPV4_2;</font>
5901                                            end
5902                                         // invalid - wait for next frame
5903                                         else
5904       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5905                                      end
5906                    
5907                                   7'b1001110 : // control in PTP version 1
5908                                      begin
5909                                         // correct address and versionPTP for version 1
5910       <font color = "red">0/1     ==>                       if (ptp_ver_1)</font>
5911                                            begin
5912                                               // sync frame
5913       <font color = "red">0/1     ==>                             if (~general_frame_tx &amp; transmit_data_buf[3:0] == 4'h0)</font>
5914                                                  begin
5915       <font color = "red">0/1     ==>                                   tx_dec_state_nxt  = TX_DEC_VIPV4_2;</font>
5916       <font color = "red">0/1     ==>                                   sync_frame_tx_nxt = 1'b1;</font>
5917       <font color = "red">0/1     ==>                                   ptp_timestamp_position = tx_ptp_count;</font>
5918       <font color = "red">0/1     ==>                                   ptp_timestamp_position_cap_v1   = 1'b1;</font>
5919                                                  end
5920                                               // delay_req frame
5921       <font color = "red">0/1     ==>                             else if (~general_frame_tx &amp; transmit_data_buf[3:0] == 4'h1)</font>
5922                                                  begin
5923       <font color = "red">0/1     ==>                                   tx_dec_state_nxt  = TX_DEC_VIPV4_2;</font>
5924       <font color = "red">0/1     ==>                                   delay_req_tx_nxt   = 1'b1;</font>
5925                                                  end
5926                                               // detect General 1588 Messages then wait for next frame and also if
5927                                               // invalid - wait for next frame
5928                                               else
5929                                               begin
5930       <font color = "red">0/1     ==>                               general_frame_tx_nxt =  general_frame_tx &amp; tx_buf_234;</font>
5931       <font color = "red">0/1     ==>                               tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5932                                               end
5933                                             end
5934                                         // invalid - wait for next frame
5935                                         else
5936       <font color = "red">0/1     ==>                         if (sync_frame_tx_nxt) // ptp_ver_2 must be set here ..</font>
5937       <font color = "red">0/1     ==>                           tx_dec_state_nxt  = TX_DEC_VIPV4_2;</font>
5938                                           else
5939       <font color = "red">0/1     ==>                           tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5940                                      end
5941                    
5942                                   7'b1010000 : // timestamp start position is 34B after messageType
5943                                      begin
5944       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_VIPV4_2;</font>
5945                                      end
5946                    
5947                                   7'b1010110 : // // timestamp start position is 8B after control for ptp verson 1
5948                                      begin
5949       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_VIPV4_2;</font>
5950                                      end
5951                    
5952                                   7'b1011001 : // timestamp end position is 9B after timestamp start
5953                                      begin
5954                                         // this will stop tx_ptp_count after TS finished for ptp verson 2
5955                                         // but need to wait longer for ptp v1
5956       <font color = "red">0/1     ==>                       if (ptp_ver_1 == 1'b1)</font>
5957       <font color = "red">0/1     ==>                         tx_dec_state_nxt  = TX_DEC_VIPV4_2;</font>
5958                                         else
5959       <font color = "red">0/1     ==>                        tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5960                                      end
5961                    
5962                                   7'b1011101 : // timestamp end position is 7B after timestamp start for ptp verson 1
5963                                      begin
5964       <font color = "red">0/1     ==>                      tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5965                                      end
5966                    
5967                                   default :
5968                                      begin
5969       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_VIPV4_2;</font>
5970                                      end
5971                    
5972                                   endcase
5973                                end
5974                    
5975                             TX_DEC_VIPV4_3 : // decode IPv4 PTP pdelay
5976                                begin
5977       <font color = "red">0/1     ==>                 case (tx_ptp_count)</font>
5978                    
5979                                   7'b0100101 : // IP multicast address 4
5980                                      begin
5981                                         // PTP peer
5982       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h6b)</font>
5983       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VIPV4_3;</font>
5984                                         // invalid - wait for next frame
5985                                         else
5986       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5987                                      end
5988                    
5989                                   7'b0101000 : // UDP destination port 1
5990                                      begin
5991       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h01)</font>
5992       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VIPV4_3;</font>
5993                                         // invalid - wait for next frame
5994                                         else
5995       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
5996                                       end
5997                    
5998                                   7'b0101001 : // UDP destination port 2
5999                                      begin
6000       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h3f)</font>
6001                                            begin
6002       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_VIPV4_3;</font>
6003       <font color = "red">0/1     ==>                             general_frame_tx_nxt = 1'b0;</font>
6004                                            end
6005       <font color = "red">0/1     ==>                       else if (transmit_data_buf[7:0] == 8'h40)</font>
6006                                            begin
6007       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_VIPV4_3;</font>
6008       <font color = "red">0/1     ==>                             general_frame_tx_nxt = 1'b1;</font>
6009                                            end
6010                                         // invalid - wait for next frame
6011                                         else
6012       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
6013                                       end
6014                    
6015                                   7'b0101110 : // messageType
6016                                      begin
6017                                         // pdelay_req frame
6018       <font color = "red">0/1     ==>                       if (~general_frame_tx &amp; transmit_data_buf[3:0] == 4'h2)</font>
6019                                            begin
6020       <font color = "red">0/1     ==>                             tx_dec_state_nxt   = TX_DEC_VIPV4_3;</font>
6021       <font color = "red">0/1     ==>                             pdelay_req_tx_nxt  = 1'b1;</font>
6022                                            end
6023                                         // pdelay_resp frame
6024       <font color = "red">0/1     ==>                       else if (~general_frame_tx &amp; transmit_data_buf[3:0] == 4'h3)</font>
6025                                            begin
6026       <font color = "red">0/1     ==>                             tx_dec_state_nxt   = TX_DEC_VIPV4_3;</font>
6027       <font color = "red">0/1     ==>                             pdelay_resp_tx_nxt = 1'b1;</font>
6028                                            end
6029                                         // detect General 1588 Messages then wait for next frame and also if
6030                                         // invalid - wait for next frame
6031                                         else
6032                                         begin
6033       <font color = "red">0/1     ==>                         general_frame_tx_nxt =  ptp_peer_final_general_chk; // Pdelay_Resp_Follow_Up</font>
6034       <font color = "red">0/1     ==>                         tx_dec_state_nxt  = TX_DEC_IDLE;</font>
6035                                         end
6036                                      end
6037                    
6038                                   default :
6039                                      begin
6040       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_VIPV4_3;</font>
6041                                      end
6042                    
6043                                   endcase
6044                                end
6045                    
6046                             TX_DEC_VIPV6_1 : // decode IPv6
6047                                begin
6048       <font color = "red">0/1     ==>                 case (tx_ptp_count)</font>
6049                                   7'b0010001 : // Ethertype IPv6
6050                                      begin
6051       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'hdd)</font>
6052       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VIPV6_1;</font>
6053                                         // invalid - wait for next frame
6054                                         else
6055       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
6056                                       end
6057                    
6058                                   7'b0011000 : // UDP protocol 1
6059                                      begin
6060       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h11)</font>
6061       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VIPV6_1;</font>
6062                                         // invalid - wait for next frame
6063                                         else
6064       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
6065                                       end
6066                    
6067                                   7'b0101010 : // IP multicast address part 1
6068                                      begin
6069                                         // PTP primary and peer delay
6070       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'hff)</font>
6071       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VIPV6_2;</font>
6072                                         // invalid - wait for next frame
6073                                         else
6074       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
6075                                      end
6076                    
6077                                   default :
6078                                      begin
6079       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_VIPV6_1;</font>
6080                                      end
6081                    
6082                                   endcase
6083                                end
6084                    
6085                             TX_DEC_VIPV6_2 : // decode IPv6 PTP primary
6086                                begin
6087       <font color = "red">0/1     ==>                 case (tx_ptp_count)</font>
6088                    
6089                                   7'b0101011 : // IP multicast address part 2
6090                                      begin
6091                                         // PTP primary or peer delay
6092       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h02)</font>
6093       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VIPV6_3;</font>
6094                                         // PTP primary
6095                                         else
6096       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VIPV6_2;</font>
6097                                      end
6098                    
6099                                   7'b0101100, 7'b0101101, 7'b0101110, 7'b0101111, 7'b0110000,
6100                                   7'b0110001, 7'b0110010, 7'b0110011, 7'b0110100, 7'b0110101,
6101                                   7'b0110110, 7'b0110111 : // IP multicast address part
6102                                      begin
6103                                         // PTP primary
6104       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h00)</font>
6105       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VIPV6_2;</font>
6106                                         // invalid - wait for next frame
6107                                         else
6108       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
6109                                      end
6110                    
6111                                   7'b0111000 : // IP multicast address
6112                                      begin
6113                                         // PTP primary
6114       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h01)</font>
6115       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VIPV6_2;</font>
6116                                         else
6117       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
6118                                      end
6119                    
6120                                   7'b0111001 : // IP multicast address
6121                                      begin
6122                                         // PTP primary
6123       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h81)</font>
6124       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VIPV6_2;</font>
6125                                         else
6126       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
6127                                      end
6128                    
6129                                   7'b0111100 : // UDP destination port 1
6130                                      begin
6131       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h01)</font>
6132       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VIPV6_2;</font>
6133                                         // invalid - wait for next frame
6134                                         else
6135       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
6136                                       end
6137                    
6138                                   7'b0111101 : // UDP destination port 2
6139                                      begin
6140       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h3f)</font>
6141                                            begin
6142       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_VIPV6_2;</font>
6143       <font color = "red">0/1     ==>                             general_frame_tx_nxt = 1'b0;</font>
6144                                            end
6145       <font color = "red">0/1     ==>                       else if (transmit_data_buf[7:0] == 8'h40)</font>
6146                                            begin
6147       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_VIPV6_2;</font>
6148       <font color = "red">0/1     ==>                             general_frame_tx_nxt = 1'b1;</font>
6149                                            end
6150                                         // invalid - wait for next frame
6151                                         else
6152       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
6153                                       end
6154                    
6155                                   7'b1000010 : // messageType
6156                                      begin
6157                                         // PTP primary
6158       <font color = "red">0/1     ==>                       if (~general_frame_tx &amp; transmit_data_buf[3:0] == 4'h0)</font>
6159                                            begin
6160       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_VIPV6_2;</font>
6161       <font color = "red">0/1     ==>                             sync_frame_tx_nxt = 1'b1;</font>
6162       <font color = "red">0/1     ==>                             ptp_timestamp_position = tx_ptp_count;</font>
6163       <font color = "red">0/1     ==>                             ptp_timestamp_position_cap   = 1'b1;</font>
6164                                            end
6165                                         // peer delay
6166       <font color = "red">0/1     ==>                       else if (~general_frame_tx &amp; transmit_data_buf[3:0] == 4'h1)</font>
6167                                            begin
6168       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_VIPV6_2;</font>
6169       <font color = "red">0/1     ==>                             delay_req_tx_nxt  = 1'b1;</font>
6170                                            end
6171                                         // detect General 1588 Messages then wait for next frame and also if
6172                                         // invalid - wait for next frame
6173                                         else
6174                                         begin
6175       <font color = "red">0/1     ==>                         general_frame_tx_nxt =  general_frame_tx_dec;</font>
6176       <font color = "red">0/1     ==>                         tx_dec_state_nxt  = TX_DEC_IDLE;</font>
6177                                         end
6178                                      end
6179                    
6180                                   7'b1100100 : // timestamp start position is 34B after messageType
6181                                      begin
6182       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_VIPV6_2;</font>
6183                                      end
6184                    
6185                                   7'b1101101 : // timestamp end position is 9B after timestamp start
6186                                      begin
6187                                         // this will stop tx_ptp_count after TS finished
6188       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_IDLE;</font>
6189                                      end
6190                    
6191                                   default :
6192                                      begin
6193       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_VIPV6_2;</font>
6194                                      end
6195                    
6196                                   endcase
6197                                end
6198                    
6199                             TX_DEC_VIPV6_3 : // decode IPv6 PTP pdelay
6200                                begin
6201       <font color = "red">0/1     ==>                 case (tx_ptp_count)</font>
6202                    
6203                                   7'b0101100, 7'b0101101, 7'b0101110, 7'b0101111, 7'b0110000,
6204                                   7'b0110001, 7'b0110010, 7'b0110011, 7'b0110100, 7'b0110101,
6205                                   7'b0110110, 7'b0110111 : // IP multicast address part
6206                                      begin
6207                                         // PTP primary
6208       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h00)</font>
6209       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VIPV6_3;</font>
6210                                         // invalid - wait for next frame
6211                                         else
6212       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
6213                                      end
6214                    
6215                                   7'b0111000 : // IP multicast address
6216                                      begin
6217                                         // PTP pdelay
6218       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h00)</font>
6219       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VIPV6_3;</font>
6220                                         // PTP primary
6221       <font color = "red">0/1     ==>                       else if (transmit_data_buf[7:0] == 8'h01)</font>
6222       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VIPV6_2;</font>
6223                                         else
6224       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
6225                                      end
6226                    
6227                                   7'b0111001 : // IP multicast address
6228                                      begin
6229                                         // PTP primary
6230       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h6b)</font>
6231       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VIPV6_3;</font>
6232                                         else
6233       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
6234                                      end
6235                    
6236                                   7'b0111100 : // UDP destination port 1
6237                                      begin
6238       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h01)</font>
6239       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_VIPV6_3;</font>
6240                                         // invalid - wait for next frame
6241                                         else
6242       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
6243                                       end
6244                    
6245                                   7'b0111101 : // UDP destination port 2
6246                                      begin
6247       <font color = "red">0/1     ==>                       if (transmit_data_buf[7:0] == 8'h3f)</font>
6248                                            begin
6249       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_VIPV6_3;</font>
6250       <font color = "red">0/1     ==>                             general_frame_tx_nxt = 1'b0;</font>
6251                                            end
6252       <font color = "red">0/1     ==>                       else if (transmit_data_buf[7:0] == 8'h40)</font>
6253                                            begin
6254       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_VIPV6_3;</font>
6255       <font color = "red">0/1     ==>                             general_frame_tx_nxt = 1'b1;</font>
6256                                            end
6257                                         // invalid - wait for next frame
6258                                         else
6259       <font color = "red">0/1     ==>                          tx_dec_state_nxt  = TX_DEC_IDLE;</font>
6260                                       end
6261                    
6262                                   7'b1000010 : // messageType
6263                                      begin
6264                                         // pdelay_req frame
6265       <font color = "red">0/1     ==>                       if (~general_frame_tx &amp; transmit_data_buf[3:0] == 4'h2)</font>
6266                                            begin
6267       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_VIPV6_3;</font>
6268       <font color = "red">0/1     ==>                             pdelay_req_tx_nxt = 1'b1;</font>
6269                                            end
6270                                         // pdelay_resp frame
6271       <font color = "red">0/1     ==>                       else if (~general_frame_tx &amp; transmit_data_buf[3:0] == 4'h3)</font>
6272                                            begin
6273       <font color = "red">0/1     ==>                             tx_dec_state_nxt  = TX_DEC_VIPV6_3;</font>
6274       <font color = "red">0/1     ==>                             pdelay_resp_tx_nxt   = 1'b1;</font>
6275                                            end
6276                                         // detect General 1588 Messages then wait for next frame and also if
6277                                         // invalid - wait for next frame
6278                                         else
6279                                         begin
6280       <font color = "red">0/1     ==>                         general_frame_tx_nxt =  ptp_peer_final_general_chk; // Pdelay_Resp_Follow_Up</font>
6281       <font color = "red">0/1     ==>                         tx_dec_state_nxt  = TX_DEC_IDLE;</font>
6282                                         end
6283                                      end
6284                    
6285                                   default :
6286                                      begin
6287       <font color = "red">0/1     ==>                       tx_dec_state_nxt  = TX_DEC_VIPV6_3;</font>
6288                                      end
6289                    
6290                                   endcase
6291                                end
6292                    
6293                    
6294                             default      : // TX_DEC_IDLE
6295                                begin
6296                                   // If new frame coming in goto RX_DEC_DA1, only if enabled
6297                                   // by synchronous process of state machine.
6298       1/1                         ptp_ver_1_nxt        = 1'b0;
6299       1/1                         ptp_ver_2_nxt        = 1'b0;
6300       1/1                         ptp_unicast_nxt      = 1'b0;
6301       1/1                         if (data_type == TYPE_PREAMBLE)
6302                                      begin
6303       1/1                               tx_dec_state_nxt     = TX_DEC_START;
6304       1/1                               en_tx_ptp_count_nxt  = 1'b1;
6305                                      end
6306                                   else
6307                                      begin
6308       1/1                               tx_dec_state_nxt     = TX_DEC_IDLE;
6309       1/1                               en_tx_ptp_count_nxt  = 1'b0;
6310                                      end
6311                                end
6312                    
6313                          endcase
6314                       end
6315                    
6316                    
6317                       // count through PTP frame when en_tx_ptp_count is high
6318                       // in 10/100 mode only update every other cycle
6319                       // tx_ptp_count is a counter up to 127.  It can rollover
6320                       // but only in cases that we dont use it, so safe
6321                       // It is used for PTP single step timestamping and for that
6322                       // the max size of the headers before the timestamp field
6323                       // is &lt;128bytes (we dont allow Ipv6 extension headers or Ipv4
6324                       // options for PTP frames
6325                       always@(posedge tx_clk or negedge n_txreset)
6326                         begin
6327       1/1                if (~n_txreset)
6328                             begin
6329       1/1                      tx_ptp_count &lt;= 7'b0000000;
6330                             end
6331       1/1                else if (~tx_en | ~en_transmit_sync)
6332                             begin
6333       1/1                      tx_ptp_count &lt;= 7'b0000000;
6334                             end
6335                          else
6336                            begin
6337       1/1                    if (en_tx_ptp_count &amp; ~nibble_sel &amp; (data_type == TYPE_DATA))
6338                                begin
6339       1/1                        tx_ptp_count &lt;= tx_ptp_count + 7'b0000001;
6340                                end
                        MISSING_ELSE
6341                             end
6342                         end
6343                    
6344                    
6345                       // drive PTP and peer delay signals
6346                       // de-assert at end of frame
6347                       // assert by TX Decode State Machine
6348                       always@(posedge tx_clk or negedge n_txreset)
6349                         begin
6350       1/1                if (~n_txreset)
6351                             begin
6352       1/1                      sync_frame_tx    &lt;= 1'b0;
6353       1/1                      delay_req_tx     &lt;= 1'b0;
6354       1/1                      pdelay_req_tx    &lt;= 1'b0;
6355       1/1                      pdelay_resp_tx   &lt;= 1'b0;
6356       1/1                      general_frame_tx &lt;= 1'b0;
6357       1/1                      ptp_ver_1        &lt;= 1'b0;
6358       1/1                      ptp_ver_2        &lt;= 1'b0;
6359       1/1                      ptp_unicast      &lt;= 1'b0;
6360                             end
6361       1/1                else if (~tx_en | ~en_transmit_sync)
6362                             begin
6363       1/1                      sync_frame_tx    &lt;= 1'b0;
6364       1/1                      delay_req_tx     &lt;= 1'b0;
6365       1/1                      pdelay_req_tx    &lt;= 1'b0;
6366       1/1                      pdelay_resp_tx   &lt;= 1'b0;
6367       1/1                      general_frame_tx &lt;= 1'b0;
6368       1/1                      ptp_ver_1        &lt;= 1'b0;
6369       1/1                      ptp_ver_2        &lt;= 1'b0;
6370       1/1                      ptp_unicast      &lt;= 1'b0;
6371                              end
6372                          else
6373                             begin
6374       1/1                      sync_frame_tx    &lt;= sync_frame_tx_nxt;
6375       1/1                      delay_req_tx     &lt;= delay_req_tx_nxt;
6376       1/1                      pdelay_req_tx    &lt;= pdelay_req_tx_nxt;
6377       1/1                      pdelay_resp_tx   &lt;= pdelay_resp_tx_nxt;
6378       1/1                      general_frame_tx &lt;= general_frame_tx_nxt;
6379       1/1                      ptp_ver_1        &lt;= ptp_ver_1_nxt;
6380       1/1                      ptp_ver_2        &lt;= ptp_ver_2_nxt;
6381       1/1                      ptp_unicast      &lt;= ptp_unicast_nxt;
6382                             end
6383                         end
6384                    
6385                       // Synchronise into TX for BP application
6386                       cdnsdru_datasync_v1 i_cdnsdru_datasync_v1_rx_dv (
6387                         .clk    (tx_clk),
6388                         .reset_n(n_txreset),
6389                         .din    (rx_dv),
6390                         .dout   (rx_dv_sync)
6391                       );
6392                    
6393                      assign apply_bp_comb =  back_pressure | halfduplex_fc_en;
6394                      cdnsdru_datasync_v1 i_cdnsdru_datasync_v1_apply_bp (
6395                        .clk    (tx_clk),
6396                        .reset_n(n_txreset),
6397                        .din    (apply_bp_comb),
6398                        .dout   (apply_bp)
6399                      );
6400                    
6401                    
6402                       // synchronise back_pressure to tx_clk. Generate back pressure signal
6403                       // when receive detected in half duplex and not transmitting.
6404                       always@(posedge tx_clk or negedge n_txreset)
6405                         begin
6406       1/1                if (~n_txreset)
6407                             begin
6408       1/1                      back_pressure_sync1 &lt;= 1'b0;
6409       1/1                      back_pressure_sync2 &lt;= 1'b0;
6410       1/1                      back_pressure_sync3 &lt;= 1'b0;
6411       1/1                      back_pressure_sync4 &lt;= 1'b0;
6412                             end
6413                          else
6414                             begin
6415                                // only set back_pressure_sync1 when rx_dv invalid
6416       1/1                      back_pressure_sync1 &lt;= apply_bp &amp;
6417                                                    (back_pressure_sync1 | ~rx_dv_sync);
6418       1/1                      back_pressure_sync2 &lt;= back_pressure_sync1 &amp; rx_dv_sync &amp;
6419                                                   (data_type == 4'b1000) &amp; ~full_duplex &amp; ~gigabit;
6420       1/1                      back_pressure_sync3 &lt;= back_pressure_sync2;
6421       1/1                      back_pressure_sync4 &lt;= back_pressure_sync3;
6422                             end
6423                         end
6424                    
6425                       // count back pressure down to zero
6426                       always@(posedge tx_clk or negedge n_txreset)
6427                         begin
6428       1/1                if (~n_txreset)
6429       1/1                   bp_cnt &lt;= 7'h00;
6430       1/1                else if (back_pressure_sync3 &amp; ~back_pressure_sync4 &amp; bit_rate)
6431       <font color = "red">0/1     ==>           bp_cnt &lt;= 7'h40;</font>
6432       1/1                else if (back_pressure_sync3 &amp; ~back_pressure_sync4)
6433       <font color = "red">0/1     ==>           bp_cnt &lt;= 7'h10;</font>
6434       1/1                else if (bp_active)
6435       <font color = "red">0/1     ==>           bp_cnt &lt;= bp_cnt - 7'h01;</font>
6436                          else
6437       1/1                   bp_cnt &lt;= bp_cnt;
</pre>
</div>
<div class="ui-layout-south">
<table align=center><tr><td class="s0 cl">0%</td>
<td class="s1 cl">10%</td>
<td class="s2 cl">20%</td>
<td class="s3 cl">30%</td>
<td class="s4 cl">40%</td>
<td class="s5 cl">50%</td>
<td class="s6 cl">60%</td>
<td class="s7 cl">70%</td>
<td class="s8 cl">80%</td>
<td class="s9 cl">90%</td>
<td class="s10 cl">100%</td></tr></table></div>
</body>
</html>
