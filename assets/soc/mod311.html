<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="Author" content="<username>"> <meta name="GENERATOR" content="urg/version [en] (platform name) [urg]">
<title>Unified Coverage Report :: Module :: svt_usb_ss_serial_if</title>
<link type="text/css" rel="stylesheet" href="css/.urg.css">
<link type="text/css" rel="stylesheet" href="css/.layout.css">
<link type="text/css" rel="stylesheet" href="css/.breadcrumb.css">
<script type="text/javascript" src="js/.jquery.js"></script>
<script type="text/javascript" src="js/.jquery-ui.js"></script>
<script type="text/javascript" src="js/.sortable.js"></script>
<script type="text/javascript" src="js/.layout.js"></script>
<script type="text/javascript" src="js/.breadcrumb.js"></script>
<script type="text/javascript">
var layout, westLayout, centerLayout;
$(document).ready(function () {
  if ($("#north-bread-crumb")) {
    $("#north-bread-crumb").jBreadCrumb({easing:'swing'})
  }
  layout = $("body").layout({ 
    resizable: true,
    spacing_open: 4,
    spacing_closed: 4,
    north: {
      size: 76
    },
    south: {
      size: 45,
      initClosed: true
    },
    west: {
      size: 500,
      resizable: true,
      initClosed: false
    }
  });
  centerLayout = $('div.ui-layout-center').layout({
    north__paneSelector: ".ui-layout-center-inner-north",
    center__paneSelector: ".ui-layout-center-inner-center", 
    north__size: 50,
    spacing_open: 4,
    spacing_closed: 4
  });
});
</script>
</head>
<body onLoad="initPage();"><div class="ui-layout-north">
<div class="logo"></div>
<center class="pagetitle">Module Definition</center>
<div align="center"><a href="dashboard.html" ><b>dashboard</b></a> | <a href="hierarchy.html" ><b>hierarchy</b></a> | <a href="modlist.html" ><b>modlist</b></a> | groups | <a href="tests.html" ><b>tests</b></a> | <a href="asserts.html" ><b>asserts</b></a></div>

</div>
<div class="ui-layout-west">
<div name='tag_svt_usb_ss_serial_if'>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module : <a href="#"  onclick="showContent('tag_svt_usb_ss_serial_if')">svt_usb_ss_serial_if</a></span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s0 cl rt">  8.26</td>
<td class="s1 cl rt"><a href="mod311.html#Line" > 17.97</a></td>
<td class="s0 cl rt"><a href="mod311.html#Cond" >  0.00</a></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="s0 cl rt"><a href="mod311.html#Branch" >  6.82</a></td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<span class=repname>Source File(s) : </span>
<br clear=all>
<a href="javascript:void(0);"  onclick="openSrcFile('/nfs_project/gemini/DV/nadeem/dv/main_regression_21-10-2022/gemini/DV/subsystem_level/config_ss_verif_env/.//../config_ss_verif_env/tb_src/vips/USB/include/sverilog/svt_usb_ss_serial_if.svi')">/nfs_project/gemini/DV/nadeem/dv/main_regression_21-10-2022/gemini/DV/subsystem_level/config_ss_verif_env/.//../config_ss_verif_env/tb_src/vips/USB/include/sverilog/svt_usb_ss_serial_if.svi</a><br clear=all>
<br clear=all>
<span class=repname>Module self-instances :</span>
<br clear=all>
<table align=left class="sortable">
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="wht cl wordwrap"><a href="mod311.html#inst_tag_25392"  onclick="showContent('inst_tag_25392')">config_ss_tb.config_ss_env_intf.host_usb_if.usb_ss_serial_if</a></td>
<td class="s0 cl rt">  8.26</td>
<td class="s1 cl rt"><a href="mod311.html#inst_tag_25392_Line" > 17.97</a></td>
<td class="s0 cl rt"><a href="mod311.html#inst_tag_25392_Cond" >  0.00</a></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="s0 cl rt"><a href="mod311.html#inst_tag_25392_Branch" >  6.82</a></td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod311.html#inst_tag_25393"  onclick="showContent('inst_tag_25393')">config_ss_tb.config_ss_env_intf.host_usb_if.usb_ss_serial_lane1_if</a></td>
<td class="s0 cl rt">  8.26</td>
<td class="s1 cl rt"><a href="mod311.html#inst_tag_25393_Line" > 17.97</a></td>
<td class="s0 cl rt"><a href="mod311.html#inst_tag_25393_Cond" >  0.00</a></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="s0 cl rt"><a href="mod311.html#inst_tag_25393_Branch" >  6.82</a></td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod311.html#inst_tag_25394"  onclick="showContent('inst_tag_25394')">config_ss_tb.config_ss_env_intf.dev_usb_if.usb_ss_serial_if</a></td>
<td class="s0 cl rt">  8.26</td>
<td class="s1 cl rt"><a href="mod311.html#inst_tag_25394_Line" > 17.97</a></td>
<td class="s0 cl rt"><a href="mod311.html#inst_tag_25394_Cond" >  0.00</a></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="s0 cl rt"><a href="mod311.html#inst_tag_25394_Branch" >  6.82</a></td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod311.html#inst_tag_25395"  onclick="showContent('inst_tag_25395')">config_ss_tb.config_ss_env_intf.dev_usb_if.usb_ss_serial_lane1_if</a></td>
<td class="s0 cl rt">  8.26</td>
<td class="s1 cl rt"><a href="mod311.html#inst_tag_25395_Line" > 17.97</a></td>
<td class="s0 cl rt"><a href="mod311.html#inst_tag_25395_Cond" >  0.00</a></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="s0 cl rt"><a href="mod311.html#inst_tag_25395_Branch" >  6.82</a></td>
<td class="wht cl rt"></td>
</tr></table></div>
</div>
<br clear=all>
<div name='inst_tag_25392'>
<hr>
<a name="inst_tag_25392"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy52.html#tag_urg_inst_25392" >config_ss_tb.config_ss_env_intf.host_usb_if.usb_ss_serial_if</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s0 cl rt">  8.26</td>
<td class="s1 cl rt"><a href="mod311.html#inst_tag_25392_Line" > 17.97</a></td>
<td class="s0 cl rt"><a href="mod311.html#inst_tag_25392_Cond" >  0.00</a></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="s0 cl rt"><a href="mod311.html#inst_tag_25392_Branch" >  6.82</a></td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s0 cl rt">  8.26</td>
<td class="s1 cl rt"> 17.97</td>
<td class="s0 cl rt">  0.00</td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="s0 cl rt">  6.82</td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s10 cl rt">100.00</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td><a href="mod649.html#inst_tag_33945" >host_usb_if</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td colspan=8>no children</td>
</tr></table><br clear=all>
</div>
</div>
<div name='inst_tag_25393'>
<hr>
<a name="inst_tag_25393"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy52.html#tag_urg_inst_25393" >config_ss_tb.config_ss_env_intf.host_usb_if.usb_ss_serial_lane1_if</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s0 cl rt">  8.26</td>
<td class="s1 cl rt"><a href="mod311.html#inst_tag_25393_Line" > 17.97</a></td>
<td class="s0 cl rt"><a href="mod311.html#inst_tag_25393_Cond" >  0.00</a></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="s0 cl rt"><a href="mod311.html#inst_tag_25393_Branch" >  6.82</a></td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s0 cl rt">  8.26</td>
<td class="s1 cl rt"> 17.97</td>
<td class="s0 cl rt">  0.00</td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="s0 cl rt">  6.82</td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s10 cl rt">100.00</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td><a href="mod649.html#inst_tag_33945" >host_usb_if</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td colspan=8>no children</td>
</tr></table><br clear=all>
</div>
</div>
<div name='inst_tag_25394'>
<hr>
<a name="inst_tag_25394"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy52.html#tag_urg_inst_25394" >config_ss_tb.config_ss_env_intf.dev_usb_if.usb_ss_serial_if</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s0 cl rt">  8.26</td>
<td class="s1 cl rt"><a href="mod311.html#inst_tag_25394_Line" > 17.97</a></td>
<td class="s0 cl rt"><a href="mod311.html#inst_tag_25394_Cond" >  0.00</a></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="s0 cl rt"><a href="mod311.html#inst_tag_25394_Branch" >  6.82</a></td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s0 cl rt">  8.26</td>
<td class="s1 cl rt"> 17.97</td>
<td class="s0 cl rt">  0.00</td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="s0 cl rt">  6.82</td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s10 cl rt">100.00</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td><a href="mod649.html#inst_tag_33946" >dev_usb_if</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td colspan=8>no children</td>
</tr></table><br clear=all>
</div>
</div>
<div name='inst_tag_25395'>
<hr>
<a name="inst_tag_25395"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy52.html#tag_urg_inst_25395" >config_ss_tb.config_ss_env_intf.dev_usb_if.usb_ss_serial_lane1_if</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s0 cl rt">  8.26</td>
<td class="s1 cl rt"><a href="mod311.html#inst_tag_25395_Line" > 17.97</a></td>
<td class="s0 cl rt"><a href="mod311.html#inst_tag_25395_Cond" >  0.00</a></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="s0 cl rt"><a href="mod311.html#inst_tag_25395_Branch" >  6.82</a></td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s0 cl rt">  8.26</td>
<td class="s1 cl rt"> 17.97</td>
<td class="s0 cl rt">  0.00</td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="s0 cl rt">  6.82</td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s10 cl rt">100.00</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td><a href="mod649.html#inst_tag_33946" >dev_usb_if</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td colspan=8>no children</td>
</tr></table><br clear=all>
</div>
</div>
</div>
<div class="ui-layout-center">
<div class="ui-layout-center-inner-center">
<div name='tag_svt_usb_ss_serial_if'>
<a name="Line"></a>
Line Coverage for Module : <a href="mod311.html" >svt_usb_ss_serial_if</a><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s1"><td class="lf">TOTAL</td><td></td><td>217</td><td>39</td><td>17.97</td></tr>
<tr class="s2"><td class="lf">INITIAL</td><td>349</td><td>4</td><td>1</td><td>25.00</td></tr>
<tr class="s0"><td class="lf">ROUTINE</td><td>356</td><td>19</td><td>0</td><td>0.00</td></tr>
<tr class="s5"><td class="lf">ALWAYS</td><td>393</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="s10"><td class="lf">INITIAL</td><td>543</td><td>7</td><td>7</td><td>100.00</td></tr>
<tr class="s6"><td class="lf">ALWAYS</td><td>554</td><td>5</td><td>3</td><td>60.00</td></tr>
<tr class="s10"><td class="lf">INITIAL</td><td>569</td><td>1</td><td>1</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">INITIAL</td><td>578</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s0"><td class="lf">ALWAYS</td><td>664</td><td>12</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">ALWAYS</td><td>708</td><td>2</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">ALWAYS</td><td>715</td><td>5</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">ROUTINE</td><td>732</td><td>24</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">INITIAL</td><td>783</td><td>45</td><td>2</td><td>4.44</td></tr>
<tr class="s10"><td class="lf">INITIAL</td><td>868</td><td>19</td><td>19</td><td>100.00</td></tr>
<tr class="s0"><td class="lf">ALWAYS</td><td>897</td><td>30</td><td>0</td><td>0.00</td></tr>
<tr class="s1"><td class="lf">INITIAL</td><td>958</td><td>8</td><td>1</td><td>12.50</td></tr>
<tr class="s0"><td class="lf">ALWAYS</td><td>971</td><td>3</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">INITIAL</td><td>976</td><td>28</td><td>1</td><td>3.57</td></tr>
</table>
<pre class="code"><br clear=all>
348                         // Wait for all values to be loaded for the calculation
349        <font color = "red">1/2     ==>      wait(initialized == 1);</font>
350        <font color = "red">0/1     ==>      clock_gen_enable = 1;</font>
351        <font color = "red">0/1     ==>      initialize_ssc_parameters;</font>
352                       end
353                     
354                       task initialize_ssc_parameters;
355                         // Load the value of clock period
356        <font color = "red">0/1     ==>      clock_period_ps_resolved = clock_period_ps;</font>
357                         // Set the ssc direction as 1 to start
358        <font color = "red">0/1     ==>      ssc_direction = 1;</font>
359                         // Convert ppm to fraction
360        <font color = "red">0/1     ==>      if(ssc_down_spread_mode) begin</font>
361        <font color = "red">0/1     ==>        max_ssc_ppm_shift = (ssc_deviation_ppm/real'(1000000));</font>
362                         end else begin 
363        <font color = "red">0/1     ==>        max_ssc_ppm_shift = ((ssc_deviation_ppm+ssc_deviation_pos_ppm)/real'(1000000));</font>
364        <font color = "red">0/1     ==>        ssc_ppm_shift_neg = ((ssc_deviation_ppm)/real'(1000000));</font>
365        <font color = "red">0/1     ==>        ssc_ppm_shift_pos = ((ssc_deviation_pos_ppm)/real'(1000000));</font>
366                         end  
367                         // Scale KHz value to Hz
368        <font color = "red">0/1     ==>      ssc_spread_frequency_scaled = ssc_spread_frequency*1000;</font>
369                         // Calculate time period and scale by 10^6 to the us domain.
370        <font color = "red">0/1     ==>      ssc_spread_time_period = (1/ssc_spread_frequency_scaled);</font>
371        <font color = "red">0/1     ==>      ssc_spread_time_period = ssc_spread_time_period * (1000000);</font>
372                         // Scale the clock timeperiod from ps to us
373        <font color = "red">0/1     ==>      clock_period_ps_scaled = (clock_period_ps/1000000);</font>
374                         // Divide the period for ssc with the period for clock to find the number to ticks to reach max ppm and back.
375        <font color = "red">0/1     ==>      ssc_num_steps = (ssc_spread_time_period/clock_period_ps_scaled);</font>
376                         // For downspread the frequency has to reach max ppm and back. So to reach max halving the value
377        <font color = "red">0/1     ==>      ssc_num_steps = ssc_num_steps/2;</font>
378                         // For each step the clock period will change by the (max shift to reach in fraction), divided by the number of ticks to reach in (calculated above), multiply the clock period
379        <font color = "red">0/1     ==>      ssc_ppm_step =  (max_ssc_ppm_shift/real'(ssc_num_steps))*clock_period_ps;</font>
380                         // The max clock period that can be generated is the clock period + the max ppm shift
381                         // For down spread the min is the actual clock period
382        <font color = "red">0/1     ==>      if(ssc_down_spread_mode) begin</font>
383        <font color = "red">0/1     ==>        clock_period_ssc_max_ps = clock_period_ps + (clock_period_ps*max_ssc_ppm_shift);</font>
384        <font color = "red">0/1     ==>        clock_period_ssc_min_ps = clock_period_ps;</font>
385                         end else begin
386        <font color = "red">0/1     ==>        clock_period_ssc_max_ps = clock_period_ps + (clock_period_ps*ssc_ppm_shift_neg);</font>
387        <font color = "red">0/1     ==>        clock_period_ssc_min_ps = clock_period_ps - (clock_period_ps*ssc_ppm_shift_pos);</font>
388                         end
389                       endtask
390                     
391                       // If the port were to fallback aor change clock rate the ssc calucations need to be made again
392                       always@(ess_operating_rate or clock_period_ps) begin
393        <font color = "red">1/2     ==>      if(initialized) initialize_ssc_parameters;</font>
                        MISSING_ELSE
394                       end
395                     
396                     //-----------------------------------------------------------------------
397                     /**
398                      * Clocking block that defines VIP USB PHYSICAL's SS Serial Tx Link
399                      * Interface signal synchronization and directionality, for the
400                      * SS wires.
401                      */
402                     clocking usb_ss_serial_phy_tx_cb @(posedge vip_tx_clk);
403                     `ifdef SVT_USB_IF_NO_PARAMS
404                       default input #(`SVT_USB_SS_SERIAL_IF_SETUP_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(`SVT_USB_SS_SERIAL_IF_HOLD_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
405                     `else
406                       default input #(setup_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(hold_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
407                     `endif
408                       output sstxp;
409                       output sstxm;
410                     endclocking
411                     
412                     //-----------------------------------------------------------------------
413                     /**
414                      * Clocking block that defines VIP USB PHYSICAL's SS Serial Tx Link
415                      * Interface signal for monitor.
416                      */
417                     clocking usb_ss_serial_phy_tx_monitor_cb @(posedge vip_tx_clk);
418                     `ifdef SVT_USB_IF_NO_PARAMS
419                       default input #(`SVT_USB_SS_SERIAL_IF_SETUP_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(`SVT_USB_SS_SERIAL_IF_HOLD_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
420                     `else
421                       default input #(setup_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(hold_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
422                     `endif
423                       input sstxp;
424                       input sstxm;
425                     `ifndef SVT_USB_JITTER_CORRECTION_DISABLE  
426                       input data_flopped_to_sample_tx;
427                       input data_flopped_to_sample_n_tx;
428                     `endif  
429                     endclocking
430                     
431                     
432                     //-----------------------------------------------------------------------
433                     /**
434                      * Clocking block that defines VIP USB PHYSICAL's SS Serial Rx Link
435                      * Interface signal synchronization and directionality, for the
436                      * SS wires.
437                      */
438                     clocking usb_ss_serial_phy_rx_cb @(posedge vip_rx_clk);
439                     `ifdef SVT_USB_IF_NO_PARAMS
440                       default input #(`SVT_USB_SS_SERIAL_IF_SETUP_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(`SVT_USB_SS_SERIAL_IF_HOLD_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
441                     `else
442                       default input #(setup_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(hold_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
443                     `endif
444                       input ssrxp;
445                       input ssrxm;
446                     `ifndef SVT_USB_JITTER_CORRECTION_DISABLE  
447                       input data_flopped_to_sample;
448                       input data_flopped_to_sample_n;
449                     `endif  
450                     endclocking
451                     
452                     //-----------------------------------------------------------------------
453                     // USB SS Serial Modports
454                     //-----------------------------------------------------------------------
455                     
456                     //-----------------------------------------------------------------------
457                     /** Modport used to connect VIP USB PHYSICAL to USB SS SERIAL interface signals from the link direction. */
458                     modport svt_usb_ss_serial_phy_port(
459                       clocking usb_ss_serial_phy_tx_cb, clocking usb_ss_serial_phy_rx_cb, output vbus, input dut_ss_termination, output vip_ss_termination);
460                     
461                     //-----------------------------------------------------------------------
462                     /** Modport used to connect VIP USB PHYSICAL to USB SS SERIAL interface signals from the PHY direction. */
463                     modport svt_usb_ss_serial_cable_port(
464                       input sstxp,
465                       input sstxm,
466                       output ssrxp,
467                       output ssrxm,
468                       input vbus,
469                       output dut_ss_termination,
470                       input vip_ss_termination
471                       );
472                     
473                     //-----------------------------------------------------------------------
474                     /** Modport used to monitor VIP USB SS serial interface signals. */
475                     modport svt_usb_ss_serial_phy_monitor_port(
476                       clocking usb_ss_serial_phy_tx_monitor_cb, clocking usb_ss_serial_phy_rx_cb, input vbus, input dut_ss_termination, input vip_ss_termination);
477                     
478                     task wait_for_hold_drive();
479                       #(hold_time_scaled + 1);
480                     endtask
481                     
482                     `ifndef __SVDOC__
483                     //-----------------------------------------------------------------------
484                     // USB SS Serial Interface Control Assigns
485                     //-----------------------------------------------------------------------
486                     
487                       //---------------------------------------------------------------------
488                       // Additions for receiver detection
489                       //---------------------------------------------------------------------
490                       assign vip_ss_termination = vip_ss_termination_reg;
491                     
492                       //-------------------------------------------------------------------------
493                       // Additions for VBUS
494                       //-------------------------------------------------------------------------
495                       assign vbus = vbus_reg;
496                     
497                       //-----------------------------------------------------------------------
498                       // Additions for Clock_Recovery
499                       //-----------------------------------------------------------------------
500                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE
501                       // Detect differential receiver value
502                       assign data_in = ((ssrxp === 1'bz) || (ssrxp === 1'bx)) ? 1'b0 :
503                                        ((ssrxm === 1'bz) || (ssrxm === 1'bx)) ? 1'b0 : ssrxp;
504                     
505                       // Use the unfiltered transmit clock whenever the DPLL is not ready
506                       assign pll_disable = (rec_clk_valid !== 1'b1) ? 1'b1 : 1'b0;
507                     `endif
508                       // Filter the output clock as per mode (normal vs. clock recovery)
509                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE  
510                       assign vip_rx_clk = (clock_recovery_enable === 1'b1) ? rec_clk_out : (ess_operating_rate === 2'b01) ? ssclk : clock5GHz;
511                     `endif
512                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE
513                       // Output clock for the VIP is from the recovered clock
514                       assign rec_clk_out = (pll_rec_clk | pll_sync_clk);
515                     
516                       // When the VIP is transmitting, or the PLL is disabled, disable the recovery of clock
517                       assign phase_rst = ((pll_disable) |
518                                           ((((data_phase_2 | !data_phase_3) &amp; (!data_phase_2 | data_phase_3)) | (int_se0))));
519                       // SE0 detection
520                       assign se0_detect = ((ssrxp === 1'bz) || (ssrxp === 1'bx)) ? 1'b0 :
521                                           ((ssrxm === 1'bz) || (ssrxm === 1'bx)) ? 1'b0 : (!(ssrxp | ssrxm));
522                     
523                       // Phase detection
524                       assign phase_det = (feed_back ^ pll_clk);
525                     
526                       // Clock extraction
527                       assign extract_clk = (phase_det &amp; phase_rst &amp; ~extract_clk_reg);
528                     
529                       // Clock valid condition
530                       assign rec_clk_valid = (pll_reset === 1'b0) ? 1'b1 : 1'b0;
531                     `endif
532                     
533                     //-----------------------------------------------------------------------
534                     // USB SS Serial Interface Control Processes
535                     //-----------------------------------------------------------------------
536                     
537                       //-----------------------------------------------------------------------
538                       // Additions for receiver detection
539                       //-----------------------------------------------------------------------
540                     
541                       // Initialize all registers
542                       initial begin
543        1/1              ess_operating_rate =  2'b01;
544        1/1              dut_ss_termination_reg = 1;  // Assume DUT SS RX termination in place
545        1/1              vip_ss_termination_reg = 0;  // Assume VIP SS RX termination not in place
546        2/2              #1;
547        1/1              if (vbus !== 1'b1) begin
548        1/1                dut_ss_termination_reg = 0;  // Assume no DUT SS RX termination when VBUS is absent
549                         end
                   <font color = "red">==>  MISSING_ELSE</font>
550                       end
551                     
552                       // Sample changes on the DUT termination signal
553                       always @ (dut_ss_termination or vbus) begin
554        1/1              if (dut_ss_termination === 1'b0) begin
555        <font color = "red">0/1     ==>        dut_ss_termination_reg = 0;  // No DUT SS RX termination - signaled by TB</font>
556        1/1              end else if (vbus !== 1'b1) begin
557        1/1                dut_ss_termination_reg = 0;  // No DUT SS RX termination - VBUS is absent
558                         end else begin
559        <font color = "red">0/1     ==>        dut_ss_termination_reg = 1;  // DUT SS RX termination in place</font>
560                         end
561                       end
562                     
563                       //-----------------------------------------------------------------------
564                       // Additions for VBUS
565                       //-----------------------------------------------------------------------
566                     
567                       // Initialize VBUS drive off
568                       initial begin
569        1/1              vbus_reg = 1'bz;  // Assume VIP not started
570                       end
571                     
572                       //-----------------------------------------------------------------------
573                       // Additions for Clock_Recovery
574                       //-----------------------------------------------------------------------
575                     
576                       // Initialize all registers
577                       initial begin
578        1/1              clk4x           = 1'b0;
579        1/1              vip_tx_clk      = 1'b0;
580                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE    
581                         clk2x           = 1'b0;
582                         data_phase_0    = 1'b0;
583                         data_phase_1    = 1'b0;
584                         data_phase_2    = 1'b0;
585                         data_phase_3    = 1'b0;
586                         dpdm_phase_0    = 1'b0;
587                         int_se0         = 1'b0;
588                         extract_clk_reg = 1'b0;
589                         feed_back       = 1'b0;
590                         pll_clk         = 1'b0;
591                         pll_rec_clk     = 1'b0;
592                         pll_reset       = 1'b1;
593                         pll_sync_clk    = 1'b0;
594                         saw_sync_clk    = 1'b0;
595                     `endif    
596        1/1              clock5GHz       = 1'b0;
597                       end
598                     
599                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE
600                       // Reset the DPLL at startup
601                       initial begin
602                         @(posedge ssclk);
603                         @(posedge ssclk);
604                         pll_reset = 0;
605                       end
606                     
607                       // Code to generate the initial recovered clock edge during the first SYNC bit
608                       always @ (posedge clk4x) begin
609                         pll_sync_clk &lt;= 1'b0;
610                       end
611                       // Generation of control signals
612                       always @ (posedge clk4x) begin
613                         data_phase_0 &lt;= data_in;
614                         data_phase_1 &lt;= data_phase_0;
615                         data_phase_2 &lt;= data_phase_1;
616                         data_phase_3 &lt;= data_phase_2;
617                         dpdm_phase_0 &lt;= se0_detect;
618                         int_se0 &lt;= dpdm_phase_0 &amp;&amp; (int_se0 || se0_detect);
619                         extract_clk_reg &lt;= phase_det &amp; phase_rst;
620                       end
621                     
622                       // Generation of feedback
623                       always @ (posedge clk4x) begin
624                         if (pll_reset) begin
625                           feed_back &lt;= 1'b1;
626                         end
627                         else begin
628                           feed_back &lt;= (!feed_back) &amp; phase_rst;
629                         end
630                       end
631                     
632                       // Generation of clock
633                       always @ (posedge clk4x) begin
634                         if (pll_reset) begin
635                           pll_clk &lt;= 1'b1;
636                         end
637                         else begin
638                           pll_clk &lt;= phase_det &amp; phase_rst;
639                         end
640                       end
641                     
642                       // Generation of recovered clock
643                       always @ (posedge clk4x) begin
644                         if (pll_reset) begin
645                           pll_rec_clk &lt;= 1'b0;
646                         end
647                         else begin
648                           pll_rec_clk &lt;= extract_clk;
649                         end
650                       end
651                     `endif  
652                     
653                       //-------------------------------------------------------------------------
654                       // Generates the TX clock based on the clock_recovery_enable setting
655                       //-------------------------------------------------------------------------
656                       bit clock_divider;
657                     
658                       // When clock recovery is disabled, the VIP TX clock is the input clock
659                       //--------------------------------------------------------------------------
660                       always @ (ssclk) begin 
661                         // Only if operating rate is 2'b00 generate the clock5GHz clock.
662                         // If VIP starts in SS mode the clock ss is anyway expected to be 5G.
663                         // If VIP starts in SSP mode the clock 5G is only required for fallback which reflected in ess_operating_rate as 2'b00
664        <font color = "red">0/1     ==>      if(ess_operating_rate == 2'b00) begin</font>
665        <font color = "red">0/2     ==>        if(clock_divider) clock5GHz = !(clock5GHz);</font>
                   <font color = "red">==>  MISSING_ELSE</font>
666        <font color = "red">0/1     ==>        clock_divider = !(clock_divider);</font>
667                         end
                   <font color = "red">==>  MISSING_ELSE</font>
668                         // if clock recovery is enabled, the vip tx clock is generated by dividing the 4x clock by a factor of 4.
669        <font color = "red">0/1     ==>      if (clock_recovery_enable === 1'b1) begin </font>
670                           // When ess_operating rate is 1 then pass the ssclk which is generating in top 
671                           // Else pass clock5GHz(3.0) local generated clock 
672        <font color = "red">0/1     ==>        clk4x = (ess_operating_rate === 2'b01) ? ssclk : clock5GHz; </font>
673                         end
674                         else begin 
675                           // When ess_operating rate is 1 then pass the ssclk which is generating in top 
676                           // Else pass clock5GHz(3.0) local generated clock 
677        <font color = "red">0/1     ==>        if(!enable_clock_jitter &amp;&amp; !enable_ssc) begin </font>
678                     `ifndef SVT_USB_JITTER_CORRECTION_DISABLE
679        <font color = "red">0/1     ==>          if(ess_operating_rate === 2'b01) begin</font>
680        <font color = "red">0/1     ==>            vip_tx_clk = ssclk; </font>
681        <font color = "red">0/1     ==>            vip_rx_clk = ssclk; </font>
682                             end
683                             else begin
684        <font color = "red">0/1     ==>            vip_tx_clk = clock5GHz; </font>
685        <font color = "red">0/1     ==>            vip_rx_clk = clock5GHz; </font>
686                             end
687                     `else
688                             vip_tx_clk = (ess_operating_rate === 2'b01) ? ssclk : clock5GHz; 
689                     `endif        
690                           end  
                   <font color = "red">==>  MISSING_ELSE</font>
691                         end 
692                       end 
693                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE  
694                       always @ (posedge clk4x) begin
695                         clk2x = ~clk2x;
696                       end
697                     
698                       // When clock recovery is enabled, the VIP TX clock is 1/4 the input clock
699                       //--------------------------------------------------------------------------
700                       always @ (posedge clk2x) begin
701                         if (clock_recovery_enable === 1'b1 &amp;&amp; !enable_clock_jitter &amp;&amp; !enable_ssc) begin
702                           vip_tx_clk = ~vip_tx_clk;
703                         end
704                       end
705                     `endif
706                     
707                       always @(ssclk_tx) begin
708        <font color = "red">0/1     ==>      if(tx_user_clock_enable === 1)</font>
709        <font color = "red">0/1     ==>        vip_tx_clk = ssclk_tx;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
710                       end
711                       
712                       // Always block which is triggered if there is a change in value of enable_clock_jitter
713                       // If the enable_clock_jitter is '0' then trigger the end of the loop which generates tx clock
714                       always@(enable_clock_jitter) begin
715        <font color = "red">0/1     ==>      if(enable_clock_jitter) begin</font>
716                         end
717                         else begin
718        <font color = "red">0/1     ==>        if(kill_jitter_clock_gen == 0) begin</font>
719        <font color = "red">0/1     ==>          kill_jitter_clock_gen = 1;</font>
720        <font color = "red">0/2     ==>          wait(kill_jitter_clock_gen == 0);</font>
721                           end
                   <font color = "red">==>  MISSING_ELSE</font>
722                         end
723                       end
724                     
725                       // This task is responsible for generating a clock cycle. The task is blocking and takes inputs:
726                       // enable_jitter : If this is '1' then a jittered clock is genearted. If '0' then a clock with no jitter is generated.
727                       // positive_jitter_mode : This when 1 generates a positive jitter i.e. extends the clock by percentage_jitter. Else shortens it by percentage_jitter
728                       // percentage_jitter :  This is a real number input which holds the percentage value of the jitter to introduce.
729                       real half_time_resolved;
730                       task generate_jitter_clock(bit enable_jitter,bit positive_jitter_mode, real percentage_jitter);
731                         // Block excersised for SSC mode.
732        <font color = "red">0/1     ==>      if(enable_ssc &amp;&amp; !disable_ssc_clk_ppm_shift) begin</font>
733                           // If the SSC direction is positive 
734                           //  if the clock period has not reached the max ssc, keep incrementing the clock period.
735                           //  else if the max SSC is reached start to decrement the period and flip the direction
736        <font color = "red">0/1     ==>        if(ssc_direction) begin</font>
737        <font color = "red">0/1     ==>          if(clock_period_ssc_max_ps - clock_period_ps_resolved &gt;= ssc_ppm_step) begin</font>
738        <font color = "red">0/1     ==>            clock_period_ps_resolved = clock_period_ps_resolved + ssc_ppm_step;</font>
739                             end else begin
740        <font color = "red">0/1     ==>            clock_period_ps_resolved = clock_period_ps_resolved - ssc_ppm_step;</font>
741        <font color = "red">0/1     ==>            ssc_direction = 0;</font>
742                             end
743                           // If the SSC direction is negative 
744                           //  if the clock period has not reached the min ssc, keep decrementing the clock period.
745                           //  else if the min SSC is reached start to increment the period and flip the direction
746                           end else begin
747        <font color = "red">0/1     ==>          if(clock_period_ps_resolved - clock_period_ssc_min_ps &gt;= ssc_ppm_step) begin</font>
748        <font color = "red">0/1     ==>            clock_period_ps_resolved = clock_period_ps_resolved - ssc_ppm_step;</font>
749                             end else begin
750        <font color = "red">0/1     ==>            clock_period_ps_resolved = clock_period_ps_resolved + ssc_ppm_step;</font>
751        <font color = "red">0/1     ==>            ssc_direction = 1;</font>
752                             end
753                           end
754                         end else begin
755        <font color = "red">0/1     ==>        clock_period_ps_resolved = clock_period_ps;</font>
756                         end
757                         // Add jitter if enabled
758        <font color = "red">0/1     ==>      if(enable_jitter) begin</font>
759        <font color = "red">0/1     ==>        clk_scale_jitter = (real'(percentage_jitter * clock_period_ps_resolved)/100);</font>
760        <font color = "red">0/2     ==>        if(positive_jitter_mode) half_clk_time = (real'(clock_period_ps_resolved + clk_scale_jitter)/2);</font>
761        <font color = "red">0/1     ==>        else half_clk_time = (real'(clock_period_ps_resolved - clk_scale_jitter)/2);</font>
762                         end
763        <font color = "red">0/1     ==>      else half_clk_time = (real'(clock_period_ps_resolved)/2);</font>
764        <font color = "red">0/1     ==>      half_time_resolved = (half_clk_time*1ps);</font>
765        <font color = "red">0/2     ==>      #(half_time_resolved);</font>
766        <font color = "red">0/1     ==>      vip_tx_clk = !(vip_tx_clk);</font>
767        <font color = "red">0/2     ==>      #(half_time_resolved);</font>
768        <font color = "red">0/1     ==>      vip_tx_clk = !(vip_tx_clk);</font>
769                     `ifdef SVT_USB_JITTER_DEBUG_TRACE    
770                         $fdisplay(file_handle,$sformatf(&quot;%32t: enable_jitter: %b enable_ssc: %b clk_scale_jitter: %f half_clk_time: %f clock_period_ps_resolved: %f clock_period_ssc_max_ps: %f clock_period_ssc_min_ps: %f&quot;,$time,enable_jitter,enable_ssc,clk_scale_jitter,half_clk_time,clock_period_ps_resolved,clock_period_ssc_max_ps,clock_period_ssc_min_ps));
771                     `endif    
772                       endtask
773                     
774                       // Initial block
775                       // This loop generates the jittered tx clock when enable_clock_jitter is '1'
776                       int decimal_delta;
777                       int decimal_no_delta;
778                       bit whole_number,resolved_to_plus_one;
779                       initial begin
780                     `ifdef SVT_USB_JITTER_DEBUG_TRACE  
781                         file_handle = $fopen($sformatf(&quot;%m.txt&quot;),&quot;w&quot;);
782                     `endif    
783        1/1              while(1) begin
784        <font color = "red">1/2     ==>        wait(initialized == 1);</font>
785        <font color = "red">0/2     ==>        wait(enable_clock_jitter == 1 || enable_ssc == 1);</font>
786        <font color = "red">0/1     ==>        vip_tx_clk = 1;</font>
787        <font color = "red">0/1     ==>        kill_jitter_clock_gen = 0;</font>
788        <font color = "red">0/1     ==>        decimal_delta = (percentage_jitter*100);</font>
789        <font color = "red">0/1     ==>        decimal_no_delta = percentage_jitter;</font>
790        <font color = "red">0/1     ==>        decimal_no_delta = (decimal_no_delta*100);</font>
791        <font color = "red">0/1     ==>        percentage_jitter_local_decimal_cap = (decimal_delta - decimal_no_delta);</font>
792        <font color = "red">0/1     ==>        if(percentage_jitter_local_decimal_cap == 0) begin </font>
793        <font color = "red">0/1     ==>          whole_number = 1;</font>
794        <font color = "red">0/1     ==>          percentage_jitter_local_decimal_cap = 99; </font>
795                           end  
796        <font color = "red">0/1     ==>        else if(percentage_jitter_local_decimal_cap &lt; 0) begin </font>
797        <font color = "red">0/1     ==>          percentage_jitter_local_decimal_cap = 100 + percentage_jitter_local_decimal_cap;</font>
798        <font color = "red">0/1     ==>          resolved_to_plus_one = 1;</font>
799                           end 
800                           else begin
801                           end
802                           // If block to generate random jitter
803        <font color = "red">0/1     ==>        if(random_jitter_mode) begin</font>
804        <font color = "red">0/1     ==>          while(1) begin</font>
805                               // The usecase of random jitter is to introduce jitter in the clock between 0% to percentage_jitter% in the clock randomly which may be positive or negative.
806                               // Eg: if the user sets 2 as percentage_jitter, the output clock will introduce jitter in the range of 0% to 1.99% randomly as positive or neagative.
807                               // Randomize the jitter in the current clock as positive or negative
808        <font color = "red">0/1     ==>            positive_jitter_mode = $urandom();</font>
809                               // If percentage_jitter is set as 1 then the percenatge variation is from 0 - 0.99%. Bypass randomize.
810                               // Else the integral part is randomized between 0-'n-1' when percentage_jitter is n. 
811                               // The final jitter introduced will be 0% to &lt;n-1&gt;.99%
812                               // Assumption here is (also mentioned in SVDOC): In this mode when the user sets tha max cap jitter it has to be an integer.
813                               // Copy the percentage_jitter real number in an integer type for randomization.
814        <font color = "red">0/1     ==>            percentage_jitter_local_int = percentage_jitter;</font>
815        <font color = "red">0/1     ==>            if(whole_number || (!whole_number &amp;&amp; resolved_to_plus_one)) begin</font>
816        <font color = "red">0/1     ==>              percentage_jitter_local_int = percentage_jitter_local_int - 1;</font>
817                               end 
                   <font color = "red">==>  MISSING_ELSE</font>
818        <font color = "red">0/1     ==>            if(percentage_jitter_local_int &gt; 0) begin</font>
819        <font color = "red">0/1     ==>              percentage_jitter_local_int = $urandom_range(0,percentage_jitter_local_int);</font>
820                               end
821                               else begin
822        <font color = "red">0/1     ==>              percentage_jitter_local_int = 0;</font>
823                               end
824                               // Randomize the trailing decimal percentage.
825        <font color = "red">0/1     ==>            percentage_jitter_local_decimal = $urandom_range(0,percentage_jitter_local_decimal_cap);</font>
826                               // Construct the percenatge randomized as &quot;jitter = int + (dec/100)&quot;.
827                               // Eg: If interger randomized is '1' and decimal is 67 the final jitter becomes 1.67.
828        <font color = "red">0/1     ==>            percentage_jitter_local = percentage_jitter_local_decimal;</font>
829        <font color = "red">0/1     ==>            percentage_jitter_local = (percentage_jitter_local/100);</font>
830        <font color = "red">0/1     ==>            percentage_jitter_local = percentage_jitter_local_int + percentage_jitter_local;</font>
831                               // Generate jitter
832        <font color = "red">0/1     ==>            generate_jitter_clock(enable_clock_jitter,positive_jitter_mode,percentage_jitter_local);</font>
833                               // After every cycle check if the jitter mode is disabled to 'break'
834        <font color = "red">0/2     ==>            if(kill_jitter_clock_gen) break;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
835                             end
836                           end
837                           else begin
838        <font color = "red">0/1     ==>          while(1) begin</font>
839        <font color = "red">0/1     ==>            if(enable_clock_jitter) begin</font>
840                                 // Loop to generate constant jitter.
841                                 // In this mode all the values come from the user.
842                                 // Type of jitter (positive/ negative)
843                                 // Percentage jitter. (This can be in decimals unlike in Random mode)
844                                 // The cycle of generation i.e. number of pulse with jitter followed by the number without jitter
845        <font color = "red">0/1     ==>              repeat(number_of_clocks_with_jitter) begin</font>
846        <font color = "red">0/1     ==>                generate_jitter_clock(1,positive_jitter_mode,percentage_jitter);</font>
847                                 end
                   <font color = "red">==>  REPEAT_FALSE</font>
848        <font color = "red">0/2     ==>              if(kill_jitter_clock_gen) break;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
849        <font color = "red">0/1     ==>              repeat(number_of_clocks_without_jitter) begin</font>
850        <font color = "red">0/1     ==>                generate_jitter_clock(0,positive_jitter_mode,percentage_jitter);</font>
851                                 end
852                               end else begin
853        <font color = "red">0/1     ==>              generate_jitter_clock(0,positive_jitter_mode,percentage_jitter);</font>
854                               end
855                               // After every cycle check if the jitter mode is disabled to 'break'
856        <font color = "red">0/2     ==>            if(kill_jitter_clock_gen) break;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
857                             end
858                           end
859        <font color = "red">0/1     ==>        kill_jitter_clock_gen = 0;</font>
860                         end  
861                       end
862                     `ifndef SVT_USB_JITTER_CORRECTION_DISABLE  
863                       //---------------------------------------------------------------
864                       // CDR
865                       //---------------------------------------------------------------
866                     
867                       initial begin
868        1/1              feedback_toggle = 1;
869        1/1              feedback_toggle_tx = 1;
870        1/1              vip_rx_clk = 1;
871        1/1              data_flopped_0 = 0;
872        1/1              data_flopped_1 = 0;
873        1/1              data_flopped_2 = 0;
874        1/1              data_flopped_0_to_sample = 0;
875        1/1              data_flopped_1_to_sample = 0;
876        1/1              data_flopped_2_to_sample = 0;
877        1/1              data_flopped_to_sample = 0;
878        1/1              data_flopped_to_sample_n = 0;
879        1/1              data_flopped_0_tx = 0;
880        1/1              data_flopped_1_tx = 0;
881        1/1              data_flopped_2_tx = 0;
882        1/1              data_flopped_0_to_sample_tx = 0;
883        1/1              data_flopped_1_to_sample_tx = 0;
884        1/1              data_flopped_2_to_sample_tx = 0;
885        1/1              data_flopped_to_sample_tx = 0;
886        1/1              data_flopped_to_sample_n_tx = 0;
887                       end
888                     
889                       //--------------------------------------------------------------------------------------------------
890                       // This signal gives an active low signal every time there is a change in the incoming signal level
891                       //--------------------------------------------------------------------------------------------------
892                       assign edge_detect_active_low = ((!(data_flopped_0) &amp; !(data_flopped_1)) | (data_flopped_0 &amp; data_flopped_1 ));
893                       assign edge_detect_active_low_tx = ((!(data_flopped_0_tx) &amp; !(data_flopped_1_tx)) | (data_flopped_0_tx &amp; data_flopped_1_tx ));
894                       bit clock_divider_tx;
895                     
896                       always@(posedge (clk4x &amp; clock_gen_enable)) begin
897        <font color = "red">0/1     ==>      if(!enable_clock_jitter &amp;&amp; !enable_ssc &amp;&amp; !is_passive &amp;&amp; !tx_user_clock_enable) begin</font>
898        <font color = "red">0/2     ==>        if(clock_divider_tx) vip_tx_clk &lt;= !vip_tx_clk;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
899        <font color = "red">0/1     ==>        clock_divider_tx &lt;= !(clock_divider_tx);</font>
900                         end
                   <font color = "red">==>  MISSING_ELSE</font>
901                         // Ignore any data which is z or x.
902        <font color = "red">0/1     ==>      if(ssrxp === 1'bz || ssrxp === 1'bx) begin</font>
903        <font color = "red">0/1     ==>        data_flopped_0 &lt;= data_flopped_0;</font>
904                         end
905                         else begin
906        <font color = "red">0/1     ==>        data_flopped_0 &lt;= ssrxp;</font>
907                         end
908        <font color = "red">0/1     ==>      data_flopped_1 &lt;= data_flopped_0;</font>
909        <font color = "red">0/1     ==>      data_flopped_2 &lt;= data_flopped_1;</font>
910        <font color = "red">0/1     ==>      data_flopped_0_to_sample &lt;= {ssrxm,ssrxp};</font>
911        <font color = "red">0/1     ==>      data_flopped_1_to_sample &lt;= data_flopped_0_to_sample;</font>
912        <font color = "red">0/1     ==>      data_flopped_2_to_sample &lt;= data_flopped_1_to_sample;</font>
913        <font color = "red">0/1     ==>      data_flopped_to_sample &lt;= data_flopped_2_to_sample[0];</font>
914        <font color = "red">0/1     ==>      data_flopped_to_sample_n &lt;= data_flopped_2_to_sample[1];</font>
915        <font color = "red">0/1     ==>      if(is_passive) begin</font>
916        <font color = "red">0/1     ==>        if(sstxp === 1'bz || sstxm === 1'bx) begin</font>
917        <font color = "red">0/1     ==>          data_flopped_0_tx &lt;= data_flopped_0_tx;</font>
918                           end
919                           else begin
920        <font color = "red">0/1     ==>          data_flopped_0_tx &lt;= sstxp;</font>
921                           end
922        <font color = "red">0/1     ==>        data_flopped_1_tx &lt;= data_flopped_0_tx;</font>
923        <font color = "red">0/1     ==>        data_flopped_2_tx &lt;= data_flopped_1_tx;</font>
924        <font color = "red">0/1     ==>        data_flopped_0_to_sample_tx &lt;= {sstxm,sstxp};</font>
925        <font color = "red">0/1     ==>        data_flopped_1_to_sample_tx &lt;= data_flopped_0_to_sample_tx;</font>
926        <font color = "red">0/1     ==>        data_flopped_2_to_sample_tx &lt;= data_flopped_1_to_sample_tx;</font>
927        <font color = "red">0/1     ==>        data_flopped_to_sample_tx &lt;= data_flopped_2_to_sample_tx[0];</font>
928        <font color = "red">0/1     ==>        data_flopped_to_sample_n_tx &lt;= data_flopped_2_to_sample_tx[1];</font>
929                         end
                   <font color = "red">==>  MISSING_ELSE</font>
930                         // Feedback toggle keeps on toggling for every posedge of reference clock.
931                         // The edge detect signal going low forces the feedback_toggle to go low. This can be considered a phase reset.
932                         // If the incoming serial data is without jitters the moment edge_detect_active_low is low feedback_toggle is also low.
933                         // So the next clock of ref_clk will give a high pulse as feedback_toggle changes and edge_detect_active_low goes high.
934                         // The next pulse goes low as the feedback toggle changes with no change in edge_detect_active_low.
935                         // Since ref_clk is 4 times the clock rate there will be 4 samples of 1 bit.
936                         // The sync is such that the feedback_toggle on no jitter will go 1 0 1 0.
937                         //
938                         // feedback_toggle_next feedback_toggle edge_detect_active_low
939                         //         1                   0                  1
940                         //         0                   1                  1
941                         //         1                   0                  1
942                         //         0                   1                  0
943                         //
944                         // This cycle repeats itself 
945                         // If there is jitter on the line then the edge_detect_active_low will either pulled in by a clock or pulled out by a clock.
946                         // This shifts the pll_clk pulse by 3 clock to the right or to the left
947        <font color = "red">0/1     ==>      feedback_toggle &lt;= !(feedback_toggle) &amp; edge_detect_active_low;</font>
948        <font color = "red">0/1     ==>      vip_rx_clk &lt;= (feedback_toggle ^ vip_rx_clk) &amp; edge_detect_active_low;</font>
949        <font color = "red">0/1     ==>      if(is_passive) begin</font>
950        <font color = "red">0/1     ==>        feedback_toggle_tx &lt;= !(feedback_toggle_tx) &amp; edge_detect_active_low_tx;</font>
951        <font color = "red">0/1     ==>        vip_tx_clk &lt;= (feedback_toggle_tx ^ vip_tx_clk) &amp; edge_detect_active_low_tx;</font>
952                         end
                   <font color = "red">==>  MISSING_ELSE</font>
953                       end
954                     `endif
955                       bit ss_data_prev;
956                       initial begin
957                         realtime t0,t1;
958        <font color = "red">1/2     ==>      wait(clock_ui_jitter_check == 1);</font>
959        <font color = "red">0/1     ==>      t0 = $realtime();</font>
960        <font color = "red">0/2     ==>      #1fs;</font>
961        <font color = "red">0/1     ==>      t1 = $realtime();</font>
962        <font color = "red">0/1     ==>      if(!(t1 &gt; t0)) begin</font>
963        <font color = "red">0/1     ==>        $display(&quot;ERROR: Timescale is not 1fs, UI checks not possible.&quot;);</font>
964                         end
                   <font color = "red">==>  MISSING_ELSE</font>
965                       end
966                     
967                       real count_max, count_min,timestamp,timestamp_gap,timestamp_current;
968                       event event_error_UI;
969                       reg ss_data;
970                       always@(*) begin
971        <font color = "red">0/2     ==>      wait(clock_ui_jitter_check == 1);</font>
972        <font color = "red">0/1     ==>      ss_data = (is_passive)? sstxp: ssrxp;</font>
973                       end
974                     
975                       initial begin
976        <font color = "red">1/2     ==>      wait(clock_ui_jitter_check == 1);</font>
977        <font color = "red">0/1     ==>      while(1) begin</font>
978                           fork begin
979                             fork
980                             begin
981        <font color = "red">0/1     ==>            while(1) begin</font>
982        <font color = "red">0/1     ==>              if(!mode_ssp) begin</font>
983        <font color = "red">0/2     ==>                #200ps;</font>
984        <font color = "red">0/1     ==>                count_max = count_max + 200.06;</font>
985        <font color = "red">0/1     ==>                count_min = count_min + 199.94;</font>
986                                 end else begin
987        <font color = "red">0/2     ==>                #100ps;</font>
988        <font color = "red">0/1     ==>                count_max = count_max + 100.03;</font>
989        <font color = "red">0/1     ==>                count_min = count_min +  99.97;</font>
990                                 end
991                               end
992                             end
993                             begin
994        <font color = "red">0/2     ==>            @(ss_data);</font>
995                             end
996                             join_any
997        <font color = "red">0/1     ==>          disable fork;</font>
998                           end join_any
999        <font color = "red">0/1     ==>        timestamp = timestamp_current;</font>
1000       <font color = "red">0/1     ==>        timestamp_current = $realtime;</font>
1001       <font color = "red">0/1     ==>        timestamp_gap = (timestamp_current - timestamp);</font>
1002       <font color = "red">0/1     ==>        if(!(timestamp_gap &gt; count_min &amp;&amp; timestamp_gap &lt; count_max)) begin</font>
1003       <font color = "red">0/1     ==>          -&gt; event_error_UI;</font>
1004                          end
                   <font color = "red">==>  MISSING_ELSE</font>
1005       <font color = "red">0/2     ==>        #1ps;</font>
1006       <font color = "red">0/1     ==>        if(!mode_ssp) begin</font>
1007       <font color = "red">0/1     ==>          count_max = 200.06;</font>
1008       <font color = "red">0/1     ==>          count_min = 199.94;</font>
1009                          end else begin
1010       <font color = "red">0/1     ==>          count_max = 100.03;</font>
1011       <font color = "red">0/1     ==>          count_min =  99.97;</font>
</pre>
<hr>
<a name="Cond"></a>
Cond Coverage for Module : <a href="mod311.html" >svt_usb_ss_serial_if</a><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s0"><td class="lf">Conditions</td><td>19</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">Logical</td><td>19</td><td>0</td><td>0.00</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       677
 EXPRESSION (((!enable_clock_jitter)) &amp;&amp; ((!enable_ssc)))
             ------------1-----------    -------2-------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       785
 EXPRESSION ((enable_clock_jitter == 1'b1) || (enable_ssc == 1'b1))
             --------------1--------------    ----------2---------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       815
 EXPRESSION (whole_number || (((!whole_number)) &amp;&amp; resolved_to_plus_one))
             ------1-----    ---------------------2---------------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       815
 SUB-EXPRESSION (((!whole_number)) &amp;&amp; resolved_to_plus_one)
                 --------1--------    ----------2---------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       897
 EXPRESSION (((!enable_clock_jitter)) &amp;&amp; ((!enable_ssc)) &amp;&amp; ((!is_passive)) &amp;&amp; ((!tx_user_clock_enable)))
             ------------1-----------    -------2-------    -------3-------    ------------4------------
</pre>
<table class="noborder">
<col span="4" width="40">
<tr><th>-1-</th><th>-2-</th><th>-3-</th><th>-4-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       972
 EXPRESSION (is_passive ? sstxp : ssrxp)
             -----1----
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<hr>
<a name="Branch"></a>
Branch Coverage for Module : <a href="mod311.html" >svt_usb_ss_serial_if</a><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s0">
<td>Branches</td>
<td></td>
<td class="rt">44</td>
<td class="rt">3</td>
<td class="rt">6.82  </td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">393</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">547</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s3">
<td>IF</td>
<td class="rt">554</td>
<td class="rt">3</td>
<td class="rt">1</td>
<td class="rt">33.33 </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">664</td>
<td class="rt">3</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">669</td>
<td class="rt">4</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">708</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">715</td>
<td class="rt">3</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">792</td>
<td class="rt">3</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">803</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">897</td>
<td class="rt">3</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">902</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">915</td>
<td class="rt">3</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">949</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">962</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>TERNARY</td>
<td class="rt">972</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">982</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">1002</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">1006</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
393            if(initialized) initialize_ssc_parameters;
               <font color = "red">-1-</font>  
           <font color = "red">    ==></font>
               MISSING_ELSE
           <font color = "green">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
547            if (vbus !== 1'b1) begin
               <font color = "red">-1-</font>  
548              dut_ss_termination_reg = 0;  // Assume no DUT SS RX termination when VBUS is absent
           <font color = "green">      ==></font>
549            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
554            if (dut_ss_termination === 1'b0) begin
               <font color = "red">-1-</font>  
555              dut_ss_termination_reg = 0;  // No DUT SS RX termination - signaled by TB
           <font color = "red">      ==></font>
556            end else if (vbus !== 1'b1) begin
                        <font color = "red">-2-</font>  
557              dut_ss_termination_reg = 0;  // No DUT SS RX termination - VBUS is absent
           <font color = "green">      ==></font>
558            end else begin
559              dut_ss_termination_reg = 1;  // DUT SS RX termination in place
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
664            if(ess_operating_rate == 2'b00) begin
               <font color = "red">-1-</font>  
665              if(clock_divider) clock5GHz = !(clock5GHz);
                 <font color = "red">-2-</font>  
           <font color = "red">      ==></font>
                 MISSING_ELSE
           <font color = "red">      ==></font>
666              clock_divider = !(clock_divider);
667            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
669            if (clock_recovery_enable === 1'b1) begin 
               <font color = "red">-1-</font>  
670              // When ess_operating rate is 1 then pass the ssclk which is generating in top 
671              // Else pass clock5GHz(3.0) local generated clock 
672              clk4x = (ess_operating_rate === 2'b01) ? ssclk : clock5GHz; 
           <font color = "red">      ==></font>
673            end
674            else begin 
675              // When ess_operating rate is 1 then pass the ssclk which is generating in top 
676              // Else pass clock5GHz(3.0) local generated clock 
677              if(!enable_clock_jitter && !enable_ssc) begin 
                 <font color = "red">-2-</font>  
678        `ifndef SVT_USB_JITTER_CORRECTION_DISABLE
679                if(ess_operating_rate === 2'b01) begin
                   <font color = "red">-3-</font>  
680                  vip_tx_clk = ssclk; 
           <font color = "red">          ==></font>
681                  vip_rx_clk = ssclk; 
682                end
683                else begin
684                  vip_tx_clk = clock5GHz; 
           <font color = "red">          ==></font>
685                  vip_rx_clk = clock5GHz; 
686                end
687        `else
688                vip_tx_clk = (ess_operating_rate === 2'b01) ? ssclk : clock5GHz; 
689        `endif        
690              end  
                 MISSING_ELSE
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
708            if(tx_user_clock_enable === 1)
               <font color = "red">-1-</font>  
709              vip_tx_clk = ssclk_tx;
           <font color = "red">      ==></font>
                 MISSING_ELSE
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
715            if(enable_clock_jitter) begin
               <font color = "red">-1-</font>  
           <font color = "red">    ==></font>
716            end
717            else begin
718              if(kill_jitter_clock_gen == 0) begin
                 <font color = "red">-2-</font>  
719                kill_jitter_clock_gen = 1;
           <font color = "red">        ==></font>
720                wait(kill_jitter_clock_gen == 0);
721              end
                 MISSING_ELSE
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
792              if(percentage_jitter_local_decimal_cap == 0) begin 
                 <font color = "red">-1-</font>  
793                whole_number = 1;
794                percentage_jitter_local_decimal_cap = 99; 
795              end  
796              else if(percentage_jitter_local_decimal_cap < 0) begin 
                      <font color = "red">-2-</font>  
           <font color = "red">      ==></font>
           <font color = "red">      ==></font>
797                percentage_jitter_local_decimal_cap = 100 + percentage_jitter_local_decimal_cap;
           <font color = "red">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
803              if(random_jitter_mode) begin
                 <font color = "red">-1-</font>  
804                while(1) begin
           <font color = "red">        ==></font>
805                  // The usecase of random jitter is to introduce jitter in the clock between 0% to percentage_jitter% in the clock randomly which may be positive or negative.
806                  // Eg: if the user sets 2 as percentage_jitter, the output clock will introduce jitter in the range of 0% to 1.99% randomly as positive or neagative.
807                  // Randomize the jitter in the current clock as positive or negative
808                  positive_jitter_mode = $urandom();
809                  // If percentage_jitter is set as 1 then the percenatge variation is from 0 - 0.99%. Bypass randomize.
810                  // Else the integral part is randomized between 0-'n-1' when percentage_jitter is n. 
811                  // The final jitter introduced will be 0% to <n-1>.99%
812                  // Assumption here is (also mentioned in SVDOC): In this mode when the user sets tha max cap jitter it has to be an integer.
813                  // Copy the percentage_jitter real number in an integer type for randomization.
814                  percentage_jitter_local_int = percentage_jitter;
815                  if(whole_number || (!whole_number && resolved_to_plus_one)) begin
816                    percentage_jitter_local_int = percentage_jitter_local_int - 1;
817                  end 
818                  if(percentage_jitter_local_int > 0) begin
819                    percentage_jitter_local_int = $urandom_range(0,percentage_jitter_local_int);
820                  end
821                  else begin
822                    percentage_jitter_local_int = 0;
823                  end
824                  // Randomize the trailing decimal percentage.
825                  percentage_jitter_local_decimal = $urandom_range(0,percentage_jitter_local_decimal_cap);
826                  // Construct the percenatge randomized as "jitter = int + (dec/100)".
827                  // Eg: If interger randomized is '1' and decimal is 67 the final jitter becomes 1.67.
828                  percentage_jitter_local = percentage_jitter_local_decimal;
829                  percentage_jitter_local = (percentage_jitter_local/100);
830                  percentage_jitter_local = percentage_jitter_local_int + percentage_jitter_local;
831                  // Generate jitter
832                  generate_jitter_clock(enable_clock_jitter,positive_jitter_mode,percentage_jitter_local);
833                  // After every cycle check if the jitter mode is disabled to 'break'
834                  if(kill_jitter_clock_gen) break;
835                end
836              end
837              else begin
838                while(1) begin
           <font color = "red">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
897            if(!enable_clock_jitter && !enable_ssc && !is_passive && !tx_user_clock_enable) begin
               <font color = "red">-1-</font>  
898              if(clock_divider_tx) vip_tx_clk <= !vip_tx_clk;
                 <font color = "red">-2-</font>  
           <font color = "red">      ==></font>
                 MISSING_ELSE
           <font color = "red">      ==></font>
899              clock_divider_tx <= !(clock_divider_tx);
900            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
902            if(ssrxp === 1'bz || ssrxp === 1'bx) begin
               <font color = "red">-1-</font>  
903              data_flopped_0 <= data_flopped_0;
           <font color = "red">      ==></font>
904            end
905            else begin
906              data_flopped_0 <= ssrxp;
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
915            if(is_passive) begin
               <font color = "red">-1-</font>  
916              if(sstxp === 1'bz || sstxm === 1'bx) begin
                 <font color = "red">-2-</font>  
917                data_flopped_0_tx <= data_flopped_0_tx;
           <font color = "red">        ==></font>
918              end
919              else begin
920                data_flopped_0_tx <= sstxp;
           <font color = "red">        ==></font>
921              end
922              data_flopped_1_tx <= data_flopped_0_tx;
923              data_flopped_2_tx <= data_flopped_1_tx;
924              data_flopped_0_to_sample_tx <= {sstxm,sstxp};
925              data_flopped_1_to_sample_tx <= data_flopped_0_to_sample_tx;
926              data_flopped_2_to_sample_tx <= data_flopped_1_to_sample_tx;
927              data_flopped_to_sample_tx <= data_flopped_2_to_sample_tx[0];
928              data_flopped_to_sample_n_tx <= data_flopped_2_to_sample_tx[1];
929            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
949            if(is_passive) begin
               <font color = "red">-1-</font>  
950              feedback_toggle_tx <= !(feedback_toggle_tx) & edge_detect_active_low_tx;
           <font color = "red">      ==></font>
951              vip_tx_clk <= (feedback_toggle_tx ^ vip_tx_clk) & edge_detect_active_low_tx;
952            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
962            if(!(t1 > t0)) begin
               <font color = "red">-1-</font>  
963              $display("ERROR: Timescale is not 1fs, UI checks not possible.");
           <font color = "red">      ==></font>
964            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
972            ss_data = (is_passive)? sstxp: ssrxp;
                                     <font color = "red">-1-</font>  
                                     <font color = "red">==></font>  
                                     <font color = "red">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
982                    if(!mode_ssp) begin
                       <font color = "red">-1-</font>  
983                      #200ps;
           <font color = "red">              ==></font>
984                      count_max = count_max + 200.06;
985                      count_min = count_min + 199.94;
986                    end else begin
987                      #100ps;
           <font color = "red">              ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1002             if(!(timestamp_gap > count_min && timestamp_gap < count_max)) begin
                 <font color = "red">-1-</font>  
1003               -> event_error_UI;
           <font color = "red">        ==></font>
1004             end
                 MISSING_ELSE
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1006             if(!mode_ssp) begin
                 <font color = "red">-1-</font>  
1007               count_max = 200.06;
           <font color = "red">        ==></font>
1008               count_min = 199.94;
1009             end else begin
1010               count_max = 100.03;
           <font color = "red">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
</div>
<div name='inst_tag_25392'>
<a name="inst_tag_25392_Line"></a>
<b>Line Coverage for Instance : <a href="mod311.html#inst_tag_25392" >config_ss_tb.config_ss_env_intf.host_usb_if.usb_ss_serial_if</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s1"><td class="lf">TOTAL</td><td></td><td>217</td><td>39</td><td>17.97</td></tr>
<tr class="s2"><td class="lf">INITIAL</td><td>349</td><td>4</td><td>1</td><td>25.00</td></tr>
<tr class="s0"><td class="lf">ROUTINE</td><td>356</td><td>19</td><td>0</td><td>0.00</td></tr>
<tr class="s5"><td class="lf">ALWAYS</td><td>393</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="s10"><td class="lf">INITIAL</td><td>543</td><td>7</td><td>7</td><td>100.00</td></tr>
<tr class="s6"><td class="lf">ALWAYS</td><td>554</td><td>5</td><td>3</td><td>60.00</td></tr>
<tr class="s10"><td class="lf">INITIAL</td><td>569</td><td>1</td><td>1</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">INITIAL</td><td>578</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s0"><td class="lf">ALWAYS</td><td>664</td><td>12</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">ALWAYS</td><td>708</td><td>2</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">ALWAYS</td><td>715</td><td>5</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">ROUTINE</td><td>732</td><td>24</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">INITIAL</td><td>783</td><td>45</td><td>2</td><td>4.44</td></tr>
<tr class="s10"><td class="lf">INITIAL</td><td>868</td><td>19</td><td>19</td><td>100.00</td></tr>
<tr class="s0"><td class="lf">ALWAYS</td><td>897</td><td>30</td><td>0</td><td>0.00</td></tr>
<tr class="s1"><td class="lf">INITIAL</td><td>958</td><td>8</td><td>1</td><td>12.50</td></tr>
<tr class="s0"><td class="lf">ALWAYS</td><td>971</td><td>3</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">INITIAL</td><td>976</td><td>28</td><td>1</td><td>3.57</td></tr>
</table>
<pre class="code"><br clear=all>
348                         // Wait for all values to be loaded for the calculation
349        <font color = "red">1/2     ==>      wait(initialized == 1);</font>
350        <font color = "red">0/1     ==>      clock_gen_enable = 1;</font>
351        <font color = "red">0/1     ==>      initialize_ssc_parameters;</font>
352                       end
353                     
354                       task initialize_ssc_parameters;
355                         // Load the value of clock period
356        <font color = "red">0/1     ==>      clock_period_ps_resolved = clock_period_ps;</font>
357                         // Set the ssc direction as 1 to start
358        <font color = "red">0/1     ==>      ssc_direction = 1;</font>
359                         // Convert ppm to fraction
360        <font color = "red">0/1     ==>      if(ssc_down_spread_mode) begin</font>
361        <font color = "red">0/1     ==>        max_ssc_ppm_shift = (ssc_deviation_ppm/real'(1000000));</font>
362                         end else begin 
363        <font color = "red">0/1     ==>        max_ssc_ppm_shift = ((ssc_deviation_ppm+ssc_deviation_pos_ppm)/real'(1000000));</font>
364        <font color = "red">0/1     ==>        ssc_ppm_shift_neg = ((ssc_deviation_ppm)/real'(1000000));</font>
365        <font color = "red">0/1     ==>        ssc_ppm_shift_pos = ((ssc_deviation_pos_ppm)/real'(1000000));</font>
366                         end  
367                         // Scale KHz value to Hz
368        <font color = "red">0/1     ==>      ssc_spread_frequency_scaled = ssc_spread_frequency*1000;</font>
369                         // Calculate time period and scale by 10^6 to the us domain.
370        <font color = "red">0/1     ==>      ssc_spread_time_period = (1/ssc_spread_frequency_scaled);</font>
371        <font color = "red">0/1     ==>      ssc_spread_time_period = ssc_spread_time_period * (1000000);</font>
372                         // Scale the clock timeperiod from ps to us
373        <font color = "red">0/1     ==>      clock_period_ps_scaled = (clock_period_ps/1000000);</font>
374                         // Divide the period for ssc with the period for clock to find the number to ticks to reach max ppm and back.
375        <font color = "red">0/1     ==>      ssc_num_steps = (ssc_spread_time_period/clock_period_ps_scaled);</font>
376                         // For downspread the frequency has to reach max ppm and back. So to reach max halving the value
377        <font color = "red">0/1     ==>      ssc_num_steps = ssc_num_steps/2;</font>
378                         // For each step the clock period will change by the (max shift to reach in fraction), divided by the number of ticks to reach in (calculated above), multiply the clock period
379        <font color = "red">0/1     ==>      ssc_ppm_step =  (max_ssc_ppm_shift/real'(ssc_num_steps))*clock_period_ps;</font>
380                         // The max clock period that can be generated is the clock period + the max ppm shift
381                         // For down spread the min is the actual clock period
382        <font color = "red">0/1     ==>      if(ssc_down_spread_mode) begin</font>
383        <font color = "red">0/1     ==>        clock_period_ssc_max_ps = clock_period_ps + (clock_period_ps*max_ssc_ppm_shift);</font>
384        <font color = "red">0/1     ==>        clock_period_ssc_min_ps = clock_period_ps;</font>
385                         end else begin
386        <font color = "red">0/1     ==>        clock_period_ssc_max_ps = clock_period_ps + (clock_period_ps*ssc_ppm_shift_neg);</font>
387        <font color = "red">0/1     ==>        clock_period_ssc_min_ps = clock_period_ps - (clock_period_ps*ssc_ppm_shift_pos);</font>
388                         end
389                       endtask
390                     
391                       // If the port were to fallback aor change clock rate the ssc calucations need to be made again
392                       always@(ess_operating_rate or clock_period_ps) begin
393        <font color = "red">1/2     ==>      if(initialized) initialize_ssc_parameters;</font>
                        MISSING_ELSE
394                       end
395                     
396                     //-----------------------------------------------------------------------
397                     /**
398                      * Clocking block that defines VIP USB PHYSICAL's SS Serial Tx Link
399                      * Interface signal synchronization and directionality, for the
400                      * SS wires.
401                      */
402                     clocking usb_ss_serial_phy_tx_cb @(posedge vip_tx_clk);
403                     `ifdef SVT_USB_IF_NO_PARAMS
404                       default input #(`SVT_USB_SS_SERIAL_IF_SETUP_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(`SVT_USB_SS_SERIAL_IF_HOLD_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
405                     `else
406                       default input #(setup_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(hold_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
407                     `endif
408                       output sstxp;
409                       output sstxm;
410                     endclocking
411                     
412                     //-----------------------------------------------------------------------
413                     /**
414                      * Clocking block that defines VIP USB PHYSICAL's SS Serial Tx Link
415                      * Interface signal for monitor.
416                      */
417                     clocking usb_ss_serial_phy_tx_monitor_cb @(posedge vip_tx_clk);
418                     `ifdef SVT_USB_IF_NO_PARAMS
419                       default input #(`SVT_USB_SS_SERIAL_IF_SETUP_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(`SVT_USB_SS_SERIAL_IF_HOLD_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
420                     `else
421                       default input #(setup_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(hold_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
422                     `endif
423                       input sstxp;
424                       input sstxm;
425                     `ifndef SVT_USB_JITTER_CORRECTION_DISABLE  
426                       input data_flopped_to_sample_tx;
427                       input data_flopped_to_sample_n_tx;
428                     `endif  
429                     endclocking
430                     
431                     
432                     //-----------------------------------------------------------------------
433                     /**
434                      * Clocking block that defines VIP USB PHYSICAL's SS Serial Rx Link
435                      * Interface signal synchronization and directionality, for the
436                      * SS wires.
437                      */
438                     clocking usb_ss_serial_phy_rx_cb @(posedge vip_rx_clk);
439                     `ifdef SVT_USB_IF_NO_PARAMS
440                       default input #(`SVT_USB_SS_SERIAL_IF_SETUP_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(`SVT_USB_SS_SERIAL_IF_HOLD_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
441                     `else
442                       default input #(setup_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(hold_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
443                     `endif
444                       input ssrxp;
445                       input ssrxm;
446                     `ifndef SVT_USB_JITTER_CORRECTION_DISABLE  
447                       input data_flopped_to_sample;
448                       input data_flopped_to_sample_n;
449                     `endif  
450                     endclocking
451                     
452                     //-----------------------------------------------------------------------
453                     // USB SS Serial Modports
454                     //-----------------------------------------------------------------------
455                     
456                     //-----------------------------------------------------------------------
457                     /** Modport used to connect VIP USB PHYSICAL to USB SS SERIAL interface signals from the link direction. */
458                     modport svt_usb_ss_serial_phy_port(
459                       clocking usb_ss_serial_phy_tx_cb, clocking usb_ss_serial_phy_rx_cb, output vbus, input dut_ss_termination, output vip_ss_termination);
460                     
461                     //-----------------------------------------------------------------------
462                     /** Modport used to connect VIP USB PHYSICAL to USB SS SERIAL interface signals from the PHY direction. */
463                     modport svt_usb_ss_serial_cable_port(
464                       input sstxp,
465                       input sstxm,
466                       output ssrxp,
467                       output ssrxm,
468                       input vbus,
469                       output dut_ss_termination,
470                       input vip_ss_termination
471                       );
472                     
473                     //-----------------------------------------------------------------------
474                     /** Modport used to monitor VIP USB SS serial interface signals. */
475                     modport svt_usb_ss_serial_phy_monitor_port(
476                       clocking usb_ss_serial_phy_tx_monitor_cb, clocking usb_ss_serial_phy_rx_cb, input vbus, input dut_ss_termination, input vip_ss_termination);
477                     
478                     task wait_for_hold_drive();
479                       #(hold_time_scaled + 1);
480                     endtask
481                     
482                     `ifndef __SVDOC__
483                     //-----------------------------------------------------------------------
484                     // USB SS Serial Interface Control Assigns
485                     //-----------------------------------------------------------------------
486                     
487                       //---------------------------------------------------------------------
488                       // Additions for receiver detection
489                       //---------------------------------------------------------------------
490                       assign vip_ss_termination = vip_ss_termination_reg;
491                     
492                       //-------------------------------------------------------------------------
493                       // Additions for VBUS
494                       //-------------------------------------------------------------------------
495                       assign vbus = vbus_reg;
496                     
497                       //-----------------------------------------------------------------------
498                       // Additions for Clock_Recovery
499                       //-----------------------------------------------------------------------
500                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE
501                       // Detect differential receiver value
502                       assign data_in = ((ssrxp === 1'bz) || (ssrxp === 1'bx)) ? 1'b0 :
503                                        ((ssrxm === 1'bz) || (ssrxm === 1'bx)) ? 1'b0 : ssrxp;
504                     
505                       // Use the unfiltered transmit clock whenever the DPLL is not ready
506                       assign pll_disable = (rec_clk_valid !== 1'b1) ? 1'b1 : 1'b0;
507                     `endif
508                       // Filter the output clock as per mode (normal vs. clock recovery)
509                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE  
510                       assign vip_rx_clk = (clock_recovery_enable === 1'b1) ? rec_clk_out : (ess_operating_rate === 2'b01) ? ssclk : clock5GHz;
511                     `endif
512                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE
513                       // Output clock for the VIP is from the recovered clock
514                       assign rec_clk_out = (pll_rec_clk | pll_sync_clk);
515                     
516                       // When the VIP is transmitting, or the PLL is disabled, disable the recovery of clock
517                       assign phase_rst = ((pll_disable) |
518                                           ((((data_phase_2 | !data_phase_3) &amp; (!data_phase_2 | data_phase_3)) | (int_se0))));
519                       // SE0 detection
520                       assign se0_detect = ((ssrxp === 1'bz) || (ssrxp === 1'bx)) ? 1'b0 :
521                                           ((ssrxm === 1'bz) || (ssrxm === 1'bx)) ? 1'b0 : (!(ssrxp | ssrxm));
522                     
523                       // Phase detection
524                       assign phase_det = (feed_back ^ pll_clk);
525                     
526                       // Clock extraction
527                       assign extract_clk = (phase_det &amp; phase_rst &amp; ~extract_clk_reg);
528                     
529                       // Clock valid condition
530                       assign rec_clk_valid = (pll_reset === 1'b0) ? 1'b1 : 1'b0;
531                     `endif
532                     
533                     //-----------------------------------------------------------------------
534                     // USB SS Serial Interface Control Processes
535                     //-----------------------------------------------------------------------
536                     
537                       //-----------------------------------------------------------------------
538                       // Additions for receiver detection
539                       //-----------------------------------------------------------------------
540                     
541                       // Initialize all registers
542                       initial begin
543        1/1              ess_operating_rate =  2'b01;
544        1/1              dut_ss_termination_reg = 1;  // Assume DUT SS RX termination in place
545        1/1              vip_ss_termination_reg = 0;  // Assume VIP SS RX termination not in place
546        2/2              #1;
547        1/1              if (vbus !== 1'b1) begin
548        1/1                dut_ss_termination_reg = 0;  // Assume no DUT SS RX termination when VBUS is absent
549                         end
                   <font color = "red">==>  MISSING_ELSE</font>
550                       end
551                     
552                       // Sample changes on the DUT termination signal
553                       always @ (dut_ss_termination or vbus) begin
554        1/1              if (dut_ss_termination === 1'b0) begin
555        <font color = "red">0/1     ==>        dut_ss_termination_reg = 0;  // No DUT SS RX termination - signaled by TB</font>
556        1/1              end else if (vbus !== 1'b1) begin
557        1/1                dut_ss_termination_reg = 0;  // No DUT SS RX termination - VBUS is absent
558                         end else begin
559        <font color = "red">0/1     ==>        dut_ss_termination_reg = 1;  // DUT SS RX termination in place</font>
560                         end
561                       end
562                     
563                       //-----------------------------------------------------------------------
564                       // Additions for VBUS
565                       //-----------------------------------------------------------------------
566                     
567                       // Initialize VBUS drive off
568                       initial begin
569        1/1              vbus_reg = 1'bz;  // Assume VIP not started
570                       end
571                     
572                       //-----------------------------------------------------------------------
573                       // Additions for Clock_Recovery
574                       //-----------------------------------------------------------------------
575                     
576                       // Initialize all registers
577                       initial begin
578        1/1              clk4x           = 1'b0;
579        1/1              vip_tx_clk      = 1'b0;
580                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE    
581                         clk2x           = 1'b0;
582                         data_phase_0    = 1'b0;
583                         data_phase_1    = 1'b0;
584                         data_phase_2    = 1'b0;
585                         data_phase_3    = 1'b0;
586                         dpdm_phase_0    = 1'b0;
587                         int_se0         = 1'b0;
588                         extract_clk_reg = 1'b0;
589                         feed_back       = 1'b0;
590                         pll_clk         = 1'b0;
591                         pll_rec_clk     = 1'b0;
592                         pll_reset       = 1'b1;
593                         pll_sync_clk    = 1'b0;
594                         saw_sync_clk    = 1'b0;
595                     `endif    
596        1/1              clock5GHz       = 1'b0;
597                       end
598                     
599                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE
600                       // Reset the DPLL at startup
601                       initial begin
602                         @(posedge ssclk);
603                         @(posedge ssclk);
604                         pll_reset = 0;
605                       end
606                     
607                       // Code to generate the initial recovered clock edge during the first SYNC bit
608                       always @ (posedge clk4x) begin
609                         pll_sync_clk &lt;= 1'b0;
610                       end
611                       // Generation of control signals
612                       always @ (posedge clk4x) begin
613                         data_phase_0 &lt;= data_in;
614                         data_phase_1 &lt;= data_phase_0;
615                         data_phase_2 &lt;= data_phase_1;
616                         data_phase_3 &lt;= data_phase_2;
617                         dpdm_phase_0 &lt;= se0_detect;
618                         int_se0 &lt;= dpdm_phase_0 &amp;&amp; (int_se0 || se0_detect);
619                         extract_clk_reg &lt;= phase_det &amp; phase_rst;
620                       end
621                     
622                       // Generation of feedback
623                       always @ (posedge clk4x) begin
624                         if (pll_reset) begin
625                           feed_back &lt;= 1'b1;
626                         end
627                         else begin
628                           feed_back &lt;= (!feed_back) &amp; phase_rst;
629                         end
630                       end
631                     
632                       // Generation of clock
633                       always @ (posedge clk4x) begin
634                         if (pll_reset) begin
635                           pll_clk &lt;= 1'b1;
636                         end
637                         else begin
638                           pll_clk &lt;= phase_det &amp; phase_rst;
639                         end
640                       end
641                     
642                       // Generation of recovered clock
643                       always @ (posedge clk4x) begin
644                         if (pll_reset) begin
645                           pll_rec_clk &lt;= 1'b0;
646                         end
647                         else begin
648                           pll_rec_clk &lt;= extract_clk;
649                         end
650                       end
651                     `endif  
652                     
653                       //-------------------------------------------------------------------------
654                       // Generates the TX clock based on the clock_recovery_enable setting
655                       //-------------------------------------------------------------------------
656                       bit clock_divider;
657                     
658                       // When clock recovery is disabled, the VIP TX clock is the input clock
659                       //--------------------------------------------------------------------------
660                       always @ (ssclk) begin 
661                         // Only if operating rate is 2'b00 generate the clock5GHz clock.
662                         // If VIP starts in SS mode the clock ss is anyway expected to be 5G.
663                         // If VIP starts in SSP mode the clock 5G is only required for fallback which reflected in ess_operating_rate as 2'b00
664        <font color = "red">0/1     ==>      if(ess_operating_rate == 2'b00) begin</font>
665        <font color = "red">0/2     ==>        if(clock_divider) clock5GHz = !(clock5GHz);</font>
                   <font color = "red">==>  MISSING_ELSE</font>
666        <font color = "red">0/1     ==>        clock_divider = !(clock_divider);</font>
667                         end
                   <font color = "red">==>  MISSING_ELSE</font>
668                         // if clock recovery is enabled, the vip tx clock is generated by dividing the 4x clock by a factor of 4.
669        <font color = "red">0/1     ==>      if (clock_recovery_enable === 1'b1) begin </font>
670                           // When ess_operating rate is 1 then pass the ssclk which is generating in top 
671                           // Else pass clock5GHz(3.0) local generated clock 
672        <font color = "red">0/1     ==>        clk4x = (ess_operating_rate === 2'b01) ? ssclk : clock5GHz; </font>
673                         end
674                         else begin 
675                           // When ess_operating rate is 1 then pass the ssclk which is generating in top 
676                           // Else pass clock5GHz(3.0) local generated clock 
677        <font color = "red">0/1     ==>        if(!enable_clock_jitter &amp;&amp; !enable_ssc) begin </font>
678                     `ifndef SVT_USB_JITTER_CORRECTION_DISABLE
679        <font color = "red">0/1     ==>          if(ess_operating_rate === 2'b01) begin</font>
680        <font color = "red">0/1     ==>            vip_tx_clk = ssclk; </font>
681        <font color = "red">0/1     ==>            vip_rx_clk = ssclk; </font>
682                             end
683                             else begin
684        <font color = "red">0/1     ==>            vip_tx_clk = clock5GHz; </font>
685        <font color = "red">0/1     ==>            vip_rx_clk = clock5GHz; </font>
686                             end
687                     `else
688                             vip_tx_clk = (ess_operating_rate === 2'b01) ? ssclk : clock5GHz; 
689                     `endif        
690                           end  
                   <font color = "red">==>  MISSING_ELSE</font>
691                         end 
692                       end 
693                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE  
694                       always @ (posedge clk4x) begin
695                         clk2x = ~clk2x;
696                       end
697                     
698                       // When clock recovery is enabled, the VIP TX clock is 1/4 the input clock
699                       //--------------------------------------------------------------------------
700                       always @ (posedge clk2x) begin
701                         if (clock_recovery_enable === 1'b1 &amp;&amp; !enable_clock_jitter &amp;&amp; !enable_ssc) begin
702                           vip_tx_clk = ~vip_tx_clk;
703                         end
704                       end
705                     `endif
706                     
707                       always @(ssclk_tx) begin
708        <font color = "red">0/1     ==>      if(tx_user_clock_enable === 1)</font>
709        <font color = "red">0/1     ==>        vip_tx_clk = ssclk_tx;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
710                       end
711                       
712                       // Always block which is triggered if there is a change in value of enable_clock_jitter
713                       // If the enable_clock_jitter is '0' then trigger the end of the loop which generates tx clock
714                       always@(enable_clock_jitter) begin
715        <font color = "red">0/1     ==>      if(enable_clock_jitter) begin</font>
716                         end
717                         else begin
718        <font color = "red">0/1     ==>        if(kill_jitter_clock_gen == 0) begin</font>
719        <font color = "red">0/1     ==>          kill_jitter_clock_gen = 1;</font>
720        <font color = "red">0/2     ==>          wait(kill_jitter_clock_gen == 0);</font>
721                           end
                   <font color = "red">==>  MISSING_ELSE</font>
722                         end
723                       end
724                     
725                       // This task is responsible for generating a clock cycle. The task is blocking and takes inputs:
726                       // enable_jitter : If this is '1' then a jittered clock is genearted. If '0' then a clock with no jitter is generated.
727                       // positive_jitter_mode : This when 1 generates a positive jitter i.e. extends the clock by percentage_jitter. Else shortens it by percentage_jitter
728                       // percentage_jitter :  This is a real number input which holds the percentage value of the jitter to introduce.
729                       real half_time_resolved;
730                       task generate_jitter_clock(bit enable_jitter,bit positive_jitter_mode, real percentage_jitter);
731                         // Block excersised for SSC mode.
732        <font color = "red">0/1     ==>      if(enable_ssc &amp;&amp; !disable_ssc_clk_ppm_shift) begin</font>
733                           // If the SSC direction is positive 
734                           //  if the clock period has not reached the max ssc, keep incrementing the clock period.
735                           //  else if the max SSC is reached start to decrement the period and flip the direction
736        <font color = "red">0/1     ==>        if(ssc_direction) begin</font>
737        <font color = "red">0/1     ==>          if(clock_period_ssc_max_ps - clock_period_ps_resolved &gt;= ssc_ppm_step) begin</font>
738        <font color = "red">0/1     ==>            clock_period_ps_resolved = clock_period_ps_resolved + ssc_ppm_step;</font>
739                             end else begin
740        <font color = "red">0/1     ==>            clock_period_ps_resolved = clock_period_ps_resolved - ssc_ppm_step;</font>
741        <font color = "red">0/1     ==>            ssc_direction = 0;</font>
742                             end
743                           // If the SSC direction is negative 
744                           //  if the clock period has not reached the min ssc, keep decrementing the clock period.
745                           //  else if the min SSC is reached start to increment the period and flip the direction
746                           end else begin
747        <font color = "red">0/1     ==>          if(clock_period_ps_resolved - clock_period_ssc_min_ps &gt;= ssc_ppm_step) begin</font>
748        <font color = "red">0/1     ==>            clock_period_ps_resolved = clock_period_ps_resolved - ssc_ppm_step;</font>
749                             end else begin
750        <font color = "red">0/1     ==>            clock_period_ps_resolved = clock_period_ps_resolved + ssc_ppm_step;</font>
751        <font color = "red">0/1     ==>            ssc_direction = 1;</font>
752                             end
753                           end
754                         end else begin
755        <font color = "red">0/1     ==>        clock_period_ps_resolved = clock_period_ps;</font>
756                         end
757                         // Add jitter if enabled
758        <font color = "red">0/1     ==>      if(enable_jitter) begin</font>
759        <font color = "red">0/1     ==>        clk_scale_jitter = (real'(percentage_jitter * clock_period_ps_resolved)/100);</font>
760        <font color = "red">0/2     ==>        if(positive_jitter_mode) half_clk_time = (real'(clock_period_ps_resolved + clk_scale_jitter)/2);</font>
761        <font color = "red">0/1     ==>        else half_clk_time = (real'(clock_period_ps_resolved - clk_scale_jitter)/2);</font>
762                         end
763        <font color = "red">0/1     ==>      else half_clk_time = (real'(clock_period_ps_resolved)/2);</font>
764        <font color = "red">0/1     ==>      half_time_resolved = (half_clk_time*1ps);</font>
765        <font color = "red">0/2     ==>      #(half_time_resolved);</font>
766        <font color = "red">0/1     ==>      vip_tx_clk = !(vip_tx_clk);</font>
767        <font color = "red">0/2     ==>      #(half_time_resolved);</font>
768        <font color = "red">0/1     ==>      vip_tx_clk = !(vip_tx_clk);</font>
769                     `ifdef SVT_USB_JITTER_DEBUG_TRACE    
770                         $fdisplay(file_handle,$sformatf(&quot;%32t: enable_jitter: %b enable_ssc: %b clk_scale_jitter: %f half_clk_time: %f clock_period_ps_resolved: %f clock_period_ssc_max_ps: %f clock_period_ssc_min_ps: %f&quot;,$time,enable_jitter,enable_ssc,clk_scale_jitter,half_clk_time,clock_period_ps_resolved,clock_period_ssc_max_ps,clock_period_ssc_min_ps));
771                     `endif    
772                       endtask
773                     
774                       // Initial block
775                       // This loop generates the jittered tx clock when enable_clock_jitter is '1'
776                       int decimal_delta;
777                       int decimal_no_delta;
778                       bit whole_number,resolved_to_plus_one;
779                       initial begin
780                     `ifdef SVT_USB_JITTER_DEBUG_TRACE  
781                         file_handle = $fopen($sformatf(&quot;%m.txt&quot;),&quot;w&quot;);
782                     `endif    
783        1/1              while(1) begin
784        <font color = "red">1/2     ==>        wait(initialized == 1);</font>
785        <font color = "red">0/2     ==>        wait(enable_clock_jitter == 1 || enable_ssc == 1);</font>
786        <font color = "red">0/1     ==>        vip_tx_clk = 1;</font>
787        <font color = "red">0/1     ==>        kill_jitter_clock_gen = 0;</font>
788        <font color = "red">0/1     ==>        decimal_delta = (percentage_jitter*100);</font>
789        <font color = "red">0/1     ==>        decimal_no_delta = percentage_jitter;</font>
790        <font color = "red">0/1     ==>        decimal_no_delta = (decimal_no_delta*100);</font>
791        <font color = "red">0/1     ==>        percentage_jitter_local_decimal_cap = (decimal_delta - decimal_no_delta);</font>
792        <font color = "red">0/1     ==>        if(percentage_jitter_local_decimal_cap == 0) begin </font>
793        <font color = "red">0/1     ==>          whole_number = 1;</font>
794        <font color = "red">0/1     ==>          percentage_jitter_local_decimal_cap = 99; </font>
795                           end  
796        <font color = "red">0/1     ==>        else if(percentage_jitter_local_decimal_cap &lt; 0) begin </font>
797        <font color = "red">0/1     ==>          percentage_jitter_local_decimal_cap = 100 + percentage_jitter_local_decimal_cap;</font>
798        <font color = "red">0/1     ==>          resolved_to_plus_one = 1;</font>
799                           end 
800                           else begin
801                           end
802                           // If block to generate random jitter
803        <font color = "red">0/1     ==>        if(random_jitter_mode) begin</font>
804        <font color = "red">0/1     ==>          while(1) begin</font>
805                               // The usecase of random jitter is to introduce jitter in the clock between 0% to percentage_jitter% in the clock randomly which may be positive or negative.
806                               // Eg: if the user sets 2 as percentage_jitter, the output clock will introduce jitter in the range of 0% to 1.99% randomly as positive or neagative.
807                               // Randomize the jitter in the current clock as positive or negative
808        <font color = "red">0/1     ==>            positive_jitter_mode = $urandom();</font>
809                               // If percentage_jitter is set as 1 then the percenatge variation is from 0 - 0.99%. Bypass randomize.
810                               // Else the integral part is randomized between 0-'n-1' when percentage_jitter is n. 
811                               // The final jitter introduced will be 0% to &lt;n-1&gt;.99%
812                               // Assumption here is (also mentioned in SVDOC): In this mode when the user sets tha max cap jitter it has to be an integer.
813                               // Copy the percentage_jitter real number in an integer type for randomization.
814        <font color = "red">0/1     ==>            percentage_jitter_local_int = percentage_jitter;</font>
815        <font color = "red">0/1     ==>            if(whole_number || (!whole_number &amp;&amp; resolved_to_plus_one)) begin</font>
816        <font color = "red">0/1     ==>              percentage_jitter_local_int = percentage_jitter_local_int - 1;</font>
817                               end 
                   <font color = "red">==>  MISSING_ELSE</font>
818        <font color = "red">0/1     ==>            if(percentage_jitter_local_int &gt; 0) begin</font>
819        <font color = "red">0/1     ==>              percentage_jitter_local_int = $urandom_range(0,percentage_jitter_local_int);</font>
820                               end
821                               else begin
822        <font color = "red">0/1     ==>              percentage_jitter_local_int = 0;</font>
823                               end
824                               // Randomize the trailing decimal percentage.
825        <font color = "red">0/1     ==>            percentage_jitter_local_decimal = $urandom_range(0,percentage_jitter_local_decimal_cap);</font>
826                               // Construct the percenatge randomized as &quot;jitter = int + (dec/100)&quot;.
827                               // Eg: If interger randomized is '1' and decimal is 67 the final jitter becomes 1.67.
828        <font color = "red">0/1     ==>            percentage_jitter_local = percentage_jitter_local_decimal;</font>
829        <font color = "red">0/1     ==>            percentage_jitter_local = (percentage_jitter_local/100);</font>
830        <font color = "red">0/1     ==>            percentage_jitter_local = percentage_jitter_local_int + percentage_jitter_local;</font>
831                               // Generate jitter
832        <font color = "red">0/1     ==>            generate_jitter_clock(enable_clock_jitter,positive_jitter_mode,percentage_jitter_local);</font>
833                               // After every cycle check if the jitter mode is disabled to 'break'
834        <font color = "red">0/2     ==>            if(kill_jitter_clock_gen) break;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
835                             end
836                           end
837                           else begin
838        <font color = "red">0/1     ==>          while(1) begin</font>
839        <font color = "red">0/1     ==>            if(enable_clock_jitter) begin</font>
840                                 // Loop to generate constant jitter.
841                                 // In this mode all the values come from the user.
842                                 // Type of jitter (positive/ negative)
843                                 // Percentage jitter. (This can be in decimals unlike in Random mode)
844                                 // The cycle of generation i.e. number of pulse with jitter followed by the number without jitter
845        <font color = "red">0/1     ==>              repeat(number_of_clocks_with_jitter) begin</font>
846        <font color = "red">0/1     ==>                generate_jitter_clock(1,positive_jitter_mode,percentage_jitter);</font>
847                                 end
                   <font color = "red">==>  REPEAT_FALSE</font>
848        <font color = "red">0/2     ==>              if(kill_jitter_clock_gen) break;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
849        <font color = "red">0/1     ==>              repeat(number_of_clocks_without_jitter) begin</font>
850        <font color = "red">0/1     ==>                generate_jitter_clock(0,positive_jitter_mode,percentage_jitter);</font>
851                                 end
852                               end else begin
853        <font color = "red">0/1     ==>              generate_jitter_clock(0,positive_jitter_mode,percentage_jitter);</font>
854                               end
855                               // After every cycle check if the jitter mode is disabled to 'break'
856        <font color = "red">0/2     ==>            if(kill_jitter_clock_gen) break;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
857                             end
858                           end
859        <font color = "red">0/1     ==>        kill_jitter_clock_gen = 0;</font>
860                         end  
861                       end
862                     `ifndef SVT_USB_JITTER_CORRECTION_DISABLE  
863                       //---------------------------------------------------------------
864                       // CDR
865                       //---------------------------------------------------------------
866                     
867                       initial begin
868        1/1              feedback_toggle = 1;
869        1/1              feedback_toggle_tx = 1;
870        1/1              vip_rx_clk = 1;
871        1/1              data_flopped_0 = 0;
872        1/1              data_flopped_1 = 0;
873        1/1              data_flopped_2 = 0;
874        1/1              data_flopped_0_to_sample = 0;
875        1/1              data_flopped_1_to_sample = 0;
876        1/1              data_flopped_2_to_sample = 0;
877        1/1              data_flopped_to_sample = 0;
878        1/1              data_flopped_to_sample_n = 0;
879        1/1              data_flopped_0_tx = 0;
880        1/1              data_flopped_1_tx = 0;
881        1/1              data_flopped_2_tx = 0;
882        1/1              data_flopped_0_to_sample_tx = 0;
883        1/1              data_flopped_1_to_sample_tx = 0;
884        1/1              data_flopped_2_to_sample_tx = 0;
885        1/1              data_flopped_to_sample_tx = 0;
886        1/1              data_flopped_to_sample_n_tx = 0;
887                       end
888                     
889                       //--------------------------------------------------------------------------------------------------
890                       // This signal gives an active low signal every time there is a change in the incoming signal level
891                       //--------------------------------------------------------------------------------------------------
892                       assign edge_detect_active_low = ((!(data_flopped_0) &amp; !(data_flopped_1)) | (data_flopped_0 &amp; data_flopped_1 ));
893                       assign edge_detect_active_low_tx = ((!(data_flopped_0_tx) &amp; !(data_flopped_1_tx)) | (data_flopped_0_tx &amp; data_flopped_1_tx ));
894                       bit clock_divider_tx;
895                     
896                       always@(posedge (clk4x &amp; clock_gen_enable)) begin
897        <font color = "red">0/1     ==>      if(!enable_clock_jitter &amp;&amp; !enable_ssc &amp;&amp; !is_passive &amp;&amp; !tx_user_clock_enable) begin</font>
898        <font color = "red">0/2     ==>        if(clock_divider_tx) vip_tx_clk &lt;= !vip_tx_clk;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
899        <font color = "red">0/1     ==>        clock_divider_tx &lt;= !(clock_divider_tx);</font>
900                         end
                   <font color = "red">==>  MISSING_ELSE</font>
901                         // Ignore any data which is z or x.
902        <font color = "red">0/1     ==>      if(ssrxp === 1'bz || ssrxp === 1'bx) begin</font>
903        <font color = "red">0/1     ==>        data_flopped_0 &lt;= data_flopped_0;</font>
904                         end
905                         else begin
906        <font color = "red">0/1     ==>        data_flopped_0 &lt;= ssrxp;</font>
907                         end
908        <font color = "red">0/1     ==>      data_flopped_1 &lt;= data_flopped_0;</font>
909        <font color = "red">0/1     ==>      data_flopped_2 &lt;= data_flopped_1;</font>
910        <font color = "red">0/1     ==>      data_flopped_0_to_sample &lt;= {ssrxm,ssrxp};</font>
911        <font color = "red">0/1     ==>      data_flopped_1_to_sample &lt;= data_flopped_0_to_sample;</font>
912        <font color = "red">0/1     ==>      data_flopped_2_to_sample &lt;= data_flopped_1_to_sample;</font>
913        <font color = "red">0/1     ==>      data_flopped_to_sample &lt;= data_flopped_2_to_sample[0];</font>
914        <font color = "red">0/1     ==>      data_flopped_to_sample_n &lt;= data_flopped_2_to_sample[1];</font>
915        <font color = "red">0/1     ==>      if(is_passive) begin</font>
916        <font color = "red">0/1     ==>        if(sstxp === 1'bz || sstxm === 1'bx) begin</font>
917        <font color = "red">0/1     ==>          data_flopped_0_tx &lt;= data_flopped_0_tx;</font>
918                           end
919                           else begin
920        <font color = "red">0/1     ==>          data_flopped_0_tx &lt;= sstxp;</font>
921                           end
922        <font color = "red">0/1     ==>        data_flopped_1_tx &lt;= data_flopped_0_tx;</font>
923        <font color = "red">0/1     ==>        data_flopped_2_tx &lt;= data_flopped_1_tx;</font>
924        <font color = "red">0/1     ==>        data_flopped_0_to_sample_tx &lt;= {sstxm,sstxp};</font>
925        <font color = "red">0/1     ==>        data_flopped_1_to_sample_tx &lt;= data_flopped_0_to_sample_tx;</font>
926        <font color = "red">0/1     ==>        data_flopped_2_to_sample_tx &lt;= data_flopped_1_to_sample_tx;</font>
927        <font color = "red">0/1     ==>        data_flopped_to_sample_tx &lt;= data_flopped_2_to_sample_tx[0];</font>
928        <font color = "red">0/1     ==>        data_flopped_to_sample_n_tx &lt;= data_flopped_2_to_sample_tx[1];</font>
929                         end
                   <font color = "red">==>  MISSING_ELSE</font>
930                         // Feedback toggle keeps on toggling for every posedge of reference clock.
931                         // The edge detect signal going low forces the feedback_toggle to go low. This can be considered a phase reset.
932                         // If the incoming serial data is without jitters the moment edge_detect_active_low is low feedback_toggle is also low.
933                         // So the next clock of ref_clk will give a high pulse as feedback_toggle changes and edge_detect_active_low goes high.
934                         // The next pulse goes low as the feedback toggle changes with no change in edge_detect_active_low.
935                         // Since ref_clk is 4 times the clock rate there will be 4 samples of 1 bit.
936                         // The sync is such that the feedback_toggle on no jitter will go 1 0 1 0.
937                         //
938                         // feedback_toggle_next feedback_toggle edge_detect_active_low
939                         //         1                   0                  1
940                         //         0                   1                  1
941                         //         1                   0                  1
942                         //         0                   1                  0
943                         //
944                         // This cycle repeats itself 
945                         // If there is jitter on the line then the edge_detect_active_low will either pulled in by a clock or pulled out by a clock.
946                         // This shifts the pll_clk pulse by 3 clock to the right or to the left
947        <font color = "red">0/1     ==>      feedback_toggle &lt;= !(feedback_toggle) &amp; edge_detect_active_low;</font>
948        <font color = "red">0/1     ==>      vip_rx_clk &lt;= (feedback_toggle ^ vip_rx_clk) &amp; edge_detect_active_low;</font>
949        <font color = "red">0/1     ==>      if(is_passive) begin</font>
950        <font color = "red">0/1     ==>        feedback_toggle_tx &lt;= !(feedback_toggle_tx) &amp; edge_detect_active_low_tx;</font>
951        <font color = "red">0/1     ==>        vip_tx_clk &lt;= (feedback_toggle_tx ^ vip_tx_clk) &amp; edge_detect_active_low_tx;</font>
952                         end
                   <font color = "red">==>  MISSING_ELSE</font>
953                       end
954                     `endif
955                       bit ss_data_prev;
956                       initial begin
957                         realtime t0,t1;
958        <font color = "red">1/2     ==>      wait(clock_ui_jitter_check == 1);</font>
959        <font color = "red">0/1     ==>      t0 = $realtime();</font>
960        <font color = "red">0/2     ==>      #1fs;</font>
961        <font color = "red">0/1     ==>      t1 = $realtime();</font>
962        <font color = "red">0/1     ==>      if(!(t1 &gt; t0)) begin</font>
963        <font color = "red">0/1     ==>        $display(&quot;ERROR: Timescale is not 1fs, UI checks not possible.&quot;);</font>
964                         end
                   <font color = "red">==>  MISSING_ELSE</font>
965                       end
966                     
967                       real count_max, count_min,timestamp,timestamp_gap,timestamp_current;
968                       event event_error_UI;
969                       reg ss_data;
970                       always@(*) begin
971        <font color = "red">0/2     ==>      wait(clock_ui_jitter_check == 1);</font>
972        <font color = "red">0/1     ==>      ss_data = (is_passive)? sstxp: ssrxp;</font>
973                       end
974                     
975                       initial begin
976        <font color = "red">1/2     ==>      wait(clock_ui_jitter_check == 1);</font>
977        <font color = "red">0/1     ==>      while(1) begin</font>
978                           fork begin
979                             fork
980                             begin
981        <font color = "red">0/1     ==>            while(1) begin</font>
982        <font color = "red">0/1     ==>              if(!mode_ssp) begin</font>
983        <font color = "red">0/2     ==>                #200ps;</font>
984        <font color = "red">0/1     ==>                count_max = count_max + 200.06;</font>
985        <font color = "red">0/1     ==>                count_min = count_min + 199.94;</font>
986                                 end else begin
987        <font color = "red">0/2     ==>                #100ps;</font>
988        <font color = "red">0/1     ==>                count_max = count_max + 100.03;</font>
989        <font color = "red">0/1     ==>                count_min = count_min +  99.97;</font>
990                                 end
991                               end
992                             end
993                             begin
994        <font color = "red">0/2     ==>            @(ss_data);</font>
995                             end
996                             join_any
997        <font color = "red">0/1     ==>          disable fork;</font>
998                           end join_any
999        <font color = "red">0/1     ==>        timestamp = timestamp_current;</font>
1000       <font color = "red">0/1     ==>        timestamp_current = $realtime;</font>
1001       <font color = "red">0/1     ==>        timestamp_gap = (timestamp_current - timestamp);</font>
1002       <font color = "red">0/1     ==>        if(!(timestamp_gap &gt; count_min &amp;&amp; timestamp_gap &lt; count_max)) begin</font>
1003       <font color = "red">0/1     ==>          -&gt; event_error_UI;</font>
1004                          end
                   <font color = "red">==>  MISSING_ELSE</font>
1005       <font color = "red">0/2     ==>        #1ps;</font>
1006       <font color = "red">0/1     ==>        if(!mode_ssp) begin</font>
1007       <font color = "red">0/1     ==>          count_max = 200.06;</font>
1008       <font color = "red">0/1     ==>          count_min = 199.94;</font>
1009                          end else begin
1010       <font color = "red">0/1     ==>          count_max = 100.03;</font>
1011       <font color = "red">0/1     ==>          count_min =  99.97;</font>
</pre>
<hr>
<a name="inst_tag_25392_Cond"></a>
<b>Cond Coverage for Instance : <a href="mod311.html#inst_tag_25392" >config_ss_tb.config_ss_env_intf.host_usb_if.usb_ss_serial_if</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s0"><td class="lf">Conditions</td><td>19</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">Logical</td><td>19</td><td>0</td><td>0.00</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       677
 EXPRESSION (((!enable_clock_jitter)) &amp;&amp; ((!enable_ssc)))
             ------------1-----------    -------2-------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       785
 EXPRESSION ((enable_clock_jitter == 1'b1) || (enable_ssc == 1'b1))
             --------------1--------------    ----------2---------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       815
 EXPRESSION (whole_number || (((!whole_number)) &amp;&amp; resolved_to_plus_one))
             ------1-----    ---------------------2---------------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       815
 SUB-EXPRESSION (((!whole_number)) &amp;&amp; resolved_to_plus_one)
                 --------1--------    ----------2---------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       897
 EXPRESSION (((!enable_clock_jitter)) &amp;&amp; ((!enable_ssc)) &amp;&amp; ((!is_passive)) &amp;&amp; ((!tx_user_clock_enable)))
             ------------1-----------    -------2-------    -------3-------    ------------4------------
</pre>
<table class="noborder">
<col span="4" width="40">
<tr><th>-1-</th><th>-2-</th><th>-3-</th><th>-4-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       972
 EXPRESSION (is_passive ? sstxp : ssrxp)
             -----1----
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<hr>
<a name="inst_tag_25392_Branch"></a>
<b>Branch Coverage for Instance : <a href="mod311.html#inst_tag_25392" >config_ss_tb.config_ss_env_intf.host_usb_if.usb_ss_serial_if</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s0">
<td>Branches</td>
<td></td>
<td class="rt">44</td>
<td class="rt">3</td>
<td class="rt">6.82  </td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">393</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">547</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s3">
<td>IF</td>
<td class="rt">554</td>
<td class="rt">3</td>
<td class="rt">1</td>
<td class="rt">33.33 </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">664</td>
<td class="rt">3</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">669</td>
<td class="rt">4</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">708</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">715</td>
<td class="rt">3</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">792</td>
<td class="rt">3</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">803</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">897</td>
<td class="rt">3</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">902</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">915</td>
<td class="rt">3</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">949</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">962</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>TERNARY</td>
<td class="rt">972</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">982</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">1002</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">1006</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
393            if(initialized) initialize_ssc_parameters;
               <font color = "red">-1-</font>  
           <font color = "red">    ==></font>
               MISSING_ELSE
           <font color = "green">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
547            if (vbus !== 1'b1) begin
               <font color = "red">-1-</font>  
548              dut_ss_termination_reg = 0;  // Assume no DUT SS RX termination when VBUS is absent
           <font color = "green">      ==></font>
549            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
554            if (dut_ss_termination === 1'b0) begin
               <font color = "red">-1-</font>  
555              dut_ss_termination_reg = 0;  // No DUT SS RX termination - signaled by TB
           <font color = "red">      ==></font>
556            end else if (vbus !== 1'b1) begin
                        <font color = "red">-2-</font>  
557              dut_ss_termination_reg = 0;  // No DUT SS RX termination - VBUS is absent
           <font color = "green">      ==></font>
558            end else begin
559              dut_ss_termination_reg = 1;  // DUT SS RX termination in place
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
664            if(ess_operating_rate == 2'b00) begin
               <font color = "red">-1-</font>  
665              if(clock_divider) clock5GHz = !(clock5GHz);
                 <font color = "red">-2-</font>  
           <font color = "red">      ==></font>
                 MISSING_ELSE
           <font color = "red">      ==></font>
666              clock_divider = !(clock_divider);
667            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
669            if (clock_recovery_enable === 1'b1) begin 
               <font color = "red">-1-</font>  
670              // When ess_operating rate is 1 then pass the ssclk which is generating in top 
671              // Else pass clock5GHz(3.0) local generated clock 
672              clk4x = (ess_operating_rate === 2'b01) ? ssclk : clock5GHz; 
           <font color = "red">      ==></font>
673            end
674            else begin 
675              // When ess_operating rate is 1 then pass the ssclk which is generating in top 
676              // Else pass clock5GHz(3.0) local generated clock 
677              if(!enable_clock_jitter && !enable_ssc) begin 
                 <font color = "red">-2-</font>  
678        `ifndef SVT_USB_JITTER_CORRECTION_DISABLE
679                if(ess_operating_rate === 2'b01) begin
                   <font color = "red">-3-</font>  
680                  vip_tx_clk = ssclk; 
           <font color = "red">          ==></font>
681                  vip_rx_clk = ssclk; 
682                end
683                else begin
684                  vip_tx_clk = clock5GHz; 
           <font color = "red">          ==></font>
685                  vip_rx_clk = clock5GHz; 
686                end
687        `else
688                vip_tx_clk = (ess_operating_rate === 2'b01) ? ssclk : clock5GHz; 
689        `endif        
690              end  
                 MISSING_ELSE
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
708            if(tx_user_clock_enable === 1)
               <font color = "red">-1-</font>  
709              vip_tx_clk = ssclk_tx;
           <font color = "red">      ==></font>
                 MISSING_ELSE
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
715            if(enable_clock_jitter) begin
               <font color = "red">-1-</font>  
           <font color = "red">    ==></font>
716            end
717            else begin
718              if(kill_jitter_clock_gen == 0) begin
                 <font color = "red">-2-</font>  
719                kill_jitter_clock_gen = 1;
           <font color = "red">        ==></font>
720                wait(kill_jitter_clock_gen == 0);
721              end
                 MISSING_ELSE
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
792              if(percentage_jitter_local_decimal_cap == 0) begin 
                 <font color = "red">-1-</font>  
793                whole_number = 1;
794                percentage_jitter_local_decimal_cap = 99; 
795              end  
796              else if(percentage_jitter_local_decimal_cap < 0) begin 
                      <font color = "red">-2-</font>  
           <font color = "red">      ==></font>
           <font color = "red">      ==></font>
797                percentage_jitter_local_decimal_cap = 100 + percentage_jitter_local_decimal_cap;
           <font color = "red">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
803              if(random_jitter_mode) begin
                 <font color = "red">-1-</font>  
804                while(1) begin
           <font color = "red">        ==></font>
805                  // The usecase of random jitter is to introduce jitter in the clock between 0% to percentage_jitter% in the clock randomly which may be positive or negative.
806                  // Eg: if the user sets 2 as percentage_jitter, the output clock will introduce jitter in the range of 0% to 1.99% randomly as positive or neagative.
807                  // Randomize the jitter in the current clock as positive or negative
808                  positive_jitter_mode = $urandom();
809                  // If percentage_jitter is set as 1 then the percenatge variation is from 0 - 0.99%. Bypass randomize.
810                  // Else the integral part is randomized between 0-'n-1' when percentage_jitter is n. 
811                  // The final jitter introduced will be 0% to <n-1>.99%
812                  // Assumption here is (also mentioned in SVDOC): In this mode when the user sets tha max cap jitter it has to be an integer.
813                  // Copy the percentage_jitter real number in an integer type for randomization.
814                  percentage_jitter_local_int = percentage_jitter;
815                  if(whole_number || (!whole_number && resolved_to_plus_one)) begin
816                    percentage_jitter_local_int = percentage_jitter_local_int - 1;
817                  end 
818                  if(percentage_jitter_local_int > 0) begin
819                    percentage_jitter_local_int = $urandom_range(0,percentage_jitter_local_int);
820                  end
821                  else begin
822                    percentage_jitter_local_int = 0;
823                  end
824                  // Randomize the trailing decimal percentage.
825                  percentage_jitter_local_decimal = $urandom_range(0,percentage_jitter_local_decimal_cap);
826                  // Construct the percenatge randomized as "jitter = int + (dec/100)".
827                  // Eg: If interger randomized is '1' and decimal is 67 the final jitter becomes 1.67.
828                  percentage_jitter_local = percentage_jitter_local_decimal;
829                  percentage_jitter_local = (percentage_jitter_local/100);
830                  percentage_jitter_local = percentage_jitter_local_int + percentage_jitter_local;
831                  // Generate jitter
832                  generate_jitter_clock(enable_clock_jitter,positive_jitter_mode,percentage_jitter_local);
833                  // After every cycle check if the jitter mode is disabled to 'break'
834                  if(kill_jitter_clock_gen) break;
835                end
836              end
837              else begin
838                while(1) begin
           <font color = "red">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
897            if(!enable_clock_jitter && !enable_ssc && !is_passive && !tx_user_clock_enable) begin
               <font color = "red">-1-</font>  
898              if(clock_divider_tx) vip_tx_clk <= !vip_tx_clk;
                 <font color = "red">-2-</font>  
           <font color = "red">      ==></font>
                 MISSING_ELSE
           <font color = "red">      ==></font>
899              clock_divider_tx <= !(clock_divider_tx);
900            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
902            if(ssrxp === 1'bz || ssrxp === 1'bx) begin
               <font color = "red">-1-</font>  
903              data_flopped_0 <= data_flopped_0;
           <font color = "red">      ==></font>
904            end
905            else begin
906              data_flopped_0 <= ssrxp;
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
915            if(is_passive) begin
               <font color = "red">-1-</font>  
916              if(sstxp === 1'bz || sstxm === 1'bx) begin
                 <font color = "red">-2-</font>  
917                data_flopped_0_tx <= data_flopped_0_tx;
           <font color = "red">        ==></font>
918              end
919              else begin
920                data_flopped_0_tx <= sstxp;
           <font color = "red">        ==></font>
921              end
922              data_flopped_1_tx <= data_flopped_0_tx;
923              data_flopped_2_tx <= data_flopped_1_tx;
924              data_flopped_0_to_sample_tx <= {sstxm,sstxp};
925              data_flopped_1_to_sample_tx <= data_flopped_0_to_sample_tx;
926              data_flopped_2_to_sample_tx <= data_flopped_1_to_sample_tx;
927              data_flopped_to_sample_tx <= data_flopped_2_to_sample_tx[0];
928              data_flopped_to_sample_n_tx <= data_flopped_2_to_sample_tx[1];
929            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
949            if(is_passive) begin
               <font color = "red">-1-</font>  
950              feedback_toggle_tx <= !(feedback_toggle_tx) & edge_detect_active_low_tx;
           <font color = "red">      ==></font>
951              vip_tx_clk <= (feedback_toggle_tx ^ vip_tx_clk) & edge_detect_active_low_tx;
952            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
962            if(!(t1 > t0)) begin
               <font color = "red">-1-</font>  
963              $display("ERROR: Timescale is not 1fs, UI checks not possible.");
           <font color = "red">      ==></font>
964            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
972            ss_data = (is_passive)? sstxp: ssrxp;
                                     <font color = "red">-1-</font>  
                                     <font color = "red">==></font>  
                                     <font color = "red">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
982                    if(!mode_ssp) begin
                       <font color = "red">-1-</font>  
983                      #200ps;
           <font color = "red">              ==></font>
984                      count_max = count_max + 200.06;
985                      count_min = count_min + 199.94;
986                    end else begin
987                      #100ps;
           <font color = "red">              ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1002             if(!(timestamp_gap > count_min && timestamp_gap < count_max)) begin
                 <font color = "red">-1-</font>  
1003               -> event_error_UI;
           <font color = "red">        ==></font>
1004             end
                 MISSING_ELSE
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1006             if(!mode_ssp) begin
                 <font color = "red">-1-</font>  
1007               count_max = 200.06;
           <font color = "red">        ==></font>
1008               count_min = 199.94;
1009             end else begin
1010               count_max = 100.03;
           <font color = "red">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
</div>
<div name='inst_tag_25393'>
<a name="inst_tag_25393_Line"></a>
<b>Line Coverage for Instance : <a href="mod311.html#inst_tag_25393" >config_ss_tb.config_ss_env_intf.host_usb_if.usb_ss_serial_lane1_if</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s1"><td class="lf">TOTAL</td><td></td><td>217</td><td>39</td><td>17.97</td></tr>
<tr class="s2"><td class="lf">INITIAL</td><td>349</td><td>4</td><td>1</td><td>25.00</td></tr>
<tr class="s0"><td class="lf">ROUTINE</td><td>356</td><td>19</td><td>0</td><td>0.00</td></tr>
<tr class="s5"><td class="lf">ALWAYS</td><td>393</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="s10"><td class="lf">INITIAL</td><td>543</td><td>7</td><td>7</td><td>100.00</td></tr>
<tr class="s6"><td class="lf">ALWAYS</td><td>554</td><td>5</td><td>3</td><td>60.00</td></tr>
<tr class="s10"><td class="lf">INITIAL</td><td>569</td><td>1</td><td>1</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">INITIAL</td><td>578</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s0"><td class="lf">ALWAYS</td><td>664</td><td>12</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">ALWAYS</td><td>708</td><td>2</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">ALWAYS</td><td>715</td><td>5</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">ROUTINE</td><td>732</td><td>24</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">INITIAL</td><td>783</td><td>45</td><td>2</td><td>4.44</td></tr>
<tr class="s10"><td class="lf">INITIAL</td><td>868</td><td>19</td><td>19</td><td>100.00</td></tr>
<tr class="s0"><td class="lf">ALWAYS</td><td>897</td><td>30</td><td>0</td><td>0.00</td></tr>
<tr class="s1"><td class="lf">INITIAL</td><td>958</td><td>8</td><td>1</td><td>12.50</td></tr>
<tr class="s0"><td class="lf">ALWAYS</td><td>971</td><td>3</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">INITIAL</td><td>976</td><td>28</td><td>1</td><td>3.57</td></tr>
</table>
<pre class="code"><br clear=all>
348                         // Wait for all values to be loaded for the calculation
349        <font color = "red">1/2     ==>      wait(initialized == 1);</font>
350        <font color = "red">0/1     ==>      clock_gen_enable = 1;</font>
351        <font color = "red">0/1     ==>      initialize_ssc_parameters;</font>
352                       end
353                     
354                       task initialize_ssc_parameters;
355                         // Load the value of clock period
356        <font color = "red">0/1     ==>      clock_period_ps_resolved = clock_period_ps;</font>
357                         // Set the ssc direction as 1 to start
358        <font color = "red">0/1     ==>      ssc_direction = 1;</font>
359                         // Convert ppm to fraction
360        <font color = "red">0/1     ==>      if(ssc_down_spread_mode) begin</font>
361        <font color = "red">0/1     ==>        max_ssc_ppm_shift = (ssc_deviation_ppm/real'(1000000));</font>
362                         end else begin 
363        <font color = "red">0/1     ==>        max_ssc_ppm_shift = ((ssc_deviation_ppm+ssc_deviation_pos_ppm)/real'(1000000));</font>
364        <font color = "red">0/1     ==>        ssc_ppm_shift_neg = ((ssc_deviation_ppm)/real'(1000000));</font>
365        <font color = "red">0/1     ==>        ssc_ppm_shift_pos = ((ssc_deviation_pos_ppm)/real'(1000000));</font>
366                         end  
367                         // Scale KHz value to Hz
368        <font color = "red">0/1     ==>      ssc_spread_frequency_scaled = ssc_spread_frequency*1000;</font>
369                         // Calculate time period and scale by 10^6 to the us domain.
370        <font color = "red">0/1     ==>      ssc_spread_time_period = (1/ssc_spread_frequency_scaled);</font>
371        <font color = "red">0/1     ==>      ssc_spread_time_period = ssc_spread_time_period * (1000000);</font>
372                         // Scale the clock timeperiod from ps to us
373        <font color = "red">0/1     ==>      clock_period_ps_scaled = (clock_period_ps/1000000);</font>
374                         // Divide the period for ssc with the period for clock to find the number to ticks to reach max ppm and back.
375        <font color = "red">0/1     ==>      ssc_num_steps = (ssc_spread_time_period/clock_period_ps_scaled);</font>
376                         // For downspread the frequency has to reach max ppm and back. So to reach max halving the value
377        <font color = "red">0/1     ==>      ssc_num_steps = ssc_num_steps/2;</font>
378                         // For each step the clock period will change by the (max shift to reach in fraction), divided by the number of ticks to reach in (calculated above), multiply the clock period
379        <font color = "red">0/1     ==>      ssc_ppm_step =  (max_ssc_ppm_shift/real'(ssc_num_steps))*clock_period_ps;</font>
380                         // The max clock period that can be generated is the clock period + the max ppm shift
381                         // For down spread the min is the actual clock period
382        <font color = "red">0/1     ==>      if(ssc_down_spread_mode) begin</font>
383        <font color = "red">0/1     ==>        clock_period_ssc_max_ps = clock_period_ps + (clock_period_ps*max_ssc_ppm_shift);</font>
384        <font color = "red">0/1     ==>        clock_period_ssc_min_ps = clock_period_ps;</font>
385                         end else begin
386        <font color = "red">0/1     ==>        clock_period_ssc_max_ps = clock_period_ps + (clock_period_ps*ssc_ppm_shift_neg);</font>
387        <font color = "red">0/1     ==>        clock_period_ssc_min_ps = clock_period_ps - (clock_period_ps*ssc_ppm_shift_pos);</font>
388                         end
389                       endtask
390                     
391                       // If the port were to fallback aor change clock rate the ssc calucations need to be made again
392                       always@(ess_operating_rate or clock_period_ps) begin
393        <font color = "red">1/2     ==>      if(initialized) initialize_ssc_parameters;</font>
                        MISSING_ELSE
394                       end
395                     
396                     //-----------------------------------------------------------------------
397                     /**
398                      * Clocking block that defines VIP USB PHYSICAL's SS Serial Tx Link
399                      * Interface signal synchronization and directionality, for the
400                      * SS wires.
401                      */
402                     clocking usb_ss_serial_phy_tx_cb @(posedge vip_tx_clk);
403                     `ifdef SVT_USB_IF_NO_PARAMS
404                       default input #(`SVT_USB_SS_SERIAL_IF_SETUP_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(`SVT_USB_SS_SERIAL_IF_HOLD_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
405                     `else
406                       default input #(setup_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(hold_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
407                     `endif
408                       output sstxp;
409                       output sstxm;
410                     endclocking
411                     
412                     //-----------------------------------------------------------------------
413                     /**
414                      * Clocking block that defines VIP USB PHYSICAL's SS Serial Tx Link
415                      * Interface signal for monitor.
416                      */
417                     clocking usb_ss_serial_phy_tx_monitor_cb @(posedge vip_tx_clk);
418                     `ifdef SVT_USB_IF_NO_PARAMS
419                       default input #(`SVT_USB_SS_SERIAL_IF_SETUP_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(`SVT_USB_SS_SERIAL_IF_HOLD_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
420                     `else
421                       default input #(setup_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(hold_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
422                     `endif
423                       input sstxp;
424                       input sstxm;
425                     `ifndef SVT_USB_JITTER_CORRECTION_DISABLE  
426                       input data_flopped_to_sample_tx;
427                       input data_flopped_to_sample_n_tx;
428                     `endif  
429                     endclocking
430                     
431                     
432                     //-----------------------------------------------------------------------
433                     /**
434                      * Clocking block that defines VIP USB PHYSICAL's SS Serial Rx Link
435                      * Interface signal synchronization and directionality, for the
436                      * SS wires.
437                      */
438                     clocking usb_ss_serial_phy_rx_cb @(posedge vip_rx_clk);
439                     `ifdef SVT_USB_IF_NO_PARAMS
440                       default input #(`SVT_USB_SS_SERIAL_IF_SETUP_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(`SVT_USB_SS_SERIAL_IF_HOLD_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
441                     `else
442                       default input #(setup_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(hold_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
443                     `endif
444                       input ssrxp;
445                       input ssrxm;
446                     `ifndef SVT_USB_JITTER_CORRECTION_DISABLE  
447                       input data_flopped_to_sample;
448                       input data_flopped_to_sample_n;
449                     `endif  
450                     endclocking
451                     
452                     //-----------------------------------------------------------------------
453                     // USB SS Serial Modports
454                     //-----------------------------------------------------------------------
455                     
456                     //-----------------------------------------------------------------------
457                     /** Modport used to connect VIP USB PHYSICAL to USB SS SERIAL interface signals from the link direction. */
458                     modport svt_usb_ss_serial_phy_port(
459                       clocking usb_ss_serial_phy_tx_cb, clocking usb_ss_serial_phy_rx_cb, output vbus, input dut_ss_termination, output vip_ss_termination);
460                     
461                     //-----------------------------------------------------------------------
462                     /** Modport used to connect VIP USB PHYSICAL to USB SS SERIAL interface signals from the PHY direction. */
463                     modport svt_usb_ss_serial_cable_port(
464                       input sstxp,
465                       input sstxm,
466                       output ssrxp,
467                       output ssrxm,
468                       input vbus,
469                       output dut_ss_termination,
470                       input vip_ss_termination
471                       );
472                     
473                     //-----------------------------------------------------------------------
474                     /** Modport used to monitor VIP USB SS serial interface signals. */
475                     modport svt_usb_ss_serial_phy_monitor_port(
476                       clocking usb_ss_serial_phy_tx_monitor_cb, clocking usb_ss_serial_phy_rx_cb, input vbus, input dut_ss_termination, input vip_ss_termination);
477                     
478                     task wait_for_hold_drive();
479                       #(hold_time_scaled + 1);
480                     endtask
481                     
482                     `ifndef __SVDOC__
483                     //-----------------------------------------------------------------------
484                     // USB SS Serial Interface Control Assigns
485                     //-----------------------------------------------------------------------
486                     
487                       //---------------------------------------------------------------------
488                       // Additions for receiver detection
489                       //---------------------------------------------------------------------
490                       assign vip_ss_termination = vip_ss_termination_reg;
491                     
492                       //-------------------------------------------------------------------------
493                       // Additions for VBUS
494                       //-------------------------------------------------------------------------
495                       assign vbus = vbus_reg;
496                     
497                       //-----------------------------------------------------------------------
498                       // Additions for Clock_Recovery
499                       //-----------------------------------------------------------------------
500                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE
501                       // Detect differential receiver value
502                       assign data_in = ((ssrxp === 1'bz) || (ssrxp === 1'bx)) ? 1'b0 :
503                                        ((ssrxm === 1'bz) || (ssrxm === 1'bx)) ? 1'b0 : ssrxp;
504                     
505                       // Use the unfiltered transmit clock whenever the DPLL is not ready
506                       assign pll_disable = (rec_clk_valid !== 1'b1) ? 1'b1 : 1'b0;
507                     `endif
508                       // Filter the output clock as per mode (normal vs. clock recovery)
509                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE  
510                       assign vip_rx_clk = (clock_recovery_enable === 1'b1) ? rec_clk_out : (ess_operating_rate === 2'b01) ? ssclk : clock5GHz;
511                     `endif
512                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE
513                       // Output clock for the VIP is from the recovered clock
514                       assign rec_clk_out = (pll_rec_clk | pll_sync_clk);
515                     
516                       // When the VIP is transmitting, or the PLL is disabled, disable the recovery of clock
517                       assign phase_rst = ((pll_disable) |
518                                           ((((data_phase_2 | !data_phase_3) &amp; (!data_phase_2 | data_phase_3)) | (int_se0))));
519                       // SE0 detection
520                       assign se0_detect = ((ssrxp === 1'bz) || (ssrxp === 1'bx)) ? 1'b0 :
521                                           ((ssrxm === 1'bz) || (ssrxm === 1'bx)) ? 1'b0 : (!(ssrxp | ssrxm));
522                     
523                       // Phase detection
524                       assign phase_det = (feed_back ^ pll_clk);
525                     
526                       // Clock extraction
527                       assign extract_clk = (phase_det &amp; phase_rst &amp; ~extract_clk_reg);
528                     
529                       // Clock valid condition
530                       assign rec_clk_valid = (pll_reset === 1'b0) ? 1'b1 : 1'b0;
531                     `endif
532                     
533                     //-----------------------------------------------------------------------
534                     // USB SS Serial Interface Control Processes
535                     //-----------------------------------------------------------------------
536                     
537                       //-----------------------------------------------------------------------
538                       // Additions for receiver detection
539                       //-----------------------------------------------------------------------
540                     
541                       // Initialize all registers
542                       initial begin
543        1/1              ess_operating_rate =  2'b01;
544        1/1              dut_ss_termination_reg = 1;  // Assume DUT SS RX termination in place
545        1/1              vip_ss_termination_reg = 0;  // Assume VIP SS RX termination not in place
546        2/2              #1;
547        1/1              if (vbus !== 1'b1) begin
548        1/1                dut_ss_termination_reg = 0;  // Assume no DUT SS RX termination when VBUS is absent
549                         end
                   <font color = "red">==>  MISSING_ELSE</font>
550                       end
551                     
552                       // Sample changes on the DUT termination signal
553                       always @ (dut_ss_termination or vbus) begin
554        1/1              if (dut_ss_termination === 1'b0) begin
555        <font color = "red">0/1     ==>        dut_ss_termination_reg = 0;  // No DUT SS RX termination - signaled by TB</font>
556        1/1              end else if (vbus !== 1'b1) begin
557        1/1                dut_ss_termination_reg = 0;  // No DUT SS RX termination - VBUS is absent
558                         end else begin
559        <font color = "red">0/1     ==>        dut_ss_termination_reg = 1;  // DUT SS RX termination in place</font>
560                         end
561                       end
562                     
563                       //-----------------------------------------------------------------------
564                       // Additions for VBUS
565                       //-----------------------------------------------------------------------
566                     
567                       // Initialize VBUS drive off
568                       initial begin
569        1/1              vbus_reg = 1'bz;  // Assume VIP not started
570                       end
571                     
572                       //-----------------------------------------------------------------------
573                       // Additions for Clock_Recovery
574                       //-----------------------------------------------------------------------
575                     
576                       // Initialize all registers
577                       initial begin
578        1/1              clk4x           = 1'b0;
579        1/1              vip_tx_clk      = 1'b0;
580                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE    
581                         clk2x           = 1'b0;
582                         data_phase_0    = 1'b0;
583                         data_phase_1    = 1'b0;
584                         data_phase_2    = 1'b0;
585                         data_phase_3    = 1'b0;
586                         dpdm_phase_0    = 1'b0;
587                         int_se0         = 1'b0;
588                         extract_clk_reg = 1'b0;
589                         feed_back       = 1'b0;
590                         pll_clk         = 1'b0;
591                         pll_rec_clk     = 1'b0;
592                         pll_reset       = 1'b1;
593                         pll_sync_clk    = 1'b0;
594                         saw_sync_clk    = 1'b0;
595                     `endif    
596        1/1              clock5GHz       = 1'b0;
597                       end
598                     
599                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE
600                       // Reset the DPLL at startup
601                       initial begin
602                         @(posedge ssclk);
603                         @(posedge ssclk);
604                         pll_reset = 0;
605                       end
606                     
607                       // Code to generate the initial recovered clock edge during the first SYNC bit
608                       always @ (posedge clk4x) begin
609                         pll_sync_clk &lt;= 1'b0;
610                       end
611                       // Generation of control signals
612                       always @ (posedge clk4x) begin
613                         data_phase_0 &lt;= data_in;
614                         data_phase_1 &lt;= data_phase_0;
615                         data_phase_2 &lt;= data_phase_1;
616                         data_phase_3 &lt;= data_phase_2;
617                         dpdm_phase_0 &lt;= se0_detect;
618                         int_se0 &lt;= dpdm_phase_0 &amp;&amp; (int_se0 || se0_detect);
619                         extract_clk_reg &lt;= phase_det &amp; phase_rst;
620                       end
621                     
622                       // Generation of feedback
623                       always @ (posedge clk4x) begin
624                         if (pll_reset) begin
625                           feed_back &lt;= 1'b1;
626                         end
627                         else begin
628                           feed_back &lt;= (!feed_back) &amp; phase_rst;
629                         end
630                       end
631                     
632                       // Generation of clock
633                       always @ (posedge clk4x) begin
634                         if (pll_reset) begin
635                           pll_clk &lt;= 1'b1;
636                         end
637                         else begin
638                           pll_clk &lt;= phase_det &amp; phase_rst;
639                         end
640                       end
641                     
642                       // Generation of recovered clock
643                       always @ (posedge clk4x) begin
644                         if (pll_reset) begin
645                           pll_rec_clk &lt;= 1'b0;
646                         end
647                         else begin
648                           pll_rec_clk &lt;= extract_clk;
649                         end
650                       end
651                     `endif  
652                     
653                       //-------------------------------------------------------------------------
654                       // Generates the TX clock based on the clock_recovery_enable setting
655                       //-------------------------------------------------------------------------
656                       bit clock_divider;
657                     
658                       // When clock recovery is disabled, the VIP TX clock is the input clock
659                       //--------------------------------------------------------------------------
660                       always @ (ssclk) begin 
661                         // Only if operating rate is 2'b00 generate the clock5GHz clock.
662                         // If VIP starts in SS mode the clock ss is anyway expected to be 5G.
663                         // If VIP starts in SSP mode the clock 5G is only required for fallback which reflected in ess_operating_rate as 2'b00
664        <font color = "red">0/1     ==>      if(ess_operating_rate == 2'b00) begin</font>
665        <font color = "red">0/2     ==>        if(clock_divider) clock5GHz = !(clock5GHz);</font>
                   <font color = "red">==>  MISSING_ELSE</font>
666        <font color = "red">0/1     ==>        clock_divider = !(clock_divider);</font>
667                         end
                   <font color = "red">==>  MISSING_ELSE</font>
668                         // if clock recovery is enabled, the vip tx clock is generated by dividing the 4x clock by a factor of 4.
669        <font color = "red">0/1     ==>      if (clock_recovery_enable === 1'b1) begin </font>
670                           // When ess_operating rate is 1 then pass the ssclk which is generating in top 
671                           // Else pass clock5GHz(3.0) local generated clock 
672        <font color = "red">0/1     ==>        clk4x = (ess_operating_rate === 2'b01) ? ssclk : clock5GHz; </font>
673                         end
674                         else begin 
675                           // When ess_operating rate is 1 then pass the ssclk which is generating in top 
676                           // Else pass clock5GHz(3.0) local generated clock 
677        <font color = "red">0/1     ==>        if(!enable_clock_jitter &amp;&amp; !enable_ssc) begin </font>
678                     `ifndef SVT_USB_JITTER_CORRECTION_DISABLE
679        <font color = "red">0/1     ==>          if(ess_operating_rate === 2'b01) begin</font>
680        <font color = "red">0/1     ==>            vip_tx_clk = ssclk; </font>
681        <font color = "red">0/1     ==>            vip_rx_clk = ssclk; </font>
682                             end
683                             else begin
684        <font color = "red">0/1     ==>            vip_tx_clk = clock5GHz; </font>
685        <font color = "red">0/1     ==>            vip_rx_clk = clock5GHz; </font>
686                             end
687                     `else
688                             vip_tx_clk = (ess_operating_rate === 2'b01) ? ssclk : clock5GHz; 
689                     `endif        
690                           end  
                   <font color = "red">==>  MISSING_ELSE</font>
691                         end 
692                       end 
693                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE  
694                       always @ (posedge clk4x) begin
695                         clk2x = ~clk2x;
696                       end
697                     
698                       // When clock recovery is enabled, the VIP TX clock is 1/4 the input clock
699                       //--------------------------------------------------------------------------
700                       always @ (posedge clk2x) begin
701                         if (clock_recovery_enable === 1'b1 &amp;&amp; !enable_clock_jitter &amp;&amp; !enable_ssc) begin
702                           vip_tx_clk = ~vip_tx_clk;
703                         end
704                       end
705                     `endif
706                     
707                       always @(ssclk_tx) begin
708        <font color = "red">0/1     ==>      if(tx_user_clock_enable === 1)</font>
709        <font color = "red">0/1     ==>        vip_tx_clk = ssclk_tx;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
710                       end
711                       
712                       // Always block which is triggered if there is a change in value of enable_clock_jitter
713                       // If the enable_clock_jitter is '0' then trigger the end of the loop which generates tx clock
714                       always@(enable_clock_jitter) begin
715        <font color = "red">0/1     ==>      if(enable_clock_jitter) begin</font>
716                         end
717                         else begin
718        <font color = "red">0/1     ==>        if(kill_jitter_clock_gen == 0) begin</font>
719        <font color = "red">0/1     ==>          kill_jitter_clock_gen = 1;</font>
720        <font color = "red">0/2     ==>          wait(kill_jitter_clock_gen == 0);</font>
721                           end
                   <font color = "red">==>  MISSING_ELSE</font>
722                         end
723                       end
724                     
725                       // This task is responsible for generating a clock cycle. The task is blocking and takes inputs:
726                       // enable_jitter : If this is '1' then a jittered clock is genearted. If '0' then a clock with no jitter is generated.
727                       // positive_jitter_mode : This when 1 generates a positive jitter i.e. extends the clock by percentage_jitter. Else shortens it by percentage_jitter
728                       // percentage_jitter :  This is a real number input which holds the percentage value of the jitter to introduce.
729                       real half_time_resolved;
730                       task generate_jitter_clock(bit enable_jitter,bit positive_jitter_mode, real percentage_jitter);
731                         // Block excersised for SSC mode.
732        <font color = "red">0/1     ==>      if(enable_ssc &amp;&amp; !disable_ssc_clk_ppm_shift) begin</font>
733                           // If the SSC direction is positive 
734                           //  if the clock period has not reached the max ssc, keep incrementing the clock period.
735                           //  else if the max SSC is reached start to decrement the period and flip the direction
736        <font color = "red">0/1     ==>        if(ssc_direction) begin</font>
737        <font color = "red">0/1     ==>          if(clock_period_ssc_max_ps - clock_period_ps_resolved &gt;= ssc_ppm_step) begin</font>
738        <font color = "red">0/1     ==>            clock_period_ps_resolved = clock_period_ps_resolved + ssc_ppm_step;</font>
739                             end else begin
740        <font color = "red">0/1     ==>            clock_period_ps_resolved = clock_period_ps_resolved - ssc_ppm_step;</font>
741        <font color = "red">0/1     ==>            ssc_direction = 0;</font>
742                             end
743                           // If the SSC direction is negative 
744                           //  if the clock period has not reached the min ssc, keep decrementing the clock period.
745                           //  else if the min SSC is reached start to increment the period and flip the direction
746                           end else begin
747        <font color = "red">0/1     ==>          if(clock_period_ps_resolved - clock_period_ssc_min_ps &gt;= ssc_ppm_step) begin</font>
748        <font color = "red">0/1     ==>            clock_period_ps_resolved = clock_period_ps_resolved - ssc_ppm_step;</font>
749                             end else begin
750        <font color = "red">0/1     ==>            clock_period_ps_resolved = clock_period_ps_resolved + ssc_ppm_step;</font>
751        <font color = "red">0/1     ==>            ssc_direction = 1;</font>
752                             end
753                           end
754                         end else begin
755        <font color = "red">0/1     ==>        clock_period_ps_resolved = clock_period_ps;</font>
756                         end
757                         // Add jitter if enabled
758        <font color = "red">0/1     ==>      if(enable_jitter) begin</font>
759        <font color = "red">0/1     ==>        clk_scale_jitter = (real'(percentage_jitter * clock_period_ps_resolved)/100);</font>
760        <font color = "red">0/2     ==>        if(positive_jitter_mode) half_clk_time = (real'(clock_period_ps_resolved + clk_scale_jitter)/2);</font>
761        <font color = "red">0/1     ==>        else half_clk_time = (real'(clock_period_ps_resolved - clk_scale_jitter)/2);</font>
762                         end
763        <font color = "red">0/1     ==>      else half_clk_time = (real'(clock_period_ps_resolved)/2);</font>
764        <font color = "red">0/1     ==>      half_time_resolved = (half_clk_time*1ps);</font>
765        <font color = "red">0/2     ==>      #(half_time_resolved);</font>
766        <font color = "red">0/1     ==>      vip_tx_clk = !(vip_tx_clk);</font>
767        <font color = "red">0/2     ==>      #(half_time_resolved);</font>
768        <font color = "red">0/1     ==>      vip_tx_clk = !(vip_tx_clk);</font>
769                     `ifdef SVT_USB_JITTER_DEBUG_TRACE    
770                         $fdisplay(file_handle,$sformatf(&quot;%32t: enable_jitter: %b enable_ssc: %b clk_scale_jitter: %f half_clk_time: %f clock_period_ps_resolved: %f clock_period_ssc_max_ps: %f clock_period_ssc_min_ps: %f&quot;,$time,enable_jitter,enable_ssc,clk_scale_jitter,half_clk_time,clock_period_ps_resolved,clock_period_ssc_max_ps,clock_period_ssc_min_ps));
771                     `endif    
772                       endtask
773                     
774                       // Initial block
775                       // This loop generates the jittered tx clock when enable_clock_jitter is '1'
776                       int decimal_delta;
777                       int decimal_no_delta;
778                       bit whole_number,resolved_to_plus_one;
779                       initial begin
780                     `ifdef SVT_USB_JITTER_DEBUG_TRACE  
781                         file_handle = $fopen($sformatf(&quot;%m.txt&quot;),&quot;w&quot;);
782                     `endif    
783        1/1              while(1) begin
784        <font color = "red">1/2     ==>        wait(initialized == 1);</font>
785        <font color = "red">0/2     ==>        wait(enable_clock_jitter == 1 || enable_ssc == 1);</font>
786        <font color = "red">0/1     ==>        vip_tx_clk = 1;</font>
787        <font color = "red">0/1     ==>        kill_jitter_clock_gen = 0;</font>
788        <font color = "red">0/1     ==>        decimal_delta = (percentage_jitter*100);</font>
789        <font color = "red">0/1     ==>        decimal_no_delta = percentage_jitter;</font>
790        <font color = "red">0/1     ==>        decimal_no_delta = (decimal_no_delta*100);</font>
791        <font color = "red">0/1     ==>        percentage_jitter_local_decimal_cap = (decimal_delta - decimal_no_delta);</font>
792        <font color = "red">0/1     ==>        if(percentage_jitter_local_decimal_cap == 0) begin </font>
793        <font color = "red">0/1     ==>          whole_number = 1;</font>
794        <font color = "red">0/1     ==>          percentage_jitter_local_decimal_cap = 99; </font>
795                           end  
796        <font color = "red">0/1     ==>        else if(percentage_jitter_local_decimal_cap &lt; 0) begin </font>
797        <font color = "red">0/1     ==>          percentage_jitter_local_decimal_cap = 100 + percentage_jitter_local_decimal_cap;</font>
798        <font color = "red">0/1     ==>          resolved_to_plus_one = 1;</font>
799                           end 
800                           else begin
801                           end
802                           // If block to generate random jitter
803        <font color = "red">0/1     ==>        if(random_jitter_mode) begin</font>
804        <font color = "red">0/1     ==>          while(1) begin</font>
805                               // The usecase of random jitter is to introduce jitter in the clock between 0% to percentage_jitter% in the clock randomly which may be positive or negative.
806                               // Eg: if the user sets 2 as percentage_jitter, the output clock will introduce jitter in the range of 0% to 1.99% randomly as positive or neagative.
807                               // Randomize the jitter in the current clock as positive or negative
808        <font color = "red">0/1     ==>            positive_jitter_mode = $urandom();</font>
809                               // If percentage_jitter is set as 1 then the percenatge variation is from 0 - 0.99%. Bypass randomize.
810                               // Else the integral part is randomized between 0-'n-1' when percentage_jitter is n. 
811                               // The final jitter introduced will be 0% to &lt;n-1&gt;.99%
812                               // Assumption here is (also mentioned in SVDOC): In this mode when the user sets tha max cap jitter it has to be an integer.
813                               // Copy the percentage_jitter real number in an integer type for randomization.
814        <font color = "red">0/1     ==>            percentage_jitter_local_int = percentage_jitter;</font>
815        <font color = "red">0/1     ==>            if(whole_number || (!whole_number &amp;&amp; resolved_to_plus_one)) begin</font>
816        <font color = "red">0/1     ==>              percentage_jitter_local_int = percentage_jitter_local_int - 1;</font>
817                               end 
                   <font color = "red">==>  MISSING_ELSE</font>
818        <font color = "red">0/1     ==>            if(percentage_jitter_local_int &gt; 0) begin</font>
819        <font color = "red">0/1     ==>              percentage_jitter_local_int = $urandom_range(0,percentage_jitter_local_int);</font>
820                               end
821                               else begin
822        <font color = "red">0/1     ==>              percentage_jitter_local_int = 0;</font>
823                               end
824                               // Randomize the trailing decimal percentage.
825        <font color = "red">0/1     ==>            percentage_jitter_local_decimal = $urandom_range(0,percentage_jitter_local_decimal_cap);</font>
826                               // Construct the percenatge randomized as &quot;jitter = int + (dec/100)&quot;.
827                               // Eg: If interger randomized is '1' and decimal is 67 the final jitter becomes 1.67.
828        <font color = "red">0/1     ==>            percentage_jitter_local = percentage_jitter_local_decimal;</font>
829        <font color = "red">0/1     ==>            percentage_jitter_local = (percentage_jitter_local/100);</font>
830        <font color = "red">0/1     ==>            percentage_jitter_local = percentage_jitter_local_int + percentage_jitter_local;</font>
831                               // Generate jitter
832        <font color = "red">0/1     ==>            generate_jitter_clock(enable_clock_jitter,positive_jitter_mode,percentage_jitter_local);</font>
833                               // After every cycle check if the jitter mode is disabled to 'break'
834        <font color = "red">0/2     ==>            if(kill_jitter_clock_gen) break;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
835                             end
836                           end
837                           else begin
838        <font color = "red">0/1     ==>          while(1) begin</font>
839        <font color = "red">0/1     ==>            if(enable_clock_jitter) begin</font>
840                                 // Loop to generate constant jitter.
841                                 // In this mode all the values come from the user.
842                                 // Type of jitter (positive/ negative)
843                                 // Percentage jitter. (This can be in decimals unlike in Random mode)
844                                 // The cycle of generation i.e. number of pulse with jitter followed by the number without jitter
845        <font color = "red">0/1     ==>              repeat(number_of_clocks_with_jitter) begin</font>
846        <font color = "red">0/1     ==>                generate_jitter_clock(1,positive_jitter_mode,percentage_jitter);</font>
847                                 end
                   <font color = "red">==>  REPEAT_FALSE</font>
848        <font color = "red">0/2     ==>              if(kill_jitter_clock_gen) break;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
849        <font color = "red">0/1     ==>              repeat(number_of_clocks_without_jitter) begin</font>
850        <font color = "red">0/1     ==>                generate_jitter_clock(0,positive_jitter_mode,percentage_jitter);</font>
851                                 end
852                               end else begin
853        <font color = "red">0/1     ==>              generate_jitter_clock(0,positive_jitter_mode,percentage_jitter);</font>
854                               end
855                               // After every cycle check if the jitter mode is disabled to 'break'
856        <font color = "red">0/2     ==>            if(kill_jitter_clock_gen) break;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
857                             end
858                           end
859        <font color = "red">0/1     ==>        kill_jitter_clock_gen = 0;</font>
860                         end  
861                       end
862                     `ifndef SVT_USB_JITTER_CORRECTION_DISABLE  
863                       //---------------------------------------------------------------
864                       // CDR
865                       //---------------------------------------------------------------
866                     
867                       initial begin
868        1/1              feedback_toggle = 1;
869        1/1              feedback_toggle_tx = 1;
870        1/1              vip_rx_clk = 1;
871        1/1              data_flopped_0 = 0;
872        1/1              data_flopped_1 = 0;
873        1/1              data_flopped_2 = 0;
874        1/1              data_flopped_0_to_sample = 0;
875        1/1              data_flopped_1_to_sample = 0;
876        1/1              data_flopped_2_to_sample = 0;
877        1/1              data_flopped_to_sample = 0;
878        1/1              data_flopped_to_sample_n = 0;
879        1/1              data_flopped_0_tx = 0;
880        1/1              data_flopped_1_tx = 0;
881        1/1              data_flopped_2_tx = 0;
882        1/1              data_flopped_0_to_sample_tx = 0;
883        1/1              data_flopped_1_to_sample_tx = 0;
884        1/1              data_flopped_2_to_sample_tx = 0;
885        1/1              data_flopped_to_sample_tx = 0;
886        1/1              data_flopped_to_sample_n_tx = 0;
887                       end
888                     
889                       //--------------------------------------------------------------------------------------------------
890                       // This signal gives an active low signal every time there is a change in the incoming signal level
891                       //--------------------------------------------------------------------------------------------------
892                       assign edge_detect_active_low = ((!(data_flopped_0) &amp; !(data_flopped_1)) | (data_flopped_0 &amp; data_flopped_1 ));
893                       assign edge_detect_active_low_tx = ((!(data_flopped_0_tx) &amp; !(data_flopped_1_tx)) | (data_flopped_0_tx &amp; data_flopped_1_tx ));
894                       bit clock_divider_tx;
895                     
896                       always@(posedge (clk4x &amp; clock_gen_enable)) begin
897        <font color = "red">0/1     ==>      if(!enable_clock_jitter &amp;&amp; !enable_ssc &amp;&amp; !is_passive &amp;&amp; !tx_user_clock_enable) begin</font>
898        <font color = "red">0/2     ==>        if(clock_divider_tx) vip_tx_clk &lt;= !vip_tx_clk;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
899        <font color = "red">0/1     ==>        clock_divider_tx &lt;= !(clock_divider_tx);</font>
900                         end
                   <font color = "red">==>  MISSING_ELSE</font>
901                         // Ignore any data which is z or x.
902        <font color = "red">0/1     ==>      if(ssrxp === 1'bz || ssrxp === 1'bx) begin</font>
903        <font color = "red">0/1     ==>        data_flopped_0 &lt;= data_flopped_0;</font>
904                         end
905                         else begin
906        <font color = "red">0/1     ==>        data_flopped_0 &lt;= ssrxp;</font>
907                         end
908        <font color = "red">0/1     ==>      data_flopped_1 &lt;= data_flopped_0;</font>
909        <font color = "red">0/1     ==>      data_flopped_2 &lt;= data_flopped_1;</font>
910        <font color = "red">0/1     ==>      data_flopped_0_to_sample &lt;= {ssrxm,ssrxp};</font>
911        <font color = "red">0/1     ==>      data_flopped_1_to_sample &lt;= data_flopped_0_to_sample;</font>
912        <font color = "red">0/1     ==>      data_flopped_2_to_sample &lt;= data_flopped_1_to_sample;</font>
913        <font color = "red">0/1     ==>      data_flopped_to_sample &lt;= data_flopped_2_to_sample[0];</font>
914        <font color = "red">0/1     ==>      data_flopped_to_sample_n &lt;= data_flopped_2_to_sample[1];</font>
915        <font color = "red">0/1     ==>      if(is_passive) begin</font>
916        <font color = "red">0/1     ==>        if(sstxp === 1'bz || sstxm === 1'bx) begin</font>
917        <font color = "red">0/1     ==>          data_flopped_0_tx &lt;= data_flopped_0_tx;</font>
918                           end
919                           else begin
920        <font color = "red">0/1     ==>          data_flopped_0_tx &lt;= sstxp;</font>
921                           end
922        <font color = "red">0/1     ==>        data_flopped_1_tx &lt;= data_flopped_0_tx;</font>
923        <font color = "red">0/1     ==>        data_flopped_2_tx &lt;= data_flopped_1_tx;</font>
924        <font color = "red">0/1     ==>        data_flopped_0_to_sample_tx &lt;= {sstxm,sstxp};</font>
925        <font color = "red">0/1     ==>        data_flopped_1_to_sample_tx &lt;= data_flopped_0_to_sample_tx;</font>
926        <font color = "red">0/1     ==>        data_flopped_2_to_sample_tx &lt;= data_flopped_1_to_sample_tx;</font>
927        <font color = "red">0/1     ==>        data_flopped_to_sample_tx &lt;= data_flopped_2_to_sample_tx[0];</font>
928        <font color = "red">0/1     ==>        data_flopped_to_sample_n_tx &lt;= data_flopped_2_to_sample_tx[1];</font>
929                         end
                   <font color = "red">==>  MISSING_ELSE</font>
930                         // Feedback toggle keeps on toggling for every posedge of reference clock.
931                         // The edge detect signal going low forces the feedback_toggle to go low. This can be considered a phase reset.
932                         // If the incoming serial data is without jitters the moment edge_detect_active_low is low feedback_toggle is also low.
933                         // So the next clock of ref_clk will give a high pulse as feedback_toggle changes and edge_detect_active_low goes high.
934                         // The next pulse goes low as the feedback toggle changes with no change in edge_detect_active_low.
935                         // Since ref_clk is 4 times the clock rate there will be 4 samples of 1 bit.
936                         // The sync is such that the feedback_toggle on no jitter will go 1 0 1 0.
937                         //
938                         // feedback_toggle_next feedback_toggle edge_detect_active_low
939                         //         1                   0                  1
940                         //         0                   1                  1
941                         //         1                   0                  1
942                         //         0                   1                  0
943                         //
944                         // This cycle repeats itself 
945                         // If there is jitter on the line then the edge_detect_active_low will either pulled in by a clock or pulled out by a clock.
946                         // This shifts the pll_clk pulse by 3 clock to the right or to the left
947        <font color = "red">0/1     ==>      feedback_toggle &lt;= !(feedback_toggle) &amp; edge_detect_active_low;</font>
948        <font color = "red">0/1     ==>      vip_rx_clk &lt;= (feedback_toggle ^ vip_rx_clk) &amp; edge_detect_active_low;</font>
949        <font color = "red">0/1     ==>      if(is_passive) begin</font>
950        <font color = "red">0/1     ==>        feedback_toggle_tx &lt;= !(feedback_toggle_tx) &amp; edge_detect_active_low_tx;</font>
951        <font color = "red">0/1     ==>        vip_tx_clk &lt;= (feedback_toggle_tx ^ vip_tx_clk) &amp; edge_detect_active_low_tx;</font>
952                         end
                   <font color = "red">==>  MISSING_ELSE</font>
953                       end
954                     `endif
955                       bit ss_data_prev;
956                       initial begin
957                         realtime t0,t1;
958        <font color = "red">1/2     ==>      wait(clock_ui_jitter_check == 1);</font>
959        <font color = "red">0/1     ==>      t0 = $realtime();</font>
960        <font color = "red">0/2     ==>      #1fs;</font>
961        <font color = "red">0/1     ==>      t1 = $realtime();</font>
962        <font color = "red">0/1     ==>      if(!(t1 &gt; t0)) begin</font>
963        <font color = "red">0/1     ==>        $display(&quot;ERROR: Timescale is not 1fs, UI checks not possible.&quot;);</font>
964                         end
                   <font color = "red">==>  MISSING_ELSE</font>
965                       end
966                     
967                       real count_max, count_min,timestamp,timestamp_gap,timestamp_current;
968                       event event_error_UI;
969                       reg ss_data;
970                       always@(*) begin
971        <font color = "red">0/2     ==>      wait(clock_ui_jitter_check == 1);</font>
972        <font color = "red">0/1     ==>      ss_data = (is_passive)? sstxp: ssrxp;</font>
973                       end
974                     
975                       initial begin
976        <font color = "red">1/2     ==>      wait(clock_ui_jitter_check == 1);</font>
977        <font color = "red">0/1     ==>      while(1) begin</font>
978                           fork begin
979                             fork
980                             begin
981        <font color = "red">0/1     ==>            while(1) begin</font>
982        <font color = "red">0/1     ==>              if(!mode_ssp) begin</font>
983        <font color = "red">0/2     ==>                #200ps;</font>
984        <font color = "red">0/1     ==>                count_max = count_max + 200.06;</font>
985        <font color = "red">0/1     ==>                count_min = count_min + 199.94;</font>
986                                 end else begin
987        <font color = "red">0/2     ==>                #100ps;</font>
988        <font color = "red">0/1     ==>                count_max = count_max + 100.03;</font>
989        <font color = "red">0/1     ==>                count_min = count_min +  99.97;</font>
990                                 end
991                               end
992                             end
993                             begin
994        <font color = "red">0/2     ==>            @(ss_data);</font>
995                             end
996                             join_any
997        <font color = "red">0/1     ==>          disable fork;</font>
998                           end join_any
999        <font color = "red">0/1     ==>        timestamp = timestamp_current;</font>
1000       <font color = "red">0/1     ==>        timestamp_current = $realtime;</font>
1001       <font color = "red">0/1     ==>        timestamp_gap = (timestamp_current - timestamp);</font>
1002       <font color = "red">0/1     ==>        if(!(timestamp_gap &gt; count_min &amp;&amp; timestamp_gap &lt; count_max)) begin</font>
1003       <font color = "red">0/1     ==>          -&gt; event_error_UI;</font>
1004                          end
                   <font color = "red">==>  MISSING_ELSE</font>
1005       <font color = "red">0/2     ==>        #1ps;</font>
1006       <font color = "red">0/1     ==>        if(!mode_ssp) begin</font>
1007       <font color = "red">0/1     ==>          count_max = 200.06;</font>
1008       <font color = "red">0/1     ==>          count_min = 199.94;</font>
1009                          end else begin
1010       <font color = "red">0/1     ==>          count_max = 100.03;</font>
1011       <font color = "red">0/1     ==>          count_min =  99.97;</font>
</pre>
<hr>
<a name="inst_tag_25393_Cond"></a>
<b>Cond Coverage for Instance : <a href="mod311.html#inst_tag_25393" >config_ss_tb.config_ss_env_intf.host_usb_if.usb_ss_serial_lane1_if</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s0"><td class="lf">Conditions</td><td>19</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">Logical</td><td>19</td><td>0</td><td>0.00</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       677
 EXPRESSION (((!enable_clock_jitter)) &amp;&amp; ((!enable_ssc)))
             ------------1-----------    -------2-------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       785
 EXPRESSION ((enable_clock_jitter == 1'b1) || (enable_ssc == 1'b1))
             --------------1--------------    ----------2---------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       815
 EXPRESSION (whole_number || (((!whole_number)) &amp;&amp; resolved_to_plus_one))
             ------1-----    ---------------------2---------------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       815
 SUB-EXPRESSION (((!whole_number)) &amp;&amp; resolved_to_plus_one)
                 --------1--------    ----------2---------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       897
 EXPRESSION (((!enable_clock_jitter)) &amp;&amp; ((!enable_ssc)) &amp;&amp; ((!is_passive)) &amp;&amp; ((!tx_user_clock_enable)))
             ------------1-----------    -------2-------    -------3-------    ------------4------------
</pre>
<table class="noborder">
<col span="4" width="40">
<tr><th>-1-</th><th>-2-</th><th>-3-</th><th>-4-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       972
 EXPRESSION (is_passive ? sstxp : ssrxp)
             -----1----
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<hr>
<a name="inst_tag_25393_Branch"></a>
<b>Branch Coverage for Instance : <a href="mod311.html#inst_tag_25393" >config_ss_tb.config_ss_env_intf.host_usb_if.usb_ss_serial_lane1_if</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s0">
<td>Branches</td>
<td></td>
<td class="rt">44</td>
<td class="rt">3</td>
<td class="rt">6.82  </td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">393</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">547</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s3">
<td>IF</td>
<td class="rt">554</td>
<td class="rt">3</td>
<td class="rt">1</td>
<td class="rt">33.33 </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">664</td>
<td class="rt">3</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">669</td>
<td class="rt">4</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">708</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">715</td>
<td class="rt">3</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">792</td>
<td class="rt">3</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">803</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">897</td>
<td class="rt">3</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">902</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">915</td>
<td class="rt">3</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">949</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">962</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>TERNARY</td>
<td class="rt">972</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">982</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">1002</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">1006</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
393            if(initialized) initialize_ssc_parameters;
               <font color = "red">-1-</font>  
           <font color = "red">    ==></font>
               MISSING_ELSE
           <font color = "green">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
547            if (vbus !== 1'b1) begin
               <font color = "red">-1-</font>  
548              dut_ss_termination_reg = 0;  // Assume no DUT SS RX termination when VBUS is absent
           <font color = "green">      ==></font>
549            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
554            if (dut_ss_termination === 1'b0) begin
               <font color = "red">-1-</font>  
555              dut_ss_termination_reg = 0;  // No DUT SS RX termination - signaled by TB
           <font color = "red">      ==></font>
556            end else if (vbus !== 1'b1) begin
                        <font color = "red">-2-</font>  
557              dut_ss_termination_reg = 0;  // No DUT SS RX termination - VBUS is absent
           <font color = "green">      ==></font>
558            end else begin
559              dut_ss_termination_reg = 1;  // DUT SS RX termination in place
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
664            if(ess_operating_rate == 2'b00) begin
               <font color = "red">-1-</font>  
665              if(clock_divider) clock5GHz = !(clock5GHz);
                 <font color = "red">-2-</font>  
           <font color = "red">      ==></font>
                 MISSING_ELSE
           <font color = "red">      ==></font>
666              clock_divider = !(clock_divider);
667            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
669            if (clock_recovery_enable === 1'b1) begin 
               <font color = "red">-1-</font>  
670              // When ess_operating rate is 1 then pass the ssclk which is generating in top 
671              // Else pass clock5GHz(3.0) local generated clock 
672              clk4x = (ess_operating_rate === 2'b01) ? ssclk : clock5GHz; 
           <font color = "red">      ==></font>
673            end
674            else begin 
675              // When ess_operating rate is 1 then pass the ssclk which is generating in top 
676              // Else pass clock5GHz(3.0) local generated clock 
677              if(!enable_clock_jitter && !enable_ssc) begin 
                 <font color = "red">-2-</font>  
678        `ifndef SVT_USB_JITTER_CORRECTION_DISABLE
679                if(ess_operating_rate === 2'b01) begin
                   <font color = "red">-3-</font>  
680                  vip_tx_clk = ssclk; 
           <font color = "red">          ==></font>
681                  vip_rx_clk = ssclk; 
682                end
683                else begin
684                  vip_tx_clk = clock5GHz; 
           <font color = "red">          ==></font>
685                  vip_rx_clk = clock5GHz; 
686                end
687        `else
688                vip_tx_clk = (ess_operating_rate === 2'b01) ? ssclk : clock5GHz; 
689        `endif        
690              end  
                 MISSING_ELSE
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
708            if(tx_user_clock_enable === 1)
               <font color = "red">-1-</font>  
709              vip_tx_clk = ssclk_tx;
           <font color = "red">      ==></font>
                 MISSING_ELSE
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
715            if(enable_clock_jitter) begin
               <font color = "red">-1-</font>  
           <font color = "red">    ==></font>
716            end
717            else begin
718              if(kill_jitter_clock_gen == 0) begin
                 <font color = "red">-2-</font>  
719                kill_jitter_clock_gen = 1;
           <font color = "red">        ==></font>
720                wait(kill_jitter_clock_gen == 0);
721              end
                 MISSING_ELSE
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
792              if(percentage_jitter_local_decimal_cap == 0) begin 
                 <font color = "red">-1-</font>  
793                whole_number = 1;
794                percentage_jitter_local_decimal_cap = 99; 
795              end  
796              else if(percentage_jitter_local_decimal_cap < 0) begin 
                      <font color = "red">-2-</font>  
           <font color = "red">      ==></font>
           <font color = "red">      ==></font>
797                percentage_jitter_local_decimal_cap = 100 + percentage_jitter_local_decimal_cap;
           <font color = "red">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
803              if(random_jitter_mode) begin
                 <font color = "red">-1-</font>  
804                while(1) begin
           <font color = "red">        ==></font>
805                  // The usecase of random jitter is to introduce jitter in the clock between 0% to percentage_jitter% in the clock randomly which may be positive or negative.
806                  // Eg: if the user sets 2 as percentage_jitter, the output clock will introduce jitter in the range of 0% to 1.99% randomly as positive or neagative.
807                  // Randomize the jitter in the current clock as positive or negative
808                  positive_jitter_mode = $urandom();
809                  // If percentage_jitter is set as 1 then the percenatge variation is from 0 - 0.99%. Bypass randomize.
810                  // Else the integral part is randomized between 0-'n-1' when percentage_jitter is n. 
811                  // The final jitter introduced will be 0% to <n-1>.99%
812                  // Assumption here is (also mentioned in SVDOC): In this mode when the user sets tha max cap jitter it has to be an integer.
813                  // Copy the percentage_jitter real number in an integer type for randomization.
814                  percentage_jitter_local_int = percentage_jitter;
815                  if(whole_number || (!whole_number && resolved_to_plus_one)) begin
816                    percentage_jitter_local_int = percentage_jitter_local_int - 1;
817                  end 
818                  if(percentage_jitter_local_int > 0) begin
819                    percentage_jitter_local_int = $urandom_range(0,percentage_jitter_local_int);
820                  end
821                  else begin
822                    percentage_jitter_local_int = 0;
823                  end
824                  // Randomize the trailing decimal percentage.
825                  percentage_jitter_local_decimal = $urandom_range(0,percentage_jitter_local_decimal_cap);
826                  // Construct the percenatge randomized as "jitter = int + (dec/100)".
827                  // Eg: If interger randomized is '1' and decimal is 67 the final jitter becomes 1.67.
828                  percentage_jitter_local = percentage_jitter_local_decimal;
829                  percentage_jitter_local = (percentage_jitter_local/100);
830                  percentage_jitter_local = percentage_jitter_local_int + percentage_jitter_local;
831                  // Generate jitter
832                  generate_jitter_clock(enable_clock_jitter,positive_jitter_mode,percentage_jitter_local);
833                  // After every cycle check if the jitter mode is disabled to 'break'
834                  if(kill_jitter_clock_gen) break;
835                end
836              end
837              else begin
838                while(1) begin
           <font color = "red">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
897            if(!enable_clock_jitter && !enable_ssc && !is_passive && !tx_user_clock_enable) begin
               <font color = "red">-1-</font>  
898              if(clock_divider_tx) vip_tx_clk <= !vip_tx_clk;
                 <font color = "red">-2-</font>  
           <font color = "red">      ==></font>
                 MISSING_ELSE
           <font color = "red">      ==></font>
899              clock_divider_tx <= !(clock_divider_tx);
900            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
902            if(ssrxp === 1'bz || ssrxp === 1'bx) begin
               <font color = "red">-1-</font>  
903              data_flopped_0 <= data_flopped_0;
           <font color = "red">      ==></font>
904            end
905            else begin
906              data_flopped_0 <= ssrxp;
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
915            if(is_passive) begin
               <font color = "red">-1-</font>  
916              if(sstxp === 1'bz || sstxm === 1'bx) begin
                 <font color = "red">-2-</font>  
917                data_flopped_0_tx <= data_flopped_0_tx;
           <font color = "red">        ==></font>
918              end
919              else begin
920                data_flopped_0_tx <= sstxp;
           <font color = "red">        ==></font>
921              end
922              data_flopped_1_tx <= data_flopped_0_tx;
923              data_flopped_2_tx <= data_flopped_1_tx;
924              data_flopped_0_to_sample_tx <= {sstxm,sstxp};
925              data_flopped_1_to_sample_tx <= data_flopped_0_to_sample_tx;
926              data_flopped_2_to_sample_tx <= data_flopped_1_to_sample_tx;
927              data_flopped_to_sample_tx <= data_flopped_2_to_sample_tx[0];
928              data_flopped_to_sample_n_tx <= data_flopped_2_to_sample_tx[1];
929            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
949            if(is_passive) begin
               <font color = "red">-1-</font>  
950              feedback_toggle_tx <= !(feedback_toggle_tx) & edge_detect_active_low_tx;
           <font color = "red">      ==></font>
951              vip_tx_clk <= (feedback_toggle_tx ^ vip_tx_clk) & edge_detect_active_low_tx;
952            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
962            if(!(t1 > t0)) begin
               <font color = "red">-1-</font>  
963              $display("ERROR: Timescale is not 1fs, UI checks not possible.");
           <font color = "red">      ==></font>
964            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
972            ss_data = (is_passive)? sstxp: ssrxp;
                                     <font color = "red">-1-</font>  
                                     <font color = "red">==></font>  
                                     <font color = "red">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
982                    if(!mode_ssp) begin
                       <font color = "red">-1-</font>  
983                      #200ps;
           <font color = "red">              ==></font>
984                      count_max = count_max + 200.06;
985                      count_min = count_min + 199.94;
986                    end else begin
987                      #100ps;
           <font color = "red">              ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1002             if(!(timestamp_gap > count_min && timestamp_gap < count_max)) begin
                 <font color = "red">-1-</font>  
1003               -> event_error_UI;
           <font color = "red">        ==></font>
1004             end
                 MISSING_ELSE
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1006             if(!mode_ssp) begin
                 <font color = "red">-1-</font>  
1007               count_max = 200.06;
           <font color = "red">        ==></font>
1008               count_min = 199.94;
1009             end else begin
1010               count_max = 100.03;
           <font color = "red">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
</div>
<div name='inst_tag_25394'>
<a name="inst_tag_25394_Line"></a>
<b>Line Coverage for Instance : <a href="mod311.html#inst_tag_25394" >config_ss_tb.config_ss_env_intf.dev_usb_if.usb_ss_serial_if</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s1"><td class="lf">TOTAL</td><td></td><td>217</td><td>39</td><td>17.97</td></tr>
<tr class="s2"><td class="lf">INITIAL</td><td>349</td><td>4</td><td>1</td><td>25.00</td></tr>
<tr class="s0"><td class="lf">ROUTINE</td><td>356</td><td>19</td><td>0</td><td>0.00</td></tr>
<tr class="s5"><td class="lf">ALWAYS</td><td>393</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="s10"><td class="lf">INITIAL</td><td>543</td><td>7</td><td>7</td><td>100.00</td></tr>
<tr class="s6"><td class="lf">ALWAYS</td><td>554</td><td>5</td><td>3</td><td>60.00</td></tr>
<tr class="s10"><td class="lf">INITIAL</td><td>569</td><td>1</td><td>1</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">INITIAL</td><td>578</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s0"><td class="lf">ALWAYS</td><td>664</td><td>12</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">ALWAYS</td><td>708</td><td>2</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">ALWAYS</td><td>715</td><td>5</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">ROUTINE</td><td>732</td><td>24</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">INITIAL</td><td>783</td><td>45</td><td>2</td><td>4.44</td></tr>
<tr class="s10"><td class="lf">INITIAL</td><td>868</td><td>19</td><td>19</td><td>100.00</td></tr>
<tr class="s0"><td class="lf">ALWAYS</td><td>897</td><td>30</td><td>0</td><td>0.00</td></tr>
<tr class="s1"><td class="lf">INITIAL</td><td>958</td><td>8</td><td>1</td><td>12.50</td></tr>
<tr class="s0"><td class="lf">ALWAYS</td><td>971</td><td>3</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">INITIAL</td><td>976</td><td>28</td><td>1</td><td>3.57</td></tr>
</table>
<pre class="code"><br clear=all>
348                         // Wait for all values to be loaded for the calculation
349        <font color = "red">1/2     ==>      wait(initialized == 1);</font>
350        <font color = "red">0/1     ==>      clock_gen_enable = 1;</font>
351        <font color = "red">0/1     ==>      initialize_ssc_parameters;</font>
352                       end
353                     
354                       task initialize_ssc_parameters;
355                         // Load the value of clock period
356        <font color = "red">0/1     ==>      clock_period_ps_resolved = clock_period_ps;</font>
357                         // Set the ssc direction as 1 to start
358        <font color = "red">0/1     ==>      ssc_direction = 1;</font>
359                         // Convert ppm to fraction
360        <font color = "red">0/1     ==>      if(ssc_down_spread_mode) begin</font>
361        <font color = "red">0/1     ==>        max_ssc_ppm_shift = (ssc_deviation_ppm/real'(1000000));</font>
362                         end else begin 
363        <font color = "red">0/1     ==>        max_ssc_ppm_shift = ((ssc_deviation_ppm+ssc_deviation_pos_ppm)/real'(1000000));</font>
364        <font color = "red">0/1     ==>        ssc_ppm_shift_neg = ((ssc_deviation_ppm)/real'(1000000));</font>
365        <font color = "red">0/1     ==>        ssc_ppm_shift_pos = ((ssc_deviation_pos_ppm)/real'(1000000));</font>
366                         end  
367                         // Scale KHz value to Hz
368        <font color = "red">0/1     ==>      ssc_spread_frequency_scaled = ssc_spread_frequency*1000;</font>
369                         // Calculate time period and scale by 10^6 to the us domain.
370        <font color = "red">0/1     ==>      ssc_spread_time_period = (1/ssc_spread_frequency_scaled);</font>
371        <font color = "red">0/1     ==>      ssc_spread_time_period = ssc_spread_time_period * (1000000);</font>
372                         // Scale the clock timeperiod from ps to us
373        <font color = "red">0/1     ==>      clock_period_ps_scaled = (clock_period_ps/1000000);</font>
374                         // Divide the period for ssc with the period for clock to find the number to ticks to reach max ppm and back.
375        <font color = "red">0/1     ==>      ssc_num_steps = (ssc_spread_time_period/clock_period_ps_scaled);</font>
376                         // For downspread the frequency has to reach max ppm and back. So to reach max halving the value
377        <font color = "red">0/1     ==>      ssc_num_steps = ssc_num_steps/2;</font>
378                         // For each step the clock period will change by the (max shift to reach in fraction), divided by the number of ticks to reach in (calculated above), multiply the clock period
379        <font color = "red">0/1     ==>      ssc_ppm_step =  (max_ssc_ppm_shift/real'(ssc_num_steps))*clock_period_ps;</font>
380                         // The max clock period that can be generated is the clock period + the max ppm shift
381                         // For down spread the min is the actual clock period
382        <font color = "red">0/1     ==>      if(ssc_down_spread_mode) begin</font>
383        <font color = "red">0/1     ==>        clock_period_ssc_max_ps = clock_period_ps + (clock_period_ps*max_ssc_ppm_shift);</font>
384        <font color = "red">0/1     ==>        clock_period_ssc_min_ps = clock_period_ps;</font>
385                         end else begin
386        <font color = "red">0/1     ==>        clock_period_ssc_max_ps = clock_period_ps + (clock_period_ps*ssc_ppm_shift_neg);</font>
387        <font color = "red">0/1     ==>        clock_period_ssc_min_ps = clock_period_ps - (clock_period_ps*ssc_ppm_shift_pos);</font>
388                         end
389                       endtask
390                     
391                       // If the port were to fallback aor change clock rate the ssc calucations need to be made again
392                       always@(ess_operating_rate or clock_period_ps) begin
393        <font color = "red">1/2     ==>      if(initialized) initialize_ssc_parameters;</font>
                        MISSING_ELSE
394                       end
395                     
396                     //-----------------------------------------------------------------------
397                     /**
398                      * Clocking block that defines VIP USB PHYSICAL's SS Serial Tx Link
399                      * Interface signal synchronization and directionality, for the
400                      * SS wires.
401                      */
402                     clocking usb_ss_serial_phy_tx_cb @(posedge vip_tx_clk);
403                     `ifdef SVT_USB_IF_NO_PARAMS
404                       default input #(`SVT_USB_SS_SERIAL_IF_SETUP_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(`SVT_USB_SS_SERIAL_IF_HOLD_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
405                     `else
406                       default input #(setup_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(hold_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
407                     `endif
408                       output sstxp;
409                       output sstxm;
410                     endclocking
411                     
412                     //-----------------------------------------------------------------------
413                     /**
414                      * Clocking block that defines VIP USB PHYSICAL's SS Serial Tx Link
415                      * Interface signal for monitor.
416                      */
417                     clocking usb_ss_serial_phy_tx_monitor_cb @(posedge vip_tx_clk);
418                     `ifdef SVT_USB_IF_NO_PARAMS
419                       default input #(`SVT_USB_SS_SERIAL_IF_SETUP_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(`SVT_USB_SS_SERIAL_IF_HOLD_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
420                     `else
421                       default input #(setup_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(hold_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
422                     `endif
423                       input sstxp;
424                       input sstxm;
425                     `ifndef SVT_USB_JITTER_CORRECTION_DISABLE  
426                       input data_flopped_to_sample_tx;
427                       input data_flopped_to_sample_n_tx;
428                     `endif  
429                     endclocking
430                     
431                     
432                     //-----------------------------------------------------------------------
433                     /**
434                      * Clocking block that defines VIP USB PHYSICAL's SS Serial Rx Link
435                      * Interface signal synchronization and directionality, for the
436                      * SS wires.
437                      */
438                     clocking usb_ss_serial_phy_rx_cb @(posedge vip_rx_clk);
439                     `ifdef SVT_USB_IF_NO_PARAMS
440                       default input #(`SVT_USB_SS_SERIAL_IF_SETUP_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(`SVT_USB_SS_SERIAL_IF_HOLD_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
441                     `else
442                       default input #(setup_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(hold_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
443                     `endif
444                       input ssrxp;
445                       input ssrxm;
446                     `ifndef SVT_USB_JITTER_CORRECTION_DISABLE  
447                       input data_flopped_to_sample;
448                       input data_flopped_to_sample_n;
449                     `endif  
450                     endclocking
451                     
452                     //-----------------------------------------------------------------------
453                     // USB SS Serial Modports
454                     //-----------------------------------------------------------------------
455                     
456                     //-----------------------------------------------------------------------
457                     /** Modport used to connect VIP USB PHYSICAL to USB SS SERIAL interface signals from the link direction. */
458                     modport svt_usb_ss_serial_phy_port(
459                       clocking usb_ss_serial_phy_tx_cb, clocking usb_ss_serial_phy_rx_cb, output vbus, input dut_ss_termination, output vip_ss_termination);
460                     
461                     //-----------------------------------------------------------------------
462                     /** Modport used to connect VIP USB PHYSICAL to USB SS SERIAL interface signals from the PHY direction. */
463                     modport svt_usb_ss_serial_cable_port(
464                       input sstxp,
465                       input sstxm,
466                       output ssrxp,
467                       output ssrxm,
468                       input vbus,
469                       output dut_ss_termination,
470                       input vip_ss_termination
471                       );
472                     
473                     //-----------------------------------------------------------------------
474                     /** Modport used to monitor VIP USB SS serial interface signals. */
475                     modport svt_usb_ss_serial_phy_monitor_port(
476                       clocking usb_ss_serial_phy_tx_monitor_cb, clocking usb_ss_serial_phy_rx_cb, input vbus, input dut_ss_termination, input vip_ss_termination);
477                     
478                     task wait_for_hold_drive();
479                       #(hold_time_scaled + 1);
480                     endtask
481                     
482                     `ifndef __SVDOC__
483                     //-----------------------------------------------------------------------
484                     // USB SS Serial Interface Control Assigns
485                     //-----------------------------------------------------------------------
486                     
487                       //---------------------------------------------------------------------
488                       // Additions for receiver detection
489                       //---------------------------------------------------------------------
490                       assign vip_ss_termination = vip_ss_termination_reg;
491                     
492                       //-------------------------------------------------------------------------
493                       // Additions for VBUS
494                       //-------------------------------------------------------------------------
495                       assign vbus = vbus_reg;
496                     
497                       //-----------------------------------------------------------------------
498                       // Additions for Clock_Recovery
499                       //-----------------------------------------------------------------------
500                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE
501                       // Detect differential receiver value
502                       assign data_in = ((ssrxp === 1'bz) || (ssrxp === 1'bx)) ? 1'b0 :
503                                        ((ssrxm === 1'bz) || (ssrxm === 1'bx)) ? 1'b0 : ssrxp;
504                     
505                       // Use the unfiltered transmit clock whenever the DPLL is not ready
506                       assign pll_disable = (rec_clk_valid !== 1'b1) ? 1'b1 : 1'b0;
507                     `endif
508                       // Filter the output clock as per mode (normal vs. clock recovery)
509                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE  
510                       assign vip_rx_clk = (clock_recovery_enable === 1'b1) ? rec_clk_out : (ess_operating_rate === 2'b01) ? ssclk : clock5GHz;
511                     `endif
512                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE
513                       // Output clock for the VIP is from the recovered clock
514                       assign rec_clk_out = (pll_rec_clk | pll_sync_clk);
515                     
516                       // When the VIP is transmitting, or the PLL is disabled, disable the recovery of clock
517                       assign phase_rst = ((pll_disable) |
518                                           ((((data_phase_2 | !data_phase_3) &amp; (!data_phase_2 | data_phase_3)) | (int_se0))));
519                       // SE0 detection
520                       assign se0_detect = ((ssrxp === 1'bz) || (ssrxp === 1'bx)) ? 1'b0 :
521                                           ((ssrxm === 1'bz) || (ssrxm === 1'bx)) ? 1'b0 : (!(ssrxp | ssrxm));
522                     
523                       // Phase detection
524                       assign phase_det = (feed_back ^ pll_clk);
525                     
526                       // Clock extraction
527                       assign extract_clk = (phase_det &amp; phase_rst &amp; ~extract_clk_reg);
528                     
529                       // Clock valid condition
530                       assign rec_clk_valid = (pll_reset === 1'b0) ? 1'b1 : 1'b0;
531                     `endif
532                     
533                     //-----------------------------------------------------------------------
534                     // USB SS Serial Interface Control Processes
535                     //-----------------------------------------------------------------------
536                     
537                       //-----------------------------------------------------------------------
538                       // Additions for receiver detection
539                       //-----------------------------------------------------------------------
540                     
541                       // Initialize all registers
542                       initial begin
543        1/1              ess_operating_rate =  2'b01;
544        1/1              dut_ss_termination_reg = 1;  // Assume DUT SS RX termination in place
545        1/1              vip_ss_termination_reg = 0;  // Assume VIP SS RX termination not in place
546        2/2              #1;
547        1/1              if (vbus !== 1'b1) begin
548        1/1                dut_ss_termination_reg = 0;  // Assume no DUT SS RX termination when VBUS is absent
549                         end
                   <font color = "red">==>  MISSING_ELSE</font>
550                       end
551                     
552                       // Sample changes on the DUT termination signal
553                       always @ (dut_ss_termination or vbus) begin
554        1/1              if (dut_ss_termination === 1'b0) begin
555        <font color = "red">0/1     ==>        dut_ss_termination_reg = 0;  // No DUT SS RX termination - signaled by TB</font>
556        1/1              end else if (vbus !== 1'b1) begin
557        1/1                dut_ss_termination_reg = 0;  // No DUT SS RX termination - VBUS is absent
558                         end else begin
559        <font color = "red">0/1     ==>        dut_ss_termination_reg = 1;  // DUT SS RX termination in place</font>
560                         end
561                       end
562                     
563                       //-----------------------------------------------------------------------
564                       // Additions for VBUS
565                       //-----------------------------------------------------------------------
566                     
567                       // Initialize VBUS drive off
568                       initial begin
569        1/1              vbus_reg = 1'bz;  // Assume VIP not started
570                       end
571                     
572                       //-----------------------------------------------------------------------
573                       // Additions for Clock_Recovery
574                       //-----------------------------------------------------------------------
575                     
576                       // Initialize all registers
577                       initial begin
578        1/1              clk4x           = 1'b0;
579        1/1              vip_tx_clk      = 1'b0;
580                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE    
581                         clk2x           = 1'b0;
582                         data_phase_0    = 1'b0;
583                         data_phase_1    = 1'b0;
584                         data_phase_2    = 1'b0;
585                         data_phase_3    = 1'b0;
586                         dpdm_phase_0    = 1'b0;
587                         int_se0         = 1'b0;
588                         extract_clk_reg = 1'b0;
589                         feed_back       = 1'b0;
590                         pll_clk         = 1'b0;
591                         pll_rec_clk     = 1'b0;
592                         pll_reset       = 1'b1;
593                         pll_sync_clk    = 1'b0;
594                         saw_sync_clk    = 1'b0;
595                     `endif    
596        1/1              clock5GHz       = 1'b0;
597                       end
598                     
599                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE
600                       // Reset the DPLL at startup
601                       initial begin
602                         @(posedge ssclk);
603                         @(posedge ssclk);
604                         pll_reset = 0;
605                       end
606                     
607                       // Code to generate the initial recovered clock edge during the first SYNC bit
608                       always @ (posedge clk4x) begin
609                         pll_sync_clk &lt;= 1'b0;
610                       end
611                       // Generation of control signals
612                       always @ (posedge clk4x) begin
613                         data_phase_0 &lt;= data_in;
614                         data_phase_1 &lt;= data_phase_0;
615                         data_phase_2 &lt;= data_phase_1;
616                         data_phase_3 &lt;= data_phase_2;
617                         dpdm_phase_0 &lt;= se0_detect;
618                         int_se0 &lt;= dpdm_phase_0 &amp;&amp; (int_se0 || se0_detect);
619                         extract_clk_reg &lt;= phase_det &amp; phase_rst;
620                       end
621                     
622                       // Generation of feedback
623                       always @ (posedge clk4x) begin
624                         if (pll_reset) begin
625                           feed_back &lt;= 1'b1;
626                         end
627                         else begin
628                           feed_back &lt;= (!feed_back) &amp; phase_rst;
629                         end
630                       end
631                     
632                       // Generation of clock
633                       always @ (posedge clk4x) begin
634                         if (pll_reset) begin
635                           pll_clk &lt;= 1'b1;
636                         end
637                         else begin
638                           pll_clk &lt;= phase_det &amp; phase_rst;
639                         end
640                       end
641                     
642                       // Generation of recovered clock
643                       always @ (posedge clk4x) begin
644                         if (pll_reset) begin
645                           pll_rec_clk &lt;= 1'b0;
646                         end
647                         else begin
648                           pll_rec_clk &lt;= extract_clk;
649                         end
650                       end
651                     `endif  
652                     
653                       //-------------------------------------------------------------------------
654                       // Generates the TX clock based on the clock_recovery_enable setting
655                       //-------------------------------------------------------------------------
656                       bit clock_divider;
657                     
658                       // When clock recovery is disabled, the VIP TX clock is the input clock
659                       //--------------------------------------------------------------------------
660                       always @ (ssclk) begin 
661                         // Only if operating rate is 2'b00 generate the clock5GHz clock.
662                         // If VIP starts in SS mode the clock ss is anyway expected to be 5G.
663                         // If VIP starts in SSP mode the clock 5G is only required for fallback which reflected in ess_operating_rate as 2'b00
664        <font color = "red">0/1     ==>      if(ess_operating_rate == 2'b00) begin</font>
665        <font color = "red">0/2     ==>        if(clock_divider) clock5GHz = !(clock5GHz);</font>
                   <font color = "red">==>  MISSING_ELSE</font>
666        <font color = "red">0/1     ==>        clock_divider = !(clock_divider);</font>
667                         end
                   <font color = "red">==>  MISSING_ELSE</font>
668                         // if clock recovery is enabled, the vip tx clock is generated by dividing the 4x clock by a factor of 4.
669        <font color = "red">0/1     ==>      if (clock_recovery_enable === 1'b1) begin </font>
670                           // When ess_operating rate is 1 then pass the ssclk which is generating in top 
671                           // Else pass clock5GHz(3.0) local generated clock 
672        <font color = "red">0/1     ==>        clk4x = (ess_operating_rate === 2'b01) ? ssclk : clock5GHz; </font>
673                         end
674                         else begin 
675                           // When ess_operating rate is 1 then pass the ssclk which is generating in top 
676                           // Else pass clock5GHz(3.0) local generated clock 
677        <font color = "red">0/1     ==>        if(!enable_clock_jitter &amp;&amp; !enable_ssc) begin </font>
678                     `ifndef SVT_USB_JITTER_CORRECTION_DISABLE
679        <font color = "red">0/1     ==>          if(ess_operating_rate === 2'b01) begin</font>
680        <font color = "red">0/1     ==>            vip_tx_clk = ssclk; </font>
681        <font color = "red">0/1     ==>            vip_rx_clk = ssclk; </font>
682                             end
683                             else begin
684        <font color = "red">0/1     ==>            vip_tx_clk = clock5GHz; </font>
685        <font color = "red">0/1     ==>            vip_rx_clk = clock5GHz; </font>
686                             end
687                     `else
688                             vip_tx_clk = (ess_operating_rate === 2'b01) ? ssclk : clock5GHz; 
689                     `endif        
690                           end  
                   <font color = "red">==>  MISSING_ELSE</font>
691                         end 
692                       end 
693                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE  
694                       always @ (posedge clk4x) begin
695                         clk2x = ~clk2x;
696                       end
697                     
698                       // When clock recovery is enabled, the VIP TX clock is 1/4 the input clock
699                       //--------------------------------------------------------------------------
700                       always @ (posedge clk2x) begin
701                         if (clock_recovery_enable === 1'b1 &amp;&amp; !enable_clock_jitter &amp;&amp; !enable_ssc) begin
702                           vip_tx_clk = ~vip_tx_clk;
703                         end
704                       end
705                     `endif
706                     
707                       always @(ssclk_tx) begin
708        <font color = "red">0/1     ==>      if(tx_user_clock_enable === 1)</font>
709        <font color = "red">0/1     ==>        vip_tx_clk = ssclk_tx;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
710                       end
711                       
712                       // Always block which is triggered if there is a change in value of enable_clock_jitter
713                       // If the enable_clock_jitter is '0' then trigger the end of the loop which generates tx clock
714                       always@(enable_clock_jitter) begin
715        <font color = "red">0/1     ==>      if(enable_clock_jitter) begin</font>
716                         end
717                         else begin
718        <font color = "red">0/1     ==>        if(kill_jitter_clock_gen == 0) begin</font>
719        <font color = "red">0/1     ==>          kill_jitter_clock_gen = 1;</font>
720        <font color = "red">0/2     ==>          wait(kill_jitter_clock_gen == 0);</font>
721                           end
                   <font color = "red">==>  MISSING_ELSE</font>
722                         end
723                       end
724                     
725                       // This task is responsible for generating a clock cycle. The task is blocking and takes inputs:
726                       // enable_jitter : If this is '1' then a jittered clock is genearted. If '0' then a clock with no jitter is generated.
727                       // positive_jitter_mode : This when 1 generates a positive jitter i.e. extends the clock by percentage_jitter. Else shortens it by percentage_jitter
728                       // percentage_jitter :  This is a real number input which holds the percentage value of the jitter to introduce.
729                       real half_time_resolved;
730                       task generate_jitter_clock(bit enable_jitter,bit positive_jitter_mode, real percentage_jitter);
731                         // Block excersised for SSC mode.
732        <font color = "red">0/1     ==>      if(enable_ssc &amp;&amp; !disable_ssc_clk_ppm_shift) begin</font>
733                           // If the SSC direction is positive 
734                           //  if the clock period has not reached the max ssc, keep incrementing the clock period.
735                           //  else if the max SSC is reached start to decrement the period and flip the direction
736        <font color = "red">0/1     ==>        if(ssc_direction) begin</font>
737        <font color = "red">0/1     ==>          if(clock_period_ssc_max_ps - clock_period_ps_resolved &gt;= ssc_ppm_step) begin</font>
738        <font color = "red">0/1     ==>            clock_period_ps_resolved = clock_period_ps_resolved + ssc_ppm_step;</font>
739                             end else begin
740        <font color = "red">0/1     ==>            clock_period_ps_resolved = clock_period_ps_resolved - ssc_ppm_step;</font>
741        <font color = "red">0/1     ==>            ssc_direction = 0;</font>
742                             end
743                           // If the SSC direction is negative 
744                           //  if the clock period has not reached the min ssc, keep decrementing the clock period.
745                           //  else if the min SSC is reached start to increment the period and flip the direction
746                           end else begin
747        <font color = "red">0/1     ==>          if(clock_period_ps_resolved - clock_period_ssc_min_ps &gt;= ssc_ppm_step) begin</font>
748        <font color = "red">0/1     ==>            clock_period_ps_resolved = clock_period_ps_resolved - ssc_ppm_step;</font>
749                             end else begin
750        <font color = "red">0/1     ==>            clock_period_ps_resolved = clock_period_ps_resolved + ssc_ppm_step;</font>
751        <font color = "red">0/1     ==>            ssc_direction = 1;</font>
752                             end
753                           end
754                         end else begin
755        <font color = "red">0/1     ==>        clock_period_ps_resolved = clock_period_ps;</font>
756                         end
757                         // Add jitter if enabled
758        <font color = "red">0/1     ==>      if(enable_jitter) begin</font>
759        <font color = "red">0/1     ==>        clk_scale_jitter = (real'(percentage_jitter * clock_period_ps_resolved)/100);</font>
760        <font color = "red">0/2     ==>        if(positive_jitter_mode) half_clk_time = (real'(clock_period_ps_resolved + clk_scale_jitter)/2);</font>
761        <font color = "red">0/1     ==>        else half_clk_time = (real'(clock_period_ps_resolved - clk_scale_jitter)/2);</font>
762                         end
763        <font color = "red">0/1     ==>      else half_clk_time = (real'(clock_period_ps_resolved)/2);</font>
764        <font color = "red">0/1     ==>      half_time_resolved = (half_clk_time*1ps);</font>
765        <font color = "red">0/2     ==>      #(half_time_resolved);</font>
766        <font color = "red">0/1     ==>      vip_tx_clk = !(vip_tx_clk);</font>
767        <font color = "red">0/2     ==>      #(half_time_resolved);</font>
768        <font color = "red">0/1     ==>      vip_tx_clk = !(vip_tx_clk);</font>
769                     `ifdef SVT_USB_JITTER_DEBUG_TRACE    
770                         $fdisplay(file_handle,$sformatf(&quot;%32t: enable_jitter: %b enable_ssc: %b clk_scale_jitter: %f half_clk_time: %f clock_period_ps_resolved: %f clock_period_ssc_max_ps: %f clock_period_ssc_min_ps: %f&quot;,$time,enable_jitter,enable_ssc,clk_scale_jitter,half_clk_time,clock_period_ps_resolved,clock_period_ssc_max_ps,clock_period_ssc_min_ps));
771                     `endif    
772                       endtask
773                     
774                       // Initial block
775                       // This loop generates the jittered tx clock when enable_clock_jitter is '1'
776                       int decimal_delta;
777                       int decimal_no_delta;
778                       bit whole_number,resolved_to_plus_one;
779                       initial begin
780                     `ifdef SVT_USB_JITTER_DEBUG_TRACE  
781                         file_handle = $fopen($sformatf(&quot;%m.txt&quot;),&quot;w&quot;);
782                     `endif    
783        1/1              while(1) begin
784        <font color = "red">1/2     ==>        wait(initialized == 1);</font>
785        <font color = "red">0/2     ==>        wait(enable_clock_jitter == 1 || enable_ssc == 1);</font>
786        <font color = "red">0/1     ==>        vip_tx_clk = 1;</font>
787        <font color = "red">0/1     ==>        kill_jitter_clock_gen = 0;</font>
788        <font color = "red">0/1     ==>        decimal_delta = (percentage_jitter*100);</font>
789        <font color = "red">0/1     ==>        decimal_no_delta = percentage_jitter;</font>
790        <font color = "red">0/1     ==>        decimal_no_delta = (decimal_no_delta*100);</font>
791        <font color = "red">0/1     ==>        percentage_jitter_local_decimal_cap = (decimal_delta - decimal_no_delta);</font>
792        <font color = "red">0/1     ==>        if(percentage_jitter_local_decimal_cap == 0) begin </font>
793        <font color = "red">0/1     ==>          whole_number = 1;</font>
794        <font color = "red">0/1     ==>          percentage_jitter_local_decimal_cap = 99; </font>
795                           end  
796        <font color = "red">0/1     ==>        else if(percentage_jitter_local_decimal_cap &lt; 0) begin </font>
797        <font color = "red">0/1     ==>          percentage_jitter_local_decimal_cap = 100 + percentage_jitter_local_decimal_cap;</font>
798        <font color = "red">0/1     ==>          resolved_to_plus_one = 1;</font>
799                           end 
800                           else begin
801                           end
802                           // If block to generate random jitter
803        <font color = "red">0/1     ==>        if(random_jitter_mode) begin</font>
804        <font color = "red">0/1     ==>          while(1) begin</font>
805                               // The usecase of random jitter is to introduce jitter in the clock between 0% to percentage_jitter% in the clock randomly which may be positive or negative.
806                               // Eg: if the user sets 2 as percentage_jitter, the output clock will introduce jitter in the range of 0% to 1.99% randomly as positive or neagative.
807                               // Randomize the jitter in the current clock as positive or negative
808        <font color = "red">0/1     ==>            positive_jitter_mode = $urandom();</font>
809                               // If percentage_jitter is set as 1 then the percenatge variation is from 0 - 0.99%. Bypass randomize.
810                               // Else the integral part is randomized between 0-'n-1' when percentage_jitter is n. 
811                               // The final jitter introduced will be 0% to &lt;n-1&gt;.99%
812                               // Assumption here is (also mentioned in SVDOC): In this mode when the user sets tha max cap jitter it has to be an integer.
813                               // Copy the percentage_jitter real number in an integer type for randomization.
814        <font color = "red">0/1     ==>            percentage_jitter_local_int = percentage_jitter;</font>
815        <font color = "red">0/1     ==>            if(whole_number || (!whole_number &amp;&amp; resolved_to_plus_one)) begin</font>
816        <font color = "red">0/1     ==>              percentage_jitter_local_int = percentage_jitter_local_int - 1;</font>
817                               end 
                   <font color = "red">==>  MISSING_ELSE</font>
818        <font color = "red">0/1     ==>            if(percentage_jitter_local_int &gt; 0) begin</font>
819        <font color = "red">0/1     ==>              percentage_jitter_local_int = $urandom_range(0,percentage_jitter_local_int);</font>
820                               end
821                               else begin
822        <font color = "red">0/1     ==>              percentage_jitter_local_int = 0;</font>
823                               end
824                               // Randomize the trailing decimal percentage.
825        <font color = "red">0/1     ==>            percentage_jitter_local_decimal = $urandom_range(0,percentage_jitter_local_decimal_cap);</font>
826                               // Construct the percenatge randomized as &quot;jitter = int + (dec/100)&quot;.
827                               // Eg: If interger randomized is '1' and decimal is 67 the final jitter becomes 1.67.
828        <font color = "red">0/1     ==>            percentage_jitter_local = percentage_jitter_local_decimal;</font>
829        <font color = "red">0/1     ==>            percentage_jitter_local = (percentage_jitter_local/100);</font>
830        <font color = "red">0/1     ==>            percentage_jitter_local = percentage_jitter_local_int + percentage_jitter_local;</font>
831                               // Generate jitter
832        <font color = "red">0/1     ==>            generate_jitter_clock(enable_clock_jitter,positive_jitter_mode,percentage_jitter_local);</font>
833                               // After every cycle check if the jitter mode is disabled to 'break'
834        <font color = "red">0/2     ==>            if(kill_jitter_clock_gen) break;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
835                             end
836                           end
837                           else begin
838        <font color = "red">0/1     ==>          while(1) begin</font>
839        <font color = "red">0/1     ==>            if(enable_clock_jitter) begin</font>
840                                 // Loop to generate constant jitter.
841                                 // In this mode all the values come from the user.
842                                 // Type of jitter (positive/ negative)
843                                 // Percentage jitter. (This can be in decimals unlike in Random mode)
844                                 // The cycle of generation i.e. number of pulse with jitter followed by the number without jitter
845        <font color = "red">0/1     ==>              repeat(number_of_clocks_with_jitter) begin</font>
846        <font color = "red">0/1     ==>                generate_jitter_clock(1,positive_jitter_mode,percentage_jitter);</font>
847                                 end
                   <font color = "red">==>  REPEAT_FALSE</font>
848        <font color = "red">0/2     ==>              if(kill_jitter_clock_gen) break;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
849        <font color = "red">0/1     ==>              repeat(number_of_clocks_without_jitter) begin</font>
850        <font color = "red">0/1     ==>                generate_jitter_clock(0,positive_jitter_mode,percentage_jitter);</font>
851                                 end
852                               end else begin
853        <font color = "red">0/1     ==>              generate_jitter_clock(0,positive_jitter_mode,percentage_jitter);</font>
854                               end
855                               // After every cycle check if the jitter mode is disabled to 'break'
856        <font color = "red">0/2     ==>            if(kill_jitter_clock_gen) break;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
857                             end
858                           end
859        <font color = "red">0/1     ==>        kill_jitter_clock_gen = 0;</font>
860                         end  
861                       end
862                     `ifndef SVT_USB_JITTER_CORRECTION_DISABLE  
863                       //---------------------------------------------------------------
864                       // CDR
865                       //---------------------------------------------------------------
866                     
867                       initial begin
868        1/1              feedback_toggle = 1;
869        1/1              feedback_toggle_tx = 1;
870        1/1              vip_rx_clk = 1;
871        1/1              data_flopped_0 = 0;
872        1/1              data_flopped_1 = 0;
873        1/1              data_flopped_2 = 0;
874        1/1              data_flopped_0_to_sample = 0;
875        1/1              data_flopped_1_to_sample = 0;
876        1/1              data_flopped_2_to_sample = 0;
877        1/1              data_flopped_to_sample = 0;
878        1/1              data_flopped_to_sample_n = 0;
879        1/1              data_flopped_0_tx = 0;
880        1/1              data_flopped_1_tx = 0;
881        1/1              data_flopped_2_tx = 0;
882        1/1              data_flopped_0_to_sample_tx = 0;
883        1/1              data_flopped_1_to_sample_tx = 0;
884        1/1              data_flopped_2_to_sample_tx = 0;
885        1/1              data_flopped_to_sample_tx = 0;
886        1/1              data_flopped_to_sample_n_tx = 0;
887                       end
888                     
889                       //--------------------------------------------------------------------------------------------------
890                       // This signal gives an active low signal every time there is a change in the incoming signal level
891                       //--------------------------------------------------------------------------------------------------
892                       assign edge_detect_active_low = ((!(data_flopped_0) &amp; !(data_flopped_1)) | (data_flopped_0 &amp; data_flopped_1 ));
893                       assign edge_detect_active_low_tx = ((!(data_flopped_0_tx) &amp; !(data_flopped_1_tx)) | (data_flopped_0_tx &amp; data_flopped_1_tx ));
894                       bit clock_divider_tx;
895                     
896                       always@(posedge (clk4x &amp; clock_gen_enable)) begin
897        <font color = "red">0/1     ==>      if(!enable_clock_jitter &amp;&amp; !enable_ssc &amp;&amp; !is_passive &amp;&amp; !tx_user_clock_enable) begin</font>
898        <font color = "red">0/2     ==>        if(clock_divider_tx) vip_tx_clk &lt;= !vip_tx_clk;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
899        <font color = "red">0/1     ==>        clock_divider_tx &lt;= !(clock_divider_tx);</font>
900                         end
                   <font color = "red">==>  MISSING_ELSE</font>
901                         // Ignore any data which is z or x.
902        <font color = "red">0/1     ==>      if(ssrxp === 1'bz || ssrxp === 1'bx) begin</font>
903        <font color = "red">0/1     ==>        data_flopped_0 &lt;= data_flopped_0;</font>
904                         end
905                         else begin
906        <font color = "red">0/1     ==>        data_flopped_0 &lt;= ssrxp;</font>
907                         end
908        <font color = "red">0/1     ==>      data_flopped_1 &lt;= data_flopped_0;</font>
909        <font color = "red">0/1     ==>      data_flopped_2 &lt;= data_flopped_1;</font>
910        <font color = "red">0/1     ==>      data_flopped_0_to_sample &lt;= {ssrxm,ssrxp};</font>
911        <font color = "red">0/1     ==>      data_flopped_1_to_sample &lt;= data_flopped_0_to_sample;</font>
912        <font color = "red">0/1     ==>      data_flopped_2_to_sample &lt;= data_flopped_1_to_sample;</font>
913        <font color = "red">0/1     ==>      data_flopped_to_sample &lt;= data_flopped_2_to_sample[0];</font>
914        <font color = "red">0/1     ==>      data_flopped_to_sample_n &lt;= data_flopped_2_to_sample[1];</font>
915        <font color = "red">0/1     ==>      if(is_passive) begin</font>
916        <font color = "red">0/1     ==>        if(sstxp === 1'bz || sstxm === 1'bx) begin</font>
917        <font color = "red">0/1     ==>          data_flopped_0_tx &lt;= data_flopped_0_tx;</font>
918                           end
919                           else begin
920        <font color = "red">0/1     ==>          data_flopped_0_tx &lt;= sstxp;</font>
921                           end
922        <font color = "red">0/1     ==>        data_flopped_1_tx &lt;= data_flopped_0_tx;</font>
923        <font color = "red">0/1     ==>        data_flopped_2_tx &lt;= data_flopped_1_tx;</font>
924        <font color = "red">0/1     ==>        data_flopped_0_to_sample_tx &lt;= {sstxm,sstxp};</font>
925        <font color = "red">0/1     ==>        data_flopped_1_to_sample_tx &lt;= data_flopped_0_to_sample_tx;</font>
926        <font color = "red">0/1     ==>        data_flopped_2_to_sample_tx &lt;= data_flopped_1_to_sample_tx;</font>
927        <font color = "red">0/1     ==>        data_flopped_to_sample_tx &lt;= data_flopped_2_to_sample_tx[0];</font>
928        <font color = "red">0/1     ==>        data_flopped_to_sample_n_tx &lt;= data_flopped_2_to_sample_tx[1];</font>
929                         end
                   <font color = "red">==>  MISSING_ELSE</font>
930                         // Feedback toggle keeps on toggling for every posedge of reference clock.
931                         // The edge detect signal going low forces the feedback_toggle to go low. This can be considered a phase reset.
932                         // If the incoming serial data is without jitters the moment edge_detect_active_low is low feedback_toggle is also low.
933                         // So the next clock of ref_clk will give a high pulse as feedback_toggle changes and edge_detect_active_low goes high.
934                         // The next pulse goes low as the feedback toggle changes with no change in edge_detect_active_low.
935                         // Since ref_clk is 4 times the clock rate there will be 4 samples of 1 bit.
936                         // The sync is such that the feedback_toggle on no jitter will go 1 0 1 0.
937                         //
938                         // feedback_toggle_next feedback_toggle edge_detect_active_low
939                         //         1                   0                  1
940                         //         0                   1                  1
941                         //         1                   0                  1
942                         //         0                   1                  0
943                         //
944                         // This cycle repeats itself 
945                         // If there is jitter on the line then the edge_detect_active_low will either pulled in by a clock or pulled out by a clock.
946                         // This shifts the pll_clk pulse by 3 clock to the right or to the left
947        <font color = "red">0/1     ==>      feedback_toggle &lt;= !(feedback_toggle) &amp; edge_detect_active_low;</font>
948        <font color = "red">0/1     ==>      vip_rx_clk &lt;= (feedback_toggle ^ vip_rx_clk) &amp; edge_detect_active_low;</font>
949        <font color = "red">0/1     ==>      if(is_passive) begin</font>
950        <font color = "red">0/1     ==>        feedback_toggle_tx &lt;= !(feedback_toggle_tx) &amp; edge_detect_active_low_tx;</font>
951        <font color = "red">0/1     ==>        vip_tx_clk &lt;= (feedback_toggle_tx ^ vip_tx_clk) &amp; edge_detect_active_low_tx;</font>
952                         end
                   <font color = "red">==>  MISSING_ELSE</font>
953                       end
954                     `endif
955                       bit ss_data_prev;
956                       initial begin
957                         realtime t0,t1;
958        <font color = "red">1/2     ==>      wait(clock_ui_jitter_check == 1);</font>
959        <font color = "red">0/1     ==>      t0 = $realtime();</font>
960        <font color = "red">0/2     ==>      #1fs;</font>
961        <font color = "red">0/1     ==>      t1 = $realtime();</font>
962        <font color = "red">0/1     ==>      if(!(t1 &gt; t0)) begin</font>
963        <font color = "red">0/1     ==>        $display(&quot;ERROR: Timescale is not 1fs, UI checks not possible.&quot;);</font>
964                         end
                   <font color = "red">==>  MISSING_ELSE</font>
965                       end
966                     
967                       real count_max, count_min,timestamp,timestamp_gap,timestamp_current;
968                       event event_error_UI;
969                       reg ss_data;
970                       always@(*) begin
971        <font color = "red">0/2     ==>      wait(clock_ui_jitter_check == 1);</font>
972        <font color = "red">0/1     ==>      ss_data = (is_passive)? sstxp: ssrxp;</font>
973                       end
974                     
975                       initial begin
976        <font color = "red">1/2     ==>      wait(clock_ui_jitter_check == 1);</font>
977        <font color = "red">0/1     ==>      while(1) begin</font>
978                           fork begin
979                             fork
980                             begin
981        <font color = "red">0/1     ==>            while(1) begin</font>
982        <font color = "red">0/1     ==>              if(!mode_ssp) begin</font>
983        <font color = "red">0/2     ==>                #200ps;</font>
984        <font color = "red">0/1     ==>                count_max = count_max + 200.06;</font>
985        <font color = "red">0/1     ==>                count_min = count_min + 199.94;</font>
986                                 end else begin
987        <font color = "red">0/2     ==>                #100ps;</font>
988        <font color = "red">0/1     ==>                count_max = count_max + 100.03;</font>
989        <font color = "red">0/1     ==>                count_min = count_min +  99.97;</font>
990                                 end
991                               end
992                             end
993                             begin
994        <font color = "red">0/2     ==>            @(ss_data);</font>
995                             end
996                             join_any
997        <font color = "red">0/1     ==>          disable fork;</font>
998                           end join_any
999        <font color = "red">0/1     ==>        timestamp = timestamp_current;</font>
1000       <font color = "red">0/1     ==>        timestamp_current = $realtime;</font>
1001       <font color = "red">0/1     ==>        timestamp_gap = (timestamp_current - timestamp);</font>
1002       <font color = "red">0/1     ==>        if(!(timestamp_gap &gt; count_min &amp;&amp; timestamp_gap &lt; count_max)) begin</font>
1003       <font color = "red">0/1     ==>          -&gt; event_error_UI;</font>
1004                          end
                   <font color = "red">==>  MISSING_ELSE</font>
1005       <font color = "red">0/2     ==>        #1ps;</font>
1006       <font color = "red">0/1     ==>        if(!mode_ssp) begin</font>
1007       <font color = "red">0/1     ==>          count_max = 200.06;</font>
1008       <font color = "red">0/1     ==>          count_min = 199.94;</font>
1009                          end else begin
1010       <font color = "red">0/1     ==>          count_max = 100.03;</font>
1011       <font color = "red">0/1     ==>          count_min =  99.97;</font>
</pre>
<hr>
<a name="inst_tag_25394_Cond"></a>
<b>Cond Coverage for Instance : <a href="mod311.html#inst_tag_25394" >config_ss_tb.config_ss_env_intf.dev_usb_if.usb_ss_serial_if</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s0"><td class="lf">Conditions</td><td>19</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">Logical</td><td>19</td><td>0</td><td>0.00</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       677
 EXPRESSION (((!enable_clock_jitter)) &amp;&amp; ((!enable_ssc)))
             ------------1-----------    -------2-------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       785
 EXPRESSION ((enable_clock_jitter == 1'b1) || (enable_ssc == 1'b1))
             --------------1--------------    ----------2---------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       815
 EXPRESSION (whole_number || (((!whole_number)) &amp;&amp; resolved_to_plus_one))
             ------1-----    ---------------------2---------------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       815
 SUB-EXPRESSION (((!whole_number)) &amp;&amp; resolved_to_plus_one)
                 --------1--------    ----------2---------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       897
 EXPRESSION (((!enable_clock_jitter)) &amp;&amp; ((!enable_ssc)) &amp;&amp; ((!is_passive)) &amp;&amp; ((!tx_user_clock_enable)))
             ------------1-----------    -------2-------    -------3-------    ------------4------------
</pre>
<table class="noborder">
<col span="4" width="40">
<tr><th>-1-</th><th>-2-</th><th>-3-</th><th>-4-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       972
 EXPRESSION (is_passive ? sstxp : ssrxp)
             -----1----
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<hr>
<a name="inst_tag_25394_Branch"></a>
<b>Branch Coverage for Instance : <a href="mod311.html#inst_tag_25394" >config_ss_tb.config_ss_env_intf.dev_usb_if.usb_ss_serial_if</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s0">
<td>Branches</td>
<td></td>
<td class="rt">44</td>
<td class="rt">3</td>
<td class="rt">6.82  </td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">393</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">547</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s3">
<td>IF</td>
<td class="rt">554</td>
<td class="rt">3</td>
<td class="rt">1</td>
<td class="rt">33.33 </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">664</td>
<td class="rt">3</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">669</td>
<td class="rt">4</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">708</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">715</td>
<td class="rt">3</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">792</td>
<td class="rt">3</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">803</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">897</td>
<td class="rt">3</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">902</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">915</td>
<td class="rt">3</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">949</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">962</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>TERNARY</td>
<td class="rt">972</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">982</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">1002</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">1006</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
393            if(initialized) initialize_ssc_parameters;
               <font color = "red">-1-</font>  
           <font color = "red">    ==></font>
               MISSING_ELSE
           <font color = "green">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
547            if (vbus !== 1'b1) begin
               <font color = "red">-1-</font>  
548              dut_ss_termination_reg = 0;  // Assume no DUT SS RX termination when VBUS is absent
           <font color = "green">      ==></font>
549            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
554            if (dut_ss_termination === 1'b0) begin
               <font color = "red">-1-</font>  
555              dut_ss_termination_reg = 0;  // No DUT SS RX termination - signaled by TB
           <font color = "red">      ==></font>
556            end else if (vbus !== 1'b1) begin
                        <font color = "red">-2-</font>  
557              dut_ss_termination_reg = 0;  // No DUT SS RX termination - VBUS is absent
           <font color = "green">      ==></font>
558            end else begin
559              dut_ss_termination_reg = 1;  // DUT SS RX termination in place
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
664            if(ess_operating_rate == 2'b00) begin
               <font color = "red">-1-</font>  
665              if(clock_divider) clock5GHz = !(clock5GHz);
                 <font color = "red">-2-</font>  
           <font color = "red">      ==></font>
                 MISSING_ELSE
           <font color = "red">      ==></font>
666              clock_divider = !(clock_divider);
667            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
669            if (clock_recovery_enable === 1'b1) begin 
               <font color = "red">-1-</font>  
670              // When ess_operating rate is 1 then pass the ssclk which is generating in top 
671              // Else pass clock5GHz(3.0) local generated clock 
672              clk4x = (ess_operating_rate === 2'b01) ? ssclk : clock5GHz; 
           <font color = "red">      ==></font>
673            end
674            else begin 
675              // When ess_operating rate is 1 then pass the ssclk which is generating in top 
676              // Else pass clock5GHz(3.0) local generated clock 
677              if(!enable_clock_jitter && !enable_ssc) begin 
                 <font color = "red">-2-</font>  
678        `ifndef SVT_USB_JITTER_CORRECTION_DISABLE
679                if(ess_operating_rate === 2'b01) begin
                   <font color = "red">-3-</font>  
680                  vip_tx_clk = ssclk; 
           <font color = "red">          ==></font>
681                  vip_rx_clk = ssclk; 
682                end
683                else begin
684                  vip_tx_clk = clock5GHz; 
           <font color = "red">          ==></font>
685                  vip_rx_clk = clock5GHz; 
686                end
687        `else
688                vip_tx_clk = (ess_operating_rate === 2'b01) ? ssclk : clock5GHz; 
689        `endif        
690              end  
                 MISSING_ELSE
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
708            if(tx_user_clock_enable === 1)
               <font color = "red">-1-</font>  
709              vip_tx_clk = ssclk_tx;
           <font color = "red">      ==></font>
                 MISSING_ELSE
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
715            if(enable_clock_jitter) begin
               <font color = "red">-1-</font>  
           <font color = "red">    ==></font>
716            end
717            else begin
718              if(kill_jitter_clock_gen == 0) begin
                 <font color = "red">-2-</font>  
719                kill_jitter_clock_gen = 1;
           <font color = "red">        ==></font>
720                wait(kill_jitter_clock_gen == 0);
721              end
                 MISSING_ELSE
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
792              if(percentage_jitter_local_decimal_cap == 0) begin 
                 <font color = "red">-1-</font>  
793                whole_number = 1;
794                percentage_jitter_local_decimal_cap = 99; 
795              end  
796              else if(percentage_jitter_local_decimal_cap < 0) begin 
                      <font color = "red">-2-</font>  
           <font color = "red">      ==></font>
           <font color = "red">      ==></font>
797                percentage_jitter_local_decimal_cap = 100 + percentage_jitter_local_decimal_cap;
           <font color = "red">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
803              if(random_jitter_mode) begin
                 <font color = "red">-1-</font>  
804                while(1) begin
           <font color = "red">        ==></font>
805                  // The usecase of random jitter is to introduce jitter in the clock between 0% to percentage_jitter% in the clock randomly which may be positive or negative.
806                  // Eg: if the user sets 2 as percentage_jitter, the output clock will introduce jitter in the range of 0% to 1.99% randomly as positive or neagative.
807                  // Randomize the jitter in the current clock as positive or negative
808                  positive_jitter_mode = $urandom();
809                  // If percentage_jitter is set as 1 then the percenatge variation is from 0 - 0.99%. Bypass randomize.
810                  // Else the integral part is randomized between 0-'n-1' when percentage_jitter is n. 
811                  // The final jitter introduced will be 0% to <n-1>.99%
812                  // Assumption here is (also mentioned in SVDOC): In this mode when the user sets tha max cap jitter it has to be an integer.
813                  // Copy the percentage_jitter real number in an integer type for randomization.
814                  percentage_jitter_local_int = percentage_jitter;
815                  if(whole_number || (!whole_number && resolved_to_plus_one)) begin
816                    percentage_jitter_local_int = percentage_jitter_local_int - 1;
817                  end 
818                  if(percentage_jitter_local_int > 0) begin
819                    percentage_jitter_local_int = $urandom_range(0,percentage_jitter_local_int);
820                  end
821                  else begin
822                    percentage_jitter_local_int = 0;
823                  end
824                  // Randomize the trailing decimal percentage.
825                  percentage_jitter_local_decimal = $urandom_range(0,percentage_jitter_local_decimal_cap);
826                  // Construct the percenatge randomized as "jitter = int + (dec/100)".
827                  // Eg: If interger randomized is '1' and decimal is 67 the final jitter becomes 1.67.
828                  percentage_jitter_local = percentage_jitter_local_decimal;
829                  percentage_jitter_local = (percentage_jitter_local/100);
830                  percentage_jitter_local = percentage_jitter_local_int + percentage_jitter_local;
831                  // Generate jitter
832                  generate_jitter_clock(enable_clock_jitter,positive_jitter_mode,percentage_jitter_local);
833                  // After every cycle check if the jitter mode is disabled to 'break'
834                  if(kill_jitter_clock_gen) break;
835                end
836              end
837              else begin
838                while(1) begin
           <font color = "red">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
897            if(!enable_clock_jitter && !enable_ssc && !is_passive && !tx_user_clock_enable) begin
               <font color = "red">-1-</font>  
898              if(clock_divider_tx) vip_tx_clk <= !vip_tx_clk;
                 <font color = "red">-2-</font>  
           <font color = "red">      ==></font>
                 MISSING_ELSE
           <font color = "red">      ==></font>
899              clock_divider_tx <= !(clock_divider_tx);
900            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
902            if(ssrxp === 1'bz || ssrxp === 1'bx) begin
               <font color = "red">-1-</font>  
903              data_flopped_0 <= data_flopped_0;
           <font color = "red">      ==></font>
904            end
905            else begin
906              data_flopped_0 <= ssrxp;
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
915            if(is_passive) begin
               <font color = "red">-1-</font>  
916              if(sstxp === 1'bz || sstxm === 1'bx) begin
                 <font color = "red">-2-</font>  
917                data_flopped_0_tx <= data_flopped_0_tx;
           <font color = "red">        ==></font>
918              end
919              else begin
920                data_flopped_0_tx <= sstxp;
           <font color = "red">        ==></font>
921              end
922              data_flopped_1_tx <= data_flopped_0_tx;
923              data_flopped_2_tx <= data_flopped_1_tx;
924              data_flopped_0_to_sample_tx <= {sstxm,sstxp};
925              data_flopped_1_to_sample_tx <= data_flopped_0_to_sample_tx;
926              data_flopped_2_to_sample_tx <= data_flopped_1_to_sample_tx;
927              data_flopped_to_sample_tx <= data_flopped_2_to_sample_tx[0];
928              data_flopped_to_sample_n_tx <= data_flopped_2_to_sample_tx[1];
929            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
949            if(is_passive) begin
               <font color = "red">-1-</font>  
950              feedback_toggle_tx <= !(feedback_toggle_tx) & edge_detect_active_low_tx;
           <font color = "red">      ==></font>
951              vip_tx_clk <= (feedback_toggle_tx ^ vip_tx_clk) & edge_detect_active_low_tx;
952            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
962            if(!(t1 > t0)) begin
               <font color = "red">-1-</font>  
963              $display("ERROR: Timescale is not 1fs, UI checks not possible.");
           <font color = "red">      ==></font>
964            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
972            ss_data = (is_passive)? sstxp: ssrxp;
                                     <font color = "red">-1-</font>  
                                     <font color = "red">==></font>  
                                     <font color = "red">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
982                    if(!mode_ssp) begin
                       <font color = "red">-1-</font>  
983                      #200ps;
           <font color = "red">              ==></font>
984                      count_max = count_max + 200.06;
985                      count_min = count_min + 199.94;
986                    end else begin
987                      #100ps;
           <font color = "red">              ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1002             if(!(timestamp_gap > count_min && timestamp_gap < count_max)) begin
                 <font color = "red">-1-</font>  
1003               -> event_error_UI;
           <font color = "red">        ==></font>
1004             end
                 MISSING_ELSE
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1006             if(!mode_ssp) begin
                 <font color = "red">-1-</font>  
1007               count_max = 200.06;
           <font color = "red">        ==></font>
1008               count_min = 199.94;
1009             end else begin
1010               count_max = 100.03;
           <font color = "red">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
</div>
<div name='inst_tag_25395'>
<a name="inst_tag_25395_Line"></a>
<b>Line Coverage for Instance : <a href="mod311.html#inst_tag_25395" >config_ss_tb.config_ss_env_intf.dev_usb_if.usb_ss_serial_lane1_if</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s1"><td class="lf">TOTAL</td><td></td><td>217</td><td>39</td><td>17.97</td></tr>
<tr class="s2"><td class="lf">INITIAL</td><td>349</td><td>4</td><td>1</td><td>25.00</td></tr>
<tr class="s0"><td class="lf">ROUTINE</td><td>356</td><td>19</td><td>0</td><td>0.00</td></tr>
<tr class="s5"><td class="lf">ALWAYS</td><td>393</td><td>2</td><td>1</td><td>50.00</td></tr>
<tr class="s10"><td class="lf">INITIAL</td><td>543</td><td>7</td><td>7</td><td>100.00</td></tr>
<tr class="s6"><td class="lf">ALWAYS</td><td>554</td><td>5</td><td>3</td><td>60.00</td></tr>
<tr class="s10"><td class="lf">INITIAL</td><td>569</td><td>1</td><td>1</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">INITIAL</td><td>578</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s0"><td class="lf">ALWAYS</td><td>664</td><td>12</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">ALWAYS</td><td>708</td><td>2</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">ALWAYS</td><td>715</td><td>5</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">ROUTINE</td><td>732</td><td>24</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">INITIAL</td><td>783</td><td>45</td><td>2</td><td>4.44</td></tr>
<tr class="s10"><td class="lf">INITIAL</td><td>868</td><td>19</td><td>19</td><td>100.00</td></tr>
<tr class="s0"><td class="lf">ALWAYS</td><td>897</td><td>30</td><td>0</td><td>0.00</td></tr>
<tr class="s1"><td class="lf">INITIAL</td><td>958</td><td>8</td><td>1</td><td>12.50</td></tr>
<tr class="s0"><td class="lf">ALWAYS</td><td>971</td><td>3</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">INITIAL</td><td>976</td><td>28</td><td>1</td><td>3.57</td></tr>
</table>
<pre class="code"><br clear=all>
348                         // Wait for all values to be loaded for the calculation
349        <font color = "red">1/2     ==>      wait(initialized == 1);</font>
350        <font color = "red">0/1     ==>      clock_gen_enable = 1;</font>
351        <font color = "red">0/1     ==>      initialize_ssc_parameters;</font>
352                       end
353                     
354                       task initialize_ssc_parameters;
355                         // Load the value of clock period
356        <font color = "red">0/1     ==>      clock_period_ps_resolved = clock_period_ps;</font>
357                         // Set the ssc direction as 1 to start
358        <font color = "red">0/1     ==>      ssc_direction = 1;</font>
359                         // Convert ppm to fraction
360        <font color = "red">0/1     ==>      if(ssc_down_spread_mode) begin</font>
361        <font color = "red">0/1     ==>        max_ssc_ppm_shift = (ssc_deviation_ppm/real'(1000000));</font>
362                         end else begin 
363        <font color = "red">0/1     ==>        max_ssc_ppm_shift = ((ssc_deviation_ppm+ssc_deviation_pos_ppm)/real'(1000000));</font>
364        <font color = "red">0/1     ==>        ssc_ppm_shift_neg = ((ssc_deviation_ppm)/real'(1000000));</font>
365        <font color = "red">0/1     ==>        ssc_ppm_shift_pos = ((ssc_deviation_pos_ppm)/real'(1000000));</font>
366                         end  
367                         // Scale KHz value to Hz
368        <font color = "red">0/1     ==>      ssc_spread_frequency_scaled = ssc_spread_frequency*1000;</font>
369                         // Calculate time period and scale by 10^6 to the us domain.
370        <font color = "red">0/1     ==>      ssc_spread_time_period = (1/ssc_spread_frequency_scaled);</font>
371        <font color = "red">0/1     ==>      ssc_spread_time_period = ssc_spread_time_period * (1000000);</font>
372                         // Scale the clock timeperiod from ps to us
373        <font color = "red">0/1     ==>      clock_period_ps_scaled = (clock_period_ps/1000000);</font>
374                         // Divide the period for ssc with the period for clock to find the number to ticks to reach max ppm and back.
375        <font color = "red">0/1     ==>      ssc_num_steps = (ssc_spread_time_period/clock_period_ps_scaled);</font>
376                         // For downspread the frequency has to reach max ppm and back. So to reach max halving the value
377        <font color = "red">0/1     ==>      ssc_num_steps = ssc_num_steps/2;</font>
378                         // For each step the clock period will change by the (max shift to reach in fraction), divided by the number of ticks to reach in (calculated above), multiply the clock period
379        <font color = "red">0/1     ==>      ssc_ppm_step =  (max_ssc_ppm_shift/real'(ssc_num_steps))*clock_period_ps;</font>
380                         // The max clock period that can be generated is the clock period + the max ppm shift
381                         // For down spread the min is the actual clock period
382        <font color = "red">0/1     ==>      if(ssc_down_spread_mode) begin</font>
383        <font color = "red">0/1     ==>        clock_period_ssc_max_ps = clock_period_ps + (clock_period_ps*max_ssc_ppm_shift);</font>
384        <font color = "red">0/1     ==>        clock_period_ssc_min_ps = clock_period_ps;</font>
385                         end else begin
386        <font color = "red">0/1     ==>        clock_period_ssc_max_ps = clock_period_ps + (clock_period_ps*ssc_ppm_shift_neg);</font>
387        <font color = "red">0/1     ==>        clock_period_ssc_min_ps = clock_period_ps - (clock_period_ps*ssc_ppm_shift_pos);</font>
388                         end
389                       endtask
390                     
391                       // If the port were to fallback aor change clock rate the ssc calucations need to be made again
392                       always@(ess_operating_rate or clock_period_ps) begin
393        <font color = "red">1/2     ==>      if(initialized) initialize_ssc_parameters;</font>
                        MISSING_ELSE
394                       end
395                     
396                     //-----------------------------------------------------------------------
397                     /**
398                      * Clocking block that defines VIP USB PHYSICAL's SS Serial Tx Link
399                      * Interface signal synchronization and directionality, for the
400                      * SS wires.
401                      */
402                     clocking usb_ss_serial_phy_tx_cb @(posedge vip_tx_clk);
403                     `ifdef SVT_USB_IF_NO_PARAMS
404                       default input #(`SVT_USB_SS_SERIAL_IF_SETUP_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(`SVT_USB_SS_SERIAL_IF_HOLD_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
405                     `else
406                       default input #(setup_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(hold_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
407                     `endif
408                       output sstxp;
409                       output sstxm;
410                     endclocking
411                     
412                     //-----------------------------------------------------------------------
413                     /**
414                      * Clocking block that defines VIP USB PHYSICAL's SS Serial Tx Link
415                      * Interface signal for monitor.
416                      */
417                     clocking usb_ss_serial_phy_tx_monitor_cb @(posedge vip_tx_clk);
418                     `ifdef SVT_USB_IF_NO_PARAMS
419                       default input #(`SVT_USB_SS_SERIAL_IF_SETUP_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(`SVT_USB_SS_SERIAL_IF_HOLD_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
420                     `else
421                       default input #(setup_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(hold_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
422                     `endif
423                       input sstxp;
424                       input sstxm;
425                     `ifndef SVT_USB_JITTER_CORRECTION_DISABLE  
426                       input data_flopped_to_sample_tx;
427                       input data_flopped_to_sample_n_tx;
428                     `endif  
429                     endclocking
430                     
431                     
432                     //-----------------------------------------------------------------------
433                     /**
434                      * Clocking block that defines VIP USB PHYSICAL's SS Serial Rx Link
435                      * Interface signal synchronization and directionality, for the
436                      * SS wires.
437                      */
438                     clocking usb_ss_serial_phy_rx_cb @(posedge vip_rx_clk);
439                     `ifdef SVT_USB_IF_NO_PARAMS
440                       default input #(`SVT_USB_SS_SERIAL_IF_SETUP_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(`SVT_USB_SS_SERIAL_IF_HOLD_TIME*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
441                     `else
442                       default input #(setup_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER) output #(hold_time*`SVT_USB_IF_TIMESCALE_MULTIPLIER);
443                     `endif
444                       input ssrxp;
445                       input ssrxm;
446                     `ifndef SVT_USB_JITTER_CORRECTION_DISABLE  
447                       input data_flopped_to_sample;
448                       input data_flopped_to_sample_n;
449                     `endif  
450                     endclocking
451                     
452                     //-----------------------------------------------------------------------
453                     // USB SS Serial Modports
454                     //-----------------------------------------------------------------------
455                     
456                     //-----------------------------------------------------------------------
457                     /** Modport used to connect VIP USB PHYSICAL to USB SS SERIAL interface signals from the link direction. */
458                     modport svt_usb_ss_serial_phy_port(
459                       clocking usb_ss_serial_phy_tx_cb, clocking usb_ss_serial_phy_rx_cb, output vbus, input dut_ss_termination, output vip_ss_termination);
460                     
461                     //-----------------------------------------------------------------------
462                     /** Modport used to connect VIP USB PHYSICAL to USB SS SERIAL interface signals from the PHY direction. */
463                     modport svt_usb_ss_serial_cable_port(
464                       input sstxp,
465                       input sstxm,
466                       output ssrxp,
467                       output ssrxm,
468                       input vbus,
469                       output dut_ss_termination,
470                       input vip_ss_termination
471                       );
472                     
473                     //-----------------------------------------------------------------------
474                     /** Modport used to monitor VIP USB SS serial interface signals. */
475                     modport svt_usb_ss_serial_phy_monitor_port(
476                       clocking usb_ss_serial_phy_tx_monitor_cb, clocking usb_ss_serial_phy_rx_cb, input vbus, input dut_ss_termination, input vip_ss_termination);
477                     
478                     task wait_for_hold_drive();
479                       #(hold_time_scaled + 1);
480                     endtask
481                     
482                     `ifndef __SVDOC__
483                     //-----------------------------------------------------------------------
484                     // USB SS Serial Interface Control Assigns
485                     //-----------------------------------------------------------------------
486                     
487                       //---------------------------------------------------------------------
488                       // Additions for receiver detection
489                       //---------------------------------------------------------------------
490                       assign vip_ss_termination = vip_ss_termination_reg;
491                     
492                       //-------------------------------------------------------------------------
493                       // Additions for VBUS
494                       //-------------------------------------------------------------------------
495                       assign vbus = vbus_reg;
496                     
497                       //-----------------------------------------------------------------------
498                       // Additions for Clock_Recovery
499                       //-----------------------------------------------------------------------
500                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE
501                       // Detect differential receiver value
502                       assign data_in = ((ssrxp === 1'bz) || (ssrxp === 1'bx)) ? 1'b0 :
503                                        ((ssrxm === 1'bz) || (ssrxm === 1'bx)) ? 1'b0 : ssrxp;
504                     
505                       // Use the unfiltered transmit clock whenever the DPLL is not ready
506                       assign pll_disable = (rec_clk_valid !== 1'b1) ? 1'b1 : 1'b0;
507                     `endif
508                       // Filter the output clock as per mode (normal vs. clock recovery)
509                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE  
510                       assign vip_rx_clk = (clock_recovery_enable === 1'b1) ? rec_clk_out : (ess_operating_rate === 2'b01) ? ssclk : clock5GHz;
511                     `endif
512                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE
513                       // Output clock for the VIP is from the recovered clock
514                       assign rec_clk_out = (pll_rec_clk | pll_sync_clk);
515                     
516                       // When the VIP is transmitting, or the PLL is disabled, disable the recovery of clock
517                       assign phase_rst = ((pll_disable) |
518                                           ((((data_phase_2 | !data_phase_3) &amp; (!data_phase_2 | data_phase_3)) | (int_se0))));
519                       // SE0 detection
520                       assign se0_detect = ((ssrxp === 1'bz) || (ssrxp === 1'bx)) ? 1'b0 :
521                                           ((ssrxm === 1'bz) || (ssrxm === 1'bx)) ? 1'b0 : (!(ssrxp | ssrxm));
522                     
523                       // Phase detection
524                       assign phase_det = (feed_back ^ pll_clk);
525                     
526                       // Clock extraction
527                       assign extract_clk = (phase_det &amp; phase_rst &amp; ~extract_clk_reg);
528                     
529                       // Clock valid condition
530                       assign rec_clk_valid = (pll_reset === 1'b0) ? 1'b1 : 1'b0;
531                     `endif
532                     
533                     //-----------------------------------------------------------------------
534                     // USB SS Serial Interface Control Processes
535                     //-----------------------------------------------------------------------
536                     
537                       //-----------------------------------------------------------------------
538                       // Additions for receiver detection
539                       //-----------------------------------------------------------------------
540                     
541                       // Initialize all registers
542                       initial begin
543        1/1              ess_operating_rate =  2'b01;
544        1/1              dut_ss_termination_reg = 1;  // Assume DUT SS RX termination in place
545        1/1              vip_ss_termination_reg = 0;  // Assume VIP SS RX termination not in place
546        2/2              #1;
547        1/1              if (vbus !== 1'b1) begin
548        1/1                dut_ss_termination_reg = 0;  // Assume no DUT SS RX termination when VBUS is absent
549                         end
                   <font color = "red">==>  MISSING_ELSE</font>
550                       end
551                     
552                       // Sample changes on the DUT termination signal
553                       always @ (dut_ss_termination or vbus) begin
554        1/1              if (dut_ss_termination === 1'b0) begin
555        <font color = "red">0/1     ==>        dut_ss_termination_reg = 0;  // No DUT SS RX termination - signaled by TB</font>
556        1/1              end else if (vbus !== 1'b1) begin
557        1/1                dut_ss_termination_reg = 0;  // No DUT SS RX termination - VBUS is absent
558                         end else begin
559        <font color = "red">0/1     ==>        dut_ss_termination_reg = 1;  // DUT SS RX termination in place</font>
560                         end
561                       end
562                     
563                       //-----------------------------------------------------------------------
564                       // Additions for VBUS
565                       //-----------------------------------------------------------------------
566                     
567                       // Initialize VBUS drive off
568                       initial begin
569        1/1              vbus_reg = 1'bz;  // Assume VIP not started
570                       end
571                     
572                       //-----------------------------------------------------------------------
573                       // Additions for Clock_Recovery
574                       //-----------------------------------------------------------------------
575                     
576                       // Initialize all registers
577                       initial begin
578        1/1              clk4x           = 1'b0;
579        1/1              vip_tx_clk      = 1'b0;
580                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE    
581                         clk2x           = 1'b0;
582                         data_phase_0    = 1'b0;
583                         data_phase_1    = 1'b0;
584                         data_phase_2    = 1'b0;
585                         data_phase_3    = 1'b0;
586                         dpdm_phase_0    = 1'b0;
587                         int_se0         = 1'b0;
588                         extract_clk_reg = 1'b0;
589                         feed_back       = 1'b0;
590                         pll_clk         = 1'b0;
591                         pll_rec_clk     = 1'b0;
592                         pll_reset       = 1'b1;
593                         pll_sync_clk    = 1'b0;
594                         saw_sync_clk    = 1'b0;
595                     `endif    
596        1/1              clock5GHz       = 1'b0;
597                       end
598                     
599                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE
600                       // Reset the DPLL at startup
601                       initial begin
602                         @(posedge ssclk);
603                         @(posedge ssclk);
604                         pll_reset = 0;
605                       end
606                     
607                       // Code to generate the initial recovered clock edge during the first SYNC bit
608                       always @ (posedge clk4x) begin
609                         pll_sync_clk &lt;= 1'b0;
610                       end
611                       // Generation of control signals
612                       always @ (posedge clk4x) begin
613                         data_phase_0 &lt;= data_in;
614                         data_phase_1 &lt;= data_phase_0;
615                         data_phase_2 &lt;= data_phase_1;
616                         data_phase_3 &lt;= data_phase_2;
617                         dpdm_phase_0 &lt;= se0_detect;
618                         int_se0 &lt;= dpdm_phase_0 &amp;&amp; (int_se0 || se0_detect);
619                         extract_clk_reg &lt;= phase_det &amp; phase_rst;
620                       end
621                     
622                       // Generation of feedback
623                       always @ (posedge clk4x) begin
624                         if (pll_reset) begin
625                           feed_back &lt;= 1'b1;
626                         end
627                         else begin
628                           feed_back &lt;= (!feed_back) &amp; phase_rst;
629                         end
630                       end
631                     
632                       // Generation of clock
633                       always @ (posedge clk4x) begin
634                         if (pll_reset) begin
635                           pll_clk &lt;= 1'b1;
636                         end
637                         else begin
638                           pll_clk &lt;= phase_det &amp; phase_rst;
639                         end
640                       end
641                     
642                       // Generation of recovered clock
643                       always @ (posedge clk4x) begin
644                         if (pll_reset) begin
645                           pll_rec_clk &lt;= 1'b0;
646                         end
647                         else begin
648                           pll_rec_clk &lt;= extract_clk;
649                         end
650                       end
651                     `endif  
652                     
653                       //-------------------------------------------------------------------------
654                       // Generates the TX clock based on the clock_recovery_enable setting
655                       //-------------------------------------------------------------------------
656                       bit clock_divider;
657                     
658                       // When clock recovery is disabled, the VIP TX clock is the input clock
659                       //--------------------------------------------------------------------------
660                       always @ (ssclk) begin 
661                         // Only if operating rate is 2'b00 generate the clock5GHz clock.
662                         // If VIP starts in SS mode the clock ss is anyway expected to be 5G.
663                         // If VIP starts in SSP mode the clock 5G is only required for fallback which reflected in ess_operating_rate as 2'b00
664        <font color = "red">0/1     ==>      if(ess_operating_rate == 2'b00) begin</font>
665        <font color = "red">0/2     ==>        if(clock_divider) clock5GHz = !(clock5GHz);</font>
                   <font color = "red">==>  MISSING_ELSE</font>
666        <font color = "red">0/1     ==>        clock_divider = !(clock_divider);</font>
667                         end
                   <font color = "red">==>  MISSING_ELSE</font>
668                         // if clock recovery is enabled, the vip tx clock is generated by dividing the 4x clock by a factor of 4.
669        <font color = "red">0/1     ==>      if (clock_recovery_enable === 1'b1) begin </font>
670                           // When ess_operating rate is 1 then pass the ssclk which is generating in top 
671                           // Else pass clock5GHz(3.0) local generated clock 
672        <font color = "red">0/1     ==>        clk4x = (ess_operating_rate === 2'b01) ? ssclk : clock5GHz; </font>
673                         end
674                         else begin 
675                           // When ess_operating rate is 1 then pass the ssclk which is generating in top 
676                           // Else pass clock5GHz(3.0) local generated clock 
677        <font color = "red">0/1     ==>        if(!enable_clock_jitter &amp;&amp; !enable_ssc) begin </font>
678                     `ifndef SVT_USB_JITTER_CORRECTION_DISABLE
679        <font color = "red">0/1     ==>          if(ess_operating_rate === 2'b01) begin</font>
680        <font color = "red">0/1     ==>            vip_tx_clk = ssclk; </font>
681        <font color = "red">0/1     ==>            vip_rx_clk = ssclk; </font>
682                             end
683                             else begin
684        <font color = "red">0/1     ==>            vip_tx_clk = clock5GHz; </font>
685        <font color = "red">0/1     ==>            vip_rx_clk = clock5GHz; </font>
686                             end
687                     `else
688                             vip_tx_clk = (ess_operating_rate === 2'b01) ? ssclk : clock5GHz; 
689                     `endif        
690                           end  
                   <font color = "red">==>  MISSING_ELSE</font>
691                         end 
692                       end 
693                     `ifdef SVT_USB_JITTER_CORRECTION_DISABLE  
694                       always @ (posedge clk4x) begin
695                         clk2x = ~clk2x;
696                       end
697                     
698                       // When clock recovery is enabled, the VIP TX clock is 1/4 the input clock
699                       //--------------------------------------------------------------------------
700                       always @ (posedge clk2x) begin
701                         if (clock_recovery_enable === 1'b1 &amp;&amp; !enable_clock_jitter &amp;&amp; !enable_ssc) begin
702                           vip_tx_clk = ~vip_tx_clk;
703                         end
704                       end
705                     `endif
706                     
707                       always @(ssclk_tx) begin
708        <font color = "red">0/1     ==>      if(tx_user_clock_enable === 1)</font>
709        <font color = "red">0/1     ==>        vip_tx_clk = ssclk_tx;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
710                       end
711                       
712                       // Always block which is triggered if there is a change in value of enable_clock_jitter
713                       // If the enable_clock_jitter is '0' then trigger the end of the loop which generates tx clock
714                       always@(enable_clock_jitter) begin
715        <font color = "red">0/1     ==>      if(enable_clock_jitter) begin</font>
716                         end
717                         else begin
718        <font color = "red">0/1     ==>        if(kill_jitter_clock_gen == 0) begin</font>
719        <font color = "red">0/1     ==>          kill_jitter_clock_gen = 1;</font>
720        <font color = "red">0/2     ==>          wait(kill_jitter_clock_gen == 0);</font>
721                           end
                   <font color = "red">==>  MISSING_ELSE</font>
722                         end
723                       end
724                     
725                       // This task is responsible for generating a clock cycle. The task is blocking and takes inputs:
726                       // enable_jitter : If this is '1' then a jittered clock is genearted. If '0' then a clock with no jitter is generated.
727                       // positive_jitter_mode : This when 1 generates a positive jitter i.e. extends the clock by percentage_jitter. Else shortens it by percentage_jitter
728                       // percentage_jitter :  This is a real number input which holds the percentage value of the jitter to introduce.
729                       real half_time_resolved;
730                       task generate_jitter_clock(bit enable_jitter,bit positive_jitter_mode, real percentage_jitter);
731                         // Block excersised for SSC mode.
732        <font color = "red">0/1     ==>      if(enable_ssc &amp;&amp; !disable_ssc_clk_ppm_shift) begin</font>
733                           // If the SSC direction is positive 
734                           //  if the clock period has not reached the max ssc, keep incrementing the clock period.
735                           //  else if the max SSC is reached start to decrement the period and flip the direction
736        <font color = "red">0/1     ==>        if(ssc_direction) begin</font>
737        <font color = "red">0/1     ==>          if(clock_period_ssc_max_ps - clock_period_ps_resolved &gt;= ssc_ppm_step) begin</font>
738        <font color = "red">0/1     ==>            clock_period_ps_resolved = clock_period_ps_resolved + ssc_ppm_step;</font>
739                             end else begin
740        <font color = "red">0/1     ==>            clock_period_ps_resolved = clock_period_ps_resolved - ssc_ppm_step;</font>
741        <font color = "red">0/1     ==>            ssc_direction = 0;</font>
742                             end
743                           // If the SSC direction is negative 
744                           //  if the clock period has not reached the min ssc, keep decrementing the clock period.
745                           //  else if the min SSC is reached start to increment the period and flip the direction
746                           end else begin
747        <font color = "red">0/1     ==>          if(clock_period_ps_resolved - clock_period_ssc_min_ps &gt;= ssc_ppm_step) begin</font>
748        <font color = "red">0/1     ==>            clock_period_ps_resolved = clock_period_ps_resolved - ssc_ppm_step;</font>
749                             end else begin
750        <font color = "red">0/1     ==>            clock_period_ps_resolved = clock_period_ps_resolved + ssc_ppm_step;</font>
751        <font color = "red">0/1     ==>            ssc_direction = 1;</font>
752                             end
753                           end
754                         end else begin
755        <font color = "red">0/1     ==>        clock_period_ps_resolved = clock_period_ps;</font>
756                         end
757                         // Add jitter if enabled
758        <font color = "red">0/1     ==>      if(enable_jitter) begin</font>
759        <font color = "red">0/1     ==>        clk_scale_jitter = (real'(percentage_jitter * clock_period_ps_resolved)/100);</font>
760        <font color = "red">0/2     ==>        if(positive_jitter_mode) half_clk_time = (real'(clock_period_ps_resolved + clk_scale_jitter)/2);</font>
761        <font color = "red">0/1     ==>        else half_clk_time = (real'(clock_period_ps_resolved - clk_scale_jitter)/2);</font>
762                         end
763        <font color = "red">0/1     ==>      else half_clk_time = (real'(clock_period_ps_resolved)/2);</font>
764        <font color = "red">0/1     ==>      half_time_resolved = (half_clk_time*1ps);</font>
765        <font color = "red">0/2     ==>      #(half_time_resolved);</font>
766        <font color = "red">0/1     ==>      vip_tx_clk = !(vip_tx_clk);</font>
767        <font color = "red">0/2     ==>      #(half_time_resolved);</font>
768        <font color = "red">0/1     ==>      vip_tx_clk = !(vip_tx_clk);</font>
769                     `ifdef SVT_USB_JITTER_DEBUG_TRACE    
770                         $fdisplay(file_handle,$sformatf(&quot;%32t: enable_jitter: %b enable_ssc: %b clk_scale_jitter: %f half_clk_time: %f clock_period_ps_resolved: %f clock_period_ssc_max_ps: %f clock_period_ssc_min_ps: %f&quot;,$time,enable_jitter,enable_ssc,clk_scale_jitter,half_clk_time,clock_period_ps_resolved,clock_period_ssc_max_ps,clock_period_ssc_min_ps));
771                     `endif    
772                       endtask
773                     
774                       // Initial block
775                       // This loop generates the jittered tx clock when enable_clock_jitter is '1'
776                       int decimal_delta;
777                       int decimal_no_delta;
778                       bit whole_number,resolved_to_plus_one;
779                       initial begin
780                     `ifdef SVT_USB_JITTER_DEBUG_TRACE  
781                         file_handle = $fopen($sformatf(&quot;%m.txt&quot;),&quot;w&quot;);
782                     `endif    
783        1/1              while(1) begin
784        <font color = "red">1/2     ==>        wait(initialized == 1);</font>
785        <font color = "red">0/2     ==>        wait(enable_clock_jitter == 1 || enable_ssc == 1);</font>
786        <font color = "red">0/1     ==>        vip_tx_clk = 1;</font>
787        <font color = "red">0/1     ==>        kill_jitter_clock_gen = 0;</font>
788        <font color = "red">0/1     ==>        decimal_delta = (percentage_jitter*100);</font>
789        <font color = "red">0/1     ==>        decimal_no_delta = percentage_jitter;</font>
790        <font color = "red">0/1     ==>        decimal_no_delta = (decimal_no_delta*100);</font>
791        <font color = "red">0/1     ==>        percentage_jitter_local_decimal_cap = (decimal_delta - decimal_no_delta);</font>
792        <font color = "red">0/1     ==>        if(percentage_jitter_local_decimal_cap == 0) begin </font>
793        <font color = "red">0/1     ==>          whole_number = 1;</font>
794        <font color = "red">0/1     ==>          percentage_jitter_local_decimal_cap = 99; </font>
795                           end  
796        <font color = "red">0/1     ==>        else if(percentage_jitter_local_decimal_cap &lt; 0) begin </font>
797        <font color = "red">0/1     ==>          percentage_jitter_local_decimal_cap = 100 + percentage_jitter_local_decimal_cap;</font>
798        <font color = "red">0/1     ==>          resolved_to_plus_one = 1;</font>
799                           end 
800                           else begin
801                           end
802                           // If block to generate random jitter
803        <font color = "red">0/1     ==>        if(random_jitter_mode) begin</font>
804        <font color = "red">0/1     ==>          while(1) begin</font>
805                               // The usecase of random jitter is to introduce jitter in the clock between 0% to percentage_jitter% in the clock randomly which may be positive or negative.
806                               // Eg: if the user sets 2 as percentage_jitter, the output clock will introduce jitter in the range of 0% to 1.99% randomly as positive or neagative.
807                               // Randomize the jitter in the current clock as positive or negative
808        <font color = "red">0/1     ==>            positive_jitter_mode = $urandom();</font>
809                               // If percentage_jitter is set as 1 then the percenatge variation is from 0 - 0.99%. Bypass randomize.
810                               // Else the integral part is randomized between 0-'n-1' when percentage_jitter is n. 
811                               // The final jitter introduced will be 0% to &lt;n-1&gt;.99%
812                               // Assumption here is (also mentioned in SVDOC): In this mode when the user sets tha max cap jitter it has to be an integer.
813                               // Copy the percentage_jitter real number in an integer type for randomization.
814        <font color = "red">0/1     ==>            percentage_jitter_local_int = percentage_jitter;</font>
815        <font color = "red">0/1     ==>            if(whole_number || (!whole_number &amp;&amp; resolved_to_plus_one)) begin</font>
816        <font color = "red">0/1     ==>              percentage_jitter_local_int = percentage_jitter_local_int - 1;</font>
817                               end 
                   <font color = "red">==>  MISSING_ELSE</font>
818        <font color = "red">0/1     ==>            if(percentage_jitter_local_int &gt; 0) begin</font>
819        <font color = "red">0/1     ==>              percentage_jitter_local_int = $urandom_range(0,percentage_jitter_local_int);</font>
820                               end
821                               else begin
822        <font color = "red">0/1     ==>              percentage_jitter_local_int = 0;</font>
823                               end
824                               // Randomize the trailing decimal percentage.
825        <font color = "red">0/1     ==>            percentage_jitter_local_decimal = $urandom_range(0,percentage_jitter_local_decimal_cap);</font>
826                               // Construct the percenatge randomized as &quot;jitter = int + (dec/100)&quot;.
827                               // Eg: If interger randomized is '1' and decimal is 67 the final jitter becomes 1.67.
828        <font color = "red">0/1     ==>            percentage_jitter_local = percentage_jitter_local_decimal;</font>
829        <font color = "red">0/1     ==>            percentage_jitter_local = (percentage_jitter_local/100);</font>
830        <font color = "red">0/1     ==>            percentage_jitter_local = percentage_jitter_local_int + percentage_jitter_local;</font>
831                               // Generate jitter
832        <font color = "red">0/1     ==>            generate_jitter_clock(enable_clock_jitter,positive_jitter_mode,percentage_jitter_local);</font>
833                               // After every cycle check if the jitter mode is disabled to 'break'
834        <font color = "red">0/2     ==>            if(kill_jitter_clock_gen) break;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
835                             end
836                           end
837                           else begin
838        <font color = "red">0/1     ==>          while(1) begin</font>
839        <font color = "red">0/1     ==>            if(enable_clock_jitter) begin</font>
840                                 // Loop to generate constant jitter.
841                                 // In this mode all the values come from the user.
842                                 // Type of jitter (positive/ negative)
843                                 // Percentage jitter. (This can be in decimals unlike in Random mode)
844                                 // The cycle of generation i.e. number of pulse with jitter followed by the number without jitter
845        <font color = "red">0/1     ==>              repeat(number_of_clocks_with_jitter) begin</font>
846        <font color = "red">0/1     ==>                generate_jitter_clock(1,positive_jitter_mode,percentage_jitter);</font>
847                                 end
                   <font color = "red">==>  REPEAT_FALSE</font>
848        <font color = "red">0/2     ==>              if(kill_jitter_clock_gen) break;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
849        <font color = "red">0/1     ==>              repeat(number_of_clocks_without_jitter) begin</font>
850        <font color = "red">0/1     ==>                generate_jitter_clock(0,positive_jitter_mode,percentage_jitter);</font>
851                                 end
852                               end else begin
853        <font color = "red">0/1     ==>              generate_jitter_clock(0,positive_jitter_mode,percentage_jitter);</font>
854                               end
855                               // After every cycle check if the jitter mode is disabled to 'break'
856        <font color = "red">0/2     ==>            if(kill_jitter_clock_gen) break;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
857                             end
858                           end
859        <font color = "red">0/1     ==>        kill_jitter_clock_gen = 0;</font>
860                         end  
861                       end
862                     `ifndef SVT_USB_JITTER_CORRECTION_DISABLE  
863                       //---------------------------------------------------------------
864                       // CDR
865                       //---------------------------------------------------------------
866                     
867                       initial begin
868        1/1              feedback_toggle = 1;
869        1/1              feedback_toggle_tx = 1;
870        1/1              vip_rx_clk = 1;
871        1/1              data_flopped_0 = 0;
872        1/1              data_flopped_1 = 0;
873        1/1              data_flopped_2 = 0;
874        1/1              data_flopped_0_to_sample = 0;
875        1/1              data_flopped_1_to_sample = 0;
876        1/1              data_flopped_2_to_sample = 0;
877        1/1              data_flopped_to_sample = 0;
878        1/1              data_flopped_to_sample_n = 0;
879        1/1              data_flopped_0_tx = 0;
880        1/1              data_flopped_1_tx = 0;
881        1/1              data_flopped_2_tx = 0;
882        1/1              data_flopped_0_to_sample_tx = 0;
883        1/1              data_flopped_1_to_sample_tx = 0;
884        1/1              data_flopped_2_to_sample_tx = 0;
885        1/1              data_flopped_to_sample_tx = 0;
886        1/1              data_flopped_to_sample_n_tx = 0;
887                       end
888                     
889                       //--------------------------------------------------------------------------------------------------
890                       // This signal gives an active low signal every time there is a change in the incoming signal level
891                       //--------------------------------------------------------------------------------------------------
892                       assign edge_detect_active_low = ((!(data_flopped_0) &amp; !(data_flopped_1)) | (data_flopped_0 &amp; data_flopped_1 ));
893                       assign edge_detect_active_low_tx = ((!(data_flopped_0_tx) &amp; !(data_flopped_1_tx)) | (data_flopped_0_tx &amp; data_flopped_1_tx ));
894                       bit clock_divider_tx;
895                     
896                       always@(posedge (clk4x &amp; clock_gen_enable)) begin
897        <font color = "red">0/1     ==>      if(!enable_clock_jitter &amp;&amp; !enable_ssc &amp;&amp; !is_passive &amp;&amp; !tx_user_clock_enable) begin</font>
898        <font color = "red">0/2     ==>        if(clock_divider_tx) vip_tx_clk &lt;= !vip_tx_clk;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
899        <font color = "red">0/1     ==>        clock_divider_tx &lt;= !(clock_divider_tx);</font>
900                         end
                   <font color = "red">==>  MISSING_ELSE</font>
901                         // Ignore any data which is z or x.
902        <font color = "red">0/1     ==>      if(ssrxp === 1'bz || ssrxp === 1'bx) begin</font>
903        <font color = "red">0/1     ==>        data_flopped_0 &lt;= data_flopped_0;</font>
904                         end
905                         else begin
906        <font color = "red">0/1     ==>        data_flopped_0 &lt;= ssrxp;</font>
907                         end
908        <font color = "red">0/1     ==>      data_flopped_1 &lt;= data_flopped_0;</font>
909        <font color = "red">0/1     ==>      data_flopped_2 &lt;= data_flopped_1;</font>
910        <font color = "red">0/1     ==>      data_flopped_0_to_sample &lt;= {ssrxm,ssrxp};</font>
911        <font color = "red">0/1     ==>      data_flopped_1_to_sample &lt;= data_flopped_0_to_sample;</font>
912        <font color = "red">0/1     ==>      data_flopped_2_to_sample &lt;= data_flopped_1_to_sample;</font>
913        <font color = "red">0/1     ==>      data_flopped_to_sample &lt;= data_flopped_2_to_sample[0];</font>
914        <font color = "red">0/1     ==>      data_flopped_to_sample_n &lt;= data_flopped_2_to_sample[1];</font>
915        <font color = "red">0/1     ==>      if(is_passive) begin</font>
916        <font color = "red">0/1     ==>        if(sstxp === 1'bz || sstxm === 1'bx) begin</font>
917        <font color = "red">0/1     ==>          data_flopped_0_tx &lt;= data_flopped_0_tx;</font>
918                           end
919                           else begin
920        <font color = "red">0/1     ==>          data_flopped_0_tx &lt;= sstxp;</font>
921                           end
922        <font color = "red">0/1     ==>        data_flopped_1_tx &lt;= data_flopped_0_tx;</font>
923        <font color = "red">0/1     ==>        data_flopped_2_tx &lt;= data_flopped_1_tx;</font>
924        <font color = "red">0/1     ==>        data_flopped_0_to_sample_tx &lt;= {sstxm,sstxp};</font>
925        <font color = "red">0/1     ==>        data_flopped_1_to_sample_tx &lt;= data_flopped_0_to_sample_tx;</font>
926        <font color = "red">0/1     ==>        data_flopped_2_to_sample_tx &lt;= data_flopped_1_to_sample_tx;</font>
927        <font color = "red">0/1     ==>        data_flopped_to_sample_tx &lt;= data_flopped_2_to_sample_tx[0];</font>
928        <font color = "red">0/1     ==>        data_flopped_to_sample_n_tx &lt;= data_flopped_2_to_sample_tx[1];</font>
929                         end
                   <font color = "red">==>  MISSING_ELSE</font>
930                         // Feedback toggle keeps on toggling for every posedge of reference clock.
931                         // The edge detect signal going low forces the feedback_toggle to go low. This can be considered a phase reset.
932                         // If the incoming serial data is without jitters the moment edge_detect_active_low is low feedback_toggle is also low.
933                         // So the next clock of ref_clk will give a high pulse as feedback_toggle changes and edge_detect_active_low goes high.
934                         // The next pulse goes low as the feedback toggle changes with no change in edge_detect_active_low.
935                         // Since ref_clk is 4 times the clock rate there will be 4 samples of 1 bit.
936                         // The sync is such that the feedback_toggle on no jitter will go 1 0 1 0.
937                         //
938                         // feedback_toggle_next feedback_toggle edge_detect_active_low
939                         //         1                   0                  1
940                         //         0                   1                  1
941                         //         1                   0                  1
942                         //         0                   1                  0
943                         //
944                         // This cycle repeats itself 
945                         // If there is jitter on the line then the edge_detect_active_low will either pulled in by a clock or pulled out by a clock.
946                         // This shifts the pll_clk pulse by 3 clock to the right or to the left
947        <font color = "red">0/1     ==>      feedback_toggle &lt;= !(feedback_toggle) &amp; edge_detect_active_low;</font>
948        <font color = "red">0/1     ==>      vip_rx_clk &lt;= (feedback_toggle ^ vip_rx_clk) &amp; edge_detect_active_low;</font>
949        <font color = "red">0/1     ==>      if(is_passive) begin</font>
950        <font color = "red">0/1     ==>        feedback_toggle_tx &lt;= !(feedback_toggle_tx) &amp; edge_detect_active_low_tx;</font>
951        <font color = "red">0/1     ==>        vip_tx_clk &lt;= (feedback_toggle_tx ^ vip_tx_clk) &amp; edge_detect_active_low_tx;</font>
952                         end
                   <font color = "red">==>  MISSING_ELSE</font>
953                       end
954                     `endif
955                       bit ss_data_prev;
956                       initial begin
957                         realtime t0,t1;
958        <font color = "red">1/2     ==>      wait(clock_ui_jitter_check == 1);</font>
959        <font color = "red">0/1     ==>      t0 = $realtime();</font>
960        <font color = "red">0/2     ==>      #1fs;</font>
961        <font color = "red">0/1     ==>      t1 = $realtime();</font>
962        <font color = "red">0/1     ==>      if(!(t1 &gt; t0)) begin</font>
963        <font color = "red">0/1     ==>        $display(&quot;ERROR: Timescale is not 1fs, UI checks not possible.&quot;);</font>
964                         end
                   <font color = "red">==>  MISSING_ELSE</font>
965                       end
966                     
967                       real count_max, count_min,timestamp,timestamp_gap,timestamp_current;
968                       event event_error_UI;
969                       reg ss_data;
970                       always@(*) begin
971        <font color = "red">0/2     ==>      wait(clock_ui_jitter_check == 1);</font>
972        <font color = "red">0/1     ==>      ss_data = (is_passive)? sstxp: ssrxp;</font>
973                       end
974                     
975                       initial begin
976        <font color = "red">1/2     ==>      wait(clock_ui_jitter_check == 1);</font>
977        <font color = "red">0/1     ==>      while(1) begin</font>
978                           fork begin
979                             fork
980                             begin
981        <font color = "red">0/1     ==>            while(1) begin</font>
982        <font color = "red">0/1     ==>              if(!mode_ssp) begin</font>
983        <font color = "red">0/2     ==>                #200ps;</font>
984        <font color = "red">0/1     ==>                count_max = count_max + 200.06;</font>
985        <font color = "red">0/1     ==>                count_min = count_min + 199.94;</font>
986                                 end else begin
987        <font color = "red">0/2     ==>                #100ps;</font>
988        <font color = "red">0/1     ==>                count_max = count_max + 100.03;</font>
989        <font color = "red">0/1     ==>                count_min = count_min +  99.97;</font>
990                                 end
991                               end
992                             end
993                             begin
994        <font color = "red">0/2     ==>            @(ss_data);</font>
995                             end
996                             join_any
997        <font color = "red">0/1     ==>          disable fork;</font>
998                           end join_any
999        <font color = "red">0/1     ==>        timestamp = timestamp_current;</font>
1000       <font color = "red">0/1     ==>        timestamp_current = $realtime;</font>
1001       <font color = "red">0/1     ==>        timestamp_gap = (timestamp_current - timestamp);</font>
1002       <font color = "red">0/1     ==>        if(!(timestamp_gap &gt; count_min &amp;&amp; timestamp_gap &lt; count_max)) begin</font>
1003       <font color = "red">0/1     ==>          -&gt; event_error_UI;</font>
1004                          end
                   <font color = "red">==>  MISSING_ELSE</font>
1005       <font color = "red">0/2     ==>        #1ps;</font>
1006       <font color = "red">0/1     ==>        if(!mode_ssp) begin</font>
1007       <font color = "red">0/1     ==>          count_max = 200.06;</font>
1008       <font color = "red">0/1     ==>          count_min = 199.94;</font>
1009                          end else begin
1010       <font color = "red">0/1     ==>          count_max = 100.03;</font>
1011       <font color = "red">0/1     ==>          count_min =  99.97;</font>
</pre>
<hr>
<a name="inst_tag_25395_Cond"></a>
<b>Cond Coverage for Instance : <a href="mod311.html#inst_tag_25395" >config_ss_tb.config_ss_env_intf.dev_usb_if.usb_ss_serial_lane1_if</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s0"><td class="lf">Conditions</td><td>19</td><td>0</td><td>0.00</td></tr>
<tr class="s0"><td class="lf">Logical</td><td>19</td><td>0</td><td>0.00</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       677
 EXPRESSION (((!enable_clock_jitter)) &amp;&amp; ((!enable_ssc)))
             ------------1-----------    -------2-------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       785
 EXPRESSION ((enable_clock_jitter == 1'b1) || (enable_ssc == 1'b1))
             --------------1--------------    ----------2---------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       815
 EXPRESSION (whole_number || (((!whole_number)) &amp;&amp; resolved_to_plus_one))
             ------1-----    ---------------------2---------------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       815
 SUB-EXPRESSION (((!whole_number)) &amp;&amp; resolved_to_plus_one)
                 --------1--------    ----------2---------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       897
 EXPRESSION (((!enable_clock_jitter)) &amp;&amp; ((!enable_ssc)) &amp;&amp; ((!is_passive)) &amp;&amp; ((!tx_user_clock_enable)))
             ------------1-----------    -------2-------    -------3-------    ------------4------------
</pre>
<table class="noborder">
<col span="4" width="40">
<tr><th>-1-</th><th>-2-</th><th>-3-</th><th>-4-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       972
 EXPRESSION (is_passive ? sstxp : ssrxp)
             -----1----
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<hr>
<a name="inst_tag_25395_Branch"></a>
<b>Branch Coverage for Instance : <a href="mod311.html#inst_tag_25395" >config_ss_tb.config_ss_env_intf.dev_usb_if.usb_ss_serial_lane1_if</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s0">
<td>Branches</td>
<td></td>
<td class="rt">44</td>
<td class="rt">3</td>
<td class="rt">6.82  </td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">393</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">547</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s3">
<td>IF</td>
<td class="rt">554</td>
<td class="rt">3</td>
<td class="rt">1</td>
<td class="rt">33.33 </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">664</td>
<td class="rt">3</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">669</td>
<td class="rt">4</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">708</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">715</td>
<td class="rt">3</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">792</td>
<td class="rt">3</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">803</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">897</td>
<td class="rt">3</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">902</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">915</td>
<td class="rt">3</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">949</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">962</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>TERNARY</td>
<td class="rt">972</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">982</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">1002</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr><tr class="s0">
<td>IF</td>
<td class="rt">1006</td>
<td class="rt">2</td>
<td class="rt">0</td>
<td class="rt">0.00  </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
393            if(initialized) initialize_ssc_parameters;
               <font color = "red">-1-</font>  
           <font color = "red">    ==></font>
               MISSING_ELSE
           <font color = "green">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
547            if (vbus !== 1'b1) begin
               <font color = "red">-1-</font>  
548              dut_ss_termination_reg = 0;  // Assume no DUT SS RX termination when VBUS is absent
           <font color = "green">      ==></font>
549            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
554            if (dut_ss_termination === 1'b0) begin
               <font color = "red">-1-</font>  
555              dut_ss_termination_reg = 0;  // No DUT SS RX termination - signaled by TB
           <font color = "red">      ==></font>
556            end else if (vbus !== 1'b1) begin
                        <font color = "red">-2-</font>  
557              dut_ss_termination_reg = 0;  // No DUT SS RX termination - VBUS is absent
           <font color = "green">      ==></font>
558            end else begin
559              dut_ss_termination_reg = 1;  // DUT SS RX termination in place
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
664            if(ess_operating_rate == 2'b00) begin
               <font color = "red">-1-</font>  
665              if(clock_divider) clock5GHz = !(clock5GHz);
                 <font color = "red">-2-</font>  
           <font color = "red">      ==></font>
                 MISSING_ELSE
           <font color = "red">      ==></font>
666              clock_divider = !(clock_divider);
667            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
669            if (clock_recovery_enable === 1'b1) begin 
               <font color = "red">-1-</font>  
670              // When ess_operating rate is 1 then pass the ssclk which is generating in top 
671              // Else pass clock5GHz(3.0) local generated clock 
672              clk4x = (ess_operating_rate === 2'b01) ? ssclk : clock5GHz; 
           <font color = "red">      ==></font>
673            end
674            else begin 
675              // When ess_operating rate is 1 then pass the ssclk which is generating in top 
676              // Else pass clock5GHz(3.0) local generated clock 
677              if(!enable_clock_jitter && !enable_ssc) begin 
                 <font color = "red">-2-</font>  
678        `ifndef SVT_USB_JITTER_CORRECTION_DISABLE
679                if(ess_operating_rate === 2'b01) begin
                   <font color = "red">-3-</font>  
680                  vip_tx_clk = ssclk; 
           <font color = "red">          ==></font>
681                  vip_rx_clk = ssclk; 
682                end
683                else begin
684                  vip_tx_clk = clock5GHz; 
           <font color = "red">          ==></font>
685                  vip_rx_clk = clock5GHz; 
686                end
687        `else
688                vip_tx_clk = (ess_operating_rate === 2'b01) ? ssclk : clock5GHz; 
689        `endif        
690              end  
                 MISSING_ELSE
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
708            if(tx_user_clock_enable === 1)
               <font color = "red">-1-</font>  
709              vip_tx_clk = ssclk_tx;
           <font color = "red">      ==></font>
                 MISSING_ELSE
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
715            if(enable_clock_jitter) begin
               <font color = "red">-1-</font>  
           <font color = "red">    ==></font>
716            end
717            else begin
718              if(kill_jitter_clock_gen == 0) begin
                 <font color = "red">-2-</font>  
719                kill_jitter_clock_gen = 1;
           <font color = "red">        ==></font>
720                wait(kill_jitter_clock_gen == 0);
721              end
                 MISSING_ELSE
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
792              if(percentage_jitter_local_decimal_cap == 0) begin 
                 <font color = "red">-1-</font>  
793                whole_number = 1;
794                percentage_jitter_local_decimal_cap = 99; 
795              end  
796              else if(percentage_jitter_local_decimal_cap < 0) begin 
                      <font color = "red">-2-</font>  
           <font color = "red">      ==></font>
           <font color = "red">      ==></font>
797                percentage_jitter_local_decimal_cap = 100 + percentage_jitter_local_decimal_cap;
           <font color = "red">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
803              if(random_jitter_mode) begin
                 <font color = "red">-1-</font>  
804                while(1) begin
           <font color = "red">        ==></font>
805                  // The usecase of random jitter is to introduce jitter in the clock between 0% to percentage_jitter% in the clock randomly which may be positive or negative.
806                  // Eg: if the user sets 2 as percentage_jitter, the output clock will introduce jitter in the range of 0% to 1.99% randomly as positive or neagative.
807                  // Randomize the jitter in the current clock as positive or negative
808                  positive_jitter_mode = $urandom();
809                  // If percentage_jitter is set as 1 then the percenatge variation is from 0 - 0.99%. Bypass randomize.
810                  // Else the integral part is randomized between 0-'n-1' when percentage_jitter is n. 
811                  // The final jitter introduced will be 0% to <n-1>.99%
812                  // Assumption here is (also mentioned in SVDOC): In this mode when the user sets tha max cap jitter it has to be an integer.
813                  // Copy the percentage_jitter real number in an integer type for randomization.
814                  percentage_jitter_local_int = percentage_jitter;
815                  if(whole_number || (!whole_number && resolved_to_plus_one)) begin
816                    percentage_jitter_local_int = percentage_jitter_local_int - 1;
817                  end 
818                  if(percentage_jitter_local_int > 0) begin
819                    percentage_jitter_local_int = $urandom_range(0,percentage_jitter_local_int);
820                  end
821                  else begin
822                    percentage_jitter_local_int = 0;
823                  end
824                  // Randomize the trailing decimal percentage.
825                  percentage_jitter_local_decimal = $urandom_range(0,percentage_jitter_local_decimal_cap);
826                  // Construct the percenatge randomized as "jitter = int + (dec/100)".
827                  // Eg: If interger randomized is '1' and decimal is 67 the final jitter becomes 1.67.
828                  percentage_jitter_local = percentage_jitter_local_decimal;
829                  percentage_jitter_local = (percentage_jitter_local/100);
830                  percentage_jitter_local = percentage_jitter_local_int + percentage_jitter_local;
831                  // Generate jitter
832                  generate_jitter_clock(enable_clock_jitter,positive_jitter_mode,percentage_jitter_local);
833                  // After every cycle check if the jitter mode is disabled to 'break'
834                  if(kill_jitter_clock_gen) break;
835                end
836              end
837              else begin
838                while(1) begin
           <font color = "red">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
897            if(!enable_clock_jitter && !enable_ssc && !is_passive && !tx_user_clock_enable) begin
               <font color = "red">-1-</font>  
898              if(clock_divider_tx) vip_tx_clk <= !vip_tx_clk;
                 <font color = "red">-2-</font>  
           <font color = "red">      ==></font>
                 MISSING_ELSE
           <font color = "red">      ==></font>
899              clock_divider_tx <= !(clock_divider_tx);
900            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
902            if(ssrxp === 1'bz || ssrxp === 1'bx) begin
               <font color = "red">-1-</font>  
903              data_flopped_0 <= data_flopped_0;
           <font color = "red">      ==></font>
904            end
905            else begin
906              data_flopped_0 <= ssrxp;
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
915            if(is_passive) begin
               <font color = "red">-1-</font>  
916              if(sstxp === 1'bz || sstxm === 1'bx) begin
                 <font color = "red">-2-</font>  
917                data_flopped_0_tx <= data_flopped_0_tx;
           <font color = "red">        ==></font>
918              end
919              else begin
920                data_flopped_0_tx <= sstxp;
           <font color = "red">        ==></font>
921              end
922              data_flopped_1_tx <= data_flopped_0_tx;
923              data_flopped_2_tx <= data_flopped_1_tx;
924              data_flopped_0_to_sample_tx <= {sstxm,sstxp};
925              data_flopped_1_to_sample_tx <= data_flopped_0_to_sample_tx;
926              data_flopped_2_to_sample_tx <= data_flopped_1_to_sample_tx;
927              data_flopped_to_sample_tx <= data_flopped_2_to_sample_tx[0];
928              data_flopped_to_sample_n_tx <= data_flopped_2_to_sample_tx[1];
929            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
949            if(is_passive) begin
               <font color = "red">-1-</font>  
950              feedback_toggle_tx <= !(feedback_toggle_tx) & edge_detect_active_low_tx;
           <font color = "red">      ==></font>
951              vip_tx_clk <= (feedback_toggle_tx ^ vip_tx_clk) & edge_detect_active_low_tx;
952            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
962            if(!(t1 > t0)) begin
               <font color = "red">-1-</font>  
963              $display("ERROR: Timescale is not 1fs, UI checks not possible.");
           <font color = "red">      ==></font>
964            end
               MISSING_ELSE
           <font color = "red">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
972            ss_data = (is_passive)? sstxp: ssrxp;
                                     <font color = "red">-1-</font>  
                                     <font color = "red">==></font>  
                                     <font color = "red">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
982                    if(!mode_ssp) begin
                       <font color = "red">-1-</font>  
983                      #200ps;
           <font color = "red">              ==></font>
984                      count_max = count_max + 200.06;
985                      count_min = count_min + 199.94;
986                    end else begin
987                      #100ps;
           <font color = "red">              ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1002             if(!(timestamp_gap > count_min && timestamp_gap < count_max)) begin
                 <font color = "red">-1-</font>  
1003               -> event_error_UI;
           <font color = "red">        ==></font>
1004             end
                 MISSING_ELSE
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1006             if(!mode_ssp) begin
                 <font color = "red">-1-</font>  
1007               count_max = 200.06;
           <font color = "red">        ==></font>
1008               count_min = 199.94;
1009             end else begin
1010               count_max = 100.03;
           <font color = "red">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
</div>
</div>
<div class="ui-layout-center-inner-north">
<div id="center-bread-crumb" class="breadCrumb module urg-margin-bottom">
  <ul name="inst_tag_25392">
    <li>
      <a href="#inst_tag_25392_Line">Line</a>    </li>
    <li>
      <a href="#inst_tag_25392_Cond">Cond</a>    </li>
    <li>
      <a href="#inst_tag_25392_Branch">Branch</a>    </li>
  </ul>
  <ul name="inst_tag_25393">
    <li>
      <a href="#inst_tag_25393_Line">Line</a>    </li>
    <li>
      <a href="#inst_tag_25393_Cond">Cond</a>    </li>
    <li>
      <a href="#inst_tag_25393_Branch">Branch</a>    </li>
  </ul>
  <ul name="inst_tag_25394">
    <li>
      <a href="#inst_tag_25394_Line">Line</a>    </li>
    <li>
      <a href="#inst_tag_25394_Cond">Cond</a>    </li>
    <li>
      <a href="#inst_tag_25394_Branch">Branch</a>    </li>
  </ul>
  <ul name="inst_tag_25395">
    <li>
      <a href="#inst_tag_25395_Line">Line</a>    </li>
    <li>
      <a href="#inst_tag_25395_Cond">Cond</a>    </li>
    <li>
      <a href="#inst_tag_25395_Branch">Branch</a>    </li>
  </ul>
  <ul name="tag_svt_usb_ss_serial_if">
    <li>
      <a href="#Line">Line</a>    </li>
    <li>
      <a href="#Cond">Cond</a>    </li>
    <li>
      <a href="#Branch">Branch</a>    </li>
  </ul>
</div>
</div>
</div>
<div class="ui-layout-south">
<table align=center><tr><td class="s0 cl">0%</td>
<td class="s1 cl">10%</td>
<td class="s2 cl">20%</td>
<td class="s3 cl">30%</td>
<td class="s4 cl">40%</td>
<td class="s5 cl">50%</td>
<td class="s6 cl">60%</td>
<td class="s7 cl">70%</td>
<td class="s8 cl">80%</td>
<td class="s9 cl">90%</td>
<td class="s10 cl">100%</td></tr></table></div>
</body>
</html>
