<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="Author" content="<username>"> <meta name="GENERATOR" content="urg/version [en] (platform name) [urg]">
<title>Unified Coverage Report :: Line split page</title>
<link type="text/css" rel="stylesheet" href="css/.urg.css">
<link type="text/css" rel="stylesheet" href="css/.layout.css">
<script type="text/javascript" src="js/.jquery.js"></script>
<script type="text/javascript" src="js/.jquery-ui.js"></script>
<script type="text/javascript" src="js/.sortable.js"></script>
<script type="text/javascript" src="js/.colResizable.js"></script>
<script type="text/javascript" src="js/.layout.js"></script>
<script type="text/javascript">
var layout, westLayout, centerLayout;
$(document).ready(function () {
  layout = $("body").layout({ 
    resizable: true,
    spacing_open: 4,
    spacing_closed: 4,
    north: {
      size: 76
    },
    south: {
      size: 45,
      initClosed: true
    }  });
  $("table").colResizable({    liveDrag:true,
    fixed:false,
    draggingClass:"dragging"
  });
});
</script>
</head>
<body><div class="ui-layout-north">
<div class="logo"></div>
<center class="pagetitle">Line split page</center>
<div align="center"><a href="dashboard.html" ><b>dashboard</b></a> | <a href="hierarchy.html" ><b>hierarchy</b></a> | <a href="modlist.html" ><b>modlist</b></a> | groups | <a href="tests.html" ><b>tests</b></a> | <a href="asserts.html" ><b>asserts</b></a></div>

</div>
<div class="ui-layout-center">
Go <a href="mod415.html#l14">back</a>
<pre class="code"><br clear=all>
821                       begin
822        1/1              if (p_edma_tx_pbuf_data == 32'd128)
823        <font color = "red">0/1     ==>        case (dma_bus_width)</font>
824        <font color = "red">0/1     ==>          2'd0    : tx_fill_lvl_multiplier = 2'd2; // Four 32b words per 128b word</font>
825        <font color = "red">0/1     ==>          2'd1    : tx_fill_lvl_multiplier = 2'd1; // Two 64b words per 128b word</font>
826        <font color = "red">0/1     ==>          default : tx_fill_lvl_multiplier = 2'd0;</font>
827                           endcase
828                         else
829        1/1                tx_fill_lvl_multiplier = 2'd0;
830                       end
831                     
832                     
833                       //==================================================================================================
834                       // dpram_fill_lvl and TX_PBUF_MAX_FILL_LVL are concatenated signals containing the value for each queue
835                       // Split these into arrays where each entry is the value for one queue
836                       // Level is dependent on ratio of data bus size to dpram width and indicates the number of AXI stripes
837                       // tat the buffer can accomodate in the unused space
838                       //==================================================================================================
839                       genvar g2;
840                       generate for (g2 = 0; g2 &lt; p_num_queues; g2 = g2 + 1)
841                       begin : gen_tx_dpram_fill_lvl
842                         wire [p_edma_tx_pbuf_addr+1:0] tx_pbuf_max_fill_lvl_shifted;
843                         
844                         assign tx_pbuf_max_fill_lvl_shifted = ({2'd0, TX_PBUF_MAX_FILL_LVL[((g2+32'd1)*p_edma_tx_pbuf_addr)-1:g2*p_edma_tx_pbuf_addr]} &lt;&lt; tx_fill_lvl_multiplier);
845                         
846                         assign dpram_fill_lvl_array[g2] =
847                           dpram_fill_lvl[((g2+32'd1)*p_edma_tx_pbuf_addr)-1:g2*p_edma_tx_pbuf_addr] &lt;&lt; tx_fill_lvl_multiplier;
848                     
849                         assign TX_PBUF_MAX_FILL_LVL_ARRAY[g2] = tx_pbuf_max_fill_lvl_shifted | {{p_edma_tx_pbuf_addr{1'b0}}, 2'd3};
850                     
851                       end
852                       endgenerate
853                     
854                     assign axi_tx_full_adj_0_shft = axi_tx_full_adj_0 &lt;&lt; tx_fill_lvl_multiplier;
855                     assign axi_tx_full_adj_1_shft = axi_tx_full_adj_1 &lt;&lt; tx_fill_lvl_multiplier;
856                     
857                       wire hw_dma_tx_start;
858                       edma_sync_toggle_detect i_edma_sync_toggle_detect_trigger_dma_tx_start (
859                         .clk      (aclk),
860                         .reset_n  (n_areset),
861                         .din      (trigger_dma_tx_start),
862                         .rise_edge(),
863                         .fall_edge(),
864                         .any_edge (hw_dma_tx_start));
865                     
866                       //========================================================================
867                       // Code that monitors tx_stop_pulse and stops the descriptor read state
868                       // machine from issuing new TX descriptor reads
869                       // Wait until current descriptor fetch is finished, and if descriptor
870                       // is for a multi buffer frame wait until all descriptors for the frame
871                       //========================================================================
872                       always @ (posedge aclk or negedge n_areset)
873                       begin
874        1/1              if  (~n_areset)
875                         begin
876        1/1                stop_tx_asap  &lt;= 1'b0;
877        1/1                stop_tx_now   &lt;= 1'b0;
878                         end
879                         else
880                         begin
881        1/1                if (~enable_tx)
882                           begin
883        1/1                  stop_tx_asap  &lt;= 1'b0;
884        1/1                  stop_tx_now   &lt;= 1'b0;
885                           end
886                           else
887                           begin
888        1/1                  if ((mrd_sm_cs == MRD_IDLE) || tx_start_pulse || hw_dma_tx_start)
889        1/1                    stop_tx_asap  &lt;= 1'b0;
890                             else
891        1/1                    if (tx_stop_pulse)
892        1/1                      stop_tx_asap  &lt;= 1'b1;
                        MISSING_ELSE
893                     
894        1/1                  if ((mrd_sm_cs == MRD_IDLE) || tx_start_pulse || hw_dma_tx_start)
895        1/1                    stop_tx_now  &lt;= 1'b0;
896                             else
897        1/1                    if ((tx_stop_pulse || stop_tx_asap) &amp;&amp; descr_rd_resp_end &amp;&amp; (db1_in_last_bit || (db1_in[45:32] == 14'd0)) )
898        1/1                      stop_tx_now  &lt;= 1'b1;
                        MISSING_ELSE
899                           end
900                         end
901                       end
902                     
903                     
904                       //==================================================================================
905                       // For priority queues, we need a descriptor read counter that will decrement from
906                       // the highest queue in multi buffer operation,
907                       // it might be the case that we end the DATA state and
908                       // need to get a new TX descriptor for that queue. In this case, we don't want to
909                       // do a full descriptor sweep and just do the single queue
910                       // Seperate counters implemented for request and response so
911                       // ar_queue_descr indicates the priority queue that the current deiscriptor read
912                       // request is for
913                       //==================================================================================
914                     
915                       assign do_descr_read = ~db1_full_q[ar_queue_descr] &amp;&amp; ~db1_in_used_bits_read_pad[ar_queue_descr] &amp; ~tx_disable_queue_pad[ar_queue_descr];
916                     
917                       generate
918                         if (p_num_queues &gt; 32'd1) begin : gen_queues_ar_queue_descr
919                           reg   [3:0]       ar_queue_descr_i;
920                           always @ (posedge aclk or negedge n_areset)
921                           begin
922                             if  (~n_areset)
923                               ar_queue_descr_i &lt;= p_num_queues_m1[3:0]; //reset to highest queue
924                             else
925                             begin
926                               if ((~enable_tx || flush_tx_rd_fifos) &amp;&amp; ~(arvalid_descr &amp;&amp; ~arready_descr))
927                                 ar_queue_descr_i &lt;= p_num_queues_m1[3:0]; //reset to highest queue
928                               else
929                                 if ((mrd_sm_cs == MRD_REQ) &amp;&amp;
930                                    ((arvalid_descr &amp;&amp; descr_rd_req_end) || (~arvalid_descr &amp;&amp; (mreq_sm_cs == MREQ_WORD1))))
931                                 begin
932                                   if (ar_queue_descr_i == 4'h0)
933                                     ar_queue_descr_i &lt;= p_num_queues_m1[3:0];
934                                    else
935                                      ar_queue_descr_i &lt;= ar_queue_descr_i - 4'h1;
936                                 end
937                     
938                             end
939                           end
940                     
941                           assign ar_queue_descr = ar_queue_descr_i;
942                     
943                         end else begin : gen_no_queues_ar_queue_descr
944                           assign ar_queue_descr = 4'h0;
945                         end
946                       endgenerate
947                     
948                     
949                       //============================================================================
950                       // AXI management read state machine
951                       // Triggers activity on AXI descriptor requests and AXI descriptor response state
952                       // machines if more than 1 read request is required per descriptor due to
953                       // descriptor size and data bus width.
954                       //============================================================================
955                     
956                       always @ (posedge aclk or negedge n_areset)
957                       begin
958        1/1              if  (~n_areset)
959        1/1                mrd_sm_cs &lt;= MRD_IDLE;
960                         else
961        1/1                if ((~enable_tx || flush_tx_rd_fifos) &amp;&amp; ~(arvalid_descr &amp;&amp; ~arready_descr))
962        1/1                  mrd_sm_cs &lt;= MRD_IDLE;
963                           else
964        1/1                  mrd_sm_cs &lt;= mrd_sm_ns;
965                       end
966                     
967                       // check it is OK to get more descriptors
968                       assign queue_active = (db1_full_q[p_num_queues-1:0] | tx_disable_queue) != {p_num_queues{1'b1}};
969                     
970                       // next state logic
971                       always @ *
972                       begin
973                         // Default behaviour is to stay in current state
974        1/1              mrd_sm_ns = mrd_sm_cs;
975                     
976        1/1              case (mrd_sm_cs)
977                     
978                           MRD_REQ:
979                             // Issue 1 descriptor read request for each queue
980                             // Proceed to MRD_CHECK when request is issued for queue 0
981        1/1                  if ( (descr_rd_req_end  &amp;&amp; (ar_queue_descr == 4'd0)) ||
982                                  (~do_descr_read &amp;&amp; ~arvalid_descr_hold &amp;&amp; (mreq_sm_cs == MREQ_WORD1) &amp;&amp; (ar_queue_descr == 4'd0)) )
983        1/1                    mrd_sm_ns = MRD_CHECK;
                        MISSING_ELSE
984                     
985                           MRD_CHECK:
986                           begin
987                             // If wrap bit or error has been seen in incoming descriptors then proceed to MRD_WAIT
988                             // so all outstanding reads can complete and descriptor req pointer can then be aligned to
989                             // descriptor resp pointer
990                             // Otherwise return to MRD_REQ once there is capacity in the primary descriptor
991                             // buffers of any queue
992        1/1                  if (db1_in_used_all_q_was_detected ||
993                                 db1_in_err_was_detected ||
994                                 db1_in_wrap_was_detected ||
995                                 db1_in_used_was_detected ||
996                                 ((db1_in_used_all_q || db1_in_buff_err) &amp;&amp; descr_rd_resp_end)
997                                )
998        <font color = "red">0/1     ==>            mrd_sm_ns = MRD_WAIT;</font>
999                             else
1000       1/1                    if (tx_stop_pulse || stop_tx_asap)
1001       1/1                      mrd_sm_ns = MRD_WAIT;
1002                              else
1003       1/1                      if (queue_active) // get more descriptors
1004       1/1                        mrd_sm_ns = MRD_REQ ;
                   <font color = "red">==>  MISSING_ELSE</font>
1005                          end
1006                    
1007                          MRD_WAIT:
1008                            // Once all outstanding requests are complete, descriptor pointer will have been updated
1009                            // Move to IDLE state on error (used bit, mid frame zero length buffer) as SW
1010                            // update of descriptors is required
1011                            // Otherwise return to MRD_REQ once there is capacity in the primary descriptor
1012                            // buffers of any queue?
1013       1/1                  if (descr_rd_pend_cnt == 5'd0)
1014                            begin
1015       1/1                    if (db1_in_used_all_q_was_detected || db1_in_err_was_detected || stop_tx_now)
1016       1/1                      mrd_sm_ns = MRD_IDLE;
1017                              else
1018       <font color = "red">0/1     ==>              if (queue_active) // get more descriptors</font>
1019       <font color = "red">0/1     ==>                mrd_sm_ns = MRD_REQ ;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
1020                            end
                        MISSING_ELSE
1021                    
1022                    
1023                          default: //MRD_IDLE:
1024                            // Start requesting descriptors on start pulse, providing there is space in
1025                            // at least 1 descriptor buffer and there isn't a pending error
1026       1/1                  if ( (tx_start_pulse || hw_dma_tx_start || tx_start_pending) &amp;&amp;
1027                                  ~db1_in_err_was_detected &amp;&amp;
1028                                  (queue_active)
1029                               )
1030       1/1                    mrd_sm_ns = MRD_REQ;
                        MISSING_ELSE
1031                    
1032                        endcase
1033                      end
1034                    
1035                      // assert descr_rd_trig as management read state machine starts a new
1036                      // sweep
1037                      always @ *
1038                      begin
1039                    
1040       1/1              case (mrd_sm_cs)
1041                    
1042                          MRD_REQ:
1043       1/1                    descr_rd_trig = 1'b0;
1044                    
1045                          MRD_CHECK:
1046                          begin
1047       1/1                  if (db1_in_used_all_q_was_detected ||
1048                                db1_in_err_was_detected ||
1049                                db1_in_wrap_was_detected ||
1050                                db1_in_used_was_detected ||
1051                                ((db1_in_used_all_q || db1_in_buff_err) &amp;&amp; descr_rd_resp_end)
1052                               )
1053       <font color = "red">0/1     ==>            descr_rd_trig = 1'b0;</font>
1054                            else
1055       1/1                    if (tx_stop_pulse || stop_tx_asap)
1056       1/1                      descr_rd_trig = 1'b0;
1057                              else
1058       1/1                      if (queue_active) // get more descriptors
1059       1/1                        descr_rd_trig = 1'b1;
1060                                else
1061       <font color = "red">0/1     ==>                descr_rd_trig = 1'b0;</font>
1062                          end
1063                    
1064                          MRD_WAIT:
1065       1/1                  if (descr_rd_pend_cnt == 5'd0)
1066                            begin
1067       1/1                    if (db1_in_used_all_q_was_detected || db1_in_err_was_detected || stop_tx_now)
1068       1/1                      descr_rd_trig = 1'b0;
1069                              else
1070       <font color = "red">0/1     ==>              if (queue_active) // get more descriptors</font>
1071       <font color = "red">0/1     ==>                descr_rd_trig = 1'b1;</font>
1072                                else
1073       <font color = "red">0/1     ==>                descr_rd_trig = 1'b0;</font>
1074                            end
1075                            else
1076       1/1                    descr_rd_trig = 1'b0;
1077                    
1078                          default: //MRD_IDLE:
1079       1/1                  if ( (tx_start_pulse || hw_dma_tx_start || tx_start_pending) &amp;&amp;
1080                                  ~db1_in_err_was_detected &amp;&amp;
1081                                  (queue_active)
1082                               )
1083       1/1                    descr_rd_trig = 1'b1;
1084                            else
1085       1/1                    descr_rd_trig = 1'b0;
1086                    
1087                        endcase
1088                      end
1089                    
1090                      //============================================================================
1091                      // TX descriptor request state machine
1092                      // Words 0 and 1 of descriptor must be fetched for 32-bit addressing and
1093                      // words 0,1 and 2 for 64-bit addressing. It is not necessary to fetch the
1094                      // timestamp words for extended descriptors
1095                      // For a 64-bit or 128 bit data bus, words 0 and 1 are requested with the
1096                      // 1st access and word 2 (if required) is requested with a 2nd access
1097                      // For a 32-bit dat bus, word 1 is requested with the 1st access, word 0 with
1098                      // the 2nd access and word 2 (if required) is requested with a 3rd access
1099                      //============================================================================
1100                    
1101                      always @ (posedge aclk or negedge n_areset)
1102                      begin
1103       1/1              if (~n_areset)
1104       1/1                mreq_sm_cs &lt;= MREQ_IDLE;
1105                        else
1106       1/1                if ((~enable_tx || flush_tx_rd_fifos) &amp;&amp; ~(arvalid_descr &amp;&amp; ~arready_descr))
1107       1/1                  mreq_sm_cs &lt;= MREQ_IDLE;
1108                          else
1109       1/1                  mreq_sm_cs &lt;= mreq_sm_ns;
1110                      end
1111                    
1112                      // next state logic
1113                      always @ *
1114                      begin
1115       1/1              mreq_sm_ns  = mreq_sm_cs;
1116                    
1117       1/1              case (mreq_sm_cs)
1118                          MREQ_WORD1:
1119                            // Get words 0 and 1 for 64/128 bit data bus or word 1 for 32-bit data bus
1120       1/1                  if (arrv_descr)
1121                            begin
1122       1/1                    if (dma_bus_width == 2'd0)  // 32 bit data bus
1123       1/1                      mreq_sm_ns  = MREQ_WORD0;
1124                              else
1125                              begin // 64/128 bit data bus
1126       <font color = "red">0/1     ==>              if (addressing_64b | tx_extended_bd_mode_en) // need word 2 in 64bit addressing/ext BD</font>
1127       <font color = "red">0/1     ==>                mreq_sm_ns = MREQ_WORD2;</font>
1128                                else
1129                                begin
1130       <font color = "red">0/1     ==>                if (ar_queue_descr == 4'd0)</font>
1131       <font color = "red">0/1     ==>                  mreq_sm_ns  = MREQ_IDLE;</font>
1132                                  else
1133       <font color = "red">0/1     ==>                  mreq_sm_ns  = MREQ_WORD1;</font>
1134                                end
1135                              end
1136                            end
1137                            else
1138       1/1                    if (~do_descr_read &amp;&amp; ~arvalid_descr_hold &amp;&amp; (ar_queue_descr == 4'd0) )
1139       <font color = "red">0/1     ==>              mreq_sm_ns  = MREQ_IDLE;</font>
                        MISSING_ELSE
1140                    
1141                          MREQ_WORD0:
1142                            // get word 0 - only for 32-bit data bus
1143       1/1                  if (arrv_descr)
1144                            begin
1145       1/1                    if (addressing_64b | tx_extended_bd_mode_en)
1146       <font color = "red">0/1     ==>              mreq_sm_ns = MREQ_WORD2;</font>
1147                              else
1148       1/1                      if (ar_queue_descr == 4'd0)
1149       1/1                        mreq_sm_ns  = MREQ_IDLE;
1150                                else
1151       <font color = "red">0/1     ==>                mreq_sm_ns  = MREQ_WORD1;</font>
1152                            end
                        MISSING_ELSE
1153                    
1154                          MREQ_WORD2:
1155                            // get word 2 - for all data bus widths
1156                            // this is the lower 32bits of the launch time when no 64bit addressing and databus = 32 bits
1157                            // or all bits of the launch time when no 64bit addressing and databus = 64/128 bits
1158                            // or the upper data buffer address bits when 64bit addressing = 1
1159       <font color = "red">0/1     ==>          if (arrv_descr)</font>
1160                            begin
1161       <font color = "red">0/1     ==>            if (addressing_64b &amp;&amp; tx_extended_bd_mode_en)</font>
1162       <font color = "red">0/1     ==>              mreq_sm_ns = MREQ_WORD4; // Get launch time</font>
1163       <font color = "red">0/1     ==>            else if (dma_bus_width == 2'd0 &amp;&amp; tx_extended_bd_mode_en)</font>
1164       <font color = "red">0/1     ==>              mreq_sm_ns = MREQ_WORD3_5; // Get upper half of the launch time</font>
1165       <font color = "red">0/1     ==>            else if (ar_queue_descr == 4'd0)</font>
1166       <font color = "red">0/1     ==>              mreq_sm_ns  = MREQ_IDLE;</font>
1167                              else
1168       <font color = "red">0/1     ==>              mreq_sm_ns  = MREQ_WORD1;</font>
1169                            end
                   <font color = "red">==>  MISSING_ELSE</font>
1170                    
1171                          MREQ_WORD3_5:
1172                            // get word 3 or 5 - only valid for 32 bit datapaths and tx_extended_bd_mode_en and 32bit addressing
1173                            // this is the upper 32bits of the launch time
1174       <font color = "red">0/1     ==>          if (arrv_descr)</font>
1175                            begin
1176       <font color = "red">0/1     ==>            if (ar_queue_descr == 4'd0)</font>
1177       <font color = "red">0/1     ==>              mreq_sm_ns  = MREQ_IDLE;</font>
1178                              else
1179       <font color = "red">0/1     ==>              mreq_sm_ns  = MREQ_WORD1;</font>
1180                            end
                   <font color = "red">==>  MISSING_ELSE</font>
1181                    
1182                          MREQ_WORD4:
1183                            // get word 4 - only valid for tx_extended_bd_mode_en and 64bit addressing
1184                            // this is the launch time
1185       <font color = "red">0/1     ==>          if (arrv_descr)</font>
1186                            begin
1187       <font color = "red">0/1     ==>            if (dma_bus_width == 2'd0)</font>
1188       <font color = "red">0/1     ==>              mreq_sm_ns  = MREQ_WORD3_5;</font>
1189       <font color = "red">0/1     ==>            else if (ar_queue_descr == 4'd0)</font>
1190       <font color = "red">0/1     ==>              mreq_sm_ns  = MREQ_IDLE;</font>
1191                              else
1192       <font color = "red">0/1     ==>              mreq_sm_ns  = MREQ_WORD1;</font>
1193                            end
                   <font color = "red">==>  MISSING_ELSE</font>
1194                    
1195                          default: //MREQ_IDLE:
1196       1/1                  if (descr_rd_trig)
1197       1/1                    mreq_sm_ns = MREQ_WORD1;
                        MISSING_ELSE
1198                    
1199                        endcase
1200                      end
1201                    
1202                    
1203                      //============================================================================
1204                      // TX descriptor response state machine next state logic
1205                      // State changes depending on bus width and whether 64b addressing is enabled
1206                      //============================================================================
1207                    
1208                      always @ (posedge aclk or negedge n_areset)
1209                      begin
1210       1/1              if  (~n_areset)
1211       1/1                mresp_sm_cs &lt;= MRESP_WORD1;
1212                        else
1213       1/1                if (~enable_tx || flush_tx_rd_fifos)
1214       1/1                  mresp_sm_cs &lt;= MRESP_WORD1;
1215                          else
1216       1/1                  mresp_sm_cs &lt;= mresp_sm_ns;
1217                      end
1218                    
1219                    
1220                      always @ *
1221                      begin
1222       1/1              mresp_sm_ns = mresp_sm_cs;
1223                    
1224       1/1              case (mresp_sm_cs)
1225                    
1226                          MRESP_WORD0:
1227                          // Receiving Word 0 - only for 32-bit data bus
1228                          begin
1229       1/1                  if (rrv_descr)
1230                            begin
1231       1/1                    if (addressing_64b | tx_extended_bd_mode_en)
1232                                // word 2 still required
1233       <font color = "red">0/1     ==>              mresp_sm_ns  = MRESP_WORD2;</font>
1234                              else
1235                                //descriptor read complete
1236       1/1                      mresp_sm_ns  = MRESP_WORD1;
1237                            end
                        MISSING_ELSE
1238                          end
1239                    
1240                          MRESP_WORD2:
1241                          // get word 2 - for all data bus widths
1242                          // this is the lower 32bits of the launch time when 32bit addressing and databus = 32 bits
1243                          // or all bits of the launch time when no 64bit addressing and databus = 64/128 bits
1244                          // or the upper data buffer address bits when 64bit addressing = 1
1245                          begin
1246       <font color = "red">0/1     ==>          if (rrv_descr &amp;&amp; addressing_64b &amp;&amp; tx_extended_bd_mode_en)</font>
1247       <font color = "red">0/1     ==>            mresp_sm_ns = MRESP_WORD4; // Get launch time</font>
1248       <font color = "red">0/1     ==>          else if (rrv_descr &amp;&amp; dma_bus_width == 2'd0 &amp;&amp; tx_extended_bd_mode_en)</font>
1249       <font color = "red">0/1     ==>            mresp_sm_ns = MRESP_WORD3_5; // Get upper half of the launch time</font>
1250       <font color = "red">0/1     ==>          else if (rrv_descr)</font>
1251       <font color = "red">0/1     ==>            mresp_sm_ns  = MRESP_WORD1;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
1252                          end
1253                    
1254                          MRESP_WORD3_5:
1255                          // get word 3 or 5 - only valid for 32 bit datapaths and tx_extended_bd_mode_en and 32bit addressing
1256                          // this is the upper 32bits of the launch time
1257                          begin
1258       <font color = "red">0/1     ==>          if (rrv_descr)</font>
1259       <font color = "red">0/1     ==>            mresp_sm_ns  = MRESP_WORD1;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
1260                          end
1261                    
1262                          MRESP_WORD4:
1263                          // get word 4 - only valid for tx_extended_bd_mode_en and 64bit addressing
1264                          // this is the launch time
1265                          begin
1266       <font color = "red">0/1     ==>          if (rrv_descr &amp;&amp; dma_bus_width == 2'd0)</font>
1267       <font color = "red">0/1     ==>            mresp_sm_ns  = MRESP_WORD3_5;</font>
1268       <font color = "red">0/1     ==>          else if (rrv_descr)</font>
1269       <font color = "red">0/1     ==>            mresp_sm_ns  = MRESP_WORD1;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
1270                          end
1271                    
1272                          default //MRESP_WORD1:
1273                          // Receive word 0 and 1 for 64/128 bit data bus or word 1 for 32-but data bus
1274                          begin
1275       1/1                  if (rrv_descr)
1276                            begin
1277       1/1                    if (dma_bus_width == 2'd0)
1278                                // 32 bit data bus - word 0 still required
1279       1/1                      mresp_sm_ns  = MRESP_WORD0;
1280                              else
1281       <font color = "red">0/1     ==>              if (addressing_64b || tx_extended_bd_mode_en)</font>
1282                                  // 64/128 bit data bus - word 2 still required
1283       <font color = "red">0/1     ==>                mresp_sm_ns  = MRESP_WORD2;</font>
1284                                else
1285                                  // 64/128 bit data bus - descriptor read complete
1286       <font color = "red">0/1     ==>                mresp_sm_ns   = MRESP_WORD1;</font>
1287                            end
                        MISSING_ELSE
1288                          end
1289                    
1290                        endcase
1291                      end
1292                    
1293                      // Flag detection of used bit
1294                      // if DMA has consummed all previosly read
1295                      // descriptors
1296                      // For multi queue operation, flag is only set
1297                      // if the used bit is observed for all queues
1298                    
1299                      generate
1300                        if (p_num_queues &gt; 32'd1)
1301                        begin : gen_queues_descr_resp_vec
1302                          reg  [p_num_queues-1:0] used_bit_vec_reg;
1303                          wire [p_num_queues-1:0] descr_resp_vec;
1304                    
1305                          assign descr_resp_vec = {{(p_num_queues-1){1'b0}}, 1'b1} &lt;&lt; r_queue;
1306                    
1307                          always @(*)
1308                            if (descr_rd_resp_end &amp;&amp; db1_in_used_bit)
1309                              used_bit_vec_reg = descr_resp_vec;
1310                            else
1311                              used_bit_vec_reg = {p_num_queues{1'b0}};
1312                    
1313                          assign used_bit_vec = used_bit_vec_reg;
1314                          assign db1_in_used_all_q = descr_rd_resp_end &amp;&amp; ((db1_in_used_bits_read | used_bit_vec) == {p_num_queues{1'b1}});
1315                        end
1316                        else
1317                        begin : gen_no_queues_descr_resp_vec
1318                          assign used_bit_vec      = descr_rd_resp_end &amp;&amp; db1_in_used_bit;
1319                          assign db1_in_used_all_q = descr_rd_resp_end &amp;&amp; db1_in_used_bit;
1320                        end
1321                      endgenerate
1322                    
1323                      // Flag detection of used bit in incoming descriptor
1324                      // for each queue
1325                      // When bit is set no further descriptor fetches will
1326                      // be made for that queue until bit is cleared
1327                      // Bit is cleared when SW issues a new tx_start_pulse
1328                      // or HW issues a new hw_dma_tx_start pulse
1329                      // tx_start_pending keeps queue active where descriptor word 1 was
1330                      // read before SW update but word 0 and/or word 2 were read after
1331                      // SW update
1332                      always @ (posedge aclk or negedge n_areset)
1333                      begin
1334       1/1              if (~n_areset)
1335       1/1                db1_in_used_bits_read &lt;= {(p_num_queues){1'b0}};
1336                        else
1337       1/1                if (mrd_sm_cs == MRD_IDLE || tx_start_pulse || hw_dma_tx_start)
1338       1/1                  db1_in_used_bits_read &lt;= {(p_num_queues){1'b0}} | tx_disable_queue[p_num_queues-1:0];
1339                          else
1340       1/1                  for (int_f=0; int_f&lt;p_num_queues; int_f=int_f+1)
1341       1/1                    if (descr_rd_resp_end &amp;&amp; ~ignore_remaining_desc_rds[int_f] &amp;&amp; db1_in_used_bit &amp;&amp; int_f == {{28{1'b0}},r_queue})
1342       <font color = "red">0/1     ==>              db1_in_used_bits_read[int_f] &lt;= 1'b1;</font>
                        MISSING_ELSE
1343                      end
1344                    
1345                      // Capture tx_start until end of current / next descriptor fetch
1346                      // so a SW update and tx_start pulse is not lost during a multi stripe
1347                      // descriptor fetch
1348                      always @ (posedge aclk or negedge n_areset)
1349                      begin
1350       1/1              if (~n_areset)
1351       1/1                tx_start_pending &lt;= 1'b0;
1352                        else
1353       1/1                if (~enable_tx || flush_tx_rd_fifos || tx_stop_pulse)
1354       1/1                  tx_start_pending &lt;= 1'b0;
1355                          else
1356       1/1                  if ((tx_start_pulse || hw_dma_tx_start) &amp;&amp; mrd_sm_cs != MRD_IDLE)
1357                              // if the start happened while we are already in the middle of sending a request, then we must not
1358       <font color = "red">0/1     ==>            tx_start_pending &lt;= 1'b1;</font>
1359                            else
1360       1/1                    if (mrd_sm_cs == MRD_IDLE &amp;&amp; mrd_sm_ns == MRD_REQ)
1361                    //          if (descr_rd_resp_end)
1362       1/1                      tx_start_pending &lt;= 1'b0;
                        MISSING_ELSE
1363                      end
1364                    
1365                    
1366                      // Indicate when incoming descriptor should be ignored
1367                      // due to previous read of wrap or used bit, or for
1368                      // a descriptor read error for the same queue
1369                      always @ (posedge aclk or negedge n_areset)
1370                      begin
1371       1/1              if  (~n_areset)
1372       1/1                ignore_remaining_desc_rds     &lt;= {p_num_queues{1'b0}};
1373                        else
1374       1/1                if (~enable_tx || flush_tx_rd_fifos)
1375       1/1                  ignore_remaining_desc_rds   &lt;= {p_num_queues{1'b0}};
1376                          else
1377       1/1                  if ((mrd_sm_cs == MRD_WAIT) &amp;&amp; (descr_rd_pend_cnt == 5'd0))
1378       1/1                    ignore_remaining_desc_rds &lt;= {p_num_queues{1'b0}};
1379                            else
1380       1/1                    for (int_d=0; int_d&lt;p_num_queues; int_d=int_d+1)
1381       1/1                      if (descr_rd_resp_end &amp;&amp; int_d == {{28{1'b0}},r_queue})
1382                                begin
1383       1/1                        if (db1_in_used_bit || db1_in_wrap_bit || db1_in_zero_len_buff_err)
1384       <font color = "red">0/1     ==>                  ignore_remaining_desc_rds[int_d] &lt;= 1'b1;</font>
                        MISSING_ELSE
1385                                end
                        MISSING_ELSE
1386                      end
1387                    
1388                    
1389                      always @ (posedge aclk or negedge n_areset)
1390                      begin
1391       1/1              if  (~n_areset)
1392       1/1                first_buffer &lt;= {p_num_queues{1'b1}};
1393                        else
1394       1/1                if (~enable_tx || flush_tx_rd_fifos)
1395       1/1                  first_buffer &lt;= {p_num_queues{1'b1}};
1396                          else
1397       1/1                  for (int_n = 0; int_n &lt; p_num_queues; int_n = int_n + 1)
1398       1/1                    if (db1_push &amp;&amp; int_n == {{28{1'b0}},r_queue})
1399       1/1                      first_buffer[int_n] &lt;= db1_in_last_bit || db1_in_used_bit || db1_in_zero_len_buff_err;
                        MISSING_ELSE
1400                      end
1401                    
1402                    
1403                      always @ (posedge aclk or negedge n_areset)
1404                      begin
1405       1/1              if  (~n_areset)
1406                        begin
1407       1/1                db1_in_used_all_q_was_detected &lt;= 1'b0;
1408       1/1                db1_in_err_was_detected        &lt;= 1'b0;
1409       1/1                db1_in_wrap_was_detected       &lt;= 1'b0;
1410       1/1                db1_in_used_was_detected       &lt;= 1'b0;
1411                        end
1412                        else
1413       1/1                if (~enable_tx || flush_tx_rd_fifos)
1414                          begin
1415       1/1                  db1_in_used_all_q_was_detected &lt;= 1'b0;
1416       1/1                  db1_in_err_was_detected        &lt;= 1'b0;
1417       1/1                  db1_in_wrap_was_detected       &lt;= 1'b0;
1418       1/1                  db1_in_used_was_detected       &lt;= 1'b0;
1419                          end
1420                          else
1421                          begin
1422                            // Used bits detected on all queues
1423                            // - not a critical error, but
1424                            // need to go back to IDLE and wait for start
1425       1/1                  if (mrd_sm_cs == MRD_IDLE)
1426       1/1                    db1_in_used_all_q_was_detected &lt;= 1'b0;
1427                            else
1428       1/1                    if (db1_in_used_all_q)
1429       <font color = "red">0/1     ==>              db1_in_used_all_q_was_detected &lt;= 1'b1;</font>
                        MISSING_ELSE
1430                    
1431                            // db1_in_err_was_detected is used to bigger error events
1432                            // 1. used bit read mid frame
1433                            // 2. zero length buffer mid frame
1434                            // These will cause
1435                            // the underlying DMA to wind back its descriptor pointer.
1436                            // When these happen, we need to stop what we're doing, go back to IDLE state
1437                            // and wait for the underlying module to see the flush
1438       1/1                  if (dma_has_seen_err)
1439       <font color = "red">0/1     ==>            db1_in_err_was_detected &lt;= 1'b0;</font>
1440                            else
1441       1/1                    if (db1_in_buff_err &amp;&amp; descr_rd_resp_end)
1442       <font color = "red">0/1     ==>              db1_in_err_was_detected &lt;= 1'b1;</font>
                        MISSING_ELSE
1443                    
1444                            // Wrap detect set if wrap bit seen in incomming descriptors
1445                            // Cleared when main state machine enters MRD_WAIT state as
1446                            // descriptor req pointer is then on track to be loaded
1447                            // with descriptor resp pointer value.
1448       1/1                  if (mrd_sm_cs == MRD_WAIT)
1449       1/1                    db1_in_wrap_was_detected &lt;= 1'b0;
1450                            else
1451       1/1                    if (db1_in_wrap_bit &amp;&amp; descr_rd_resp_end)
1452       <font color = "red">0/1     ==>              db1_in_wrap_was_detected &lt;= 1'b1;</font>
                        MISSING_ELSE
1453                    
1454                            // Used detect set if used bit seen in incomming descriptors
1455                            // Cleared when main state machine enters MRD_WAIT state as
1456                            // descriptor req pointer is then on track to be loaded
1457                            // with descriptor resp pointer value.
1458       1/1                  if (mrd_sm_cs == MRD_WAIT)
1459       1/1                    db1_in_used_was_detected &lt;= 1'b0;
1460                            else
1461       1/1                    if (db1_in_used_bit &amp;&amp; descr_rd_resp_end)
1462       <font color = "red">0/1     ==>              db1_in_used_was_detected &lt;= 1'b1;</font>
                        MISSING_ELSE
1463                          end
1464                      end
1465                    
1466                      // Drive descriptor read request signaling from mrd_req state machine
1467                    
1468                      assign  arlen_descr = 8'h00;
1469                      assign  cur_descr_ptr = tx_descr_ptr_req_pad[ar_queue_descr];
1470                      assign  arsize_descr  = (dma_bus_width == 2'b00) ? 3'd2 : 3'd3;
1471                    
1472                      always @ *
1473                      begin
1474       1/1              cur_descr_ptr_inc = 32'd0;
1475                    
1476       1/1              case (mreq_sm_cs)
1477                          MREQ_WORD1:
1478                          // Get words 0 and 1 for 64/128 bit data bus or word 1 for 32-bit data bus
1479                          begin
1480       1/1                  if (|dma_bus_width) // 128b/64b data bus
1481                            begin
1482                              // send request for words 0 and 1
1483       <font color = "red">0/1     ==>            arvalid_descr        = do_descr_read || arvalid_descr_hold;</font>
1484                            end
1485                            else  // 32-bit data bus
1486                            begin
1487                              // send request for word 1 only
1488                              // Use an adder for address generation to ensure we
1489                              // support descriptor pointers that are not 64b aligned
1490       1/1                    arvalid_descr       = do_descr_read || arvalid_descr_hold;
1491       1/1                    cur_descr_ptr_inc   = 32'd4;
1492                            end
1493                          end
1494                    
1495                          MREQ_WORD0:
1496                          // get word 0 - only for 32-bit data bus
1497                          begin
1498       1/1                  arvalid_descr        = 1'b1;
1499                          end
1500                    
1501                          MREQ_WORD2:
1502                          // get word 2 - for all data bus widths
1503                          begin
1504       <font color = "red">0/1     ==>          arvalid_descr       = 1'b1;</font>
1505       <font color = "red">0/1     ==>          cur_descr_ptr_inc   = 32'd8;</font>
1506                          end
1507                    
1508                          MREQ_WORD3_5:
1509                          // get word 3/5 - for 32 bit DPs only (must be getting launch times here)
1510                          begin
1511       <font color = "red">0/1     ==>          arvalid_descr        = 1'b1;</font>
1512       <font color = "red">0/1     ==>          if (addressing_64b) // must be requesting word 5</font>
1513       <font color = "red">0/1     ==>            cur_descr_ptr_inc = 32'h00000014;</font>
1514                            else
1515       <font color = "red">0/1     ==>            cur_descr_ptr_inc = 32'h0000000c;</font>
1516                          end
1517                    
1518                          MREQ_WORD4:
1519                          // get word 4 - for obtaining first word of launch time (must be in 64b addressing)
1520                          begin
1521       <font color = "red">0/1     ==>          arvalid_descr       = 1'b1;</font>
1522       <font color = "red">0/1     ==>          cur_descr_ptr_inc   = 32'h00000010;</font>
1523                          end
1524                    
1525                          default: //MREQ_IDLE - no access
1526                          begin
1527       1/1                  arvalid_descr        = 1'b0;
1528                          end
1529                    
1530                        endcase
1531                      end
1532                    
1533                      assign araddr_descr[63:32]    = addressing_64b  ? upper_tx_q_base_addr  : 32'h00000000;
1534                      assign araddr_descr_par[7:4]  = (addressing_64b &amp;&amp; (p_edma_asf_dap_prot &gt; 0)) ? upper_tx_q_base_par : 4'h0;
1535                    
1536                      // The lower address is sum of cur_descr_ptr and cur_descr_ptr_inc.
1537                      // Note that if there was no parity, the in_par to the following module isn't really valid
1538                      // but will be ignored anyway.
1539                      edma_arith_par #(
1540                        .p_dwidth (32),
1541                        .p_pwidth (4),
1542                        .p_has_par(p_edma_asf_dap_prot)
1543                      ) i_arith_araddr_descr (
1544                        .in_val (cur_descr_ptr[31:0]),
1545                        .in_par (cur_descr_ptr[p_awid_par-1:p_awid_par-4]),
1546                        .op_val (cur_descr_ptr_inc),
1547                        .op_add (1'b1),
1548                        .out_val(araddr_descr[31:0]),
1549                        .out_par(araddr_descr_par[3:0])
1550                      );
1551                    
1552                      //============================================================================
1553                      // Pad AXI rdata to 128 bits and swizzle for descriptor reads with and without
1554                      // endian swap
1555                      //============================================================================
1556                      generate if (p_edma_bus_width == 32'd128) begin : gen_nopad_rdata
1557                          assign rdata_pad      = rdata;
1558                          assign rdata_pad_par  = rdata_par;
1559                      end else begin : gen_pad_rdata
1560                          assign rdata_pad      = {{(128-p_edma_bus_width){1'b0}},rdata};
1561                          assign rdata_pad_par  = {{(16-p_edma_bus_pwid){1'b0}},rdata_par};
1562                      end
1563                      endgenerate
1564                    
1565                    
1566                      always @ *
1567                      begin
1568       1/1              case (dma_bus_width)
1569                    
1570                          2'b00 : begin // 32-bit
1571       1/1                  rdata_pad_swap = {96'd0,
1572                                              rdata_pad[7:0],     rdata_pad[15:8],
1573                                              rdata_pad[23:16],   rdata_pad[31:24]};
1574       1/1                  rdata_pad_swap_par = {12'd0,
1575                                              rdata_pad_par[0],   rdata_pad_par[1],
1576                                              rdata_pad_par[2],   rdata_pad_par[3]};
1577                            end
1578                          2'b01 : begin // 64-bit
1579       <font color = "red">0/1     ==>          rdata_pad_swap = {64'd0,</font>
1580                                              rdata_pad[7:0],     rdata_pad[15:8],
1581                                              rdata_pad[23:16],   rdata_pad[31:24],
1582                                              rdata_pad[39:32],   rdata_pad[47:40],
1583                                              rdata_pad[55:48],   rdata_pad[63:56]};
1584       <font color = "red">0/1     ==>          rdata_pad_swap_par = {8'd0,</font>
1585                                              rdata_pad_par[0],   rdata_pad_par[1],
1586                                              rdata_pad_par[2],   rdata_pad_par[3],
1587                                              rdata_pad_par[4],   rdata_pad_par[5],
1588                                              rdata_pad_par[6],   rdata_pad_par[7]};
1589                            end
1590                    
1591                          default : begin // 128-bit
1592       <font color = "red">0/1     ==>          rdata_pad_swap = {rdata_pad[7:0],     rdata_pad[15:8],</font>
1593                                              rdata_pad[23:16],   rdata_pad[31:24],
1594                                              rdata_pad[39:32],   rdata_pad[47:40],
1595                                              rdata_pad[55:48],   rdata_pad[63:56],
1596                                              rdata_pad[71:64],   rdata_pad[79:72],
1597                                              rdata_pad[87:80],   rdata_pad[95:88],
1598                                              rdata_pad[103:96],  rdata_pad[111:104],
1599                                              rdata_pad[119:112], rdata_pad[127:120]};
1600       <font color = "red">0/1     ==>          rdata_pad_swap_par = {rdata_pad_par[0],   rdata_pad_par[1],</font>
1601                                              rdata_pad_par[2],   rdata_pad_par[3],
1602                                              rdata_pad_par[4],   rdata_pad_par[5],
1603                                              rdata_pad_par[6],   rdata_pad_par[7],
1604                                              rdata_pad_par[8],   rdata_pad_par[9],
1605                                              rdata_pad_par[10],  rdata_pad_par[11],
1606                                              rdata_pad_par[12],  rdata_pad_par[13],
1607                                              rdata_pad_par[14],  rdata_pad_par[15]};
1608                            end
1609                        endcase
1610                      end
1611                    
1612                    
1613                      assign rdata_descr_le     = endian_swap[0] ? rdata_pad_swap     : rdata_pad;
1614                      assign rdata_descr_le_par = endian_swap[0] ? rdata_pad_swap_par : rdata_pad_par;
1615                      assign rdata_data_le      = endian_swap[1] ? rdata_pad_swap     : rdata_pad;
1616                      assign rdata_data_le_par  = endian_swap[1] ? rdata_pad_swap_par : rdata_pad_par;
1617                    
1618                      //====================================================
1619                      // Copy descriptor data from rdata bus
1620                      // Position of data on bus depends on bus width,
1621                      // descriptor word(s) being read and endianism
1622                      //====================================================
1623                      always @ *
1624                      begin
1625       1/1              case (mresp_sm_cs)
1626                          MRESP_WORD1:
1627                          // MRESP_WORD1 - Receiving word 0 and 1 for 64/128 bit data bus or word 1 for 32-but data bus
1628                          //
1629                          begin
1630       1/1                  if (dma_bus_width[1] &amp;&amp; r_araddr[3])
1631                            begin
1632                              // 128 bit data bus with raddr[3] == 1
1633                              // BD word 1 is in 127:96, BD word 0 is in 95:64
1634       <font color = "red">0/1     ==>            rdata_descr     = rdata_descr_le[127:64];</font>
1635       <font color = "red">0/1     ==>            rdata_descr_par = rdata_descr_le_par[15:8];</font>
1636                            end
1637                            else
1638       1/1                    if (dma_bus_width[1] &amp;&amp; ~r_araddr[3])
1639                              begin
1640                                // 128 bit data bus with raddr[3] == 0
1641                                // BD word 1 is in 63:32, BD word 0 is in 31:0
1642       <font color = "red">0/1     ==>              rdata_descr     = rdata_descr_le[63:0];</font>
1643       <font color = "red">0/1     ==>              rdata_descr_par = rdata_descr_le_par[7:0];</font>
1644                              end
1645                              else
1646       1/1                      if (dma_bus_width == 2'b01)
1647                                begin
1648                                  // 64 bit data bus
1649                                  // BD word 1 is in 63:32, BD word 0 is in 31:0
1650       <font color = "red">0/1     ==>                rdata_descr     = rdata_descr_le[63:0];</font>
1651       <font color = "red">0/1     ==>                rdata_descr_par = rdata_descr_le_par[7:0];</font>
1652                                end
1653                                else
1654                                  // 32 bit data bus
1655                                  // BD word 1 is in 31:0
1656                                  begin
1657       1/1                          rdata_descr[63:32]= rdata_descr_le[31:0];
1658       1/1                          rdata_descr[31:0] = 32'd0;
1659       1/1                          rdata_descr_par   = {rdata_descr_le_par[3:0],4'h0};
1660                                  end
1661                          end
1662                    
1663                          MRESP_WORD2, MRESP_WORD4 :
1664                          // MRESP_WORD2 :
1665                          // get word 2 - for all data bus widths
1666                          // this is the lower 32bits of the launch time when 32bit addressing and databus = 32 bits
1667                          // or all bits of the launch time when no 64bit addressing and databus = 64/128 bits
1668                          // or the upper data buffer address bits when 64bit addressing = 1
1669                          //
1670                          // MRESP_WORD4
1671                          // get word 4 - only valid for tx_extended_bd_mode_en and 64bit addressing
1672                          // this is the launch time
1673                          begin
1674       <font color = "red">0/1     ==>          if (dma_bus_width[1] &amp;&amp; r_araddr[3])</font>
1675                            begin
1676                              // 128 bit data bus with raddr[3] == 1
1677                              // BD word 2 &amp; 3 is in 127:64
1678       <font color = "red">0/1     ==>            rdata_descr     = rdata_descr_le[127:64];</font>
1679       <font color = "red">0/1     ==>            rdata_descr_par = rdata_descr_le_par[15:8];</font>
1680                            end
1681                            else
1682       <font color = "red">0/1     ==>            if (dma_bus_width[1] &amp;&amp; ~r_araddr[3])</font>
1683                              begin
1684                                // 128 bit data bus with raddr[3] == 0
1685                                // BD word 2 &amp; 3 is in 63:0
1686       <font color = "red">0/1     ==>              rdata_descr     = rdata_descr_le[63:0];</font>
1687       <font color = "red">0/1     ==>              rdata_descr_par = rdata_descr_le_par[7:0];</font>
1688                              end
1689                              else
1690       <font color = "red">0/1     ==>              if (dma_bus_width == 2'b01)</font>
1691                                begin
1692                                  // 64 bit data bus
1693                                  // BD word 2 &amp; 3 is in 63:0
1694       <font color = "red">0/1     ==>                rdata_descr     = rdata_descr_le[63:0];</font>
1695       <font color = "red">0/1     ==>                rdata_descr_par = rdata_descr_le_par[7:0];</font>
1696                                end
1697                                else
1698                                begin
1699                                  // 32 bit data bus
1700                                  // BD word 2 is in 31:0
1701       <font color = "red">0/1     ==>                rdata_descr[63:32]= 32'd0;</font>
1702       <font color = "red">0/1     ==>                rdata_descr[31:0] = rdata_descr_le[31:0];</font>
1703       <font color = "red">0/1     ==>                rdata_descr_par   = {4'h0,rdata_descr_le_par[3:0]};</font>
1704                                end
1705                    
1706                          end
1707                    
1708                    //      MRESP_WORD0,MRESP_WORD3_5:
1709                          default:
1710                          // receive word 0, MRESP_WORD3_5 - valid only for 32-bit data bus
1711                          begin
1712       1/1                  rdata_descr[63:32]= 32'd0;
1713       1/1                  rdata_descr[31:0] = rdata_descr_le[31:0];
1714       1/1                  rdata_descr_par   = {4'h0,rdata_descr_le_par[3:0]};
1715                          end
1716                    
1717                        endcase
1718                      end
1719                    
1720                      //====================================================
1721                      // Assert descr_rd_req_end when AR request is
1722                      // accepted for last word of descriptor read request
1723                      //====================================================
1724                      always @ *
1725                      begin
1726       1/1              case (mreq_sm_cs)
1727                          MREQ_WORD1:
1728                            // Last word unless 32-bit data bus or 64 bit addressing
1729       1/1                  descr_rd_req_end = arrv_descr &amp;&amp; (dma_bus_width != 2'd0) &amp;&amp; ~(addressing_64b | tx_extended_bd_mode_en);
1730                    
1731                          MREQ_WORD0:
1732                            // Last word unless 64 bit addressing
1733       1/1                  descr_rd_req_end = arrv_descr &amp;&amp; ~(addressing_64b | tx_extended_bd_mode_en);
1734                    
1735                          MREQ_WORD2:
1736                            // 64 bit addressing or bd_extended
1737       <font color = "red">0/1     ==>          descr_rd_req_end = arrv_descr &amp;&amp; ((dma_bus_width != 2'd0 &amp;&amp; tx_extended_bd_mode_en &amp;&amp; !addressing_64b) || (addressing_64b &amp;&amp; !tx_extended_bd_mode_en));</font>
1738                    
1739                          MREQ_WORD3_5:
1740                            // bd_extended only - always finish
1741       <font color = "red">0/1     ==>          descr_rd_req_end = arrv_descr;</font>
1742                    
1743                          MREQ_WORD4:
1744                            // bd_extended only, only finish if not 32 bit
1745       <font color = "red">0/1     ==>          descr_rd_req_end = arrv_descr &amp;&amp; dma_bus_width != 2'd0;</font>
1746                    
1747                          default: //MREQ_IDLE:
1748                            // No access in this state
1749       1/1                  descr_rd_req_end = 1'b0;
1750                    
1751                        endcase
1752                      end
1753                    
1754                    
1755                      //====================================================
1756                      // Assert descr_rd_resp_end when rvalid is asserted for
1757                      // last word of descriptor read response
1758                      //====================================================
1759                      assign descr_rd_resp_end = rrv_descr &amp;&amp; (mresp_sm_ns == MRESP_WORD1);
1760                    
1761                    
1762                      //========================================================
1763                      // Store partial descriptor in holding register when it is
1764                      // read via multiple read requests
1765                      //========================================================
1766                      wire db1_in_hold_nxt_128;
1767                      assign db1_in_hold_nxt_128 = (db1_in_hold[128] || (rresp != 2'b00));
1768                      always @ (posedge aclk or negedge n_areset)
1769                      begin
1770       1/1              if (~n_areset)
1771       1/1                db1_in_hold &lt;= 129'd0;
1772                        else
1773       1/1                if (~enable_tx || flush_tx_rd_fifos)
1774       1/1                  db1_in_hold &lt;= 129'd0;
1775                          else
1776       1/1                  case (mresp_sm_cs)
1777                    
1778                              MRESP_WORD0:
1779                              // receiving word 0 - valid only for 32-bit data bus
1780                              // Need to keep previously loaded word 1
1781       1/1                      if (rrv_descr)
1782       1/1                        db1_in_hold &lt;= {db1_in_hold_nxt_128,
                        MISSING_ELSE
1783                                                  {64{1'b0}},
1784                                                  db1_in_hold[63:32],
1785                                                  rdata_descr[31:0]};
1786                    
1787                              MRESP_WORD2:
1788                              // receive word 2 or 4
1789       <font color = "red">0/1     ==>              if (rrv_descr)</font>
1790       <font color = "red">0/1     ==>                db1_in_hold &lt;= {db1_in_hold_nxt_128,</font>
                   <font color = "red">==>  MISSING_ELSE</font>
1791                                                  rdata_descr,
1792                                                  db1_in_hold[63:0]};
1793                    
1794                              MRESP_WORD3_5,MRESP_WORD4:
1795                              // receive word 3 or 5 (only need to buffer in extended bd mode, 32 bit datapaths ..)
1796                              // receive word 4 (only buffer the lower 32 bits in case we are in 32bit mode). If in 64/128, we'll finish here
1797       <font color = "red">0/1     ==>              if (rrv_descr)</font>
1798       <font color = "red">0/1     ==>                db1_in_hold &lt;= {db1_in_hold_nxt_128,</font>
                   <font color = "red">==>  MISSING_ELSE</font>
1799                                                  rdata_descr[31:0],
1800                                                  db1_in_hold[95:0]};
1801                    
1802                              default:  // MRESP_WORD1
1803                              // Receiving word 0 and 1 for 64/128 bit data bus or word 1 for 32-but data bus
1804                              // Always store whether last word of descriptor or not so that used, last and wrap
1805                              // status is captured
1806       1/1                      if (rrv_descr)
1807       1/1                          db1_in_hold &lt;= {(rresp != 2'b00),{64{1'b0}}, rdata_descr};
                        MISSING_ELSE
1808                    
1809                            endcase
1810                      end
1811                    
1812                      //====================================================
1813                      // Assemble descriptor for storage in buffer
1814                      // Build from rdata_descr and holding register depending
1815                      // on descriptor size,  address bus width
1816                      //====================================================
1817                      always @ *
1818                      begin
1819       1/1              case (mresp_sm_cs)
1820                          MRESP_WORD1:
1821                          begin
1822                          // Pass words 0 and 1 to buffer
1823       1/1                  db1_in_129  = {65'd0,
1824                                          rdata_descr};
1825       1/1                  db1_in_129_par  = {9'h000,rdata_descr_par};
1826                          end
1827                    
1828                          MRESP_WORD0:
1829                          begin
1830                          // Pass word 0 and previously read word 1 to buffer
1831                          // Only valid for 32-bit data bus
1832       1/1                  db1_in_129  = {65'd0,
1833                                          db1_in_hold[63:32],
1834                                          rdata_descr[31:0]};
1835       1/1                  db1_in_129_par  = {9'h000,
1836                                                db1_in_par_hold[7:4],
1837                                                rdata_descr_par[3:0]};
1838                          end
1839                    
1840                          MRESP_WORD2:
1841                            // if 64 bit addressing enabled, bits 95:64 are the upper address bits ..
1842                            // otherwise, bits 95:64 are the launch time and bit 96 is the launch time enable ..
1843       <font color = "red">0/1     ==>          if (addressing_64b)</font>
1844                            begin
1845       <font color = "red">0/1     ==>            db1_in_129      = {33'd0,</font>
1846                                                 rdata_descr[31:0],
1847                                                 db1_in_hold[63:0]};
1848       <font color = "red">0/1     ==>            db1_in_129_par  = {5'd0,</font>
1849                                                rdata_descr_par[3:0],
1850                                                db1_in_par_hold[7:0]};
1851                            end
1852                            else
1853                            begin
1854       <font color = "red">0/1     ==>            db1_in_129      = {32'd0,</font>
1855                                                 rdata_descr[63],
1856                                                 rdata_descr[31:0],
1857                                                 db1_in_hold[63:0]};
1858       <font color = "red">0/1     ==>            db1_in_129_par  = {4'h0,</font>
1859                                                rdata_descr[63],
1860                                                rdata_descr_par[3:0],
1861                                                db1_in_par_hold[7:0]};
1862                            end
1863                          MRESP_WORD3_5:
1864                            // we are finishing up here, tx_extended_bd_mode_en must be set..
1865                            // if addressing_64b = 1, bits 95:64 are the upper address bits, 127:96 is the launch time
1866                            //  and bit 128 is the launch time enable (taken from bit 31 of current bus) ..
1867                            // if addressing_64b = 0, bits 95:64 is the launch time
1868                            //  and bit 96 is the launch time enable (taken from bit 31 of current bus) ..
1869       <font color = "red">0/1     ==>          if (addressing_64b)</font>
1870                            begin
1871       <font color = "red">0/1     ==>            db1_in_129  = {rdata_descr[31],     // launch time enable</font>
1872                                             db1_in_hold[127:0]};
1873       <font color = "red">0/1     ==>            db1_in_129_par  = {rdata_descr[31],</font>
1874                                                db1_in_par_hold[15:0]};
1875                            end
1876                            else
1877                            begin
1878       <font color = "red">0/1     ==>            db1_in_129  = {32'd0,</font>
1879                                             rdata_descr[31],     // launch time enable
1880                                             db1_in_hold[95:0]};
1881       <font color = "red">0/1     ==>            db1_in_129_par  = {4'h0,</font>
1882                                                rdata_descr[31],
1883                                                db1_in_par_hold[11:0]};
1884                            end
1885                          default: // MRESP_WORD4
1886                          begin
1887                            // bits 95:64 are the upper address bits ..
1888                            // 127:96 is the launch time
1889                            // and bit 128 is the launch time enable
1890       1/1                    db1_in_129  = {rdata_descr[63],     // launch time enable
1891                                             rdata_descr[31:0],   // launch time
1892                                             db1_in_hold[95:0]};
1893       1/1                    db1_in_129_par  = {rdata_descr[63],
1894                                                rdata_descr_par[3:0],
1895                                                db1_in_par_hold[11:0]};
1896                          end
1897                        endcase
1898                      end
1899                      // Automatically shorten the bus depending on the congifuration choices
1900                      // If 64b addressing = 0 and ext bd = 0, then the descriptor is 64bits in size
1901                      // If 64b addressing = 1 and ext bd = 0, then the descriptor is 96bits in size
1902                      // If 64b addressing = 0 and ext bd = 1, then the descriptor is 97bits in size
1903                      // If 64b addressing = 1 and ext bd = 1, then the descriptor is 129bits in size
1904                      assign db1_in     = db1_in_129[p_descr_width-1:0];
1905                      assign db1_in_par = db1_in_129_par[p_descr_pwidth-1:0];
1906                    
1907                      assign db1_in_rresp_err = (mresp_sm_cs == MRESP_WORD1) ? (rresp != 2'b00)
1908                                                                             : (db1_in_hold[128] || (rresp != 2'b00));
1909                    
1910                    
1911                      //====================================================
1912                      // Extract used, wrap and last status bits from descriptor
1913                      // word 1 as it is read from AXI
1914                      // Status must be valid as last descriptor word is read,
1915                      // which may or may not be word 1 - depending on bus width
1916                      // and addressing mode - so extract status from input
1917                      // to primary descriptor buffer or from holding register
1918                      // as required
1919                      //====================================================
1920                      always @ *
1921                      begin
1922       1/1              if (rrv_descr &amp;&amp; (mresp_sm_cs == MRESP_WORD1))
1923                        //reading word 1
1924                        begin
1925       1/1                db1_in_used_bit = db1_in[63] &amp;&amp; ~ignore_remaining_desc_rds_pad[r_queue];
1926       1/1                db1_in_wrap_bit = db1_in[62] &amp;&amp; ~db1_in_used_bit &amp;&amp; ~ignore_remaining_desc_rds_pad[r_queue];
1927       1/1                db1_in_last_bit = db1_in[47] &amp;&amp; ~db1_in_used_bit &amp;&amp; ~ignore_remaining_desc_rds_pad[r_queue];
1928                        end
1929                        else
1930                        begin
1931       1/1                db1_in_used_bit = db1_in_hold[63] &amp;&amp; ~ignore_remaining_desc_rds_pad[r_queue];
1932       1/1                db1_in_wrap_bit = db1_in_hold[62] &amp;&amp; ~db1_in_used_bit &amp;&amp; ~ignore_remaining_desc_rds_pad[r_queue];
1933       1/1                db1_in_last_bit = db1_in_hold[47] &amp;&amp; ~db1_in_used_bit &amp;&amp; ~ignore_remaining_desc_rds_pad[r_queue];
1934                        end
1935                      end
1936                    
1937                    
1938                      //====================================================
1939                      // Calculate descriptor address increment
1940                      // Descriptor can be 2, 4 or 6 words
1941                      // legacy is 32'd8                         = 2 BD words
1942                      // addr64 AND extended BD will be 32'd24   = 6 BD words
1943                      // addr64 exOR extended BD will be 32'd16  = 4 BD words
1944                      //====================================================
1945                      always @ *
1946                      begin
1947       1/1              if (~addressing_64b &amp;&amp; ~tx_extended_bd_mode_en)
1948       1/1                tx_next_descr_ptr_inc = 32'h00000008;
1949                        else
1950       1/1                if (addressing_64b &amp;&amp; tx_extended_bd_mode_en)
1951       <font color = "red">0/1     ==>          tx_next_descr_ptr_inc = 32'h00000018;</font>
1952                          else
1953       1/1                  tx_next_descr_ptr_inc = 32'h00000010;
1954                    
1955                      end
1956                    
1957                    
1958                      //====================================================
1959                      // Track the number of outstanding descriptor read
1960                      // requests
1961                      //  - increment on request, decrement on response
1962                      //  - a descriptor fetch can consist of several separate
1963                      //    requests/responses depending on descriptor size
1964                      //    and data bus width, so increment on the last
1965                      //    request and decrement on the last response
1966                      //====================================================
1967                    
1968                      always @ (posedge aclk or negedge n_areset)
1969                      begin
1970       1/1              if (~n_areset)
1971       1/1                descr_rd_pend_cnt &lt;= 5'd0;
1972                        else
1973       1/1                if (~enable_tx || flush_tx_rd_fifos)
1974       1/1                  descr_rd_pend_cnt &lt;= 5'd0;
1975                          else
1976       1/1                  if (descr_rd_req_end &amp;&amp; ~descr_rd_resp_end)
1977       1/1                    descr_rd_pend_cnt &lt;= descr_rd_pend_cnt + 5'd1;
1978                            else
1979       1/1                    if (~descr_rd_req_end &amp;&amp; descr_rd_resp_end)
1980       1/1                      descr_rd_pend_cnt &lt;= descr_rd_pend_cnt - 5'd1;
                        MISSING_ELSE
1981                      end
1982                    
1983                      //====================================================
1984                      // Manage the descriptor pointers for each queue
1985                      // When we issue a request, increment the current req pointer.
1986                      // When we get a  response, increment the current resp pointer.
1987                      // If any of these valid responses have the wrap bit set, then we need to reset
1988                      // the pointers.  A valid response is one that doesnt have ignore_remaining_desc_rds
1989                      // bit set or used bit set
1990                      //====================================================
1991                      always @ (posedge aclk or negedge n_areset)
1992                      begin
1993       1/1              if (~n_areset)
1994                        begin
1995       1/1                for (int_a = 0; int_a &lt; p_num_queues; int_a = int_a + 1)
1996                          begin
1997       1/1                  tx_descr_ptr_req[int_a]  &lt;= {p_awid_par{1'b0}};
1998       1/1                  tx_descr_ptr_resp[int_a] &lt;= {p_awid_par{1'b0}};
1999                          end
2000                        end
2001                        else
2002       1/1                if (((~enable_tx || flush_tx_rd_fifos) &amp;&amp; ~(arvalid_descr &amp;&amp; ~arready_descr)) ||
2003                              (new_tx_q_ptr_pulse &amp;&amp; (mrd_sm_cs == MRD_IDLE)))
2004                          // initialise pointers to config reg base values
2005                          begin
2006       1/1                  for (int_e = 0; int_e &lt; p_num_queues; int_e = int_e + 1)
2007                            begin
2008       1/1                    tx_descr_ptr_req[int_e] &lt;= tx_base_addr_arr[int_e];
2009       1/1                    tx_descr_ptr_resp[int_e]&lt;= tx_base_addr_arr[int_e];
2010                            end
2011                          end
2012                          else
2013                          begin
2014       1/1                  for (int_k = 0; int_k &lt; p_num_queues; int_k = int_k + 1)
2015                            begin
2016       1/1                    if (int_k == {{28{1'b0}},r_queue})
2017                              begin
2018       1/1                      if (descr_rd_resp_end)
2019                                // Response pointer returns to base when wrap bit is observed, and does not increment if used bit
2020                                // is observed or there has been an illegal descriptor
2021                                // Otherwise, increment on each descriptor response
2022                                begin
2023       1/1                        if (~db1_in_used_bit &amp;&amp; ~ignore_remaining_desc_rds_pad[r_queue] &amp;&amp; ~db1_in_zero_len_buff_err)
2024                                  begin
2025       1/1                          if (db1_in_wrap_bit)
2026       <font color = "red">0/1     ==>                    tx_descr_ptr_resp[int_k]  &lt;= tx_base_addr_arr[int_k];</font>
2027                                    else
2028       1/1                            tx_descr_ptr_resp[int_k]  &lt;= cur_tx_descr_ptr_resp_inc[p_awid_par-1:0];
2029                                  end
                        MISSING_ELSE
2030                                end
                        MISSING_ELSE
2031                              end
                   <font color = "red">==>  MISSING_ELSE</font>
2032                    
2033       1/1                    if ((mrd_sm_cs == MRD_WAIT) &amp;&amp; (descr_rd_pend_cnt == 5'd0))
2034                              // If main descriptor read state machine enters MRD_WAIT state then there has been a wrap bit, used bit or an
2035                              // illegal descriptor - so align req pointer with resp pointer
2036       1/1                      tx_descr_ptr_req[int_k] &lt;= tx_descr_ptr_resp[int_k];
2037                              else
2038       1/1                      if (descr_rd_req_end &amp;&amp; int_k == {{28{1'b0}},ar_queue_descr})
2039                                // Otherwise increment pointer when each request is output
2040       1/1                        tx_descr_ptr_req[int_k]  &lt;= ar_tx_descr_ptr_req_inc[p_awid_par-1:0];
                        MISSING_ELSE
2041                            end
2042                          end
2043                      end
2044                    
2045                      // following is for LINT
2046                      genvar q_cnt_1;
2047                      generate for (q_cnt_1=0; q_cnt_1&lt;p_num_queues; q_cnt_1 = q_cnt_1+1) begin : gen_pad_sigs
2048                        assign ipv4_fo_cnt_pad[q_cnt_1] = ipv4_fo_cnt[q_cnt_1];
2049                        assign ignore_remaining_desc_rds_pad[q_cnt_1] = ignore_remaining_desc_rds[q_cnt_1];
2050                        assign first_buffer_pad[q_cnt_1] = first_buffer[q_cnt_1];
2051                        assign db1_in_used_bits_read_pad[q_cnt_1] = db1_in_used_bits_read[q_cnt_1];
2052                        assign tx_disable_queue_pad[q_cnt_1] = tx_disable_queue[q_cnt_1];
2053                        assign tx_descr_ptr_resp_pad[q_cnt_1] = tx_descr_ptr_resp[q_cnt_1];
2054                        assign requested_axi_data_pad[q_cnt_1] = requested_axi_data[q_cnt_1];
2055                        assign tx_descr_ptr_req_pad[q_cnt_1] = tx_descr_ptr_req[q_cnt_1];
2056                        assign seq_num_st0_ctr_pad[q_cnt_1] = seq_num_st0_ctr[q_cnt_1];
2057                        assign seq_num_st1_ctr_pad[q_cnt_1] = seq_num_st1_ctr[q_cnt_1];
2058                        assign seq_num_st2_ctr_pad[q_cnt_1] = seq_num_st2_ctr[q_cnt_1];
2059                        assign seq_num_st3_ctr_pad[q_cnt_1] = seq_num_st3_ctr[q_cnt_1];
2060                      end
2061                      endgenerate
2062                    
2063                      genvar q_cnt;
2064                      generate for (q_cnt=p_num_queues; q_cnt&lt;16; q_cnt = q_cnt+1)
2065                      begin : set_unused_sigs
2066                        wire zero = 1'b0;
2067                        always@(*)
2068                        begin
2069       15/15              db2_descr_wb_addr[q_cnt] = {p_awid_par{zero}};
2070                        end
2071                        assign ipv4_fo_cnt_pad[q_cnt] = 13'd0;
2072                        assign ignore_remaining_desc_rds_pad[q_cnt] = 1'b0;
2073                        assign first_buffer_pad[q_cnt] = {p_awid_par{1'b0}};
2074                        assign db1_in_used_bits_read_pad[q_cnt] = 1'b0;
2075                        assign tx_descr_ptr_resp_pad[q_cnt] = {p_awid_par{1'b0}};
2076                        assign tx_descr_ptr_req_pad[q_cnt] = {p_awid_par{1'b0}};
2077                        assign db1_full_q[q_cnt] = 1'b0;
2078                        assign tx_disable_queue_pad[q_cnt] = 1'b0;
2079                        assign tx_base_addr_arr[q_cnt] = {p_awid_par{1'b0}};
2080                        assign db2_out_dma[q_cnt] = {p_descr_width+4{1'b0}};
2081                        assign db2_out_dma_par[q_cnt] = {p_descr_pwidth{1'b0}};
2082                        assign db2_out_axi[q_cnt] = {p_descr_width+4{1'b0}};
2083                        assign db2_out_axi_par[q_cnt] = {p_descr_pwidth{1'b0}};
2084                        assign db2_out_nxt_axi[q_cnt] = {p_descr_width+4{1'b0}};
2085                        assign db2_out_nxt_axi_par[q_cnt] = {p_descr_pwidth{1'b0}};
2086                        assign db2_fill_axi_q[q_cnt] = {p_axi_tx_descr_rd_buff_bits+1{1'b0}};
2087                        assign dpram_fill_lvl_array[q_cnt] = {p_edma_tx_pbuf_addr+2{1'b0}};
2088                        assign TX_PBUF_MAX_FILL_LVL_ARRAY[q_cnt] = {p_edma_tx_pbuf_addr+2{1'b0}};
2089                        assign requested_axi_data_pad[q_cnt] = {p_edma_tx_pbuf_addr+2{1'b0}};
2090                        assign seq_num_st0_ctr_pad[q_cnt] = {32{1'b0}};
2091                        assign seq_num_st1_ctr_pad[q_cnt] = {32{1'b0}};
2092                        assign seq_num_st2_ctr_pad[q_cnt] = {32{1'b0}};
2093                        assign seq_num_st3_ctr_pad[q_cnt] = {32{1'b0}};
2094                      end
2095                      endgenerate
2096                    
2097                      // Calculations handling parity as well
2098                      // cur_tx_descr_ptr_resp_inc = tx_descr_ptr_resp[r_queue] + tx_next_descr_ptr_inc;
2099                      edma_arith_par #(
2100                        .p_dwidth (32),
2101                        .p_pwidth (4),
2102                        .p_has_par(p_edma_asf_dap_prot)
2103                      ) i_arith_cur_tx_descr_ptr_resp (
2104                        .in_val (tx_descr_ptr_resp_pad[r_queue][31:0]),
2105                        .in_par (tx_descr_ptr_resp_pad[r_queue][p_awid_par-1:p_awid_par-4]),
2106                        .op_val (tx_next_descr_ptr_inc),
2107                        .op_add (1'b1),
2108                        .out_val(cur_tx_descr_ptr_resp_inc[31:0]),
2109                        .out_par(cur_tx_descr_ptr_resp_inc[35:32])
2110                      );
2111                      // ar_tx_descr_ptr_req_inc = tx_descr_ptr_req[ar_queue_descr] + tx_next_descr_ptr_inc;
2112                      edma_arith_par #(
2113                        .p_dwidth (32),
2114                        .p_pwidth (4),
2115                        .p_has_par(p_edma_asf_dap_prot)
2116                      ) i_arith_ar_tx_descr_ptr_req (
2117                        .in_val (tx_descr_ptr_req_pad[ar_queue_descr][31:0]),
2118                        .in_par (tx_descr_ptr_req_pad[ar_queue_descr][p_awid_par-1:p_awid_par-4]),
2119                        .op_val (tx_next_descr_ptr_inc),
2120                        .op_add (1'b1),
2121                        .out_val(ar_tx_descr_ptr_req_inc[31:0]),
2122                        .out_par(ar_tx_descr_ptr_req_inc[35:32])
2123                      );
2124                    
2125                      // Push descriptor to descriptor buffer when descriptor fetch response is received, unless the descriptor is
2126                      // ignored due to a previous descriptor with used, wrap or error
2127                      // Push descriptors with error conditions (multi buffer used bit or zero length last) so AHB will flag
2128                      // relevant interrupt
2129                      // Descriptors with used bit set are not pushed unless db1_in_used_all_q is set - therefore only 1 descriptor
2130                      // with a used bit is pushed in a multi queue config when no queues have available descriptors
2131                      // Descriptor is not pushed if an AXI response error was received for part or all of the descriptor
2132                      assign db1_push = descr_rd_resp_end &amp;&amp; ~ignore_remaining_desc_rds_pad[r_queue] &amp;&amp;
2133                                        (~db1_in_used_bit || (db1_in_used_all_q &amp;&amp; !q0_num_used_all) || db1_in_buff_err) &amp;&amp; ~db1_in_rresp_err;
2134                    
2135                    
2136                      // ======================================================================================
2137                      // Descriptor buffer per queue
2138                      // Module contains primary and secondary descriptor buffers and descriptor
2139                      // generatot logic
2140                      // Secondary descriptor buffer has separate read ports for AXI and AHB DMAs. AXI port
2141                      // supplies values for current and next read pointer location
2142                      // AHB memory fill level si for use by descriptor generatot logic
2143                      // ======================================================================================
2144                      genvar gv_db;
2145                      generate
2146                        for (gv_db = 0; gv_db &lt; p_num_queues; gv_db = gv_db + 1)
2147                    
2148                        begin : tx_descr_buff
2149                          wire [p_edma_tx_pbuf_addr+1:0]    axi_tx_full_adj_tmp;
2150                          wire                              sram_full;
2151                          wire [p_edma_tx_pbuf_addr+2:0]    axi_tx_full_adj_0_shift_p_adj_1_shift;
2152                          
2153                          
2154                          assign db1_push_q[gv_db]          = db1_push &amp;&amp; (r_queue == gv_db[3:0]);
2155                          assign descr_rd_req_end_q[gv_db]  = descr_rd_req_end &amp;&amp; (ar_queue_descr == gv_db[3:0]);
2156                          assign descr_rd_resp_end_q[gv_db] = descr_rd_resp_end &amp;&amp; (r_queue == gv_db[3:0]);
2157                    
2158                          assign db2_pop_axi_q[gv_db] = db2_pop_axi &amp;&amp; (cur_db2_axi_queue == gv_db[3:0]);
2159                          assign db2_pop_dma_q[gv_db] = db2_pop_dma &amp;&amp; (cur_db2_dma_queue == gv_db[3:0]);
2160                          
2161                          assign axi_tx_full_adj_0_shift_p_adj_1_shift = axi_tx_full_adj_0_shft + axi_tx_full_adj_1_shft;
2162                          assign axi_tx_full_adj_tmp  = gv_db == 0 ? axi_tx_full_adj_0_shift_p_adj_1_shift[p_edma_tx_pbuf_addr+1:0] : axi_tx_full_adj_0_shft;
2163                    
2164                          edma_pbuf_axi_fe_desc_buff #(
2165                    
2166                            .p_edma_lso                   (p_edma_lso),
2167                            .p_edma_asf_dap_prot          (p_edma_asf_dap_prot),
2168                            .p_axi_tx_descr_rd_buff_depth (p_axi_tx_descr_rd_buff_depth),
2169                            .p_axi_tx_descr_rd_buff_bits  (p_axi_tx_descr_rd_buff_bits),
2170                            .p_descr_width                (p_descr_width),
2171                            .p_num_queues                 (p_num_queues),
2172                            .p_edma_tx_pbuf_addr          (p_edma_tx_pbuf_addr),
2173                            .p_edma_tx_pbuf_data          (p_edma_tx_pbuf_data),
2174                            .p_this_queue                 (gv_db)
2175                    
2176                          ) i_tx_descr_buff (
2177                    
2178                            .aclk                   (aclk),
2179                            .n_areset               (n_areset),
2180                    
2181                            .enable_tx              ((enable_tx &amp;&amp; ~flush_tx_rd_fifos) || (arvalid_data &amp;&amp; ~arready_data)),
2182                    
2183                            .db1_in                 (db1_in),
2184                            .db1_in_par             (db1_in_par),
2185                            .db1_push               (db1_push_q[gv_db]),
2186                            .descr_rd_req_end       (descr_rd_req_end_q[gv_db]),
2187                            .descr_rd_resp_end      (descr_rd_resp_end_q[gv_db]),
2188                            .db1_full               (db1_full_q[gv_db[3:0]]),
2189                    
2190                            .db2_out_axi            (db2_out_axi[gv_db]),
2191                            .db2_out_axi_par        (db2_out_axi_par[gv_db]),
2192                            .db2_out_nxt_axi        (db2_out_nxt_axi[gv_db]),
2193                            .db2_out_nxt_axi_par    (db2_out_nxt_axi_par[gv_db]),
2194                            .db2_pop_axi            (db2_pop_axi_q[gv_db]),
2195                            .db2_fill_axi           (db2_fill_axi_q[gv_db]),
2196                            .db2_empty_axi          (db2_empty_axi_q[gv_db]),
2197                    
2198                            .db2_out_dma            (db2_out_dma[gv_db]),
2199                            .db2_out_dma_par        (db2_out_dma_par[gv_db]),
2200                            .db2_pop_dma            (db2_pop_dma_q[gv_db]),
2201                            .db2_empty_dma          (db2_empty_dma_q[gv_db]),
2202                    
2203                            .sram_fill_lvl          (dpram_fill_lvl_array[gv_db] &amp; TX_PBUF_MAX_FILL_LVL_ARRAY[gv_db]),
2204                            .sram_max_fill_lvl      (TX_PBUF_MAX_FILL_LVL_ARRAY[gv_db]),
2205                            .sram_full              (sram_full),
2206                            .q0_dpram_full          (q0_dpram_full),
2207                            .num_pkts_in_buf        (num_pkts_in_buf[8*gv_db+7:8*gv_db]),
2208                            .dma_bus_width          (dma_bus_width),
2209                            .tx_cutthru             (tx_cutthru),
2210                            .requested_axi_data     (requested_axi_data[gv_db]),
2211                            .axi_tx_full_adj_0      (axi_tx_full_adj_tmp),
2212                            .ahb_dma_queue_ptr      (cur_db2_axi_queue_hold),
2213                    
2214                            .single_frame_too_big   (single_frame_too_big[gv_db]),
2215                            .db1_out_par_err        (dap_err_db1_out[gv_db]),
2216                            .db2_out_par_err        (dap_err_db2_out[gv_db])
2217                          );
2218                    
2219                          // Block packet if SRAM buffer is full or if Q0 is running low in space as Q0 needs space for
2220                          // writebacks to happen otherwise the internal AHB DMA will stall...
2221                          assign sram_full = buffer_full_q[gv_db];
2222                    
2223                        end
2224                    
2225                    
2226                        // Secondary descriptor buffer empty status is always 16 bits regardless of the number of queues,
2227                        //  - mark non existent buffers as always empty
2228                        for (gv_db = p_num_queues; gv_db &lt; 16; gv_db = gv_db + 1)
2229                        begin : ignore
2230                          assign db2_empty_axi_q[gv_db] = 1'b1;
2231                          assign db2_empty_dma_q[gv_db] = 1'b1;
2232                        end
2233                      endgenerate
2234                    
2235                      always @ (posedge aclk or negedge n_areset)
2236                      begin
2237       1/1              if (~n_areset)
2238       1/1                frame_too_large &lt;= 1'b0;
2239                        else
2240       1/1                frame_too_large &lt;= |single_frame_too_big;
2241                      end
2242                    
2243                      // Arbitration scheme selects the highest numbered queue which has a non-empty secondary descriptor
2244                      // buffer. However, for multi buffer operation need to keep arbiter on current queue until a
2245                      // descripor with the last bit or used bit set is processed
2246                      always @ (posedge aclk or negedge n_areset)
2247                      begin
2248       1/1              if (~n_areset)
2249                        begin
2250       1/1                track_db2_axi_queue_for_mb    &lt;= 4'h0;
2251       1/1                hold_db2_axi_queue_for_mb_op  &lt;= 1'b0;
2252                        end
2253                        else
2254                        begin
2255       1/1                if ((~enable_tx || flush_tx_rd_fifos) &amp;&amp; ~(arvalid_data &amp;&amp; ~arready_data))
2256                          begin
2257       1/1                  track_db2_axi_queue_for_mb    &lt;= 4'h0;
2258       1/1                  hold_db2_axi_queue_for_mb_op  &lt;= 1'b0;
2259                          end
2260                          else
2261       1/1                  if (db2_pop_axi)
2262                            begin
2263       1/1                    if (~(cur_db2_out_axi_last_bit || cur_db2_out_axi_used_bit))
2264                              begin
2265       <font color = "red">0/1     ==>              track_db2_axi_queue_for_mb    &lt;= cur_db2_axi_queue;</font>
2266       <font color = "red">0/1     ==>              hold_db2_axi_queue_for_mb_op  &lt;= 1'b1;</font>
2267                              end
2268                              else
2269       1/1                      hold_db2_axi_queue_for_mb_op  &lt;= 1'b0;
2270                          end
                        MISSING_ELSE
2271                        end
2272                      end
2273                    
2274                    
2275                      //=====================================================================
2276                      // Calculate current secondary descriptor buffer queue
2277                      //  - Highest priority queue for which a descrptor exists in the
2278                      //    secondary descriptor buffer, unless locked due to a multi
2279                      //    buffer frame
2280                      //  - Rearbitration only takes place when data read state machine is
2281                      //    in the IDLE state so once a queue is selected all the assocoated
2282                      //    buffer data for the descriptor will be requested
2283                      //=====================================================================
2284                      always @ *
2285                      begin
2286       1/1              if (drd_sm_cs != DRD_IDLE)
2287       1/1                cur_db2_axi_queue = cur_db2_axi_queue_hold;
2288                        else
2289       1/1                if (hold_db2_axi_queue_for_mb_op)
2290       <font color = "red">0/1     ==>          cur_db2_axi_queue = track_db2_axi_queue_for_mb;</font>
2291                          else
2292       1/1                  cur_db2_axi_queue = ~db2_empty_axi_q[15] ? 4'hf :
2293                                                ~db2_empty_axi_q[14] ? 4'he :
2294                                                ~db2_empty_axi_q[13] ? 4'hd :
2295                                                ~db2_empty_axi_q[12] ? 4'hc :
2296                                                ~db2_empty_axi_q[11] ? 4'hb :
2297                                                ~db2_empty_axi_q[10] ? 4'ha :
2298                                                ~db2_empty_axi_q[9]  ? 4'h9 :
2299                                                ~db2_empty_axi_q[8]  ? 4'h8 :
2300                                                ~db2_empty_axi_q[7]  ? 4'h7 :
2301                                                ~db2_empty_axi_q[6]  ? 4'h6 :
2302                                                ~db2_empty_axi_q[5]  ? 4'h5 :
2303                                                ~db2_empty_axi_q[4]  ? 4'h4 :
2304                                                ~db2_empty_axi_q[3]  ? 4'h3 :
2305                                                ~db2_empty_axi_q[2]  ? 4'h2 :
2306                                                ~db2_empty_axi_q[1]  ? 4'h1 :
2307                                                                       4'h0;
2308                      end
2309                    
2310                      // Capture queue ID when the descriptor processing starts
2311                      // As the ID is also pushed to the AHB DMA queue ID FIFO at this point
2312                      // use the FIFO push signal as the capture strobe
2313                      always @ (posedge aclk or negedge n_areset)
2314                      begin
2315       1/1              if (~n_areset)
2316       1/1                cur_db2_axi_queue_hold &lt;= 4'h0;
2317                        else
2318       1/1                if (db2_dma_qid_push)
2319       1/1                  cur_db2_axi_queue_hold &lt;= cur_db2_axi_queue;
                        MISSING_ELSE
2320                      end
2321                    
2322                      // If the descriptor buffer holds a generated header descriptor then this cannot be
2323                      // processed until the next descriptr (the payload descriptor) is also available
2324                      // - therefore there must be at least 2 entries in the buffer in this case
2325                      // If the descriptor is not for a generated header then no addtional descriptors are
2326                      // required
2327                      assign db2_avail_axi = cur_db2_out_axi_gh ? |db2_fill_axi[p_axi_tx_descr_rd_buff_bits:1]
2328                                                                : ~db2_empty_axi;
2329                    
2330                    
2331                      // When AXI DMA starts using a descriptor push the queue ID into a
2332                      // FIFO. FIFO is used to supply the queue ID for the AHB DMA to
2333                      // ensure that AXI and AHB DMAs are operating on the same descriptor
2334                      // from the same queue even when new descriptors are being pushed
2335                      // into the FIFOs
2336                    
2337                      assign db2_dma_qid_push = (drd_sm_cs == DRD_IDLE) &amp;&amp; db2_avail_axi &amp;&amp; ~db2_dma_qid_full;
2338                    
2339                      edma_gen_fifo #(
2340                        .FIFO_WIDTH       (4),
2341                        .FIFO_DEPTH       (p_axi_tx_descr_rd_buff_depth),
2342                        .FIFO_ADDR_WIDTH  (p_axi_tx_descr_rd_buff_bits)
2343                      ) i_dma_qid_buff (
2344                    
2345                        .clk_pcie   (aclk),
2346                        .rst_n      (n_areset),
2347                    
2348                        .flush      (~enable_tx || flush_tx_rd_fifos),
2349                    
2350                        .qempty     (db2_dma_qid_empty),
2351                        .qfull      (db2_dma_qid_full),
2352                        .qlevel     (),
2353                    
2354                        .push       (db2_dma_qid_push),
2355                        .din        (cur_db2_axi_queue),
2356                    
2357                        .pop        (db2_pop_dma),
2358                        .qout       (cur_db2_dma_queue)
2359                    
2360                      );
2361                    
2362                    
2363                      //=====================================================================
2364                      // Get descriptor for AXI and AHB DMA from buffer output
2365                      // Descriptor is 64 or 96 bits depending on 64/32 bit addressing
2366                      // and header modifier bits are the top 4 bits
2367                      //  - {Generated Header, First Header, Last Header, No Increment)
2368                    
2369                      // For AHB DMA, if descriptor is for a generated header, invert the last
2370                      // header flag and map to descriptor word 1 bit 14. This is returned in
2371                      // the writeback value and is used by the writeback filtering logic.
2372                      // Override the bottom 4 bits of buffer address field as the data will
2373                      // be aligned before passing to AHB DMA - address is therefore modified
2374                      // so AHB DMA will expect data to start in byte lane 0
2375                      //=====================================================================
2376                      assign ahb_addr_align = (dma_bus_width == 2'b00) ? {cur_db2_out_dma_sel[3:2], 2'd0} :
2377                                              (dma_bus_width == 2'b01) ? {cur_db2_out_dma_sel[3],   3'd0} :
2378                                                                         4'd0;
2379                    
2380                      assign cur_db2_out_dma_sel      = db2_out_dma[cur_db2_dma_queue];
2381                      assign cur_db2_out_dma_sel_par  = db2_out_dma_par[cur_db2_dma_queue];
2382                      always @ *
2383                      begin
2384       1/1              if (cur_db2_out_dma_gh)
2385                          // Generated header
2386       <font color = "red">0/1     ==>        cur_db2_out_dma = {{(130-p_descr_width){1'b0}},</font>
2387                                             cur_db2_out_dma_sel[p_descr_width-1:47],
2388                                             ~cur_db2_out_dma_lh, // last header bit
2389                                             cur_db2_out_dma_sel[45:4],
2390                                             ahb_addr_align};
2391                        else
2392       1/1                cur_db2_out_dma = {{(130-p_descr_width){1'b0}},
2393                                             cur_db2_out_dma_sel[p_descr_width-1:4],
2394                                             ahb_addr_align};
2395                      end
2396                    
2397                      generate if (p_edma_asf_dap_prot == 1) begin : gen_cur_db2_out_dma_par
2398                        // Terminate and regenerate parity for cur_db2_out_dma looking at cur_db2_out_dma_sel[p_descr_width-1:0]
2399                        // and associated parity.
2400                        gem_par_chk_regen #(.p_chk_dwid(p_descr_width), .p_new_dwid(129)) i_regen_par (
2401                          .odd_par  (1'b0),
2402                          .chk_dat  (cur_db2_out_dma_sel[p_descr_width-1:0]),
2403                          .chk_par  (cur_db2_out_dma_sel_par),
2404                          .new_dat  (cur_db2_out_dma[128:0]),
2405                          .dat_out  (),
2406                          .par_out  (cur_db2_out_dma_par),
2407                          .chk_err  (dap_err_cur_db2_out_dma)
2408                        );
2409                      end else begin : gen_no_cur_db2_out_dma_par
2410                        assign cur_db2_out_dma_par      = {17{1'b0}};
2411                        assign dap_err_cur_db2_out_dma  = 1'b0;
2412                      end
2413                      endgenerate
2414                    
2415                      assign cur_db2_out_dma_gh       = cur_db2_out_dma_sel[p_descr_width+3];
2416                      assign cur_db2_out_dma_lh       = cur_db2_out_dma_sel[p_descr_width+1];
2417                      assign cur_db2_out_dma_last_bit = cur_db2_out_dma[47];
2418                      assign cur_db2_out_dma_used_bit = cur_db2_out_dma[63];
2419                    
2420                      // new downstream TX WR block I/F
2421                      assign cur_descr_rd_valid = !db2_empty_dma &amp;&amp; !db2_dma_qid_empty;
2422                      assign db2_pop_dma        = cur_descr_rd_rdy;
2423                      // The downstream TX WR block only needs launch time and word 0/1 of descriptor, so drop the upper databuffer address bits in 64-bit mode.
2424                      // If 64-bit these are bits 95:64. 128 is launch time enable and 127:96 is the launch time
2425                      // If 32-bit, 128:97 is 0. 96 is launch time enable and 95:64 is the launch time.
2426                      generate if (p_edma_tsu == 1) begin : gen_cur_descr_rd_with_launch
2427                        assign cur_descr_rd     = addressing_64b  ? {cur_db2_out_dma[128:96],cur_db2_out_dma[63:0]}
2428                                                                  : {cur_db2_out_dma[96:64],cur_db2_out_dma[63:0]};
2429                        assign cur_descr_rd_par = addressing_64b  ? {cur_db2_out_dma_par[16:12],cur_db2_out_dma_par[7:0]}
2430                                                                  : cur_db2_out_dma_par[12:0];
2431                      end else begin  : gen_cur_descr_rd_no_launch
2432                        assign cur_descr_rd     = {33'd0, cur_db2_out_dma[63:0]};
2433                        assign cur_descr_rd_par = {5'd0,cur_db2_out_dma_par[7:0]};
2434                      end
2435                      endgenerate
2436                      assign cur_descr_rd_add   = db2_descr_wb_addr[cur_db2_dma_queue][31:0];
2437                    
2438                      assign cur_descr_rd_queue = cur_db2_dma_queue;
2439                    
2440                      // The AXI block doesnt need the launch time so drop it
2441                      always @(*)
2442                      begin
2443       1/1              if (p_edma_addr_width == 32'd64 &amp;&amp; addressing_64b)
2444                        begin
2445       <font color = "red">0/1     ==>        cur_db2_out_axi         = db2_out_axi[cur_db2_axi_queue][31+p_edma_addr_width:0];  // AXI doesnt need the launch time</font>
2446       <font color = "red">0/1     ==>        cur_db2_out_axi_par     = db2_out_axi_par[cur_db2_axi_queue][3+(p_edma_addr_width/8):0];</font>
2447       <font color = "red">0/1     ==>        cur_db2_out_nxt_axi     = db2_out_nxt_axi[cur_db2_axi_queue][31+p_edma_addr_width:0];</font>
2448       <font color = "red">0/1     ==>        cur_db2_out_nxt_axi_par = db2_out_nxt_axi_par[cur_db2_axi_queue][3+(p_edma_addr_width/8):0];</font>
2449                        end
2450                        else
2451                        begin
2452       1/1                cur_db2_out_axi         = {{32{1'b0}},db2_out_axi[cur_db2_axi_queue][63:0]};
2453       1/1                cur_db2_out_axi_par     = {4'h0,db2_out_axi_par[cur_db2_axi_queue][7:0]};
2454       1/1                cur_db2_out_nxt_axi     = {{32{1'b0}},db2_out_nxt_axi[cur_db2_axi_queue][63:0]};
2455       1/1                cur_db2_out_nxt_axi_par = {4'h0,db2_out_nxt_axi_par[cur_db2_axi_queue][7:0]};
2456                        end
2457                      end
2458                      assign cur_db2_out_axi_gh            = db2_out_axi[cur_db2_axi_queue][p_descr_width+3];
2459                      assign cur_db2_out_axi_fh            = db2_out_axi[cur_db2_axi_queue][p_descr_width+2];
2460                      assign cur_db2_out_axi_lh            = db2_out_axi[cur_db2_axi_queue][p_descr_width+1];
2461                      assign cur_db2_out_axi_last_bit      = cur_db2_out_axi[47];
2462                      assign cur_db2_out_axi_used_bit      = cur_db2_out_axi[63];
2463                      assign cur_db2_out_axi_len_field     = cur_db2_out_axi[45:32];
2464                      assign cur_db2_out_axi_zero_len_buff = (cur_db2_out_axi_len_field[13:0] == 14'h0000);
2465                    
2466                    
2467                    
2468                    
2469                      //=====================================================================
2470                      // Secondary descriptor buffer fill status for current queue
2471                      //=====================================================================
2472                      assign db2_empty_axi = db2_empty_axi_q[cur_db2_axi_queue];
2473                      assign db2_empty_dma = db2_empty_dma_q[cur_db2_dma_queue];
2474                      assign db2_fill_axi  = db2_fill_axi_q[cur_db2_axi_queue];
2475                    
2476                      assign db2_pop_axi = all_data_for_txbuf_requested;
2477                    
2478                    
2479                      //============================================================================
2480                      // Main AXI Data read state machine
2481                      // Controls fetching of transmit data
2482                      // This state machine does not wait for AXI responses - it issues data reads
2483                      // up to the maximum allowed pipeline depth.
2484                      //============================================================================
2485                    
2486                      // state vector
2487                      always @ (posedge aclk or negedge n_areset)
2488                      begin
2489       1/1              if  (~n_areset)
2490       1/1                drd_sm_cs &lt;= DRD_IDLE;
2491                        else
2492                        begin
2493       1/1                if ((~enable_tx || flush_tx_rd_fifos) &amp;&amp; ~(arvalid_data &amp;&amp; ~arready_data))
2494       1/1                  drd_sm_cs &lt;= DRD_IDLE;
2495                          else
2496       1/1                  drd_sm_cs &lt;= drd_sm_ns;
2497                        end
2498                      end
2499                    
2500                      // next state logic
2501                      always @ *
2502                      begin
2503                    
2504       1/1              drd_sm_ns = drd_sm_cs;
2505                    
2506       1/1              case (drd_sm_cs)
2507                    
2508                          DRD_CHK_DESCR:
2509                          begin
2510                            // If there is no data associated with descriptor then return to idle state
2511                            // Otherwise proceed to packet data state when first read request has been accepetd by
2512                            // system bus fabric
2513       1/1                  if (cur_db2_out_axi_zero_len_buff || cur_db2_out_axi_used_bit)
2514       <font color = "red">0/1     ==>            drd_sm_ns = DRD_IDLE;</font>
2515                            else
2516       1/1                    if (arrv_data)
2517       1/1                      drd_sm_ns = DRD_PKTDATA;
                        MISSING_ELSE
2518                          end
2519                    
2520                          DRD_PKTDATA:
2521                          begin
2522                            // Return to idle state when all data assocoated with the descriptor has been requested
2523       1/1                  if (all_data_for_txbuf_requested)
2524       1/1                      drd_sm_ns = DRD_IDLE;
                        MISSING_ELSE
2525                          end
2526                    
2527                          default:  //DRD_IDLE:
2528                            // begin processing available descriptor if there is space in the AHB DMA queue ID FIFO
2529       1/1                  if (db2_avail_axi &amp;&amp; ~db2_dma_qid_full)
2530       1/1                    drd_sm_ns = DRD_CHK_DESCR;
                        MISSING_ELSE
2531                    
2532                        endcase
2533                      end
2534                    
2535                      // Assert ARVALID for AXI data requests
2536                      always @ *
2537                      begin
2538                    
2539       1/1              if ((drd_sm_cs == DRD_CHK_DESCR) &amp;&amp; ~cur_db2_out_axi_zero_len_buff &amp;&amp; ~cur_db2_out_axi_used_bit)
2540       1/1                arvalid_data  = ~dpram_full || arvalid_data_hold;
2541                        else
2542       1/1                if ((drd_sm_cs == DRD_PKTDATA) &amp;&amp; ~all_data_for_txbuf_requested)
2543       1/1                  arvalid_data  = ~dpram_full || arvalid_data_hold;
2544                          else
2545       1/1                  arvalid_data  = arvalid_data_hold;
2546                      end
2547                    
2548                      // Keep descriptor and data ARVALID asserted until accepted by bus fabric
2549                      always @ (posedge aclk or negedge n_areset)
2550                      begin
2551       1/1              if  (~n_areset)
2552                        begin
2553       1/1                arvalid_data_hold  &lt;= 1'b0;
2554       1/1                arvalid_descr_hold &lt;= 1'b0;
2555                        end
2556                        else
2557                        begin
2558       1/1                if (arvalid_data &amp;&amp; ~arready_data)
2559       1/1                  arvalid_data_hold &lt;= 1'b1;
2560                          else
2561       1/1                  if (arready_data)
2562       1/1                    arvalid_data_hold &lt;= 1'b0;
                        MISSING_ELSE
2563                    
2564       1/1                if (arvalid_descr &amp;&amp; ~arready_descr)
2565       1/1                  arvalid_descr_hold &lt;= 1'b1;
2566                          else
2567       1/1                  if (arready_descr)
2568       1/1                    arvalid_descr_hold &lt;= 1'b0;
                        MISSING_ELSE
2569                        end
2570                      end
2571                    
2572                    
2573                      //=====================================================================
2574                      // Generate address for data reads
2575                      // Load from descriptor as main state machine transitions to data state,
2576                      // then increment by burst length as each request is output
2577                      // Maintain lower bits of address obtained from descriptor for all
2578                      // reads generated from a descriptor. These are zeroed by top level
2579                      // arbiter in edma_pbuf_axi_fe before going out on AXI bus,
2580                      // but are passed through the ar2r FIFO unmodified for use by the read
2581                      // data alignment logic
2582                      //=====================================================================
2583                      always @ (posedge aclk or negedge n_areset)
2584                      begin
2585       1/1              if  (~n_areset)
2586       1/1                araddr_data  &lt;= 64'h00000000_00000000;
2587                        else
2588       1/1                if ((drd_sm_cs == DRD_IDLE) &amp;&amp; ~db2_empty_axi)
2589       1/1                  araddr_data &lt;= {cur_db2_out_axi[95:64],cur_db2_out_axi[31:0]};
2590                          else
2591       1/1                  if (arrv_data)
2592       1/1                    araddr_data &lt;= araddr_data_nxt;
                        MISSING_ELSE
2593                      end
2594                    
2595                      // Increment amount based on last length and bus width
2596                      always@(*)
2597                      begin
2598       1/1              case (dma_bus_width)
2599       1/1                2'b00   : araddr_data_inc = {53'd0, data_len, 2'd0};
2600       <font color = "red">0/1     ==>        2'b01   : araddr_data_inc = {52'd0, data_len, 3'd0};</font>
2601       <font color = "red">0/1     ==>        default : araddr_data_inc = {51'd0, data_len, 4'd0};</font>
2602                        endcase
2603                      end
2604                    
2605                      // Add araddr_data and araddr_data_inc
2606                      edma_arith_par #(
2607                        .p_dwidth (64),
2608                        .p_pwidth (8),
2609                        .p_has_par(p_edma_asf_dap_prot)
2610                      ) i_arith_cur_descr_rd_add_p4 (
2611                        .in_val (araddr_data),
2612                        .in_par (araddr_data_par),
2613                        .op_val (araddr_data_inc),
2614                        .op_add (1'b1),
2615                        .out_val(araddr_data_nxt),
2616                        .out_par(araddr_data_nxt_par)
2617                      );
2618                    
2619                      //=====================================================================
2620                      // ARSIZE for data reads - always read full stripe
2621                      //=====================================================================
2622                      assign arsize_data = (dma_bus_width == 2'b00) ? 3'h2 : // 32-bit
2623                                           (dma_bus_width == 2'b01) ? 3'h3 : // 64-bit
2624                                                                      3'h4;  // 128-bit
2625                    
2626                    
2627                    
2628                      // ===========================================================================
2629                      // Calculate if there is enough space in the AHB DMA buffer to accomodate the
2630                      // data that will be returned with the next AXI burst
2631                      // Available space is obtained by taking the current buffer space and subtracting
2632                      // the AXI data that has already been requested.
2633                      // The incoming data will decrement the requested data counter some time before
2634                      // it decrements the current buffer space, due to data pipeleining. The data
2635                      // present in this pipeline is accounted for in the axi_tx_full_threshold value
2636                      // ===========================================================================
2637                    
2638                    
2639                      // Calculate the amount of data (in AXI beats) the current AXI request will return.
2640                      // When data is written to SRAM there are additional status words written per
2641                      // buffer - so add 4 beats for the last request of each buffer
2642                      always @(*)
2643                      begin
2644       1/1              if (ar_last_req_of_buf)
2645       1/1                requesting_axi_data = {11'd0, data_len} + (18'd4 &lt;&lt; tx_fill_lvl_multiplier);
2646                        else
2647       1/1                requesting_axi_data = {11'd0, data_len};
2648                      end
2649                    
2650                    
2651                      // Calculate the amount of data (in AXI beats) the current incoming response beat carries
2652                      // This will normaly be 1, but beacuse 4 beats were added to the counter for
2653                      // the buffer status words for the last request of the buffer, 4 beats are
2654                      // also added to the last beat of the buffer
2655                      always @(*)
2656                      begin
2657       1/1              if (r_last_burst_of_buf &amp;&amp; rlast)
2658       1/1                received_axi_data = (20'd1 + (18'd4 &lt;&lt; tx_fill_lvl_multiplier));
2659                        else
2660       1/1                received_axi_data = 20'd1;
2661                      end
2662                    
2663                      // Count requested AXI data in beats per queue
2664                      // Add requests as they are accepted
2665                      // Subrtract resonse beats as they are received
2666                      genvar gv_rad;
2667                      generate
2668                        for (gv_rad = 0; gv_rad &lt; p_num_queues; gv_rad = gv_rad + 1)
2669                    
2670                        begin : req_axi_data
2671                    
2672                          assign arrv_data_q[gv_rad] = arrv_data &amp;&amp; (ar_queue_data == gv_rad[3:0]);
2673                          assign rrv_data_q[gv_rad]  = rrv_data  &amp;&amp; (r_queue == gv_rad[3:0]);
2674                          
2675                          wire [p_edma_tx_pbuf_addr+2:0] requested_axi_data_1;
2676                          wire [p_edma_tx_pbuf_addr+2:0] requested_axi_data_2;
2677                          
2678                          assign requested_axi_data_1 = requested_axi_data[gv_rad] - received_axi_data[p_edma_tx_pbuf_addr+1:0] + requesting_axi_data[p_edma_tx_pbuf_addr+1:0];
2679                          assign requested_axi_data_2 = requested_axi_data[gv_rad] + requesting_axi_data[p_edma_tx_pbuf_addr+1:0];
2680                          
2681                          always @ (posedge aclk or negedge n_areset)
2682                          begin
2683       1/1                  if (~n_areset)
2684       1/1                    requested_axi_data[gv_rad] &lt;= {p_edma_tx_pbuf_addr+2{1'b0}};
2685                            else
2686       1/1                    if (~enable_tx || flush_tx_rd_fifos)
2687       1/1                      requested_axi_data[gv_rad] &lt;= {p_edma_tx_pbuf_addr+2{1'b0}};
2688                              else
2689       1/1                      if (arrv_data_q[gv_rad] &amp;&amp; rrv_data_q[gv_rad])
2690       <font color = "red">0/1     ==>                requested_axi_data[gv_rad] &lt;= requested_axi_data_1[p_edma_tx_pbuf_addr+1:0];</font>
2691                                else
2692       1/1                        if (arrv_data_q[gv_rad])
2693       1/1                          requested_axi_data[gv_rad] &lt;= requested_axi_data_2[p_edma_tx_pbuf_addr+1:0];
2694                                  else
2695       1/1                          if (rrv_data_q[gv_rad])
2696       1/1                            requested_axi_data[gv_rad] &lt;= requested_axi_data[gv_rad] - received_axi_data[p_edma_tx_pbuf_addr+1:0];
                        MISSING_ELSE
2697                          end
2698                    
2699                        end
2700                      endgenerate
2701                    
2702                      // Select dpram space available for current queue and for queue 0
2703                      assign cur_q_dpram_space = dpram_fill_lvl_array[cur_db2_axi_queue] &amp; TX_PBUF_MAX_FILL_LVL_ARRAY[cur_db2_axi_queue];
2704                      assign q0_dpram_space    = dpram_fill_lvl_array[0]                 &amp; TX_PBUF_MAX_FILL_LVL_ARRAY[0];
2705                    
2706                    
2707                      // Calculate data in AXI DMA pipeline
2708                      // - al register and rdata_slice register
2709                      always @ *
2710                      begin
2711       1/1              if (al_full)
2712                        begin
2713       1/1                if (al_last_beat_of_buf)
2714       1/1                  al_dpram_data = (32'd1 + (30'd4 &lt;&lt; tx_fill_lvl_multiplier));
2715                          else
2716       1/1                  al_dpram_data = 32'd1;
2717                        end
2718                        else
2719       1/1                al_dpram_data = 32'd0;
2720                    
2721       1/1              if (rdata_slice_full)
2722                        begin
2723       1/1                if (rdata_slice_last_beat_of_buf)
2724       1/1                  rdata_slice_dpram_data = (32'd1 + (30'd4 &lt;&lt; tx_fill_lvl_multiplier));
2725                          else
2726       1/1                  rdata_slice_dpram_data = 32'd1;
2727                        end
2728                        else
2729       1/1                rdata_slice_dpram_data = 32'd0;
2730                      end
2731                      
2732                      // Looking above it is evident that pipe_dpram_data can never overflow, but AFL is moaning because it is not clever
2733                      // enough to understand that the result of this operation is not going to overflow, so we want to make the tool happy
2734                      // and we will add a bit to the result.
2735                      assign pipe_dpram_data = al_dpram_data[p_edma_tx_pbuf_addr+1:0] + rdata_slice_dpram_data[p_edma_tx_pbuf_addr+1:0];
2736                    
2737                      // Q0 is a special queue that holds &quot;status only frames&quot;. These consume 2-3 locations of Q0's region every time
2738                      // there is a used_bit_read_all event. Since we are adding used_bit_read_events to the descriptors up front
2739                      // (way before the actual 2-3 SRAM locations are written to), we need to take that into account when
2740                      // issuing new AR requests to avoid issuing a request that the underlying DMA wont eventually be able to
2741                      // accept due to Q0 being full fue to status words.
2742                      // basically we will only allow one used bit read event through the DMA at any one time.
2743                      always @ (posedge aclk or negedge n_areset)
2744                      begin
2745       1/1              if  (~n_areset)
2746                        begin
2747       1/1                q0_num_used_all &lt;= 1'd0;
2748                        end
2749                        else
2750                        begin
2751       1/1                if (~enable_tx || flush_tx_rd_fifos)
2752                          begin
2753       1/1                  q0_num_used_all &lt;= 1'd0;
2754                          end
2755                          else
2756                          begin
2757                            // Used bits detected on all queues
2758       1/1                  if (db1_in_used_all_q &amp;&amp; !db1_in_used_all_q_was_detected)
2759                            begin
2760       <font color = "red">0/1     ==>            if (!(tx_descr_wr_vld &amp;&amp; tx_descr_wr_sts[5]))</font>
2761       <font color = "red">0/1     ==>              q0_num_used_all &lt;= 1'b1;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
2762                            end
2763       1/1                  else if (tx_descr_wr_vld &amp;&amp; tx_descr_wr_sts[5])
2764       <font color = "red">0/1     ==>            q0_num_used_all &lt;= 1'b0;</font>
                        MISSING_ELSE
2765                          end
2766                        end
2767                      end
2768                      assign q0_num_used_all_pad = {{p_edma_tx_pbuf_addr-1{1'b0}},q0_num_used_all};
2769                    
2770                    
2771                      // Calculate dpram space from current level value, AXI data already requested and AXI data for current request
2772                      // If requested and current AXI data exceeds space then set to zero
2773                      // This consists of a number of airthmetic operations, each one done separately for LINT reasons ..
2774                      wire  [p_edma_tx_pbuf_addr+2:0] calc_space_a1;
2775                      wire  [p_edma_tx_pbuf_addr+3:0] calc_space_a2;
2776                      wire  [p_edma_tx_pbuf_addr+3:0] calc_space_a3;
2777                      assign calc_space_a1 = requested_axi_data_pad[ar_queue_data] + axi_tx_full_adj_0_shft;
2778                      assign calc_space_a2 = calc_space_a1 + {1'd0,pipe_dpram_data[p_edma_tx_pbuf_addr+1:0]};
2779                      assign calc_space_a3 = {2'b00,cur_q_dpram_space} - calc_space_a2;
2780                    
2781                      always @ *
2782                      begin
2783       1/1              if (calc_space_a2 &lt; {2'd0,cur_q_dpram_space})
2784       1/1                cur_q_dpram_space_total = calc_space_a3[p_edma_tx_pbuf_addr+1:0];
2785                        else
2786       1/1                cur_q_dpram_space_total = {p_edma_tx_pbuf_addr+2{1'b0}};
2787                      end
2788                    
2789                      wire [p_edma_tx_pbuf_addr+2:0] calc_space_b1;
2790                      wire [p_edma_tx_pbuf_addr+3:0] calc_space_b2;
2791                      wire [p_edma_tx_pbuf_addr+3:0] calc_space_b3;
2792                      assign calc_space_b1 = requested_axi_data[0] + axi_tx_full_adj_0_shft;
2793                      assign calc_space_b2 = calc_space_b1 + {1'b0,pipe_dpram_data[p_edma_tx_pbuf_addr+1:0]};
2794                      assign calc_space_b3 = {2'd0,q0_dpram_space} - calc_space_b2;
2795                      
2796                      always @ *
2797                      begin
2798       1/1              if (calc_space_b2 &lt; {2'd0,q0_dpram_space})
2799       1/1                q0_dpram_space_total = calc_space_b3[p_edma_tx_pbuf_addr+1:0];
2800                        else
2801       1/1                q0_dpram_space_total = {p_edma_tx_pbuf_addr+2{1'b0}};
2802                      end
2803                      
2804                      wire  [p_edma_tx_pbuf_addr+2:0] 
2805                             requesting_axi_data_p_q0_num_used_all_x4;
2806                      assign requesting_axi_data_p_q0_num_used_all_x4 = (requesting_axi_data[p_edma_tx_pbuf_addr+1:0] + {q0_num_used_all_pad[p_edma_tx_pbuf_addr-1:0],2'b00});  
2807                      
2808                      always @ *
2809                      begin
2810       1/1              if (ar_queue_data == 4'd0)
2811       1/1                cur_q_dpram_full = (requesting_axi_data_p_q0_num_used_all_x4[p_edma_tx_pbuf_addr+1:0] &gt; cur_q_dpram_space_total) &amp; tx_cutthru;
2812                        else
2813       <font color = "red">0/1     ==>        cur_q_dpram_full = (requesting_axi_data[p_edma_tx_pbuf_addr+1:0] &gt; cur_q_dpram_space_total) &amp; tx_cutthru;</font>
2814                      end
2815                    
2816                      // Claim q0 is full if there isnt enough space in Q0 for all the status only frames that have been requested (max 1)
2817                      // Fix 4 locations for the max 1 used bit read event that could be going through the system
2818                      // We should use this to block any queue from committing the underlying DMA to a frame unless there is space in Q0
2819                      assign q0_dpram_full = {{(p_edma_tx_pbuf_addr-1){1'b0}},3'd4} &gt; q0_dpram_space_total;
2820                    
2821                      // Calculate if DPRAM space can accomodate 4 worst case AXI bursts - if so back to back read requests will be permitted
2822                      // without insterting a delay to allow full status to update
2823                      always @ *
2824                      begin
2825       1/1              if (burst_length[4]) // 16 beats
2826       1/1                prog_data_len_burst = 9'd16;
2827                        else
2828       1/1                if (burst_length[3]) // 8 beats
2829       1/1                  prog_data_len_burst = 9'd8;
2830                          else
2831       1/1                  if (burst_length[2]) // 4 beats
2832       1/1                    prog_data_len_burst = 9'd4;
2833                            else
2834       1/1                    if (|burst_length[1:0]) // single beat
2835       1/1                      prog_data_len_burst = 9'd1;
2836                              else // 256 beats
2837       <font color = "red">0/1     ==>              prog_data_len_burst = 9'd256;</font>
2838                      end
2839                    
2840                      // about four_shifted_by_mult_p_prog_data_len_burst = prog_data_len_burst + {4'd0,four_shifted_by_mult};
2841                      // we can say that: prog_data_len_burst in the worst case is 9'd256 and the other addend is 000010000 = 16
2842                      // therefore the addition will be on 9 bits. Having said that, AFL says that there should be a bit more in 
2843                      // the result because it is not clever enough to detect the maximum value the operation result can assume
2844                      // so we want to make it happy adding an extra bit to the result
2845                      wire  [4:0] four_shifted_by_mult;
2846                      wire  [9:0] four_shifted_by_mult_p_prog_data_len_burst;
2847                      wire [10:0] four_shifted_by_mult_p_prog_data_len_burst_x4;
2848                    
2849                      assign      four_shifted_by_mult                          = 3'd4 &lt;&lt; tx_fill_lvl_multiplier;
2850                      assign      four_shifted_by_mult_p_prog_data_len_burst    = prog_data_len_burst + {4'd0,four_shifted_by_mult};
2851                      assign      four_shifted_by_mult_p_prog_data_len_burst_x4 = {four_shifted_by_mult_p_prog_data_len_burst[8:0], 2'b00};
2852                        
2853                      // cur_q_dpram_space_total maximum width is is p_edma_tx_pbuf_addr + 2 = 16+2 = 18 bits
2854                      // prog_data_len_burst is 9 bits
2855                      // 3'd4 &lt;&lt; tx_fill_lvl_multiplier is maximum 5 bits (value 16)
2856                      // the sum between prog_data_len_burst and (16'd4 &lt;&lt; tx_fill_lvl_multiplier) is still 9 bits
2857                      // 4 * sum = 11 bits.
2858                      
2859                      // cur_q_dpram_space_total (p_edma_tx_pbuf_addr + 2) has to be compared to four_shifted_by_mult_p_prog_data_len_burst_x4 (11 bits)
2860                      // So if p_edma_tx_pbuf_addr + 2 &gt; 11 we need to pad four_shifted_by_mult_p_prog_data_len_burst_x4, otherwise we will pad cur_q_dpram_space_total
2861                      // to 11 
2862                      generate if (p_edma_tx_pbuf_addr &gt; 32'd9) begin: gen_dpram_b2b_space_pad1
2863                        assign dpram_b2b_space = (cur_q_dpram_space_total &gt; {{(p_edma_tx_pbuf_addr-9){1'b0}},four_shifted_by_mult_p_prog_data_len_burst_x4});
2864                      end else if(p_edma_tx_pbuf_addr == 32'd9) begin: gen_dpram_b2b_space_nopad
2865                        assign dpram_b2b_space = (cur_q_dpram_space_total &gt; four_shifted_by_mult_p_prog_data_len_burst_x4);
2866                      end else begin: gen_dpram_b2b_space_pad2 // p_edma_tx_pbuf_addr &lt; 32'd9
2867                        assign dpram_b2b_space = ({{(9-p_edma_tx_pbuf_addr){1'b0}},cur_q_dpram_space_total} &gt; four_shifted_by_mult_p_prog_data_len_burst_x4);
2868                      end
2869                      endgenerate
2870                        
2871                      // DPRAM full flag
2872                      // Assert when DPRAM cannot accept another AXI burst
2873                      always @ (posedge aclk or negedge n_areset)
2874                      begin
2875       1/1              if  (~n_areset)
2876       1/1                dpram_full  &lt;= 1'b0;
2877                        else
2878                        begin
2879       1/1                if (~enable_tx || flush_tx_rd_fifos)
2880       1/1                  dpram_full &lt;= 1'b0;
2881                          else
2882       1/1                  dpram_full  &lt;= (arrv_data &amp;&amp; ~dpram_b2b_space) || cur_q_dpram_full;
2883                        end
2884                      end
2885                    
2886                    
2887                      // Obtain some information about the buffer being read
2888                      // This is needed to issue the data reads
2889                      always @ *
2890                      begin
2891       1/1              case (dma_bus_width)
2892       1/1                2'b00   : alignment_addr = {2'b00, cur_db2_out_axi[1:0]};
2893       <font color = "red">0/1     ==>        2'b01   : alignment_addr = {1'b0, cur_db2_out_axi[2:0]};</font>
2894       <font color = "red">0/1     ==>        default : alignment_addr = cur_db2_out_axi[3:0];</font>
2895                        endcase
2896                      end
2897                    
2898                      // Calculate the number of AXI beats required to read the current buffer
2899                      //  - dependent on the buffer length, the data bus width and the start address
2900                      // Calucate if the lower bits of the descriptor length field, plus
2901                      // the address alignments passes into the next word. If this
2902                      // is the case we add 1 to the total number of words needing read.
2903                    
2904                      assign cur_db2_out_axi_len_field_minus1 = cur_db2_out_axi_len_field - 14'd1;
2905                      assign num_beats_plus1_sum_128          = {{1'b0,alignment_addr}            + ((cur_db2_out_axi_len_field[4:0] - 5'd1) &amp; 5'b01111)};
2906                      assign num_beats_plus1_sum_64           = {1'b0,{{1'd0,alignment_addr[2:0]} + ((cur_db2_out_axi_len_field[3:0] - 4'd1) &amp; 4'b0111)}};
2907                      assign num_beats_plus1_sum_32           = {2'd0,{{1'd0,alignment_addr[1:0]} + ((cur_db2_out_axi_len_field[2:0] - 3'd1) &amp; 3'b011)}};
2908                      
2909                      assign num_beats_al_128                 = {2'd0,{{cur_db2_out_axi_len_field_minus1[13:4] + {5'd0,num_beats_plus1_sum_128[4]}} + 11'd1}};
2910                      assign num_beats_al_64                  = {1'b0,{1'd0,cur_db2_out_axi_len_field_minus1[13:3]}  + {6'd0,num_beats_plus1_sum_64[3]}  + 12'd1};
2911                      assign num_beats_al_32                  = {cur_db2_out_axi_len_field_minus1[13:2]        + {7'd0,num_beats_plus1_sum_32[2]}} + 12'd1;
2912                    
2913                      always @ (posedge aclk or negedge n_areset)
2914                      begin
2915       1/1              if  (~n_areset)
2916       1/1                num_beats_al &lt;= 13'd0;
2917                        else
2918                        begin
2919       1/1                if (dma_bus_width[1])
2920       <font color = "red">0/1     ==>          num_beats_al &lt;= num_beats_al_128;</font>
2921       1/1                else if (dma_bus_width[0])
2922       <font color = "red">0/1     ==>          num_beats_al &lt;= num_beats_al_64;</font>
2923                          else
2924       1/1                  num_beats_al &lt;= num_beats_al_32;
2925                        end
2926                      end
2927                    
2928                      // Caluculate numbe of beats required for the AHB DMA to read data when data is aligned to byte
2929                      // 0 of data bus
2930                      assign num_beats_ahb_128 = cur_db2_out_axi_len_field[13:4] + {13'd0, |cur_db2_out_axi_len_field[3:0]};
2931                      assign num_beats_ahb_64  = cur_db2_out_axi_len_field[13:3] + {13'd0, |cur_db2_out_axi_len_field[2:0]};
2932                      assign num_beats_ahb_32  = cur_db2_out_axi_len_field[13:2] + {13'd0, |cur_db2_out_axi_len_field[1:0]};
2933                    
2934                      assign num_beats_ahb = dma_bus_width[1]       ? num_beats_ahb_128[12:0] :
2935                                             dma_bus_width == 2'b01 ? num_beats_ahb_64[12:0]  :
2936                                                                      num_beats_ahb_32[12:0]  ;
2937                    
2938                      // Indicate if AHB will require less beats than AXI due to alignment logic
2939                      assign ar_ahb_less_beats = (num_beats_al != num_beats_ahb);
2940                    
2941                    
2942                      // Calucualte data still to be requested - we have the number of beats to
2943                      // read in num_beats_al. tx_buf_beat_req_ctr is a running beat counter. data_len
2944                      // will identify the length of the current burst being careful not to break the
2945                      // 4K boundary rule and using the burst_length register contents (from gem_registers)
2946                      assign num_tx_beats_remaining = (num_beats_al - tx_buf_beat_req_ctr);
2947                    
2948                      // Calculate the burst length in beats from the programmed burst_length value
2949                      // If force_max_ahb_burst_tx is low, truncate burst if remaiing data is less
2950                      // than programmed burst length
2951                      // If force_max_ahb_burst_tx is high use programmed burst length regardless
2952                      // of data availability - note force_max_ahb_burst_tx is not supported for
2953                      // programmed burst length of 256
2954                      // Set to max burst length when data read state machine is in idle state
2955                      // so DPRAM space can be checked against worst case burst before actual
2956                      // burst length is available
2957                      always @ *
2958                      begin
2959       1/1              if (burst_length[4]) // 16 beats
2960                        begin
2961       1/1                if (force_max_ahb_burst_tx || (|num_tx_beats_remaining[12:4]) || (drd_sm_cs == DRD_IDLE))
2962       1/1                  data_len_burst = 9'd16;
2963                          else
2964       1/1                  data_len_burst = {5'h00, num_tx_beats_remaining[3:0]};
2965                        end
2966                        else
2967       1/1                if (burst_length[3]) // 8 beats
2968                          begin
2969       1/1                  if (force_max_ahb_burst_tx || (|num_tx_beats_remaining[12:3]) || (drd_sm_cs == DRD_IDLE))
2970       1/1                    data_len_burst = 9'd8;
2971                            else
2972       1/1                    data_len_burst = {6'h00, num_tx_beats_remaining[2:0]};
2973                          end
2974                          else
2975       1/1                  if (burst_length[2]) // 4 beats
2976                            begin
2977       1/1                    if (force_max_ahb_burst_tx || (|num_tx_beats_remaining[12:2]) || (drd_sm_cs == DRD_IDLE))
2978       1/1                      data_len_burst = 9'd4;
2979                              else
2980       1/1                      data_len_burst = {7'h00, num_tx_beats_remaining[1:0]};
2981                            end
2982                            else
2983       1/1                    if (|burst_length[1:0]) // single beat
2984       1/1                      data_len_burst = 9'd1;
2985                              else // 256 beats - ignore force_max_ahb_burst_tx
2986                              begin
2987       <font color = "red">0/1     ==>              if (|num_tx_beats_remaining[12:8] || (drd_sm_cs == DRD_IDLE))</font>
2988       <font color = "red">0/1     ==>                data_len_burst = 9'd256;</font>
2989                                else
2990       <font color = "red">0/1     ==>                data_len_burst = {1'b0, num_tx_beats_remaining[7:0]};</font>
2991                              end
2992                      end
2993                    
2994                      // Calculate the number of beats from current address to a 4K boundary.
2995                      // Dependent on data bus width, equal to (4096 - address[11:0]) / bytes_per_beat
2996                      always @ *
2997                      begin
2998       1/1              case (dma_bus_width)
2999       1/1                2'b00   : data_len_4k = 11'h400 - {1'b0, araddr_data[11:2]};
3000       <font color = "red">0/1     ==>        2'b01   : data_len_4k = 11'h200 - {2'b00, araddr_data[11:3]};</font>
3001       <font color = "red">0/1     ==>        default : data_len_4k = 11'h100 - {3'b000, araddr_data[11:4]};</font>
3002                        endcase
3003                      end
3004                    
3005                      // Use burst length which doesn't break a 4K boundary
3006                      // Subtract 1 for ARLEN encoding
3007                      // When data read state machine is in the idle state ignore 4K boundary as it takes a clock cycle for
3008                      // the address counter to update from the new descriptor - this can cause the synchronous DPRAM full
3009                      // flag to use a burst lenght value that is too small
3010                      always @(*)
3011                      begin
3012       1/1              if ((({2'b00, data_len_burst} &gt; data_len_4k) &amp;&amp; (|data_len_4k)) &amp;&amp; (drd_sm_cs != DRD_IDLE))
3013                        begin
3014       <font color = "red">0/1     ==>        if (force_max_ahb_burst_tx)</font>
3015       <font color = "red">0/1     ==>          data_len  = 9'h001;</font>
3016                          else
3017       <font color = "red">0/1     ==>          data_len  = data_len_4k[8:0];</font>
3018                        end
3019                        else
3020       1/1                data_len  = data_len_burst;
3021                      end
3022                    
3023                      assign arlen_data  = data_len[7:0] - 8'd1;
3024                    
3025                      wire [13:0] tx_buf_beat_req_ctr_p_data_len;
3026                      assign      tx_buf_beat_req_ctr_p_data_len = tx_buf_beat_req_ctr + {4'h0, data_len};
3027                      
3028                      // Count the number of read request beats made for the current descriptor
3029                      always @ (posedge aclk or negedge n_areset)
3030                      begin
3031       1/1              if  (~n_areset)
3032       1/1                tx_buf_beat_req_ctr &lt;= 13'd0;
3033                        else
3034                        begin
3035       1/1                if ((~enable_tx || flush_tx_rd_fifos) &amp;&amp; ~(arvalid_data &amp;&amp; ~arready_data))
3036       1/1                  tx_buf_beat_req_ctr &lt;= 13'd0;
3037                          else
3038       1/1                  if (all_data_for_txbuf_requested)
3039       1/1                    tx_buf_beat_req_ctr &lt;= 13'd0;
3040                            else
3041       1/1                    if (arrv_data)
3042       1/1                      tx_buf_beat_req_ctr &lt;= tx_buf_beat_req_ctr_p_data_len[12:0];
                        MISSING_ELSE
3043                        end
3044                      end
3045                    
3046                    
3047                      // Capture AXI RDATA for data reads
3048                      // rdata_slice_full indicates data has not yet been delivered to AHB
3049                      // and prevents acceptance of more data from AXI R channel
3050                      always @ (posedge aclk or negedge n_areset)
3051                      begin
3052       1/1              if  (~n_areset)
3053                        begin
3054       1/1                rdata_slice                  &lt;= {p_edma_bus_width{1'b0}};
3055       1/1                rdata_slice_full             &lt;= 1'b0;
3056       1/1                rdata_slice_last_beat_of_buf &lt;= 1'b0;
3057                        end
3058                        else
3059                        begin
3060       1/1                if (~enable_tx || flush_tx_rd_fifos)
3061                          begin
3062       1/1                  rdata_slice                  &lt;= {p_edma_bus_width{1'b0}};
3063       1/1                  rdata_slice_full             &lt;= 1'b0;
3064       1/1                  rdata_slice_last_beat_of_buf &lt;= 1'b0;
3065                          end
3066                          else
3067                          begin
3068       1/1                  if (rdata_slice_pop &amp;&amp; ~rdata_slice_push)
3069       1/1                    rdata_slice_full  &lt;= 1'b0;
3070                            else
3071       1/1                    if (rdata_slice_push)
3072                              begin
3073       1/1                      rdata_slice                  &lt;= rdata_hmod[p_edma_bus_width-1:0];
3074       1/1                      rdata_slice_full             &lt;= 1'b1;
3075       1/1                      rdata_slice_last_beat_of_buf &lt;= al_last_beat_of_buf;
3076                              end
                        MISSING_ELSE
3077                          end
3078                        end
3079                      end
3080                    
3081                      generate if (p_edma_asf_dap_prot == 1) begin : gen_rdata_slice_par
3082                        reg [p_edma_bus_pwid-1:0] rdata_slice_par_r;
3083                        always@(posedge aclk or negedge n_areset)
3084                        begin
3085                          if (~n_areset)
3086                            rdata_slice_par_r &lt;= {p_edma_bus_pwid{1'b0}};
3087                          else if (~enable_tx || flush_tx_rd_fifos)
3088                            rdata_slice_par_r &lt;= {p_edma_bus_pwid{1'b0}};
3089                          else if (~(rdata_slice_pop &amp;&amp; ~rdata_slice_push) &amp;&amp; rdata_slice_push)
3090                            rdata_slice_par_r &lt;= rdata_hmod_par[p_edma_bus_pwid-1:0];
3091                        end
3092                        assign rdata_slice_par  = rdata_slice_par_r;
3093                      end else begin : gen_no_rdata_slice_par
3094                        assign rdata_slice_par  = {p_edma_bus_pwid{1'b0}};
3095                      end
3096                      endgenerate
3097                    
3098                      assign rdata_slice_push  = al_full &amp;&amp; rdata_slice_ready;
3099                      assign rdata_slice_pop   = rdata_slice_full &amp;&amp; buff_stripe_rdy;
3100                      assign rdata_slice_ready = ~rdata_slice_full || rdata_slice_pop;
3101                    
3102                      generate if (p_edma_bus_width &lt; 32'd128) begin : gen_buff_stripe_pad
3103                        assign buff_stripe      = {{(128-p_edma_bus_width){1'b0}},rdata_slice};
3104                        if (p_edma_asf_dap_prot == 1) begin : gen_par
3105                          assign buff_stripe_par  = {{(16-p_edma_bus_pwid){1'b0}},rdata_slice_par};
3106                        end else begin : gen_no_par
3107                          assign buff_stripe_par  = 16'h0000;
3108                        end
3109                      end else begin : gen_no_buff_stripe_pad
3110                        assign buff_stripe      = rdata_slice;
3111                        if (p_edma_asf_dap_prot == 1) begin : gen_par
3112                          assign buff_stripe_par  = rdata_slice_par;
3113                        end else begin : gen_no_par
3114                          assign buff_stripe_par  = 16'h0000;
3115                        end
3116                      end
3117                      endgenerate
3118                    
3119                      assign buff_stripe_vld      = rdata_slice_full;
3120                      assign buff_stripe_last     = rdata_slice_last_beat_of_buf;
3121                    
3122                      // Count AXI R channel beats in last burst of frame
3123                      // Only active when force_max_ahb_burst_tx is asserted
3124                      // Used to identify data in excess of that required for the TX frame
3125                      always @ (posedge aclk or negedge n_areset)
3126                      begin
3127       1/1              if  (~n_areset)
3128       1/1                r_ctr &lt;= 4'h0;
3129                        else
3130       1/1                if (~enable_tx || flush_tx_rd_fifos)
3131       1/1                  r_ctr &lt;= 4'h0;
3132                          else
3133       1/1                  if (force_max_ahb_burst_tx)
3134                            begin
3135       <font color = "red">0/1     ==>            if (rrv_data &amp;&amp; r_last_burst_of_buf)</font>
3136                              begin
3137       <font color = "red">0/1     ==>              if (rlast)</font>
3138       <font color = "red">0/1     ==>                r_ctr &lt;= 4'h0;</font>
3139                                else
3140       <font color = "red">0/1     ==>                r_ctr &lt;= r_ctr + 4'h1;</font>
3141                              end
                   <font color = "red">==>  MISSING_ELSE</font>
3142                            end
3143                            else
3144       1/1                    r_ctr &lt;= 4'h0;
3145                      end
3146                    
3147                      // Indicate when reading padded data - i.e. data in excess of that required for frame
3148                      // r_num_pad is bottom 4 bits of num_tx_beats_remaining at point where burst was issued
3149                      // on AR channel, retimed to AXI R channel
3150                      assign r_is_pad          = (r_ctr &gt;= r_num_pad) &amp;&amp; r_last_burst_of_buf &amp;&amp; (|r_num_pad);
3151                      assign r_last_before_pad = (r_ctr == (r_num_pad - 4'd1)) &amp;&amp; r_last_burst_of_buf &amp;&amp; (|r_num_pad) &amp;&amp; (|burst_length);
3152                    
3153                    
3154                      // Indicate when all data for TX frame has been requested
3155                      //  - will be asserted for descriptors which require no data
3156                      assign all_data_for_txbuf_requested = (({tx_buf_beat_req_ctr} &gt;= num_beats_al) &amp;&amp; (|tx_buf_beat_req_ctr)) ||
3157                                                             ((cur_db2_out_axi_zero_len_buff || cur_db2_out_axi_used_bit) &amp;&amp; (drd_sm_cs == DRD_CHK_DESCR));
3158                    
3159                      // Indicate when incoming descriptor is part of a multi buffer set and has the last bit set and a
3160                      // zero length field
3161                      // This is an error condition as there is no further buffer to supply data
3162                      assign db1_in_zero_len_buff_err = (db1_in[45:32] == 14'h0000) &amp;&amp; ~first_buffer_pad[r_queue] &amp;&amp; db1_in_last_bit;
3163                    
3164                      // Indicate when incoming descriptor is part of a multi buffer set and has the used bit set
3165                      // This is an error condition as there is no further buffer to supply data
3166                      assign db1_in_used_buff_err = db1_in_used_bit &amp;&amp; ~first_buffer_pad[r_queue];
3167                    
3168                      // Indicate when incoming descriptor has an error
3169                      assign db1_in_buff_err = db1_in_zero_len_buff_err || db1_in_used_buff_err;
3170                    
3171                      // Drive AXI RREADY for descriptor and data fetches
3172                      //  - always high for descriptor fetches as descriptor request is only made if there
3173                      //    is capacity in descriptor buffer
3174                      //  - drive low for data fecth if there is already data in alignment registers
3175                      assign rready_descr = 1'b1;
3176                    
3177                      assign rready_data = ~res_only &amp;&amp; al_ready;
3178                    
3179                      // Counters to track addresses of descriptors output to AHB DMA
3180                    
3181                      always @ (posedge aclk or negedge n_areset)
3182                      begin
3183       1/1              if (~n_areset)
3184                        begin
3185       1/1                for (int_m = 0; int_m &lt; p_num_queues; int_m = int_m + 1)
3186       1/1                  db2_descr_ptr[int_m] &lt;= {p_awid_par{1'b0}};
3187                        end
3188                        else
3189       1/1                if (~enable_tx || flush_tx_rd_fifos || (new_tx_q_ptr_pulse &amp;&amp; (mrd_sm_cs == MRD_IDLE)))
3190                          // initialise pointers to config reg base values
3191                          begin
3192       1/1                  for (int_m = 0; int_m &lt; p_num_queues; int_m = int_m + 1)
3193       1/1                    db2_descr_ptr[int_m]  &lt;= tx_base_addr_arr[int_m];
3194                          end
3195                          else
3196                          begin
3197       1/1                  for (int_m = 0; int_m &lt; p_num_queues; int_m = int_m + 1)
3198                            begin
3199       1/1                    if ((db2_pop_dma_q[int_m]) &amp;&amp; ~db2_out_dma[int_m][p_descr_width]) //~no increment bit
3200                              begin
3201       1/1                      if (~db2_out_dma[int_m][63]) // ~used bit
3202                                begin
3203       1/1                        if (db2_out_dma[int_m][62]) // wrap bit
3204                                    // load from base address register
3205       <font color = "red">0/1     ==>                  db2_descr_ptr[int_m]  &lt;= tx_base_addr_arr[int_m];</font>
3206                                  else
3207       1/1                          db2_descr_ptr[int_m]  &lt;= db2_descr_ptr_inc[int_m][p_awid_par-1:0];
3208                                end
                   <font color = "red">==>  MISSING_ELSE</font>
3209                              end
                        MISSING_ELSE
3210                            end
3211                          end
3212                      end
3213                    
3214                      // Build array of address update results.
3215                      // Each entry of array db2_descr_ptr_inc is db2_descr_ptr + tx_next_descr_ptr_inc
3216                      genvar g_loop_2;
3217                      generate for (g_loop_2=0;g_loop_2&lt;p_num_queues;g_loop_2=g_loop_2+1) begin : gen_db2_loop
3218                        edma_arith_par #(
3219                          .p_dwidth (32),
3220                          .p_pwidth (4),
3221                          .p_has_par(p_edma_asf_dap_prot)
3222                        ) i_arith_db2_descr_ptr (
3223                          .in_val (db2_descr_ptr[g_loop_2][31:0]),
3224                          .in_par (db2_descr_ptr[g_loop_2][p_awid_par-1:p_awid_par-4]),
3225                          .op_val (tx_next_descr_ptr_inc),
3226                          .op_add (1'b1),
3227                          .out_val(db2_descr_ptr_inc[g_loop_2][31:0]),
3228                          .out_par(db2_descr_ptr_inc[g_loop_2][35:32])
3229                        );
3230                      end
3231                      endgenerate
3232                    
3233                      // Flag first descriptor of frame in descriptors output to AHB
3234                      always @ (posedge aclk or negedge n_areset)
3235                      begin
3236       1/1              if  (~n_areset)
3237       1/1                db2_first_buffer &lt;= {p_num_queues{1'b1}};
3238                        else
3239       1/1                if (~enable_tx || flush_tx_rd_fifos)
3240       1/1                  db2_first_buffer &lt;= {p_num_queues{1'b1}};
3241                          else
3242       1/1                  for (int_x = 0; int_x &lt; p_num_queues; int_x = int_x + 1)
3243       1/1                    if (db2_pop_dma &amp;&amp; int_x[3:0] == cur_db2_dma_queue)
3244       1/1                      db2_first_buffer[int_x] &lt;= cur_db2_out_dma_last_bit || cur_db2_out_dma_used_bit;
                        MISSING_ELSE
3245                      end
3246                    
3247                      // Capture address of first descriptor of the frame for
3248                      // descriptors output to AHB DMA
3249                      // For segmented/fragmented frames this will be the address
3250                      // of the header descriptor supplied by SW
3251                      always @ (posedge aclk or negedge n_areset)
3252                      begin
3253       1/1              if (~n_areset)
3254                        begin
3255       1/1                for (int_v = 0; int_v &lt; p_num_queues; int_v = int_v + 1)
3256       1/1                  db2_1st_descr_addr[int_v] &lt;= {p_awid_par{1'b0}};
3257                        end
3258                        else
3259       1/1                if (~enable_tx || flush_tx_rd_fifos)
3260       1/1                  for (int_w = 0; int_w &lt; p_num_queues; int_w = int_w + 1)
3261       1/1                    db2_1st_descr_addr[int_w] &lt;= {p_awid_par{1'b0}};
3262                            else
3263       1/1                    for (int_q = 0; int_q &lt; p_num_queues; int_q = int_q + 1)
3264       1/1                      if ( (db2_pop_dma_q[int_q] &amp;&amp; db2_first_buffer[int_q] &amp;&amp; ~db2_out_dma[int_q][p_descr_width+3]) ||
3265                                     (db2_pop_dma_q[int_q] &amp;&amp; db2_first_buffer[int_q] &amp;&amp; db2_out_dma[int_q][p_descr_width+3] &amp;&amp; db2_out_dma[int_q][p_descr_width+2]) )
3266       1/1                        db2_1st_descr_addr[int_q] &lt;= db2_descr_ptr[int_q];
                        MISSING_ELSE
3267                      end
3268                    
3269                      // Drive writeback address from counter or storage register
3270                      // - dependend on whether counter holds the address of the first descriptor in a multi buffer frame
3271                    
3272                      always @ *
3273                      begin
3274       1/1              for (int_r = 0; int_r &lt; p_num_queues; int_r = int_r + 1)
3275       1/1                if ( (db2_first_buffer[int_r] &amp;&amp; ~db2_out_dma[int_r][p_descr_width+3]) ||
3276                               (db2_first_buffer[int_r] &amp;&amp; db2_out_dma[int_r][p_descr_width+3] &amp;&amp; db2_out_dma[int_r][p_descr_width+2]) )
3277       1/1                  db2_descr_wb_addr[int_r] = db2_descr_ptr[int_r];
3278                          else
3279       1/1                  db2_descr_wb_addr[int_r] = db2_1st_descr_addr[int_r];
3280                      end
3281                    
3282                      // Concatenate descriptor pointers and writeback addresses into single busses for transfer to AHB DMA
3283                      genvar g;
3284                      generate for (g = 0; g &lt; p_num_queues; g = g + 1)
3285                      begin : gen_axi_tx_dma_descr_ptr
3286                        assign axi_tx_dma_descr_ptr[(g*32)+31:g*32] = db2_descr_ptr[g][31:0];
3287                      end
3288                      endgenerate
3289                    
3290                      // Generate toggle signal when axi_tx_dma_descr_ptr changes
3291                      //  - i.e. when db2 is popped
3292                      always @ (posedge aclk or negedge n_areset)
3293                      begin
3294       1/1              if (~n_areset)
3295       1/1                axi_tx_dma_descr_ptr_tog &lt;= 1'b0;
3296                        else
3297       1/1                if (db2_pop_dma)
3298       1/1                  axi_tx_dma_descr_ptr_tog &lt;= ~axi_tx_dma_descr_ptr_tog;
                        MISSING_ELSE
3299                      end
3300                    
3301                    
3302                      //=============================================================
3303                      // Align incoming rdata to byte 0 of data bus
3304                      // - For data reads only - descriptor reads are not affected
3305                      //=============================================================
3306                      always @ (*)
3307                      begin
3308       1/1              rdata_res_c = rdata_res;
3309       1/1              rdata_al_c  = rdata_al;
3310       1/1              if (res_push)
3311                        begin
3312       <font color = "red">0/1     ==>        case (dma_bus_width)</font>
3313                            // Note - res_push will not be active for aligned address, so
3314                            // default branches in case statements are for highest
3315                            // misaligned addresses
3316                            2'b00 :
3317                            begin
3318       <font color = "red">0/1     ==>            case (r_araddr[1:0])</font>
3319       <font color = "red">0/1     ==>              2'b01   : rdata_res_c[23:0] = rdata_data_le[31:8];</font>
3320       <font color = "red">0/1     ==>              2'b10   : rdata_res_c[15:0] = rdata_data_le[31:16];</font>
3321       <font color = "red">0/1     ==>              default : rdata_res_c[7:0]  = rdata_data_le[31:24];</font>
3322                              endcase
3323                            end
3324                            2'b01 :
3325                            begin
3326       <font color = "red">0/1     ==>            case (r_araddr[2:0])</font>
3327       <font color = "red">0/1     ==>              3'b001  : rdata_res_c[55:0] = rdata_data_le[63:8];</font>
3328       <font color = "red">0/1     ==>              3'b010  : rdata_res_c[47:0] = rdata_data_le[63:16];</font>
3329       <font color = "red">0/1     ==>              3'b011  : rdata_res_c[39:0] = rdata_data_le[63:24];</font>
3330       <font color = "red">0/1     ==>              3'b100  : rdata_res_c[31:0] = rdata_data_le[63:32];</font>
3331       <font color = "red">0/1     ==>              3'b101  : rdata_res_c[23:0] = rdata_data_le[63:40];</font>
3332       <font color = "red">0/1     ==>              3'b110  : rdata_res_c[15:0] = rdata_data_le[63:48];</font>
3333       <font color = "red">0/1     ==>              default : rdata_res_c[7:0]  = rdata_data_le[63:56];</font>
3334                              endcase
3335                            end
3336                            default :
3337                            begin
3338       <font color = "red">0/1     ==>            rdata_res_c[120] = 1'b0;</font>
3339       <font color = "red">0/1     ==>            case (r_araddr[3:0])</font>
3340       <font color = "red">0/1     ==>              4'b0001 : rdata_res_c[119:0] = rdata_data_le[127:8];</font>
3341       <font color = "red">0/1     ==>              4'b0010 : rdata_res_c[111:0] = rdata_data_le[127:16];</font>
3342       <font color = "red">0/1     ==>              4'b0011 : rdata_res_c[103:0] = rdata_data_le[127:24];</font>
3343       <font color = "red">0/1     ==>              4'b0100 : rdata_res_c[95:0]  = rdata_data_le[127:32];</font>
3344       <font color = "red">0/1     ==>              4'b0101 : rdata_res_c[87:0]  = rdata_data_le[127:40];</font>
3345       <font color = "red">0/1     ==>              4'b0110 : rdata_res_c[79:0]  = rdata_data_le[127:48];</font>
3346       <font color = "red">0/1     ==>              4'b0111 : rdata_res_c[71:0]  = rdata_data_le[127:56];</font>
3347       <font color = "red">0/1     ==>              4'b1000 : rdata_res_c[63:0]  = rdata_data_le[127:64];</font>
3348       <font color = "red">0/1     ==>              4'b1001 : rdata_res_c[55:0]  = rdata_data_le[127:72];</font>
3349       <font color = "red">0/1     ==>              4'b1010 : rdata_res_c[47:0]  = rdata_data_le[127:80];</font>
3350       <font color = "red">0/1     ==>              4'b1011 : rdata_res_c[39:0]  = rdata_data_le[127:88];</font>
3351       <font color = "red">0/1     ==>              4'b1100 : rdata_res_c[31:0]  = rdata_data_le[127:96];</font>
3352       <font color = "red">0/1     ==>              4'b1101 : rdata_res_c[23:0]  = rdata_data_le[127:104];</font>
3353       <font color = "red">0/1     ==>              4'b1110 : rdata_res_c[15:0]  = rdata_data_le[127:112];</font>
3354       <font color = "red">0/1     ==>              default : rdata_res_c[7:0]   = rdata_data_le[127:120];</font>
3355                              endcase
3356                            end
3357                          endcase
3358                        end
                        MISSING_ELSE
3359                    
3360       1/1              if (al_push &amp;&amp; ~res_only)
3361                        begin
3362       1/1                case (dma_bus_width)
3363                            2'b00 :
3364                            begin
3365       1/1                    rdata_al_c[128:32] = {97{1'b0}};
3366       1/1                    case (r_araddr[1:0])
3367       <font color = "red">0/1     ==>              2'b01   : rdata_al_c[31:0] = {rdata_data_le[7:0],  rdata_res[23:0]};</font>
3368       <font color = "red">0/1     ==>              2'b10   : rdata_al_c[31:0] = {rdata_data_le[15:0], rdata_res[15:0]};</font>
3369       <font color = "red">0/1     ==>              2'b11   : rdata_al_c[31:0] = {rdata_data_le[23:0], rdata_res[7:0]};</font>
3370       1/1                      default : rdata_al_c[31:0] =  rdata_data_le[31:0];
3371                              endcase
3372                            end
3373                    
3374                            2'b01 :
3375                            begin
3376       <font color = "red">0/1     ==>            rdata_al_c[128:64] = {65{1'b0}};</font>
3377       <font color = "red">0/1     ==>            case (r_araddr[2:0])</font>
3378       <font color = "red">0/1     ==>              3'b001  : rdata_al_c[63:0] = {rdata_data_le[7:0],  rdata_res[55:0]};</font>
3379       <font color = "red">0/1     ==>              3'b010  : rdata_al_c[63:0] = {rdata_data_le[15:0], rdata_res[47:0]};</font>
3380       <font color = "red">0/1     ==>              3'b011  : rdata_al_c[63:0] = {rdata_data_le[23:0], rdata_res[39:0]};</font>
3381       <font color = "red">0/1     ==>              3'b100  : rdata_al_c[63:0] = {rdata_data_le[31:0], rdata_res[31:0]};</font>
3382       <font color = "red">0/1     ==>              3'b101  : rdata_al_c[63:0] = {rdata_data_le[39:0], rdata_res[23:0]};</font>
3383       <font color = "red">0/1     ==>              3'b110  : rdata_al_c[63:0] = {rdata_data_le[47:0], rdata_res[15:0]};</font>
3384       <font color = "red">0/1     ==>              3'b111  : rdata_al_c[63:0] = {rdata_data_le[55:0], rdata_res[7:0]};</font>
3385       <font color = "red">0/1     ==>              default : rdata_al_c[63:0] =  rdata_data_le[63:0];</font>
3386                              endcase
3387                            end
3388                    
3389                            default :
3390                            begin
3391       <font color = "red">0/1     ==>            rdata_al_c[128] = 1'b0;</font>
3392       <font color = "red">0/1     ==>            case (r_araddr[3:0])</font>
3393       <font color = "red">0/1     ==>              4'b0001 : rdata_al_c[127:0] = {rdata_data_le[7:0],   rdata_res[119:0]};</font>
3394       <font color = "red">0/1     ==>              4'b0010 : rdata_al_c[127:0] = {rdata_data_le[15:0],  rdata_res[111:0]};</font>
3395       <font color = "red">0/1     ==>              4'b0011 : rdata_al_c[127:0] = {rdata_data_le[23:0],  rdata_res[103:0]};</font>
3396       <font color = "red">0/1     ==>              4'b0100 : rdata_al_c[127:0] = {rdata_data_le[31:0],  rdata_res[95:0]};</font>
3397       <font color = "red">0/1     ==>              4'b0101 : rdata_al_c[127:0] = {rdata_data_le[39:0],  rdata_res[87:0]};</font>
3398       <font color = "red">0/1     ==>              4'b0110 : rdata_al_c[127:0] = {rdata_data_le[47:0],  rdata_res[79:0]};</font>
3399       <font color = "red">0/1     ==>              4'b0111 : rdata_al_c[127:0] = {rdata_data_le[55:0],  rdata_res[71:0]};</font>
3400       <font color = "red">0/1     ==>              4'b1000 : rdata_al_c[127:0] = {rdata_data_le[63:0],  rdata_res[63:0]};</font>
3401       <font color = "red">0/1     ==>              4'b1001 : rdata_al_c[127:0] = {rdata_data_le[71:0],  rdata_res[55:0]};</font>
3402       <font color = "red">0/1     ==>              4'b1010 : rdata_al_c[127:0] = {rdata_data_le[79:0],  rdata_res[47:0]};</font>
3403       <font color = "red">0/1     ==>              4'b1011 : rdata_al_c[127:0] = {rdata_data_le[87:0],  rdata_res[39:0]};</font>
3404       <font color = "red">0/1     ==>              4'b1100 : rdata_al_c[127:0] = {rdata_data_le[95:0],  rdata_res[31:0]};</font>
3405       <font color = "red">0/1     ==>              4'b1101 : rdata_al_c[127:0] = {rdata_data_le[103:0], rdata_res[23:0]};</font>
3406       <font color = "red">0/1     ==>              4'b1110 : rdata_al_c[127:0] = {rdata_data_le[111:0], rdata_res[15:0]};</font>
3407       <font color = "red">0/1     ==>              4'b1111 : rdata_al_c[127:0] = {rdata_data_le[119:0], rdata_res[7:0]};</font>
3408       <font color = "red">0/1     ==>              default : rdata_al_c[127:0] =  rdata_data_le[127:0];</font>
3409                              endcase
3410                            end
3411                          endcase
3412                        end
3413       1/1              else if (al_push &amp;&amp; res_only)
3414       <font color = "red">0/1     ==>        rdata_al_c = {{(129-p_edma_bus_width+8){1'b0}}, rdata_res_r};</font>
                        MISSING_ELSE
3415                      end
3416                    
3417                      always @ (posedge aclk or negedge n_areset)
3418                      begin
3419       1/1              if (~n_areset)
3420                        begin
3421       1/1                rdata_res_r &lt;= {(p_edma_bus_width-8){1'b0}};
3422       1/1                rdata_al_r  &lt;= {p_edma_bus_width{1'b0}};
3423       1/1                al_full   &lt;= 1'b0;
3424       1/1                res_full  &lt;= 1'b0;
3425       1/1                res_only  &lt;= 1'b0;
3426                        end
3427                        else
3428       1/1                if (~enable_tx || flush_tx_rd_fifos)
3429                          begin
3430       1/1                  al_full   &lt;= 1'b0;
3431       1/1                  res_full  &lt;= 1'b0;
3432       1/1                  res_only  &lt;= 1'b0;
3433                          end
3434                          else
3435                          begin
3436       1/1                  rdata_res_r &lt;= rdata_res_c[(p_edma_bus_width-9):0];
3437       1/1                  rdata_al_r  &lt;= rdata_al_c[(p_edma_bus_width-1):0];
3438                    
3439       1/1                  if (al_pop &amp;&amp; ~al_push)
3440       1/1                    al_full  &lt;= 1'b0;
3441                            else
3442       1/1                    if (al_push)
3443       1/1                      al_full  &lt;= 1'b1;
                        MISSING_ELSE
3444                    
3445       1/1                  if (res_pop &amp;&amp; ~res_push)
3446       1/1                    res_full  &lt;= 1'b0;
3447                            else
3448       1/1                    if (res_push)
3449       <font color = "red">0/1     ==>              res_full  &lt;= 1'b1;</font>
                        MISSING_ELSE
3450                    
3451       1/1                  if (res_push &amp;&amp; (rlast || r_last_before_pad) &amp;&amp; r_last_burst_of_buf)
3452       <font color = "red">0/1     ==>            res_only  &lt;= 1'b1;</font>
3453                            else
3454       1/1                    if (res_pop)
3455       1/1                      res_only  &lt;= 1'b0;
                        MISSING_ELSE
3456                    
3457                          end
3458                      end
3459                      assign rdata_res = {{(129-p_edma_bus_width){1'b0}}, rdata_res_r};
3460                      assign rdata_al  =  {{(129-p_edma_bus_width){1'b0}}, rdata_al_r};
3461                    
3462                      //=============================================================
3463                      //  ASF - Align the parirty of incoming rdata
3464                      //=============================================================
3465                      generate if (p_edma_asf_dap_prot == 1) begin : gen_par_rdata_res_al
3466                        reg [15:0]  rdata_res_par_c;
3467                        reg [16:0]  rdata_al_par_c;
3468                        reg [p_edma_bus_width/8-2:0]  rdata_res_par_r;
3469                        reg [p_edma_bus_width/8-1:0]  rdata_al_par_r;
3470                    
3471                        always @ (*)
3472                        begin
3473                          rdata_res_par_c = {{(1+(128-p_edma_bus_width)/8){1'b0}}, rdata_res_par_r};
3474                          rdata_al_par_c  = {{(1+(128-p_edma_bus_width)/8){1'b0}}, rdata_al_par_r};
3475                          if (res_push)
3476                            case (dma_bus_width)
3477                              // Note - res_push will not be active for aligned address, so
3478                              // default branches in case statements are for highest
3479                              // misaligned addresses
3480                              2'b00 :
3481                                case (r_araddr[1:0])
3482                                  2'b01   : rdata_res_par_c[2:0] = rdata_data_le_par[3:1];
3483                                  2'b10   : rdata_res_par_c[1:0] = rdata_data_le_par[3:2];
3484                                  default : rdata_res_par_c[0]   = rdata_data_le_par[3];
3485                                endcase
3486                              2'b01 :
3487                                case (r_araddr[2:0])
3488                                  3'b001  : rdata_res_par_c[6:0] = rdata_data_le_par[7:1];
3489                                  3'b010  : rdata_res_par_c[5:0] = rdata_data_le_par[7:2];
3490                                  3'b011  : rdata_res_par_c[4:0] = rdata_data_le_par[7:3];
3491                                  3'b100  : rdata_res_par_c[3:0] = rdata_data_le_par[7:4];
3492                                  3'b101  : rdata_res_par_c[2:0] = rdata_data_le_par[7:5];
3493                                  3'b110  : rdata_res_par_c[1:0] = rdata_data_le_par[7:6];
3494                                  default : rdata_res_par_c[0]   = rdata_data_le_par[7];
3495                                endcase
3496                              default :
3497                                case (r_araddr[3:0])
3498                                  4'b0001 : rdata_res_par_c[14:0]  = rdata_data_le_par[15:1];
3499                                  4'b0010 : rdata_res_par_c[13:0]  = rdata_data_le_par[15:2];
3500                                  4'b0011 : rdata_res_par_c[12:0]  = rdata_data_le_par[15:3];
3501                                  4'b0100 : rdata_res_par_c[11:0]  = rdata_data_le_par[15:4];
3502                                  4'b0101 : rdata_res_par_c[10:0]  = rdata_data_le_par[15:5];
3503                                  4'b0110 : rdata_res_par_c[9:0]   = rdata_data_le_par[15:6];
3504                                  4'b0111 : rdata_res_par_c[8:0]   = rdata_data_le_par[15:7];
3505                                  4'b1000 : rdata_res_par_c[7:0]   = rdata_data_le_par[15:8];
3506                                  4'b1001 : rdata_res_par_c[6:0]   = rdata_data_le_par[15:9];
3507                                  4'b1010 : rdata_res_par_c[5:0]   = rdata_data_le_par[15:10];
3508                                  4'b1011 : rdata_res_par_c[4:0]   = rdata_data_le_par[15:11];
3509                                  4'b1100 : rdata_res_par_c[3:0]   = rdata_data_le_par[15:12];
3510                                  4'b1101 : rdata_res_par_c[2:0]   = rdata_data_le_par[15:13];
3511                                  4'b1110 : rdata_res_par_c[1:0]   = rdata_data_le_par[15:14];
3512                                  default : rdata_res_par_c[0]     = rdata_data_le_par[15];
3513                                endcase
3514                            endcase
3515                    
3516                          if (al_push &amp;&amp; ~res_only)
3517                          begin
3518                            case (dma_bus_width)
3519                              2'b00 :
3520                                case (r_araddr[1:0])
3521                                  2'b01   : rdata_al_par_c[3:0]  = {rdata_data_le_par[0],   rdata_res_par[2:0]};
3522                                  2'b10   : rdata_al_par_c[3:0]  = {rdata_data_le_par[1:0], rdata_res_par[1:0]};
3523                                  2'b11   : rdata_al_par_c[3:0]  = {rdata_data_le_par[2:0], rdata_res_par[0]};
3524                                  default : rdata_al_par_c[3:0]  =  rdata_data_le_par[3:0];
3525                                endcase
3526                    
3527                              2'b01 :
3528                                case (r_araddr[2:0])
3529                                  3'b001  : rdata_al_par_c[7:0] = {rdata_data_le_par[0],   rdata_res_par[6:0]};
3530                                  3'b010  : rdata_al_par_c[7:0] = {rdata_data_le_par[1:0], rdata_res_par[5:0]};
3531                                  3'b011  : rdata_al_par_c[7:0] = {rdata_data_le_par[2:0], rdata_res_par[4:0]};
3532                                  3'b100  : rdata_al_par_c[7:0] = {rdata_data_le_par[3:0], rdata_res_par[3:0]};
3533                                  3'b101  : rdata_al_par_c[7:0] = {rdata_data_le_par[4:0], rdata_res_par[2:0]};
3534                                  3'b110  : rdata_al_par_c[7:0] = {rdata_data_le_par[5:0], rdata_res_par[1:0]};
3535                                  3'b111  : rdata_al_par_c[7:0] = {rdata_data_le_par[6:0], rdata_res_par[0]};
3536                                  default : rdata_al_par_c[7:0] =  rdata_data_le_par[7:0];
3537                                endcase
3538                    
3539                              default :
3540                                case (r_araddr[3:0])
3541                                  4'b0001 : rdata_al_par_c[15:0] = {rdata_data_le_par[0],    rdata_res_par[14:0]};
3542                                  4'b0010 : rdata_al_par_c[15:0] = {rdata_data_le_par[1:0],  rdata_res_par[13:0]};
3543                                  4'b0011 : rdata_al_par_c[15:0] = {rdata_data_le_par[2:0],  rdata_res_par[12:0]};
3544                                  4'b0100 : rdata_al_par_c[15:0] = {rdata_data_le_par[3:0],  rdata_res_par[11:0]};
3545                                  4'b0101 : rdata_al_par_c[15:0] = {rdata_data_le_par[4:0],  rdata_res_par[10:0]};
3546                                  4'b0110 : rdata_al_par_c[15:0] = {rdata_data_le_par[5:0],  rdata_res_par[9:0]};
3547                                  4'b0111 : rdata_al_par_c[15:0] = {rdata_data_le_par[6:0],  rdata_res_par[8:0]};
3548                                  4'b1000 : rdata_al_par_c[15:0] = {rdata_data_le_par[7:0],  rdata_res_par[7:0]};
3549                                  4'b1001 : rdata_al_par_c[15:0] = {rdata_data_le_par[8:0],  rdata_res_par[6:0]};
3550                                  4'b1010 : rdata_al_par_c[15:0] = {rdata_data_le_par[9:0],  rdata_res_par[5:0]};
3551                                  4'b1011 : rdata_al_par_c[15:0] = {rdata_data_le_par[10:0], rdata_res_par[4:0]};
3552                                  4'b1100 : rdata_al_par_c[15:0] = {rdata_data_le_par[11:0], rdata_res_par[3:0]};
3553                                  4'b1101 : rdata_al_par_c[15:0] = {rdata_data_le_par[12:0], rdata_res_par[2:0]};
3554                                  4'b1110 : rdata_al_par_c[15:0] = {rdata_data_le_par[13:0], rdata_res_par[1:0]};
3555                                  4'b1111 : rdata_al_par_c[15:0] = {rdata_data_le_par[14:0], rdata_res_par[0]};
3556                                  default : rdata_al_par_c[15:0] =  rdata_data_le_par[15:0];
3557                                endcase
3558                            endcase
3559                          end
3560                          else
3561                            if (al_push &amp;&amp; res_only)
3562                              rdata_al_par_c = {{(1+(128-p_edma_bus_width+8)/8){1'b0}}, rdata_res_par_r};
3563                    
3564                        end
3565                    
3566                        always @ (posedge aclk or negedge n_areset)
3567                        begin
3568                          if (~n_areset)
3569                          begin
3570                            rdata_res_par_r &lt;= {p_edma_bus_width/8-1{1'b0}};
3571                            rdata_al_par_r  &lt;= {p_edma_bus_width/8{1'b0}};
3572                          end
3573                          else
3574                            if(enable_tx &amp;&amp; ~flush_tx_rd_fifos)
3575                            begin
3576                              rdata_res_par_r &lt;= rdata_res_par_c[(p_edma_bus_width/8-2):0];
3577                              rdata_al_par_r  &lt;= rdata_al_par_c[(p_edma_bus_width/8-1):0];
3578                            end
3579                        end
3580                        assign rdata_al_par   = {{(1+(128-p_edma_bus_width)/8){1'b0}}, rdata_al_par_r};
3581                        assign rdata_res_par  = {{(1+(128-p_edma_bus_width)/8){1'b0}}, rdata_res_par_r};
3582                      end else begin : gen_no_par_rdata_res_al
3583                        assign rdata_res_par  = 16'd0;
3584                        assign rdata_al_par   = 17'd0;
3585                      end
3586                      endgenerate
3587                    
3588                      assign rdata_align = ((dma_bus_width == 2'b00) &amp;&amp; (r_araddr[1:0] == 2'b00)) ||
3589                                           ((dma_bus_width == 2'b01) &amp;&amp; (r_araddr[2:0] == 3'b000)) ||
3590                                           (dma_bus_width[1] &amp;&amp; (r_araddr[3:0] == 4'b0000));
3591                    
3592                      // Push data into residue buffer if masaligned - apart from the last stripe when the number of AHB beats is less
3593                      // than the number of AXI beats
3594                      assign res_push  = rrv_data &amp;&amp; ~r_is_pad &amp;&amp; ~rdata_align &amp;&amp; ~(r_ahb_less_beats &amp;&amp; (rlast || r_last_before_pad) &amp;&amp; r_last_burst_of_buf);
3595                      assign res_pop   = al_push;
3596                    
3597                    
3598                      // Push data into rdata_al
3599                      //  - Push on all incoming beats apart from first beat of unaligned access
3600                      //     - First beat of unaligned access goes completely to residue register
3601                      //  - Push if res_only flag is set
3602                      //     - Will occur for unaligned accesses where aligned burst has less beats than unaligned burst
3603                      assign al_push   = (rrv_data &amp;&amp; ~r_is_pad &amp;&amp; ~(r_1st_beat_of_buf &amp;&amp; ~rdata_align)) ||
3604                                         (res_only &amp;&amp; al_ready);
3605                    
3606                      assign al_pop    = rdata_slice_push;
3607                      assign al_ready  = (~al_full || al_pop);
3608                    
3609                    
3610                      // Status bits which accompany data through rdata_res and rdata_al registers
3611                      generate if (p_edma_lso == 1'b1) begin : gen_res_lso
3612                      always @ (posedge aclk or negedge n_areset)
3613                      begin
3614                        if (~n_areset)
3615                        begin
3616                          res_first_burst_of_buf &lt;= 1'b0;
3617                          res_1st_beat_of_buf    &lt;= 1'b0;
3618                          res_tcp_hdr            &lt;= 1'b0;
3619                          res_udp_hdr            &lt;= 1'b0;
3620                    
3621                          al_first_burst_of_buf  &lt;= 1'b0;
3622                          al_tcp_hdr             &lt;= 1'b0;
3623                          al_udp_hdr             &lt;= 1'b0;
3624                        end
3625                        else
3626                          if (~enable_tx || flush_tx_rd_fifos)
3627                          begin
3628                            res_first_burst_of_buf &lt;= 1'b0;
3629                            res_1st_beat_of_buf    &lt;= 1'b0;
3630                            res_tcp_hdr            &lt;= 1'b0;
3631                            res_udp_hdr            &lt;= 1'b0;
3632                    
3633                            al_first_burst_of_buf  &lt;= 1'b0;
3634                            al_tcp_hdr             &lt;= 1'b0;
3635                            al_udp_hdr             &lt;= 1'b0;
3636                          end
3637                          else
3638                          begin
3639                            if (res_push)
3640                            begin
3641                              res_first_burst_of_buf &lt;= r_first_burst_of_buf;
3642                              res_1st_beat_of_buf    &lt;= r_1st_beat_of_buf;
3643                              res_tcp_hdr            &lt;= r_tcp_hdr;
3644                              res_udp_hdr            &lt;= r_udp_hdr;
3645                            end
3646                    
3647                            if (al_push)
3648                            begin
3649                              if (res_only) // Data only coming from residue register
3650                              begin
3651                                al_first_burst_of_buf &lt;= res_first_burst_of_buf;
3652                                al_tcp_hdr            &lt;= res_tcp_hdr;
3653                                al_udp_hdr            &lt;= res_udp_hdr;
3654                              end
3655                              else
3656                                if (res_full) // Data coming from residue register and AXI bus
3657                                begin
3658                                  al_first_burst_of_buf &lt;= res_first_burst_of_buf;  // 1st burst may be single beat
3659                                  al_tcp_hdr            &lt;= r_tcp_hdr;
3660                                  al_udp_hdr            &lt;= r_udp_hdr;
3661                                end
3662                                else  // Data coming from AXI bus only
3663                                begin
3664                                  al_first_burst_of_buf &lt;= r_first_burst_of_buf;
3665                                  al_tcp_hdr            &lt;= r_tcp_hdr;
3666                                  al_udp_hdr            &lt;= r_udp_hdr;
3667                                end
3668                            end
3669                          end
3670                      end
3671                      end else begin : gen_no_res_lso
3672                        wire zero;
3673                        assign zero = 1'b0;
3674                        always @(zero)
3675                        begin
3676       1/1                res_first_burst_of_buf  = zero;
3677       1/1                res_1st_beat_of_buf     = zero;
3678       1/1                res_tcp_hdr             = zero;
3679       1/1                res_udp_hdr             = zero;
3680       1/1                al_first_burst_of_buf   = zero;
3681       1/1                al_tcp_hdr              = zero;
3682       1/1                al_udp_hdr              = zero;
3683                        end
3684                      end
3685                      endgenerate
3686                    
3687                      // same process as above but always there ..
3688                      always @ (posedge aclk or negedge n_areset)
3689                      begin
3690       1/1              if (~n_areset)
3691                        begin
3692       1/1                res_last_burst_of_buf  &lt;= 1'b0;
3693       1/1                res_last               &lt;= 1'b0;
3694                    
3695       1/1                al_last_burst_of_buf   &lt;= 1'b0;
3696       1/1                al_last                &lt;= 1'b0;
3697                        end
3698                        else
3699       1/1                if (~enable_tx || flush_tx_rd_fifos)
3700                          begin
3701       1/1                  res_last_burst_of_buf  &lt;= 1'b0;
3702       1/1                  res_last               &lt;= 1'b0;
3703                    
3704       1/1                  al_last_burst_of_buf   &lt;= 1'b0;
3705       1/1                  al_last                &lt;= 1'b0;
3706                          end
3707                          else
3708                          begin
3709       1/1                  if (res_push)
3710                            begin
3711       <font color = "red">0/1     ==>            res_last_burst_of_buf  &lt;= r_last_burst_of_buf;</font>
3712       <font color = "red">0/1     ==>            res_last               &lt;= rlast || r_last_before_pad;</font>
3713                            end
                        MISSING_ELSE
3714                    
3715       1/1                  if (al_push)
3716                            begin
3717       1/1                    if (res_only) // Data only coming from residue register
3718                              begin
3719       <font color = "red">0/1     ==>              al_last_burst_of_buf  &lt;= res_last_burst_of_buf;</font>
3720       <font color = "red">0/1     ==>              al_last               &lt;= res_last;</font>
3721                              end
3722                              else
3723       1/1                      if (res_full) // Data coming from residue register and AXI bus
3724                                begin
3725       <font color = "red">0/1     ==>                al_last_burst_of_buf  &lt;= r_last_burst_of_buf;     // Last burst may be single beat</font>
3726       <font color = "red">0/1     ==>                al_last               &lt;= (rlast || r_last_before_pad) &amp;&amp; ~res_push;</font>
3727                                end
3728                                else  // Data coming from AXI bus only
3729                                begin
3730       1/1                        al_last_burst_of_buf  &lt;= r_last_burst_of_buf;
3731       1/1                        al_last               &lt;= (rlast || r_last_before_pad);
3732                                end
3733                            end
                        MISSING_ELSE
3734                          end
3735                      end
3736                    
3737                      assign al_last_beat_of_buf = al_last_burst_of_buf &amp;&amp; al_last;
3738                    
3739                      // Parameterise the FIFO width for ASF protection
3740                      localparam p_ar2al_dwidth  = 14+14+2+1+1+1+4;
3741                      localparam p_ar2al_pwidth  = (p_ar2al_dwidth+7) / 8;
3742                      localparam p_ar2al_width   = (p_edma_asf_dap_prot == 1)  ? p_ar2al_dwidth + p_ar2al_pwidth : p_ar2al_dwidth;
3743                    
3744                      wire  [p_ar2al_width-1:0] ar2al_fifo_in, ar2al_fifo_out;
3745                    
3746                      assign ar2al_fifo_in[p_ar2al_dwidth-1:0]  = {ar_hdr_len, ar_pyld_len, ar_tcp_st_id, ar_tcp_sn_sel, ar_1st_hdr, ar_last_hdr, ar_queue_data};
3747                      assign {al_hdr_len, al_pyld_len, al_tcp_st_id,
3748                              al_tcp_sn_sel, al_1st_hdr, al_last_hdr,
3749                              al_queue} = ar2al_fifo_out[p_ar2al_dwidth-1:0];
3750                    
3751                      // Optional parity protection
3752                      generate if ((p_edma_asf_dap_prot == 1) &amp;&amp; (p_edma_lso == 1'b1)) begin : gen_ar2al_par
3753                        // Check and generate new parity for ar2al_fifo_in.
3754                        gem_par_chk_regen #(.p_chk_dwid (48),.p_new_dwid(p_ar2al_dwidth)) i_regen_par_wb_word1 (
3755                          .odd_par  (1'b0),
3756                          .chk_dat  ({cur_db2_out_axi[63:32],cur_db2_out_nxt_axi[47:32]}),
3757                          .chk_par  ({cur_db2_out_axi_par[7:4],cur_db2_out_nxt_axi_par[5:4]}),
3758                          .new_dat  (ar2al_fifo_in[p_ar2al_dwidth-1:0]),
3759                          .dat_out  (),
3760                          .par_out  (ar2al_fifo_in[p_ar2al_width-1:p_ar2al_dwidth]),
3761                          .chk_err  ()
3762                        );
3763                        
3764                        // Check parity of ar2al_fifo_out.
3765                        cdnsdru_asf_parity_check_v1 #(
3766                          .p_data_width (p_ar2al_dwidth)
3767                        ) i_par_chk (
3768                          .odd_par    (1'b0),
3769                          .data_in    (ar2al_fifo_out[p_ar2al_dwidth-1:0]),
3770                          .parity_in  (ar2al_fifo_out[p_ar2al_width-1:p_ar2al_dwidth]),
3771                          .parity_err (dap_err_ar2al_fifo)
3772                        );
3773                      end else begin : gen_no_ar2al_par
3774                        assign dap_err_ar2al_fifo = 1'b0;
3775                      end
3776                      endgenerate
3777                      
3778                      generate if (p_edma_lso == 1'b1) begin: gen_ar2al_fifo
3779                        edma_gen_fifo #( .FIFO_WIDTH(p_ar2al_width),
3780                                       .FIFO_DEPTH(p_axi_access_pipeline_depth),
3781                                       .FIFO_ADDR_WIDTH(p_axi_access_pipeline_bits)
3782                                      ) i_ar_to_al_fifo (
3783                          .qout       (ar2al_fifo_out),
3784                          .qempty     (),
3785                          .qfull      (),
3786                          .qlevel     (),
3787                          .clk_pcie   (aclk),
3788                          .rst_n      (n_areset),
3789                          .din        (ar2al_fifo_in),
3790                          .push       (ar2al_push),
3791                          .flush      (~enable_tx || flush_tx_rd_fifos),
3792                          .pop        (ar2al_pop)
3793                        );
3794                      end else begin: no_gen_ar2al_fifo
3795                        assign ar2al_fifo_out = {p_ar2al_width{1'b0}};
3796                      end
3797                      endgenerate  
3798                    
3799                      assign ar2al_push = arrv_data &amp;&amp; (ar_tcp_hdr || ar_udp_hdr) &amp;&amp; ar_first_req_of_buf;
3800                    
3801                      assign ar2al_pop  = al_pop &amp;&amp; (al_tcp_hdr || al_udp_hdr) &amp;&amp; al_last_burst_of_buf &amp;&amp; al_last;
3802                    
3803                    
3804                    
3805                      // Pass parameters for use by header modification logic to AR2R FIFO
3806                      assign  ar_hdr_len          = cur_db2_out_axi[45:32];
3807                      assign  ar_pyld_len         = cur_db2_out_nxt_axi[45:32];
3808                      assign  ar_udp_hdr          = cur_db2_out_axi_gh &amp;&amp; (cur_db2_out_axi[50:49] == 2'b01);
3809                      assign  ar_tcp_hdr          = cur_db2_out_axi_gh &amp;&amp; cur_db2_out_axi[50];
3810                      assign  ar_tcp_st_id        = cur_db2_out_axi[57:56];
3811                      assign  ar_tcp_sn_sel       = cur_db2_out_axi[51];
3812                      assign  ar_1st_hdr          = cur_db2_out_axi_fh;
3813                      assign  ar_last_hdr         = cur_db2_out_axi_lh;
3814                      assign  ar_queue_data       = cur_db2_axi_queue;
3815                      assign  ar_first_req_of_buf = drd_sm_cs == DRD_CHK_DESCR;
3816                      assign  ar_last_req_of_buf  = (num_tx_beats_remaining &lt;= {4'h0, data_len});
3817                    
3818                    
3819                      // Mark first beat of burst in incoming data
3820                      always @ (posedge aclk or negedge n_areset)
3821                      begin
3822       1/1              if  (~n_areset)
3823       1/1                r_1st_beat &lt;= 1'd1;
3824                        else
3825       1/1                if (~enable_tx || flush_tx_rd_fifos)
3826       1/1                  r_1st_beat &lt;= 1'd1;
3827                          else
3828       1/1                  if (rrv_data)
3829       1/1                    r_1st_beat &lt;= rlast;
                        MISSING_ELSE
3830                      end
3831                    
3832                      // Mark first beat of buffer in incoming data
3833                      assign r_1st_beat_of_buf = r_1st_beat &amp;&amp; r_first_burst_of_buf;
3834                    
3835                      // Mark first beat of burst in rdata_al register
3836                      generate if (p_edma_lso == 1'b1) begin : gen_al_1st_beat
3837                      always @ (posedge aclk or negedge n_areset)
3838                      begin
3839                        if  (~n_areset)
3840                          al_1st_beat &lt;= 1'd1;
3841                        else
3842                          if (~enable_tx || flush_tx_rd_fifos)
3843                            al_1st_beat &lt;= 1'd1;
3844                          else
3845                            if (al_pop)
3846                              al_1st_beat &lt;= al_last;
3847                      end
3848                    
3849                      // Calculate number of 32-bit words in 1st beat of read data
3850                      // - dependent on data bus width
3851                      // - value is number of words - 1, and is therefore
3852                      //   byte number of ms word in beat
3853                      reg   [11:0]  words_1st_beat;
3854                      always @ *
3855                      begin
3856                        case (dma_bus_width)
3857                          2'b00   : words_1st_beat = 12'd0;
3858                          2'b01   : words_1st_beat = 12'd1;
3859                          default : words_1st_beat = 12'd3;
3860                        endcase
3861                      end
3862                    
3863                      // Count incoming rdata_al bytes
3864                      // Separate counters for byte ID of MS and LS bytes in stripe
3865                      
3866                      wire [12:0] al_ms_word_id_p1;
3867                      wire [12:0] al_ms_word_id_p2;
3868                      wire [12:0] al_ms_word_id_p4;
3869                      wire [12:0] al_ls_word_id_p1;
3870                      wire [12:0] al_ls_word_id_p2;
3871                      wire [12:0] al_ls_word_id_p4;
3872                      assign      al_ms_word_id_p1 = al_ms_word_id + 12'd1;
3873                      assign      al_ms_word_id_p2 = al_ms_word_id + 12'd2;
3874                      assign      al_ms_word_id_p4 = al_ms_word_id + 12'd4;
3875                      assign      al_ls_word_id_p1 = al_ls_word_id + 12'd1;
3876                      assign      al_ls_word_id_p2 = al_ls_word_id + 12'd2;
3877                      assign      al_ls_word_id_p4 = al_ls_word_id + 12'd4;
3878                      
3879                      always @ (posedge aclk or negedge n_areset)
3880                      begin
3881                        if  (~n_areset)
3882                        begin
3883                          al_ms_word_id &lt;= 12'd0;
3884                          al_ls_word_id &lt;= 12'd0;
3885                        end
3886                        else
3887                          if (~enable_tx || flush_tx_rd_fifos)
3888                          begin
3889                            al_ms_word_id &lt;= 12'd0;
3890                            al_ls_word_id &lt;= 12'd0;
3891                          end
3892                          else
3893                          if (al_push &amp;&amp; ((r_1st_beat_of_buf &amp;&amp; rdata_align &amp;&amp; ~res_full) || (res_1st_beat_of_buf &amp;&amp; res_full)))
3894                          begin
3895                            if (r_tcp_hdr || r_udp_hdr)
3896                            begin
3897                              al_ms_word_id &lt;= words_1st_beat;
3898                              al_ls_word_id &lt;= 12'd0;
3899                            end
3900                            else
3901                            begin
3902                              al_ms_word_id &lt;= 12'd0;
3903                              al_ls_word_id &lt;= 12'd0;
3904                            end
3905                          end
3906                          else
3907                            if ((al_push &amp;&amp; ~res_only &amp;&amp; (r_tcp_hdr || r_udp_hdr)) ||
3908                                (al_push &amp;&amp; res_only &amp;&amp; (res_tcp_hdr || res_udp_hdr)))
3909                            begin
3910                              case (dma_bus_width)
3911                                2'b00   : al_ms_word_id &lt;= al_ms_word_id_p1[11:0];
3912                                2'b01   : al_ms_word_id &lt;= al_ms_word_id_p2[11:0];
3913                                default : al_ms_word_id &lt;= al_ms_word_id_p4[11:0];
3914                              endcase
3915                    
3916                              case (dma_bus_width)
3917                                2'b00   : al_ls_word_id &lt;= al_ls_word_id_p1[11:0];
3918                                2'b01   : al_ls_word_id &lt;= al_ls_word_id_p2[11:0];
3919                                default : al_ls_word_id &lt;= al_ls_word_id_p4[11:0];
3920                              endcase
3921                            end
3922                      end
3923                    
3924                      // Calculate word positions and get values of of fields of interest in incoming
3925                      // header
3926                      // Fields which have an effect on other fields may or may not be
3927                      // in the same beat depending on bus width so must use immediate and stored
3928                      // versions of values and flags and select accordingly
3929                      always @ (posedge aclk or negedge n_areset)
3930                      begin
3931                        if (~n_areset)
3932                        begin
3933                          byte12_r &lt;= 8'd0;
3934                          byte13_r &lt;= 8'd0;
3935                          byte16_r &lt;= 8'd0;
3936                          byte17_r &lt;= 8'd0;
3937                          byte20_r &lt;= 8'd0;
3938                          byte21_r &lt;= 8'd0;
3939                        end
3940                        else
3941                        begin
3942                          if (|byte15_12_trig &amp;&amp; al_pop)
3943                            {byte12_r, byte13_r}  &lt;= {byte12, byte13};
3944                    
3945                          if (|byte19_16_trig &amp;&amp; al_pop)
3946                            {byte16_r, byte17_r}  &lt;= {byte16, byte17};
3947                    
3948                          if (|byte23_20_trig &amp;&amp; al_pop)
3949                            {byte20_r, byte21_r}  &lt;= {byte20, byte21};
3950                        end
3951                      end
3952                      end else begin : gen_no_bytes
3953                        wire zero;
3954                        assign zero = 1'b0;
3955                        always @(zero)
3956                        begin
3957       1/1                byte12_r = {8{zero}};
3958       1/1                byte13_r = {8{zero}};
3959       1/1                byte16_r = {8{zero}};
3960       1/1                byte17_r = {8{zero}};
3961       1/1                byte20_r = {8{zero}};
3962       1/1                byte21_r = {8{zero}};
3963       1/1                al_1st_beat = zero;
3964       1/1                al_ls_word_id = {12{zero}};
3965       1/1                al_ms_word_id = {12{zero}};
3966                        end
3967                      end
3968                      endgenerate
3969                    
3970                      assign byte12 = |byte15_12_trig ? byte12_hdr : byte12_r;
3971                      assign byte13 = |byte15_12_trig ? byte13_hdr : byte13_r;
3972                    
3973                      assign byte16 = |byte19_16_trig ? byte16_hdr : byte16_r;
3974                      assign byte17 = |byte19_16_trig ? byte17_hdr : byte17_r;
3975                    
3976                      assign byte20 = |byte23_20_trig ? byte20_hdr : byte20_r;
3977                      assign byte21 = |byte23_20_trig ? byte21_hdr : byte21_r;
3978                    
3979                      assign vlan   = |byte15_12_trig ? ({byte12, byte13} == 16'h8100) : vlan_r;
3980                    
3981                      assign svlan  = |byte15_12_trig ? ({byte12, byte13} == 16'h88a8) : svlan_r;
3982                    
3983                    
3984                      generate if (p_edma_lso == 1'b1) begin : gen_vlan
3985                      always @ (posedge aclk or negedge n_areset)
3986                      begin
3987                        if (~n_areset)
3988                        begin
3989                          vlan_r    &lt;= 1'd0;
3990                          svlan_r   &lt;= 1'd0;
3991                        end
3992                        else
3993                        if (|byte15_12_trig  &amp;&amp; al_pop)
3994                        begin
3995                          vlan_r   &lt;= vlan;
3996                          svlan_r  &lt;= svlan;
3997                        end
3998                      end
3999                      end else begin : gen_no_vlan
4000                        wire zero;
4001                        assign zero = 1'b0;
4002                        always @(zero)
4003                        begin
4004       1/1                vlan_r = zero;
4005       1/1                svlan_r = zero;
4006                        end
4007                      end
4008                      endgenerate
4009                    
4010                      always @ *
4011                      begin
4012       1/1              if (vlan &amp;&amp; ~svlan)
4013                        // vlan only
4014                        begin
4015       <font color = "red">0/1     ==>        ethertype_trig = byte19_16_trig;</font>
4016       <font color = "red">0/1     ==>        eth_hdr_len    = 12'd3  + 12'd1;</font>
4017       <font color = "red">0/1     ==>        ethertype      = {byte16, byte17};</font>
4018                        end
4019                        else
4020       1/1                if (svlan)
4021                          // svlan only
4022                          begin
4023       <font color = "red">0/1     ==>          ethertype_trig = byte23_20_trig;</font>
4024       <font color = "red">0/1     ==>          eth_hdr_len    = 12'd3  + 12'd2;</font>
4025       <font color = "red">0/1     ==>          ethertype      = {byte20, byte21};</font>
4026                          end
4027                          else // no vlsn or svlan
4028                          begin
4029       1/1                  ethertype_trig = byte15_12_trig;
4030       1/1                  eth_hdr_len    = 12'd3;
4031       1/1                  ethertype      = {byte12, byte13};
4032                          end
4033                      end
4034                    
4035                      // Detect IPv4 or IPv6 from ethertype
4036                      always @ *
4037                      begin
4038       1/1              if (|ethertype_trig)
4039                        begin
4040       <font color = "red">0/1     ==>        ipv4 = (ethertype == 16'h0800);</font>
4041       <font color = "red">0/1     ==>        ipv6 = (ethertype == 16'h86dd);</font>
4042                        end
4043                        else
4044                        begin
4045       1/1                ipv4 = ipv4_r;
4046       1/1                ipv6 = ipv6_r;
4047                        end
4048                      end
4049                    
4050                      generate if (p_edma_lso == 1'b1) begin : gen_ip
4051                      always @ (posedge aclk or negedge n_areset)
4052                      begin
4053                        if (~n_areset)
4054                        begin
4055                          ipv4_r &lt;= 1'd0;
4056                          ipv6_r &lt;= 1'd0;
4057                        end
4058                        else
4059                        begin
4060                          if (|ethertype_trig &amp;&amp; al_pop)
4061                          begin
4062                            ipv4_r &lt;= ipv4;
4063                            ipv6_r &lt;= ipv6;
4064                          end
4065                        end
4066                      end
4067                      end else begin : gen_no_ip
4068                        wire zero;
4069                        assign zero = 1'b0;
4070                        always @(zero)
4071                        begin
4072       1/1                ipv4_r = zero;
4073       1/1                ipv6_r = zero;
4074                        end
4075                      end
4076                      endgenerate
4077                    
4078                    
4079                      // Calculate IPv4 field positions from ethernet header length
4080                      // Positions are for 32-bit words
4081                      assign ipv4_ihl_pstn    = eth_hdr_len;
4082                      assign ipv4_tl_pstn     = eth_hdr_len + 12'd1;
4083                      assign ipv4_fo_pstn     = eth_hdr_len + 12'd2;
4084                    
4085                      // Capture ipv4 header length value
4086                      // No conversion required as already relates to 32-bit words
4087                      generate if (p_edma_lso == 1'b1) begin : gen_ipv4_hdr_len
4088                      always @ (posedge aclk or negedge n_areset)
4089                      begin
4090                        if (~n_areset)
4091                          ipv4_hdr_len &lt;= 12'd5;
4092                        else
4093                          if (al_pop &amp;&amp; al_first_burst_of_buf &amp;&amp; al_1st_beat &amp;&amp; ~|ipv4_ihl_trig)
4094                            // Load with default value at start of each data buffer
4095                            ipv4_hdr_len &lt;= 12'd5;
4096                          else
4097                            if (|ipv4_ihl_trig &amp;&amp; al_pop)
4098                              ipv4_hdr_len &lt;= {8'd0, ipv4_ihl[3:0]};
4099                      end
4100                      end else begin : gen_no_gen_ipv4_hdr_len
4101                        wire zero;
4102                        assign zero = 1'b0;
4103       1/1              always @(zero) ipv4_hdr_len = {12{zero}};
4104                      end
4105                      endgenerate
4106                    
4107                      // Calculate IPv6 field positions from ethernet header length
4108                      // Positions are for 32-bit words
4109                      assign ipv6_pl_pstn     = eth_hdr_len + 12'd1;
4110                      assign ipv6_hdr_nh_pstn = eth_hdr_len + 12'd2;
4111                      assign ipv6_hdr_len     = 12'd10;
4112                    
4113                    
4114                      // Calculate TCP field positions from ethernet header length
4115                      // and IPv4/IPv6 header length
4116                      // Positions are for 32-bit words
4117                      // Need to consider case where IPv6 has header extensions and last header extension is
4118                      // 8 bytes long - in this case the header extension and upper half of the sequence number can occur
4119                      // in the same stripe if the data bus width is 128 bits
4120                      
4121                      wire [12:0] eth_hdr_len_p_ipv4_hdr_len;
4122                      wire [12:0] eth_hdr_len_p_ipv6_hdr_len;
4123                      wire [13:0] eth_hdr_len_p_ipv6_ttl_hdr_len;
4124                        
4125                      wire [13:0] eth_hdr_len_p_ipv4_hdr_len_p1;
4126                      wire [13:0] eth_hdr_len_p_ipv4_hdr_len_p2;
4127                      wire [13:0] eth_hdr_len_p_ipv4_hdr_len_p3;
4128                      
4129                      wire [14:0] eth_hdr_len_p_ipv6_ttl_hdr_len_p1;
4130                      wire [14:0] eth_hdr_len_p_ipv6_ttl_hdr_len_p2;
4131                      wire [14:0] eth_hdr_len_p_ipv6_ttl_hdr_len_p3;
4132                      wire [14:0] eth_hdr_len_p_ipv6_ttl_hdr_len_p4;
4133                      wire [14:0] eth_hdr_len_p_ipv6_ttl_hdr_len_p5;
4134                      
4135                      assign      eth_hdr_len_p_ipv4_hdr_len        = eth_hdr_len + ipv4_hdr_len;
4136                      assign      eth_hdr_len_p_ipv4_hdr_len_p1     = eth_hdr_len_p_ipv4_hdr_len + 13'd1;
4137                      assign      eth_hdr_len_p_ipv4_hdr_len_p2     = eth_hdr_len_p_ipv4_hdr_len + 13'd2;
4138                      assign      eth_hdr_len_p_ipv4_hdr_len_p3     = eth_hdr_len_p_ipv4_hdr_len + 13'd3;
4139                      
4140                      assign      eth_hdr_len_p_ipv6_hdr_len        = eth_hdr_len + ipv6_hdr_len;
4141                      assign      eth_hdr_len_p_ipv6_ttl_hdr_len    = eth_hdr_len_p_ipv6_hdr_len + {1'b0,ipv6_ttl_ehdr_len};
4142                      
4143                      assign      eth_hdr_len_p_ipv6_ttl_hdr_len_p1 = eth_hdr_len_p_ipv6_ttl_hdr_len + 14'd1;
4144                      assign      eth_hdr_len_p_ipv6_ttl_hdr_len_p2 = eth_hdr_len_p_ipv6_ttl_hdr_len + 14'd2;
4145                      assign      eth_hdr_len_p_ipv6_ttl_hdr_len_p3 = eth_hdr_len_p_ipv6_ttl_hdr_len + 14'd3;
4146                      assign      eth_hdr_len_p_ipv6_ttl_hdr_len_p4 = eth_hdr_len_p_ipv6_ttl_hdr_len + 14'd4;
4147                      assign      eth_hdr_len_p_ipv6_ttl_hdr_len_p5 = eth_hdr_len_p_ipv6_ttl_hdr_len + 14'd5;
4148                      
4149                      always @(*)
4150                      begin
4151       1/1              if (ipv4)
4152                        begin
4153       <font color = "red">0/1     ==>        tcp_sn_byte3_2_pstn = eth_hdr_len_p_ipv4_hdr_len_p1[11:0];</font>
4154       <font color = "red">0/1     ==>        tcp_sn_byte1_0_pstn = eth_hdr_len_p_ipv4_hdr_len_p2[11:0];</font>
4155       <font color = "red">0/1     ==>        tcp_fl_pstn         = eth_hdr_len_p_ipv4_hdr_len_p3[11:0];</font>
4156                        end
4157       1/1              else if (ipv6_ehdr_seq_num)
4158                        begin
4159       <font color = "red">0/1     ==>        tcp_sn_byte3_2_pstn = eth_hdr_len_p_ipv6_ttl_hdr_len_p3[11:0];</font>
4160       <font color = "red">0/1     ==>        tcp_sn_byte1_0_pstn = eth_hdr_len_p_ipv6_ttl_hdr_len_p4[11:0];</font>
4161       <font color = "red">0/1     ==>        tcp_fl_pstn         = eth_hdr_len_p_ipv6_ttl_hdr_len_p5[11:0];</font>
4162                        end
4163                        else
4164                        begin
4165       1/1                tcp_sn_byte3_2_pstn = eth_hdr_len_p_ipv6_ttl_hdr_len_p1[11:0];
4166       1/1                tcp_sn_byte1_0_pstn = eth_hdr_len_p_ipv6_ttl_hdr_len_p2[11:0];
4167       1/1                tcp_fl_pstn         = eth_hdr_len_p_ipv6_ttl_hdr_len_p3[11:0];
4168                        end
4169                      end
4170                    
4171                      //==========================================================
4172                      // Generate trigger signal when 32-bit word of interest is
4173                      // present in current read data beat.
4174                      // 4-bit trigger indicates which word lane of the data bus the
4175                      // word of interest is in.
4176                      // Only bottom bit of trigger is active for 32-bit data bus and
4177                      // only bottom 2 bits of trigger are active for 64-bit data bus
4178                      // Also output values of words which are required for
4179                      // header decode or loading sequence number counters
4180                      // various byte of the output words are of no interest
4181                      //  - these connect to the unused* signals
4182                      //==========================================================
4183                    
4184                      // Ethernet header fields
4185                      edma_pbuf_axi_fe_hdr_parse i_hdr_parse_byte15_12 (
4186                        .enable         (1'b1),
4187                        .rdata          (rdata_al[127:0]),
4188                        .dma_bus_width  (dma_bus_width),
4189                        .ls_word_id     (al_ls_word_id),
4190                        .ms_word_id     (al_ms_word_id),
4191                        .word_pstn      (12'd3),
4192                        .trig           (byte15_12_trig),
4193                        .data_word      ({unused1, unused0, byte13_hdr, byte12_hdr})
4194                      );
4195                    
4196                      edma_pbuf_axi_fe_hdr_parse i_hdr_parse_byte19_16 (
4197                        .enable         (1'b1),
4198                        .rdata          (rdata_al[127:0]),
4199                        .dma_bus_width  (dma_bus_width),
4200                        .ls_word_id     (al_ls_word_id),
4201                        .ms_word_id     (al_ms_word_id),
4202                        .word_pstn      (12'd4),
4203                        .trig           (byte19_16_trig),
4204                        .data_word      ({unused3, unused2, byte17_hdr, byte16_hdr})
4205                      );
4206                    
4207                      edma_pbuf_axi_fe_hdr_parse i_hdr_parse_byte23_20 (
4208                        .enable         (1'b1),
4209                        .rdata          (rdata_al[127:0]),
4210                        .dma_bus_width  (dma_bus_width),
4211                        .ls_word_id     (al_ls_word_id),
4212                        .ms_word_id     (al_ms_word_id),
4213                        .word_pstn      (12'd5),
4214                        .trig           (byte23_20_trig),
4215                        .data_word      ({unused5, unused4, byte21_hdr, byte20_hdr})
4216                      );
4217                    
4218                      // IPv4 Internet Header Length
4219                      edma_pbuf_axi_fe_hdr_parse i_hdr_parse_ipv4_ihl (
4220                        .enable         (ipv4),
4221                        .rdata          (rdata_al[127:0]),
4222                        .dma_bus_width  (dma_bus_width),
4223                        .ls_word_id     (al_ls_word_id),
4224                        .ms_word_id     (al_ms_word_id),
4225                        .word_pstn      (ipv4_ihl_pstn),
4226                        .trig           (ipv4_ihl_trig),
4227                        .data_word      ({unused8, ipv4_ihl, unused7, unused6})
4228                    
4229                      );
4230                    
4231                      // IPv4 Total Length
4232                      edma_pbuf_axi_fe_hdr_parse i_hdr_parse_ipv4_tl (
4233                        .enable         (ipv4),
4234                        .rdata          (rdata_al[127:0]),
4235                        .dma_bus_width  (dma_bus_width),
4236                        .ls_word_id     (al_ls_word_id),
4237                        .ms_word_id     (al_ms_word_id),
4238                        .word_pstn      (ipv4_tl_pstn),
4239                        .trig           (ipv4_tl_trig),
4240                        .data_word      ()
4241                    
4242                      );
4243                    
4244                      // IPv4 Fragment Offset
4245                      edma_pbuf_axi_fe_hdr_parse i_hdr_parse_ipv4_fo (
4246                        .enable         (ipv4),
4247                        .rdata          (rdata_al[127:0]),
4248                        .dma_bus_width  (dma_bus_width),
4249                        .ls_word_id     (al_ls_word_id),
4250                        .ms_word_id     (al_ms_word_id),
4251                        .word_pstn      (ipv4_fo_pstn[11:0]),
4252                        .trig           (ipv4_fo_trig),
4253                        .data_word      ({unused11, unused10, unused9, ipv4_fo_byte1_hdr})
4254                    
4255                      );
4256                    
4257                      // IPv6 Payload Length
4258                      edma_pbuf_axi_fe_hdr_parse i_hdr_parse_ipv6_pl (
4259                        .enable         (ipv6),
4260                        .rdata          (rdata_al[127:0]),
4261                        .dma_bus_width  (dma_bus_width),
4262                        .ls_word_id     (al_ls_word_id),
4263                        .ms_word_id     (al_ms_word_id),
4264                        .word_pstn      (ipv6_pl_pstn),
4265                        .trig           (ipv6_pl_trig),
4266                        .data_word      ()
4267                    
4268                      );
4269                    
4270                      // TCP Sequence Number - upper 16 bits
4271                      edma_pbuf_axi_fe_hdr_parse i_hdr_parse_tcp_sn_3_2 (
4272                        .enable         (tcp_parse_enable),
4273                        .rdata          (rdata_al[127:0]),
4274                        .dma_bus_width  (dma_bus_width),
4275                        .ls_word_id     (al_ls_word_id),
4276                        .ms_word_id     (al_ms_word_id),
4277                        .word_pstn      (tcp_sn_byte3_2_pstn),
4278                        .trig           (tcp_sn_byte3_2_trig),
4279                        .data_word      ({tcp_sn_byte2_hdr, tcp_sn_byte3_hdr, unused13, unused12})
4280                    
4281                      );
4282                    
4283                      // TCP Sequence Number - lower 16 bits
4284                      edma_pbuf_axi_fe_hdr_parse i_hdr_parse_tcp_sn_1_0 (
4285                        .enable         (tcp_parse_enable),
4286                        .rdata          (rdata_al[127:0]),
4287                        .dma_bus_width  (dma_bus_width),
4288                        .ls_word_id     (al_ls_word_id),
4289                        .ms_word_id     (al_ms_word_id),
4290                        .word_pstn      (tcp_sn_byte1_0_pstn),
4291                        .trig           (tcp_sn_byte1_0_trig),
4292                        .data_word      ({unused15, unused14, tcp_sn_byte0_hdr, tcp_sn_byte1_hdr})
4293                    
4294                      );
4295                    
4296                      // TCP Flags
4297                      edma_pbuf_axi_fe_hdr_parse i_hdr_parse_tcp_sn (
4298                        .enable         (tcp_parse_enable),
4299                        .rdata          (rdata_al[127:0]),
4300                        .dma_bus_width  (dma_bus_width),
4301                        .ls_word_id     (al_ls_word_id),
4302                        .ms_word_id     (al_ms_word_id),
4303                        .word_pstn      (tcp_fl_pstn),
4304                        .trig           (tcp_fl_trig),
4305                        .data_word      ({tcp_fl_byte0_hdr, tcp_fl_byte1_hdr, unused17, unused16})
4306                    
4307                      );
4308                    
4309                      // IPv6 Next Header field in main header
4310                      edma_pbuf_axi_fe_hdr_parse i_hdr_parse_ipv6_hdr_nh (
4311                        .enable         (ipv6),
4312                        .rdata          (rdata_al[127:0]),
4313                        .dma_bus_width  (dma_bus_width),
4314                        .ls_word_id     (al_ls_word_id),
4315                        .ms_word_id     (al_ms_word_id),
4316                        .word_pstn      (ipv6_hdr_nh_pstn[11:0]),
4317                        .trig           (ipv6_hdr_nh_trig),
4318                        .data_word      ({unused20, unused19, unused18, ipv6_hdr_nh})
4319                    
4320                      );
4321                    
4322                      // IPv6 Extension header next header and header length fields
4323                      edma_pbuf_axi_fe_hdr_parse i_hdr_parse_ehdr (
4324                        .enable         (ipv6_ehdr),
4325                        .rdata          (rdata_al[127:0]),
4326                        .dma_bus_width  (dma_bus_width),
4327                        .ls_word_id     (al_ls_word_id),
4328                        .ms_word_id     (al_ms_word_id),
4329                        .word_pstn      (ipv6_ehdr_pstn),
4330                        .trig           (ipv6_ehdr_trig),
4331                        .data_word      ({ipv6_ehdr_ehl, ipv6_ehdr_nh, unused22, unused21})
4332                    
4333                      );
4334                    
4335                      // IPv6 speculative Extension header next header and header length fields
4336                      // Required for 128bit data bus as 2 extension headers can be contained within
4337                      // the same stripe
4338                      edma_pbuf_axi_fe_hdr_parse i_hdr_parse_ehdr2 (
4339                        .enable         (ipv6_ehdr),
4340                        .rdata          (rdata_al[127:0]),
4341                        .dma_bus_width  (dma_bus_width),
4342                        .ls_word_id     (al_ls_word_id),
4343                        .ms_word_id     (al_ms_word_id),
4344                        .word_pstn      (ipv6_ehdr_pstn + 12'd2),
4345                        .trig           (ipv6_ehdr2_trig),
4346                        .data_word      ({ipv6_ehdr2_ehl, ipv6_ehdr2_nh, unused24, unused23})
4347                    
4348                      );
4349                    
4350                      //============================================================================
4351                      // IPv6 header extensions
4352                      //============================================================================
4353                    
4354                      // Validate output from second extension header parser
4355                      // Only valid if main extrension header parser indicated a length of 8
4356                      // bytes and that the next header was another extension header
4357                      assign ipv6_ehdr2_valid = |ipv6_ehdr_trig &amp;&amp;
4358                                                (ipv6_ehdr_nh != 8'd06) &amp;&amp;
4359                                                (ipv6_ehdr_ehl == 8'd0);
4360                    
4361                      // IPv6 Extension header flag
4362                      // Set when next header field in IPv6 header indciates non-TCP header
4363                      // Clear when next header field in extension header indciates TCP header
4364                      generate if (p_edma_lso == 1'b1) begin : gen_ipv6
4365                      always @ (posedge aclk or negedge n_areset)
4366                      begin
4367                        if (~n_areset)
4368                          ipv6_ehdr &lt;= 1'd0;
4369                        else
4370                          if (al_pop &amp;&amp; al_first_burst_of_buf &amp;&amp; al_1st_beat)
4371                            // clear at start of header
4372                            // can only occur if previous header was errored
4373                            //  - had extension headers but no next header field with TCP value
4374                            ipv6_ehdr &lt;= 1'd0;
4375                          else
4376                            if (|ipv6_hdr_nh_trig &amp;&amp; al_pop &amp;&amp; ipv6_hdr_nh != 8'd06)
4377                              // set if IPv6 header next header flag isn't TCP
4378                              ipv6_ehdr &lt;= 1'd1;
4379                            else
4380                              if (|ipv6_ehdr_trig &amp;&amp; al_pop &amp;&amp; ipv6_ehdr_nh == 8'd06)
4381                                // clear if IPv6 extension header next header flag is TCP
4382                                ipv6_ehdr &lt;= 1'd0;
4383                              else
4384                                if (ipv6_ehdr2_valid &amp;&amp; |ipv6_ehdr2_trig &amp;&amp; al_pop &amp;&amp; ipv6_ehdr2_nh == 8'd06)
4385                                  // clear if 2 IPv6 extension headers in stripe and
4386                                  // next header field of second extension header is TCP
4387                                  ipv6_ehdr &lt;= 1'd0;
4388                      end
4389                    
4390                      // IPv6 Extension header start position
4391                      
4392                      wire [12:0] eth_hdr_len_p10;
4393                      wire [12:0] ipv6_ehdr_pstn_p2;
4394                      wire [13:0] ipv6_ehdr_pstn_p2_p_ehdr2_len;
4395                      wire [12:0] ipv6_ehdr_pstn_p_ehdr_len;
4396                      
4397                      assign      eth_hdr_len_p10               = eth_hdr_len       + 12'd10;
4398                      assign      ipv6_ehdr_pstn_p2             = ipv6_ehdr_pstn    + 12'd2;
4399                      assign      ipv6_ehdr_pstn_p2_p_ehdr2_len = ipv6_ehdr_pstn_p2 + {1'b0,ipv6_ehdr2_len};
4400                      assign      ipv6_ehdr_pstn_p_ehdr_len     = ipv6_ehdr_pstn    + ipv6_ehdr_len;
4401                      
4402                      always @ (posedge aclk or negedge n_areset)
4403                      begin
4404                        if (~n_areset)
4405                        begin
4406                          ipv6_ehdr_pstn &lt;= 12'hfff;
4407                        end
4408                        else
4409                          if (al_pop &amp;&amp; al_first_burst_of_buf &amp;&amp; al_1st_beat)
4410                            // Set to max value at start of packet so
4411                            // parser will not trigger until IPv6 header parsed
4412                            ipv6_ehdr_pstn &lt;= 12'hfff;
4413                          else
4414                            if (al_pop &amp;&amp; |ipv6_hdr_nh_trig &amp;&amp; ipv6_hdr_nh != 8'd06)
4415                              // Set to end of IPv6 header if next header field does not
4416                              // indiocate IPv4
4417                              ipv6_ehdr_pstn &lt;= eth_hdr_len_p10[11:0];
4418                            else
4419                              // Add on both extension header lengths if 2 extension headers start in the same stripe
4420                              if (al_pop &amp;&amp; ipv6_ehdr &amp;&amp; ipv6_ehdr2_valid &amp;&amp; |ipv6_ehdr2_trig)
4421                                ipv6_ehdr_pstn  &lt;= ipv6_ehdr_pstn_p2_p_ehdr2_len[11:0];
4422                              else
4423                                // Add on extension header length at start of extension header
4424                                if (al_pop &amp;&amp; |ipv6_ehdr_trig)
4425                                  ipv6_ehdr_pstn  &lt;= ipv6_ehdr_pstn_p_ehdr_len[11:0];
4426                      end
4427                      
4428                      wire [13:0] ipv6_ttl_ehdr_len_1;
4429                      wire [12:0] ipv6_ttl_ehdr_len_2;
4430                      assign      ipv6_ttl_ehdr_len_1 = ipv6_ttl_ehdr_len + ipv6_ehdr_len + ipv6_ehdr2_len;
4431                      assign      ipv6_ttl_ehdr_len_2 = ipv6_ttl_ehdr_len + ipv6_ehdr_len;
4432                      
4433                      // IPv6 Extension header total length count
4434                      always @ (posedge aclk or negedge n_areset)
4435                      begin
4436                        if (~n_areset)
4437                          ipv6_ttl_ehdr_len  &lt;= 12'd0;
4438                        else
4439                          if (al_pop &amp;&amp; al_first_burst_of_buf &amp;&amp; al_1st_beat)
4440                            // clear at start of buffer data
4441                            ipv6_ttl_ehdr_len &lt;= 12'd0;
4442                          else
4443                            if (al_pop &amp;&amp; ipv6_ehdr &amp;&amp; ipv6_ehdr2_valid &amp;&amp; |ipv6_ehdr2_trig)
4444                              // Add length of both extension headers
4445                              ipv6_ttl_ehdr_len &lt;= ipv6_ttl_ehdr_len_1[11:0];
4446                            else
4447                              if (al_pop &amp;&amp; ipv6_ehdr &amp;&amp; |ipv6_ehdr_trig)
4448                                // Add length of extension headers
4449                                ipv6_ttl_ehdr_len &lt;= ipv6_ttl_ehdr_len_2[11:0];
4450                      end
4451                      end else begin : gen_no_ipv6
4452                        wire   zero;
4453                        assign zero = 1'b0;
4454                        always @(*)
4455                        begin
4456       1/1                ipv6_ttl_ehdr_len = {12{zero}};
4457       1/1                ipv6_ehdr_pstn    = {12{zero}};
4458       1/1                ipv6_ehdr         = zero;
4459                        end
4460                      end
4461                      endgenerate
4462                      
4463                      wire [8:0] ipv6_ehdr_ehl_p1;
4464                      wire [8:0] ipv6_ehdr2_ehl_p1;
4465                      wire [9:0] ipv6_ehdr_ehl_p1_shifted;
4466                      wire [9:0] ipv6_ehdr2_ehl_p1_shifted;
4467                      
4468                      assign ipv6_ehdr_ehl_p1          = ipv6_ehdr_ehl  + 8'd1;
4469                      assign ipv6_ehdr2_ehl_p1         = ipv6_ehdr2_ehl + 8'd1;
4470                      assign ipv6_ehdr_ehl_p1_shifted  = {ipv6_ehdr_ehl_p1,1'b0};  
4471                      assign ipv6_ehdr2_ehl_p1_shifted = {ipv6_ehdr2_ehl_p1,1'b0};
4472                      
4473                      assign ipv6_ehdr_len  = {2'd0, ipv6_ehdr_ehl_p1_shifted};
4474                      assign ipv6_ehdr2_len = {2'd0, ipv6_ehdr2_ehl_p1_shifted};
4475                    
4476                      // Flag if final extension header is 8 bytes and sequence number is contained in
4477                      // the same stripe on 128-bit data bus. Extension header must start in 1st word
4478                      // of data bus
4479                      assign ipv6_ehdr_seq_num = (ipv6_ehdr_trig == 4'd1) &amp;&amp;
4480                                                 (ipv6_ehdr_nh  == 8'd06) &amp;&amp;
4481                                                 (ipv6_ehdr_ehl == 8'd0);
4482                    
4483                    
4484                      // generate enable for TCP sequence number and flags parsers
4485                      assign tcp_parse_enable = ipv4 || (ipv6 &amp;&amp; (~ipv6_ehdr || ipv6_ehdr_seq_num));
4486                    
4487                      // Sequence number counters
4488                      // 1 counter per stream, 4 streams per queue
4489                      // The counter load and increment events cannot occur simultaneously as the sequence
4490                      // number is in at least the 3rd beat of the header
4491                      generate if (p_edma_lso == 1'b1) begin : gen_seq_num_st
4492                        wire [32:0] seq_num_st0_ctr_tmp [15:0];
4493                        wire [32:0] seq_num_st1_ctr_tmp [15:0];
4494                        wire [32:0] seq_num_st2_ctr_tmp [15:0];
4495                        wire [32:0] seq_num_st3_ctr_tmp [15:0];
4496                        
4497                        genvar gen_a;
4498                        for (gen_a = 0; gen_a &lt; p_num_queues; gen_a = gen_a + 1) begin: gen_seq_num_st_ctr
4499                          assign seq_num_st0_ctr_tmp[gen_a] = seq_num_st0_ctr_pad[gen_a] + {18'd0,sn_fo_inc_pyld_len};
4500                          assign seq_num_st1_ctr_tmp[gen_a] = seq_num_st1_ctr_pad[gen_a] + {18'd0,sn_fo_inc_pyld_len};
4501                          assign seq_num_st2_ctr_tmp[gen_a] = seq_num_st2_ctr_pad[gen_a] + {18'd0,sn_fo_inc_pyld_len};
4502                          assign seq_num_st3_ctr_tmp[gen_a] = seq_num_st3_ctr_pad[gen_a] + {18'd0,sn_fo_inc_pyld_len};
4503                        end
4504                      
4505                      always @ (posedge aclk or negedge n_areset)
4506                      begin
4507                        if (~n_areset)
4508                          for (int_u = 0; int_u &lt; p_num_queues; int_u = int_u + 1)
4509                          begin
4510                            seq_num_st0_ctr[int_u] &lt;= 32'd0;
4511                            seq_num_st1_ctr[int_u] &lt;= 32'd0;
4512                            seq_num_st2_ctr[int_u] &lt;= 32'd0;
4513                            seq_num_st3_ctr[int_u] &lt;= 32'd0;
4514                          end
4515                        else
4516                          if (~enable_tx || flush_tx_rd_fifos)
4517                          for (int_u = 0; int_u &lt; p_num_queues; int_u = int_u + 1)
4518                          begin
4519                            seq_num_st0_ctr[int_u] &lt;= 32'd0;
4520                            seq_num_st1_ctr[int_u] &lt;= 32'd0;
4521                            seq_num_st2_ctr[int_u] &lt;= 32'd0;
4522                            seq_num_st3_ctr[int_u] &lt;= 32'd0;
4523                          end
4524                          else
4525                            if (al_tcp_hdr &amp;&amp; al_1st_hdr &amp;&amp; ~al_tcp_sn_sel &amp;&amp; al_pop)
4526                            begin
4527                              for (int_u = 0; int_u &lt; p_num_queues; int_u = int_u + 1)
4528                                if (int_u[3:0] == al_queue)
4529                                // Load counter from header field value
4530                                case (al_tcp_st_id)
4531                                  2'd0 :
4532                                  begin
4533                                    if (|tcp_sn_byte1_0_trig)
4534                                      seq_num_st0_ctr[int_u][15:0]  &lt;= {tcp_sn_byte1_hdr, tcp_sn_byte0_hdr};
4535                    
4536                                    if (|tcp_sn_byte3_2_trig)
4537                                      seq_num_st0_ctr[int_u][31:16] &lt;= {tcp_sn_byte3_hdr, tcp_sn_byte2_hdr};
4538                                  end
4539                    
4540                                  2'd1 :
4541                                  begin
4542                                    if (|tcp_sn_byte1_0_trig)
4543                                      seq_num_st1_ctr[int_u][15:0]  &lt;= {tcp_sn_byte1_hdr, tcp_sn_byte0_hdr};
4544                    
4545                                    if (|tcp_sn_byte3_2_trig)
4546                                      seq_num_st1_ctr[int_u][31:16] &lt;= {tcp_sn_byte3_hdr, tcp_sn_byte2_hdr};
4547                                  end
4548                    
4549                                  2'd2 :
4550                                  begin
4551                                    if (|tcp_sn_byte1_0_trig)
4552                                      seq_num_st2_ctr[int_u][15:0]  &lt;= {tcp_sn_byte1_hdr, tcp_sn_byte0_hdr};
4553                    
4554                                    if (|tcp_sn_byte3_2_trig)
4555                                      seq_num_st2_ctr[int_u][31:16] &lt;= {tcp_sn_byte3_hdr, tcp_sn_byte2_hdr};
4556                                  end
4557                    
4558                                  default :
4559                                  begin
4560                                    if (|tcp_sn_byte1_0_trig)
4561                                      seq_num_st3_ctr[int_u][15:0]  &lt;= {tcp_sn_byte1_hdr, tcp_sn_byte0_hdr};
4562                    
4563                                    if (|tcp_sn_byte3_2_trig)
4564                                      seq_num_st3_ctr[int_u][31:16] &lt;= {tcp_sn_byte3_hdr, tcp_sn_byte2_hdr};
4565                                  end
4566                                endcase
4567                            end
4568                            else
4569                              for (int_u = 0; int_u &lt; p_num_queues; int_u = int_u + 1)
4570                                if (sn_inc &amp;&amp; int_u[3:0] == sn_fo_inc_queue)
4571                                  // Increment counter with payload length value
4572                                  case (sn_inc_st_id)
4573                                    2'd0    : seq_num_st0_ctr[int_u] &lt;= seq_num_st0_ctr_tmp[int_u][31:0];
4574                                    2'd1    : seq_num_st1_ctr[int_u] &lt;= seq_num_st1_ctr_tmp[int_u][31:0];
4575                                    2'd2    : seq_num_st2_ctr[int_u] &lt;= seq_num_st2_ctr_tmp[int_u][31:0];
4576                                    default : seq_num_st3_ctr[int_u] &lt;= seq_num_st3_ctr_tmp[int_u][31:0];
4577                                  endcase
4578                        end
4579                      end else begin : gen_no_seq_num_st
4580                        wire zero;
4581                        assign zero = 1'b0;
4582                        always @(zero)
4583                        begin
4584       1/1                for (int_u = 0; int_u &lt; p_num_queues; int_u = int_u + 1)
4585                          begin
4586       1/1                  seq_num_st0_ctr[int_u]  = {32{zero}};
4587       1/1                  seq_num_st1_ctr[int_u]  = {32{zero}};
4588       1/1                  seq_num_st2_ctr[int_u]  = {32{zero}};
4589       1/1                  seq_num_st3_ctr[int_u]  = {32{zero}};
4590                          end
4591                        end
4592                      end
4593                      endgenerate
4594                    
4595                      // Depending on data bus widths and header extensions, TCP sequence number and IPv4 fragment
4596                      // offset fields field may or may not be in the last beat of the data read from the header buffer.
4597                      // Therefore, delay the increment of the sequence number and fragmant offset counters
4598                      // for 1 clock cycle to avoid inserting incremented counter values into current header
4599                      generate if (p_edma_lso == 1'b1) begin : gen_sn_inc
4600                      always @ (posedge aclk or negedge n_areset)
4601                      begin
4602                        if (~n_areset)
4603                        begin
4604                          sn_inc              &lt;= 1'b0;
4605                          fo_inc              &lt;= 1'b0;
4606                          sn_fo_inc_queue     &lt;= 4'd0;
4607                          sn_inc_st_id        &lt;= 2'd0;
4608                          sn_fo_inc_pyld_len  &lt;= 14'd0;
4609                        end
4610                        else
4611                          if (al_pop &amp;&amp; al_last &amp;&amp; (al_tcp_hdr || al_udp_hdr) &amp;&amp; al_last_burst_of_buf)
4612                          begin
4613                            sn_inc              &lt;= al_tcp_hdr;
4614                            sn_inc_st_id        &lt;= al_tcp_st_id;
4615                            fo_inc              &lt;= al_udp_hdr;
4616                            sn_fo_inc_queue     &lt;= al_queue;
4617                            sn_fo_inc_pyld_len  &lt;= al_pyld_len;
4618                          end
4619                          else
4620                          begin
4621                            sn_inc  &lt;= 1'b0;
4622                            fo_inc  &lt;= 1'b0;
4623                          end
4624                      end
4625                      end else begin : gen_no_sn_inc
4626                        wire zero;
4627                        assign zero = 1'b0;
4628                        always @(zero)
4629                        begin
4630       1/1                sn_inc              = zero;
4631       1/1                sn_inc_st_id        = {2{zero}};
4632       1/1                fo_inc              = 1'b0;
4633       1/1                sn_fo_inc_queue     = 4'd0;
4634       1/1                sn_fo_inc_pyld_len  = 14'd0;
4635                        end
4636                      end
4637                      endgenerate
4638                    
4639                    
4640                      //============================================================================
4641                      // Calculate IPv4 Fragment Offset and Flags value
4642                      // Required for UFO only
4643                      // The fragment counter clear and increment events can occur simultaneously for
4644                      // different queues as header buffers for different queues can be read
4645                      // consecutively. The events cannot occur simultaneously for the same queue
4646                      // as there must be a data buffer read between 2 header buffer reads
4647                      //============================================================================
4648                    
4649                      // Fragment offset counter
4650                      // Zero when start of 1st UFO header from large UFO frame is received,
4651                      // then increment by payload length at end of each header
4652                      generate if (p_edma_lso == 1'b1) begin : gen_ipv4_fo_cnt
4653                      reg   [13:0]  ipv4_fo_cnt_nxt [p_num_queues-1:0];
4654                      integer int_g;
4655                      integer int_h;
4656                      always @ (*)
4657                      begin
4658                        for (int_g = 0; int_g &lt; p_num_queues; int_g = int_g + 1)
4659                        begin
4660                          if (fo_inc &amp;&amp; int_g == {{28{1'b0}},sn_fo_inc_queue}) // Increment event for queue int_g
4661                            ipv4_fo_cnt_nxt[int_g] = ipv4_fo_cnt[int_g] + (sn_fo_inc_pyld_len &gt;&gt; 3);
4662                          else if (al_udp_hdr &amp;&amp; al_1st_hdr &amp;&amp; al_first_burst_of_buf &amp;&amp; al_pop &amp;&amp; (int_g == {{28{1'b0}},al_queue})) // Counter clear event for queue int_g
4663                            ipv4_fo_cnt_nxt[int_g] = 14'd0;
4664                          else
4665                            ipv4_fo_cnt_nxt[int_g] = {1'b0,ipv4_fo_cnt[int_g]};
4666                        end
4667                      end
4668                      always @ (posedge aclk or negedge n_areset)
4669                      begin
4670                        if (~n_areset)
4671                        begin
4672                          for (int_c = 0; int_c &lt; p_num_queues; int_c = int_c + 1)
4673                            ipv4_fo_cnt[int_c] &lt;= 13'd0;
4674                        end
4675                        else
4676                        begin
4677                          for (int_h = 0; int_h &lt; p_num_queues; int_h = int_h + 1)
4678                            ipv4_fo_cnt[int_h] &lt;= ipv4_fo_cnt_nxt[int_h][12:0];
4679                        end
4680                      end
4681                      end else begin : gen_no_ipv4_fo_cnt
4682                        wire zero;
4683                        assign zero = 1'b0;
4684                        always @(zero)
4685                        begin
4686       1/1                for (int_c = 0; int_c &lt; p_num_queues; int_c = int_c + 1)
4687       1/1                  ipv4_fo_cnt[int_c]  = {13{zero}};
4688                        end
4689                      end
4690                      endgenerate
4691                    
4692                    
4693                      //========================================================================
4694                      // Modify data stream - TCP sequence number, TCP Flags, IPv4 Total Length,
4695                      // IPv4 Fragment Offset, IPv4 Flags, IPv6 Payload Length
4696                      // Fields can be in 1 of 4 32-bit word positions
4697                      // Offset within 32-bit word does not change as all ethernet,
4698                      // IPv4 and IUPv6 header options/extensions are a mutiple of 4 bytes
4699                      //========================================================================
4700                    
4701                    
4702                      // Substitute header fields in incoming data stream
4703                      // Substitute strobes are mutually exclusive so use sum of products to improve
4704                      // timing by avoiding prioroity encoding of case statement or if-then-else
4705                      // Data stream is processed 32 bits at a time, so some bytes are always unmodified
4706                      // Substitution is only active when LSO is enabled via p_edma_lso - therefore
4707                      // when disabled, synthesis will optimise out all logic which generates the
4708                      // alternative values and the substitute strobes
4709                    
4710                      generate
4711                    
4712                        if (p_edma_lso == 1)
4713                        begin : gen_lso_hm
4714                          reg  [31:0] rdata_al_word;
4715                          reg  [31:0] cur_seq_num_ctr;
4716                          wire  [3:0] no_sub;
4717                          wire [15:0] ipv4_tl;
4718                          wire [15:0] ipv4_fo;
4719                          wire [15:0] ipv6_pl;
4720                          wire [15:0] tcp_fl;
4721                          wire  [3:0] sub_tcp_sn_byte1_0;
4722                          wire  [3:0] sub_tcp_sn_byte3_2;
4723                          wire  [3:0] sub_tcp_fl;
4724                          wire  [3:0] sub_ipv4_tl;
4725                          wire  [3:0] sub_ipv4_fo;
4726                          wire  [3:0] sub_ipv6_pl;
4727                          wire        mod_tcp_sn;
4728                          wire        mod_tcp_fl;
4729                          wire        mod_ipv4_tl;
4730                          wire        mod_ipv4_fo;
4731                          wire        mod_ipv6_pl;
4732                          integer     int_b;
4733                          
4734                          // Flag which headers require TCP sequence number field modification
4735                          //  - all headers with TSO flag set, except the first header where
4736                          //    sequence number select is low
4737                          assign mod_tcp_sn = al_tcp_hdr &amp;&amp; ~(~al_tcp_sn_sel &amp;&amp; al_1st_hdr);
4738                    
4739                          // Flag which headers require TCP flag field modification
4740                          //  - all headers with TSO flag set, except the last header
4741                          assign mod_tcp_fl = al_tcp_hdr &amp;&amp; ~al_last_hdr;
4742                    
4743                          // Flag which heacders require IPv4 total length field modification
4744                          // All IPv4 headers with TSO or UFO flag set
4745                          assign mod_ipv4_tl = ipv4 &amp;&amp; (al_tcp_hdr || al_udp_hdr);
4746                    
4747                          // Flag which heacders required IPv4 fragment offset and flags field modification
4748                          //  - all IPv4 headers with UFO flag set
4749                          assign mod_ipv4_fo = ipv4 &amp;&amp; al_udp_hdr;
4750                    
4751                          // Flag which heacders required IPv6 payload length field modification
4752                          //  - all IPv6 headers with TSO flag set
4753                          assign mod_ipv6_pl = ipv6 &amp;&amp; al_tcp_hdr;
4754                    
4755                    
4756                          // Clear TCP PSH and FIN flags
4757                          assign tcp_fl  = {tcp_fl_byte1_hdr[7:0], tcp_fl_byte0_hdr[7:4], 1'b0, tcp_fl_byte0_hdr[2:1], 1'b0};
4758                    
4759                          // Combine triggers and modify flags to create word-specific substitute strobes
4760                          //  - also create word-specific no-substitute signal where no modification is
4761                          //    required for any byte in the 32-bit word
4762                          assign sub_tcp_sn_byte1_0  = tcp_sn_byte1_0_trig &amp; {4{mod_tcp_sn}};
4763                          assign sub_tcp_sn_byte3_2  = tcp_sn_byte3_2_trig &amp; {4{mod_tcp_sn}};
4764                          assign sub_tcp_fl          = tcp_fl_trig         &amp; {4{mod_tcp_fl}};
4765                          assign sub_ipv4_tl         = ipv4_tl_trig        &amp; {4{mod_ipv4_tl}};
4766                          assign sub_ipv4_fo         = ipv4_fo_trig        &amp; {4{mod_ipv4_fo}};
4767                          assign sub_ipv6_pl         = ipv6_pl_trig        &amp; {4{mod_ipv6_pl}};
4768                    
4769                          assign no_sub = ~sub_tcp_sn_byte1_0  &amp;
4770                                    ~sub_tcp_sn_byte3_2  &amp;
4771                                    ~sub_tcp_fl          &amp;
4772                                    ~sub_ipv4_tl         &amp;
4773                                    ~sub_ipv4_fo         &amp;
4774                                    ~sub_ipv6_pl;
4775                    
4776                          //============================================================================
4777                          // Calculate IPv4 Total Length value
4778                          // Required for TSO and UFO
4779                          // Value includes the IP header and IP payload and is in bytes
4780                          // In the case of TSO:
4781                          //  = IP header + TCP header + TCP payload
4782                          //  = (header buffer length - ethernet header length) + payload buffer length
4783                          // In the case of UFO:
4784                          //  = IP header + IP fragment
4785                          //  = (header buffer length - ethernet header length) + payload buffer length
4786                          //============================================================================
4787                          assign ipv4_tl = {2'd0, al_hdr_len} - ((eth_hdr_len[9:0] &lt;&lt; 2) + 12'd2) + {2'd0, al_pyld_len};
4788                    
4789                    
4790                          //============================================================================
4791                          // Calculate IPv6 Payload Length value
4792                          // Required for TSO only
4793                          // Value includes the IPv6 extension headers and IP payload only and is in bytes
4794                          // In the case of TSO:
4795                          //  = (IPv6 extension headers + TCP header) + TCP payload
4796                          //  = (header buffer length - ethernet header length - main ipv6 header length) + payload buffer length
4797                          //============================================================================
4798                          assign ipv6_pl = {2'd0, al_hdr_len} - ((eth_hdr_len[9:0] &lt;&lt; 2) + 12'd2) - 14'd40 + {2'd0, al_pyld_len};
4799                    
4800                    
4801                          // Combine fragent offset and flags into 16-bit field
4802                          // MF flag is set for all headers apart from last, DF and RSVD flags are unmodified
4803                          assign ipv4_fo = al_last_hdr ? {ipv4_fo_byte1_hdr[7:5], ipv4_fo_cnt_pad[al_queue]} :
4804                                                     {ipv4_fo_byte1_hdr[7:6], 1'b1,  ipv4_fo_cnt_pad[al_queue]};
4805                    
4806                          always@(*)
4807                          begin
4808                            // Select sequence number counter for current header using stream and queue ID
4809                            case (al_tcp_st_id)
4810                              2'd0    : cur_seq_num_ctr = seq_num_st0_ctr_pad[al_queue];
4811                              2'd1    : cur_seq_num_ctr = seq_num_st1_ctr_pad[al_queue];
4812                              2'd2    : cur_seq_num_ctr = seq_num_st2_ctr_pad[al_queue];
4813                              default : cur_seq_num_ctr = seq_num_st3_ctr_pad[al_queue];
4814                            endcase
4815                          end
4816                    
4817                          always@(*)
4818                          begin
4819                            for (int_b = 0; int_b &lt; 4; int_b = int_b + 1)
4820                            begin
4821                              rdata_al_word = rdata_al[32*int_b +: 32];
4822                              rdata_hmod[32*int_b +: 32] = // Lower 16 bits of TCP sequence number
4823                                                           ({rdata_al_word[31:16],
4824                                                             cur_seq_num_ctr[7:0],
4825                                                             cur_seq_num_ctr[15:8]} &amp; {32{sub_tcp_sn_byte1_0[int_b]}}) |
4826                    
4827                                                           // Upper 16 bits of TCP sequence number
4828                                                           ({cur_seq_num_ctr[23:16],
4829                                                             cur_seq_num_ctr[31:24],
4830                                                             rdata_al_word[15:0]}   &amp; {32{sub_tcp_sn_byte3_2[int_b]}}) |
4831                    
4832                                                           // TCP flags
4833                                                           ({tcp_fl[7:0],
4834                                                             tcp_fl[15:8],
4835                                                             rdata_al_word[15:0]}   &amp; {32{sub_tcp_fl[int_b]}}) |
4836                    
4837                                                           // IPv4 Total Length
4838                                                           ({rdata_al_word[31:16],
4839                                                             ipv4_tl[7:0],
4840                                                             ipv4_tl[15:8]}         &amp; {32{sub_ipv4_tl[int_b]}}) |
4841                    
4842                                                           // IPv4 Fragment Offset and Flags
4843                                                           ({rdata_al_word[31:16],
4844                                                             ipv4_fo[7:0],
4845                                                             ipv4_fo[15:8]}         &amp; {32{sub_ipv4_fo[int_b]}}) |
4846                    
4847                                                           // IPv6 Payload Length
4848                                                           ({ipv6_pl[7:0],
4849                                                             ipv6_pl[15:8],
4850                                                             rdata_al_word[15:0]}   &amp; {32{sub_ipv6_pl[int_b]}}) |
4851                    
4852                                                           // No substitution
4853                                                           (rdata_al_word           &amp; {32{no_sub[int_b]}});
4854                            end
4855                          end
4856                    
4857                        end else begin : gen_no_lso_hm
4858                          always@(*)
4859                          begin
4860       1/1                  rdata_hmod = rdata_al[127:0];
4861                          end
4862                        end
4863                    
4864                        // Check and regenerate parity for rdata_hmod, can only really base on
4865                        // rdata_al as most other fields are not protected.
4866                        if (p_edma_asf_dap_prot == 1) begin : gen_rdata_hmod_par
4867                          gem_par_chk_regen #(.p_chk_dwid (128)) i_regen_rdata_hmod_par (
4868                            .odd_par  (1'b0),
4869                            .chk_dat  (rdata_al[127:0]),
4870                            .chk_par  (rdata_al_par[15:0]),
4871                            .new_dat  (rdata_hmod),
4872                            .dat_out  (),
4873                            .par_out  (rdata_hmod_par),
4874                            .chk_err  (dap_err_rdata_al)
4875                          );
4876                        end else begin : gen_no_rdata_hmod_par
4877                          assign rdata_hmod_par   = 16'h0000;
4878                          assign dap_err_rdata_al = 1'b0;
4879                        end
4880                    
4881                      endgenerate
4882                    
4883                    
4884                    
4885                      //============================================================================
4886                      // Separate writeback buffers for data, address and interrupt
4887                      // Separate buffers are required as pops are independent, although push is common
4888                      // All 3 buffers are pushed at the same time (when the writeback is accepted
4889                      // from the AHB DMA), but are popped independently
4890                      //   - address FIFO : when the address for the last AXI write of the writeback
4891                      //     is accepted by the AW channel
4892                      //   - data FIFO : when the data for the last AXI write of the writeback
4893                      //     is accepted by the W channel
4894                      // For TSO and UFO frames discard writebacks which bit 14 of word 1 set
4895                      //  - this bit is set for all generated frames apart from the last
4896                      //  - Therefore SW will only see the writeback for the last generated fram from
4897                      //    the large TCP or UDP frame
4898                      //============================================================================
4899                    
4900                      assign write_back_mask = |tx_descr_wr_data[51:49] &amp;&amp; tx_descr_wr_data[46];
4901                    
4902                    
4903                      // Clear fragmented packet status for checksum gen when UFO enabled
4904                      // AHB DMA warns that fragment was received, but this isexpected for UDP
4905                      // fragmentation so is not passed back to SW
4906                      always @ *
4907                      begin
4908                        // tx_descr_wr_data orginally contained the following busses ...
4909                        //  assign tx_descr_wr_data = { tx_timestamp,
4910                        //                              descriptor_wb_word1,
4911                        //                              status_word_rd_1}; // ie timestamp, bd word1, bd word0[31:0]
4912                        //
4913                        // Extract timestamp bits out to make life simpler ..
4914                        // Currently, we only protect the timestamp, which is the 42 bits ...
4915                        // i.e. parity in tx_descr_wr_ts_par protects tx_descr_wr_ts
4916       1/1              tx_timestamp       = tx_descr_wr_ts;
4917       1/1              tx_timestamp_par   = tx_descr_wr_ts_par;
4918                    
4919       1/1              if (tx_descr_wr_data[49] &amp;&amp; (tx_descr_wr_data[54:52] == 3'd5))
4920       <font color = "red">0/1     ==>        tx_descr_wr_data_clean = {tx_descr_wr_data[63:55],</font>
4921                                                    3'd0,
4922                                                    tx_descr_wr_data[51:0]};
4923                        else
4924       1/1                tx_descr_wr_data_clean = tx_descr_wr_data[63:0];
4925                      end
4926                    
4927                      // Special case to cope with status that doesnt require a writeback ..
4928                      wire dma_ignore_wb;
4929                      assign dma_ignore_wb = {tx_descr_wr_sts[9:5],tx_descr_wr_sts[0]} == 6'b000010;
4930                    
4931                      // If writeback is to be discarded don't care about FIFO status
4932                      always @(*)
4933                      begin
4934       1/1              if (flush_tx_wr_fifos)
4935       <font color = "red">0/1     ==>        tx_descr_wr_rdy = 1'b0;</font>
4936                    
4937                        // special case to cope with status that doesnt require a writeback ..
4938       1/1              else if (dma_ignore_wb &amp;&amp; !wb_int_fifo_empty)
4939       <font color = "red">0/1     ==>        tx_descr_wr_rdy = 1'b0;</font>
4940                    
4941                        else
4942       1/1                tx_descr_wr_rdy =     write_back_mask ||
4943                                                (~wb_addr_fifo_full &amp;&amp; ~wb_data_fifo_full &amp;&amp; ~wb_int_fifo_full) ||
4944                                                (wb_int_fifo_empty &amp;&amp; dma_ignore_wb);
4945                      end
4946                    
4947                      assign wb_fifo_push = tx_descr_wr_vld &amp;&amp; tx_descr_wr_rdy &amp;&amp; ~write_back_mask &amp;&amp; !dma_ignore_wb;
4948                    
4949                      assign wb_data_fifo_pop = wrv_descr &amp;&amp; (w_tx_descr_cnt == (tx_descr_writebacks_num-2'd1));
4950                    
4951                      assign wb_int_fifo_pop  = brv_descr;
4952                    
4953                      // Writeback address buffer
4954                    
4955                      // Assign lower 32-bits of the address. the parity bits are
4956                      // assigned later.
4957                      assign tx_descr_wb_addr[31:0] = tx_descr_wr_data_clean[31:0];
4958                    
4959                      edma_gen_fifo #(
4960                        .FIFO_WIDTH       (p_awid_par+4),
4961                        .FIFO_DEPTH       (p_axi_tx_descr_wr_buff_depth),
4962                        .FIFO_ADDR_WIDTH  (p_axi_tx_descr_wr_buff_bits)
4963                      ) i_tx_descr_wr_add_fifo (
4964                        .qout       ({aw_queue_descr, wb_addr_fifo_out}),
4965                        .qempty     (wb_addr_fifo_empty),
4966                        .qfull      (wb_addr_fifo_full),
4967                        .qlevel     (),
4968                        .clk_pcie   (aclk),
4969                        .rst_n      (n_areset),
4970                    
4971                        .din        ({tx_descr_wr_sts[4:1],tx_descr_wb_addr}),
4972                        .push       (wb_fifo_push),
4973                        .flush      ((~enable_tx || flush_tx_wr_fifos) &amp;&amp; ~(awvalid_descr &amp;&amp; ~awready_descr)),
4974                        .pop        (wb_addr_fifo_pop)
4975                      );
4976                    
4977                      // Writeback data buffer
4978                      // Work out how many bits are required for the writeback buffer. This buffer stores the writeback data and
4979                      // optional timestamp value. If p_edma_asf_dap_prot is set to 1 then these buses will also have parity.
4980                      localparam p_wb_data_bits  = (p_edma_asf_dap_prot == 1)  ? 36  : 32;
4981                      localparam p_wb_ts_bits    = (p_edma_asf_dap_prot == 1)  ? 48  : 42;
4982                      localparam p_wb_buffer_wid = (p_edma_tsu == 1)           ? p_wb_data_bits + p_wb_ts_bits
4983                                                                              : p_wb_data_bits;
4984                    
4985                      wire  [p_wb_buffer_wid-1:0] wb_data_fifo_in, wb_data_fifo_out;
4986                    
4987                      // Bottom data bits always exists
4988                      assign wb_data_fifo_in[31:0]  = tx_descr_wr_data_clean[63:32];
4989                      assign wb_data                = wb_data_fifo_out[31:0];
4990                    
4991                      generate // The optional bits
4992                    
4993                      // Parity bits for wb_data
4994                      if (p_edma_asf_dap_prot == 1) begin : gen_par
4995                        assign wb_data_fifo_in[35:32] = tx_descr_wr_data_par_clean[7:4];
4996                        assign wb_data_par  = wb_data_fifo_out[35:32];
4997                      end else begin : gen_no_par
4998                        assign wb_data_par  = 4'd0;
4999                      end
5000                    
5001                      // Timestamp bits
5002                      if (p_edma_tsu == 1) begin : gen_wb_timestamp
5003                        assign wb_data_fifo_in[p_wb_data_bits+41:p_wb_data_bits]  = tx_timestamp;
5004                        assign wb_timestamp = wb_data_fifo_out[p_wb_data_bits+41:p_wb_data_bits];
5005                        if (p_edma_asf_dap_prot == 1) begin : gen_par
5006                          assign wb_data_fifo_in[p_wb_data_bits+47:p_wb_data_bits+42] = tx_timestamp_par;
5007                          assign wb_timestamp_par = wb_data_fifo_out[p_wb_data_bits+47:p_wb_data_bits+42];
5008                        end else begin : gen_no_par
5009                          assign wb_timestamp_par = 6'd0;
5010                        end
5011                      end else begin : gen_no_wb_timestamp
5012                        assign wb_timestamp     = {42{1'b0}};
5013                        assign wb_timestamp_par = 6'd0;
5014                      end
5015                      endgenerate
5016                    
5017                      edma_gen_fifo #(
5018                        .FIFO_WIDTH       (p_wb_buffer_wid),
5019                        .FIFO_DEPTH       (p_axi_tx_descr_wr_buff_depth),
5020                        .FIFO_ADDR_WIDTH  (p_axi_tx_descr_wr_buff_bits)
5021                      ) i_tx_descr_wr_dat_fifo (
5022                        .qout       (wb_data_fifo_out),
5023                        .qempty     (),
5024                        .qfull      (wb_data_fifo_full),
5025                        .qlevel     (),
5026                        .clk_pcie   (aclk),
5027                        .rst_n      (n_areset),
5028                    
5029                        .din        (wb_data_fifo_in),
5030                        .push       (wb_fifo_push),
5031                        .flush      ((~enable_tx || flush_tx_wr_fifos) &amp;&amp; ~(wvalid_descr &amp;&amp; ~wready_descr)),
5032                        .pop        (wb_data_fifo_pop)
5033                      );
5034                    
5035                      // Writeback interrupt buffer
5036                      edma_gen_fifo #(
5037                        .FIFO_WIDTH       (10),
5038                        .FIFO_DEPTH       (p_axi_tx_descr_wr_buff_depth),
5039                        .FIFO_ADDR_WIDTH  (p_axi_tx_descr_wr_buff_bits)
5040                      ) i_tx_descr_wr_int_fifo (
5041                        .qout       (wb_int_fifo_out),
5042                        .qempty     (wb_int_fifo_empty),
5043                        .qfull      (wb_int_fifo_full),
5044                        .qlevel     (wb_int_fifo_fill), // NOTE: This is probed inside tb_sv_coverage, so cannot be deleted even though this is not used in the design
5045                        .clk_pcie   (aclk),
5046                        .rst_n      (n_areset),
5047                    
5048                        .din        (wb_int_fifo_in),
5049                        .push       (wb_fifo_push),
5050                        .flush      (~enable_tx || flush_tx_wr_fifos),
5051                        .pop        (wb_int_fifo_pop)
5052                      );
5053                    
5054                    
5055                      //===================================================================================
5056                      // Determine how many AXI writes are required for a descriptor writeback based on
5057                      // extended descriptors, 32/64 bit addressing and data bus width.
5058                      // Also drive writeback data based on the current count.
5059                      // 1 descriptor word must be written for normal descriptors, 3 for extended
5060                      // Address of timestamp words change for 64 vs 32 bit addressing
5061                      //===================================================================================
5062                      always @ *
5063                      begin
5064       1/1              awlen_descr       = 8'h00;
5065                    
5066       1/1              if (~tx_extended_bd_mode_en)
5067                        begin
5068                          // Note in extended buffer descriptor mode - write 1 descriptor word
5069       1/1                tx_descr_writebacks_num = 2'd1;
5070       1/1                wdata_int         = {4{wb_data}};
5071       1/1                wdata_par_int     = {4{wb_data_par}};
5072       1/1                awsize_descr      = 3'h2;
5073       1/1                wb_addr_fifo_op   = 33'd0;
5074                        end
5075                        else
5076                          // In extended buffer descriptor mode - write 3 descriptor words
5077       1/1                case ({addressing_64b, dma_bus_width})
5078                    
5079                            3'b0_00 : // extended buffer descriptor, 32-bit addressing, 32-bit data bus
5080                            begin
5081       1/1                    tx_descr_writebacks_num = 2'd3;
5082       1/1                    case (w_tx_descr_cnt)
5083                                2'd0 :
5084                                begin
5085       1/1                        wdata_int     = {4{22'd0, wb_timestamp[41:32]}};  // Timestamp (upper 10 bits)
5086       1/1                        wdata_par_int = {4{2'b00,wb_timestamp_par[5:4]}};
5087                                end
5088                                2'd1 :
5089                                begin
5090       <font color = "red">0/1     ==>                wdata_int     = {4{wb_timestamp[31:0]}};          // Timestamp (lower 32 bits)</font>
5091       <font color = "red">0/1     ==>                wdata_par_int = {4{wb_timestamp_par[3:0]}};</font>
5092                                end
5093                                default :
5094                                begin
5095       1/1                        wdata_int     = {4{wb_data[31:0]}};
5096       1/1                        wdata_par_int = {4{wb_data_par}};
5097                                end
5098                              endcase
5099                    
5100       1/1                    case (aw_tx_descr_cnt_r)
5101                                2'd0 :
5102                                begin
5103       1/1                        wb_addr_fifo_op    = 33'h100000008;
5104       1/1                        awsize_descr       = 3'h2;
5105                                end
5106                                2'd1 :
5107                                begin
5108       <font color = "red">0/1     ==>                wb_addr_fifo_op    = 33'h100000004;</font>
5109       <font color = "red">0/1     ==>                awsize_descr       = 3'h2;</font>
5110                                end
5111                                default :
5112                                begin
5113       1/1                        wb_addr_fifo_op    = 33'h000000000;
5114       1/1                        awsize_descr       = 3'h2;
5115                                end
5116                              endcase
5117                    
5118                            end
5119                    
5120                            3'b0_01 : // extended buffer descriptor, 32-bit addressing, 64-bit data bus
5121                            begin
5122       <font color = "red">0/1     ==>            tx_descr_writebacks_num = 2'd2;</font>
5123       <font color = "red">0/1     ==>            case (w_tx_descr_cnt)</font>
5124                                2'd0 :
5125                                begin
5126       <font color = "red">0/1     ==>                wdata_int     = {2{22'd0,wb_timestamp[41:0]}};  // Timestamp (42 bits) padded to 64bits</font>
5127       <font color = "red">0/1     ==>                wdata_par_int = {2{2'b00,wb_timestamp_par}};</font>
5128                                end
5129                                default :
5130                                begin
5131       <font color = "red">0/1     ==>                wdata_int     = {4{wb_data[31:0]}};</font>
5132       <font color = "red">0/1     ==>                wdata_par_int = {4{wb_data_par}};</font>
5133                                end
5134                              endcase
5135                    
5136       <font color = "red">0/1     ==>            case (aw_tx_descr_cnt_r)</font>
5137                                2'd0 :
5138                                begin
5139       <font color = "red">0/1     ==>                wb_addr_fifo_op    = 33'h100000004;</font>
5140       <font color = "red">0/1     ==>                awsize_descr       = 3'h3;</font>
5141                                end
5142                                default :
5143                                begin
5144       <font color = "red">0/1     ==>                wb_addr_fifo_op    = 33'h000000000;</font>
5145       <font color = "red">0/1     ==>                awsize_descr       = 3'h2;</font>
5146                                end
5147                              endcase
5148                    
5149                            end
5150                    
5151                            3'b0_10, 3'b0_11 : // extended buffer descriptor, 32-bit addressing, 128-bit data bus
5152                            begin
5153       <font color = "red">0/1     ==>            tx_descr_writebacks_num = 2'd1;</font>
5154       <font color = "red">0/1     ==>            wdata_int       = {22'd0, wb_timestamp, // Timestamp 64bits</font>
5155                                                wb_data[31:0],32'd0   // Writeback data
5156                                                };
5157       <font color = "red">0/1     ==>            wdata_par_int   = {2'b00,wb_timestamp_par,wb_data_par,4'd0};</font>
5158       <font color = "red">0/1     ==>            wb_addr_fifo_op = 33'h000000004;</font>
5159       <font color = "red">0/1     ==>            awsize_descr    = 3'h4;</font>
5160                    
5161                            end
5162                    
5163                            3'b1_00 : // extended buffer descriptor, 64-bit addressing, 32-bit data bus
5164                            begin
5165       <font color = "red">0/1     ==>            tx_descr_writebacks_num = 2'd3;</font>
5166       <font color = "red">0/1     ==>            case (w_tx_descr_cnt)</font>
5167                                2'd0 :
5168                                begin
5169       <font color = "red">0/1     ==>                wdata_int     = {4{22'd0, wb_timestamp[41:32]}};  // Timestamp (upper 10 bits)</font>
5170       <font color = "red">0/1     ==>                wdata_par_int = {4{2'b00,wb_timestamp_par[5:4]}};</font>
5171                                end
5172                                2'd1 :
5173                                begin
5174       <font color = "red">0/1     ==>                wdata_int     = {4{wb_timestamp[31:0]}};          // Timestamp (lower 32 bits)</font>
5175       <font color = "red">0/1     ==>                wdata_par_int = {4{wb_timestamp_par[3:0]}};</font>
5176                                end
5177                                default :
5178                                begin
5179       <font color = "red">0/1     ==>                wdata_int     = {4{wb_data[31:0]}};</font>
5180       <font color = "red">0/1     ==>                wdata_par_int = {4{wb_data_par}};</font>
5181                                end
5182                              endcase
5183                    
5184       <font color = "red">0/1     ==>            case (aw_tx_descr_cnt_r)</font>
5185                                2'd0    :
5186                                begin
5187       <font color = "red">0/1     ==>                wb_addr_fifo_op    = 33'h100000010;</font>
5188       <font color = "red">0/1     ==>                awsize_descr       = 3'h2;</font>
5189                                end
5190                                2'd1    :
5191                                begin
5192       <font color = "red">0/1     ==>                wb_addr_fifo_op    = 33'h10000000c;</font>
5193       <font color = "red">0/1     ==>                awsize_descr       = 3'h2;</font>
5194                                end
5195                                default :
5196                                begin
5197       <font color = "red">0/1     ==>                wb_addr_fifo_op    = 33'h000000000;</font>
5198       <font color = "red">0/1     ==>                awsize_descr       = 3'h2;</font>
5199                                end
5200                              endcase
5201                    
5202                            end
5203                    
5204                            3'b1_01 : // extended buffer descriptor, 64-bit addressing, 64-bit data bus
5205                            begin
5206       <font color = "red">0/1     ==>            tx_descr_writebacks_num = 2'd2;</font>
5207       <font color = "red">0/1     ==>            case (w_tx_descr_cnt)</font>
5208                                2'd0 :
5209                                begin
5210       <font color = "red">0/1     ==>                wdata_int     = {2{22'd0,wb_timestamp[41:0]}};  // Timestamp (42 bits) padded to 64bits</font>
5211       <font color = "red">0/1     ==>                wdata_par_int = {2{2'b00,wb_timestamp_par}};</font>
5212                                end
5213                                default :
5214                                begin
5215       <font color = "red">0/1     ==>                wdata_int     = {4{wb_data[31:0]}};</font>
5216       <font color = "red">0/1     ==>                wdata_par_int = {4{wb_data_par}};</font>
5217                                end
5218                              endcase
5219                    
5220       <font color = "red">0/1     ==>            case (aw_tx_descr_cnt_r)</font>
5221                                2'd0    :
5222                                begin
5223       <font color = "red">0/1     ==>                wb_addr_fifo_op    = 33'h10000000c;</font>
5224       <font color = "red">0/1     ==>                awsize_descr       = 3'h3;</font>
5225                                end
5226                                default :
5227                                begin
5228       <font color = "red">0/1     ==>                wb_addr_fifo_op    = 33'h000000000;</font>
5229       <font color = "red">0/1     ==>                awsize_descr       = 3'h2;</font>
5230                                end
5231                              endcase
5232                            end
5233                    
5234                            default : // extended buffer descriptor, 64-bit addressing, 128-bit data bus
5235                            begin  // 3'b1_10
5236       <font color = "red">0/1     ==>            tx_descr_writebacks_num = 2'd2;</font>
5237       <font color = "red">0/1     ==>            case (w_tx_descr_cnt)</font>
5238                                2'd0 :
5239                                begin
5240       <font color = "red">0/1     ==>                wdata_int     = {2{22'd0,wb_timestamp[41:0]}};  // Timestamp (42 bits) padded to 64bits</font>
5241       <font color = "red">0/1     ==>                wdata_par_int = {2{2'b00,wb_timestamp_par}};</font>
5242                                end
5243                                default :
5244                                begin
5245       <font color = "red">0/1     ==>                wdata_int     = {4{wb_data[31:0]}};</font>
5246       <font color = "red">0/1     ==>                wdata_par_int = {4{wb_data_par}};</font>
5247                                end
5248                              endcase
5249                    
5250       <font color = "red">0/1     ==>            case (aw_tx_descr_cnt_r)</font>
5251                                2'd0    :
5252                                begin
5253       <font color = "red">0/1     ==>                wb_addr_fifo_op    = 33'h10000000c;</font>
5254       <font color = "red">0/1     ==>                awsize_descr       = 3'h3;</font>
5255                                end
5256                                default :
5257                                begin
5258       <font color = "red">0/1     ==>                wb_addr_fifo_op    = 33'h000000000;</font>
5259       <font color = "red">0/1     ==>                awsize_descr       = 3'h2;</font>
5260                                end
5261                              endcase
5262                            end
5263                    
5264                          endcase
5265                      end
5266                      assign awaddr_descr[63:32]    = addressing_64b ? upper_tx_q_base_addr : 32'd0;
5267                      assign awaddr_descr_par[7:4]  = (addressing_64b &amp;&amp; (p_edma_asf_dap_prot &gt; 0)) ? upper_tx_q_base_par : 4'h0;
5268                    
5269                      // The lower address is sum of wb_addr_fifo_out[31:0] and wb_addr_fifo_op.
5270                      // Note that if there was no parity, the in_par to the following module isn't really valid
5271                      // but will be ignored anyway.
5272                      edma_arith_par #(
5273                        .p_dwidth (32),
5274                        .p_pwidth (4),
5275                        .p_has_par(p_edma_asf_dap_prot)
5276                      ) i_arith_awaddr_descr (
5277                        .in_val (wb_addr_fifo_out[31:0]),
5278                        .in_par (wb_addr_fifo_out[p_awid_par-1:p_awid_par-4]),
5279                        .op_val (wb_addr_fifo_op[31:0]),
5280                        .op_add (wb_addr_fifo_op[32]),
5281                        .out_val(awaddr_descr[31:0]),
5282                        .out_par(awaddr_descr_par[3:0])
5283                      );
5284                    
5285                      //Swizzle writeback wdata for endian swap
5286                      always @ *
5287                      begin
5288       1/1              if (endian_swap[0])
5289       <font color = "red">0/1     ==>        case (dma_bus_width)</font>
5290                    
5291                            2'b00 : // 32-bit
5292                            begin
5293       <font color = "red">0/1     ==>            wdata_descr     = {96'd0,</font>
5294                                                  wdata_int[7:0],   wdata_int[15:8],
5295                                                  wdata_int[23:16], wdata_int[31:24]};
5296       <font color = "red">0/1     ==>            wdata_descr_par = {12'h000,</font>
5297                                                  wdata_par_int[0], wdata_par_int[1],
5298                                                  wdata_par_int[2], wdata_par_int[3]};
5299                            end
5300                            2'b01 : // 64-bit
5301                            begin
5302       <font color = "red">0/1     ==>            wdata_descr     = {64'd0,</font>
5303                                                  wdata_int[7:0],   wdata_int[15:8],
5304                                                  wdata_int[23:16], wdata_int[31:24],
5305                                                  wdata_int[39:32], wdata_int[47:40],
5306                                                  wdata_int[55:48], wdata_int[63:56]};
5307       <font color = "red">0/1     ==>            wdata_descr_par = {8'h00,</font>
5308                                                  wdata_par_int[0], wdata_par_int[1],
5309                                                  wdata_par_int[2], wdata_par_int[3],
5310                                                  wdata_par_int[4], wdata_par_int[5],
5311                                                  wdata_par_int[6], wdata_par_int[7]};
5312                            end
5313                            default : // 128-bit
5314                            begin
5315       <font color = "red">0/1     ==>            wdata_descr     = { wdata_int[7:0],     wdata_int[15:8],</font>
5316                                                  wdata_int[23:16],   wdata_int[31:24],
5317                                                  wdata_int[39:32],   wdata_int[47:40],
5318                                                  wdata_int[55:48],   wdata_int[63:56],
5319                                                  wdata_int[71:64],   wdata_int[79:72],
5320                                                  wdata_int[87:80],   wdata_int[95:88],
5321                                                  wdata_int[103:96],  wdata_int[111:104],
5322                                                  wdata_int[119:112], wdata_int[127:120]};
5323       <font color = "red">0/1     ==>            wdata_descr_par = { wdata_par_int[0],   wdata_par_int[1],</font>
5324                                                  wdata_par_int[2],   wdata_par_int[3],
5325                                                  wdata_par_int[4],   wdata_par_int[5],
5326                                                  wdata_par_int[6],   wdata_par_int[7],
5327                                                  wdata_par_int[8],   wdata_par_int[9],
5328                                                  wdata_par_int[10],  wdata_par_int[11],
5329                                                  wdata_par_int[12],  wdata_par_int[13],
5330                                                  wdata_par_int[14],  wdata_par_int[15]};
5331                            end
5332                          endcase
5333                        else
5334                        begin
5335       1/1                wdata_descr     = wdata_int;
5336       1/1                wdata_descr_par = wdata_par_int;
5337                        end
5338                      end
5339                    
5340                      assign wlast_descr = 1'b1;
5341                    
5342                      // Registered state members
5343                      always @ (posedge aclk or negedge n_areset)
5344                      begin
5345       1/1              if (~n_areset)
5346       1/1                aw_tx_descr_cnt_r &lt;= 2'b00;
5347                        else
5348       1/1                if ((~enable_tx || flush_tx_wr_fifos) &amp;&amp; ~(awvalid_descr &amp;&amp; ~awready_descr))
5349       1/1                  aw_tx_descr_cnt_r &lt;= 2'b00;
5350                          else
5351       1/1                  aw_tx_descr_cnt_r &lt;= aw_tx_descr_cnt;
5352                      end
5353                    
5354                      always @ (posedge aclk or negedge n_areset)
5355                      begin
5356       1/1              if (~n_areset)
5357       1/1                w_tx_descr_cnt    &lt;= 2'b00;
5358                        else
5359       1/1                if ((~enable_tx || flush_tx_wr_fifos) &amp;&amp; ~(wvalid_descr &amp;&amp; ~wready_descr))
5360       1/1                  w_tx_descr_cnt    &lt;= 2'b00;
5361                          else
5362       1/1                  if (tx_extended_bd_mode_en)
5363                            begin
5364       <font color = "red">0/1     ==>            if (wrv_descr)</font>
5365                              begin
5366       <font color = "red">0/1     ==>              if (w_tx_descr_cnt == (tx_descr_writebacks_num-2'd1))</font>
5367       <font color = "red">0/1     ==>                w_tx_descr_cnt &lt;= 2'b00;</font>
5368                                else
5369       <font color = "red">0/1     ==>                w_tx_descr_cnt &lt;= w_tx_descr_cnt + 2'b01;</font>
5370                              end
                   <font color = "red">==>  MISSING_ELSE</font>
5371                            end
5372                            else
5373       1/1                    w_tx_descr_cnt &lt;= 2'b00;
5374                      end
5375                    
5376                    
5377                      // Generate pop for the writeback address FIFO
5378                      always @ *
5379                      begin
5380                        // Add defaults to reduce codebase and keep it tidy
5381       1/1              wb_addr_fifo_pop  = 1'b0;
5382       1/1              aw_tx_descr_cnt   = aw_tx_descr_cnt_r;
5383                    
5384                        // Count how many aw access have occurred and pop on the last aw access.
5385       1/1              if (awrv_descr)
5386                        begin
5387       1/1                wb_addr_fifo_pop = (aw_tx_descr_cnt_r == (tx_descr_writebacks_num-2'd1));
5388       1/1                if (aw_tx_descr_cnt == (tx_descr_writebacks_num-2'd1))
5389       1/1                  aw_tx_descr_cnt  = 2'b00;
5390                          else
5391       <font color = "red">0/1     ==>          aw_tx_descr_cnt  = aw_tx_descr_cnt_r + 2'b01;</font>
5392                        end
                        MISSING_ELSE
5393                    
5394                      end
5395                    
5396                    
5397                      // Writeback signals to AXI arbiter
5398                      assign awvalid_descr = ~wb_addr_fifo_empty;
5399                    
5400                    
5401                      // TX Interrupt Generation
5402                      // The signal &quot;tx_descr_wr_vld &amp;&amp; tx_descr_wr_rdy&quot; is set to validate the DMA interrupt signals
5403                      // If tx_descr_wr_vld &amp;&amp; tx_descr_wr_rdy is set together with the dataphase of a descriptor write, then we buffer
5404                      // the interrupt details into the TX descriptor write buffer.  Further interrupts signalled
5405                      // when we are not writing to the buffer are sampled and stored locally. When the AXI writeback
5406                      // has completed, the buffer is popped and we can issue all the interrupts
5407                    
5408                    
5409                      assign wb_int_fifo_in = {tx_descr_wr_sts[9:5],tx_descr_wr_sts[0],tx_descr_wr_sts[4:1]};
5410                    
5411                      always @(*)
5412                      begin
5413       1/1              if (wb_int_fifo_empty &amp;&amp; tx_descr_wr_vld &amp;&amp; {tx_descr_wr_sts[9:5],tx_descr_wr_sts[0]} == 6'b000010)
5414                        begin
5415       <font color = "red">0/1     ==>        reflected_tx_sts_vld = tx_descr_wr_vld;</font>
5416       <font color = "red">0/1     ==>        reflected_tx_sts     = tx_descr_wr_sts;</font>
5417                        end
5418                        else
5419                        begin
5420       1/1                reflected_tx_sts_vld = wb_int_fifo_pop;
5421       1/1                reflected_tx_sts     = {wb_int_fifo_out[9:5],wb_int_fifo_out[3:0],wb_int_fifo_out[4]};
5422                        end
5423                      end
5424                    
5425                      // Handling AXI BRESP/RRESP errors
5426                      // Simply pass to gem_registers, signal an interrupt and disable RX / TX
5427                      // Do not forward to AHB
5428                      always @ (posedge aclk or negedge n_areset)
5429                      begin
5430       1/1              if  (~n_areset)
5431       1/1                disable_tx    &lt;= 1'b0;
5432                        else
5433       1/1                if (~enable_tx)
5434       1/1                  disable_tx  &lt;= 1'b0;
5435                          else
5436       1/1                  disable_tx  &lt;= disable_tx ||
</pre>
</div>
<div class="ui-layout-south">
<table align=center><tr><td class="s0 cl">0%</td>
<td class="s1 cl">10%</td>
<td class="s2 cl">20%</td>
<td class="s3 cl">30%</td>
<td class="s4 cl">40%</td>
<td class="s5 cl">50%</td>
<td class="s6 cl">60%</td>
<td class="s7 cl">70%</td>
<td class="s8 cl">80%</td>
<td class="s9 cl">90%</td>
<td class="s10 cl">100%</td></tr></table></div>
</body>
</html>
