<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="Author" content="<username>"> <meta name="GENERATOR" content="urg/version [en] (platform name) [urg]">
<title>Unified Coverage Report :: Module :: edma_pbuf_axi_fe_desc_buff</title>
<link type="text/css" rel="stylesheet" href="css/.urg.css">
<link type="text/css" rel="stylesheet" href="css/.layout.css">
<link type="text/css" rel="stylesheet" href="css/.breadcrumb.css">
<script type="text/javascript" src="js/.jquery.js"></script>
<script type="text/javascript" src="js/.jquery-ui.js"></script>
<script type="text/javascript" src="js/.sortable.js"></script>
<script type="text/javascript" src="js/.layout.js"></script>
<script type="text/javascript" src="js/.breadcrumb.js"></script>
<script type="text/javascript">
var layout, westLayout, centerLayout;
$(document).ready(function () {
  if ($("#north-bread-crumb")) {
    $("#north-bread-crumb").jBreadCrumb({easing:'swing'})
  }
  layout = $("body").layout({ 
    resizable: true,
    spacing_open: 4,
    spacing_closed: 4,
    north: {
      size: 76
    },
    south: {
      size: 45,
      initClosed: true
    },
    west: {
      size: 500,
      resizable: true,
      initClosed: false
    }
  });
  centerLayout = $('div.ui-layout-center').layout({
    north__paneSelector: ".ui-layout-center-inner-north",
    center__paneSelector: ".ui-layout-center-inner-center", 
    north__size: 50,
    spacing_open: 4,
    spacing_closed: 4
  });
});
</script>
</head>
<body onLoad="initPage();"><div class="ui-layout-north">
<div class="logo"></div>
<center class="pagetitle">Module Definition</center>
<div align="center"><a href="dashboard.html" ><b>dashboard</b></a> | <a href="hierarchy.html" ><b>hierarchy</b></a> | <a href="modlist.html" ><b>modlist</b></a> | groups | <a href="tests.html" ><b>tests</b></a> | <a href="asserts.html" ><b>asserts</b></a></div>

</div>
<div class="ui-layout-west">
<div name='tag_edma_pbuf_axi_fe_desc_buff'>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module : <a href="#"  onclick="showContent('tag_edma_pbuf_axi_fe_desc_buff')">edma_pbuf_axi_fe_desc_buff</a></span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s4 cl rt"> 40.43</td>
<td class="s5 cl rt"><a href="mod534.html#Line" > 59.41</a></td>
<td class="s2 cl rt"><a href="mod534.html#Cond" > 25.96</a></td>
<td class="s2 cl rt"><a href="mod534.html#Toggle" > 20.98</a></td>
<td class="wht cl rt"></td>
<td class="s5 cl rt"><a href="mod534.html#Branch" > 55.36</a></td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<span class=repname>Source File(s) : </span>
<br clear=all>
<a href="javascript:void(0);"  onclick="openSrcFile('/nfs_project/gemini/DV/nadeem/dv/night_reg/gemini/design/ip/GbE/hdl/edma_pbuf_axi_fe_desc_buff.v')">/nfs_project/gemini/DV/nadeem/dv/night_reg/gemini/design/ip/GbE/hdl/edma_pbuf_axi_fe_desc_buff.v</a><br clear=all>
<br clear=all>
<span class=repname>Module self-instances :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="wht cl wordwrap"><a href="mod534.html#inst_tag_38558"  onclick="showContent('inst_tag_38558')">config_ss_tb.DUT.config_ss.gbe_u.gem_top_u.i_gem_ss.i_gem_top.gen_dma.gen_pbuf_axi_dma.i_edma_pbuf_axi_top.i_edma_pbuf_axi_fe.i_edma_pbuf_axi_fe_tx.tx_descr_buff[0].i_tx_descr_buff<img src="fx.gif" class="icon"></a></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
</tr></table></div>
</div>
<br clear=all>
</div>
<div class="ui-layout-center">
<div class="ui-layout-center-inner-center">
<div name='tag_edma_pbuf_axi_fe_desc_buff'>
<a name="Line"></a>
Line Coverage for Module : <a href="mod534.html" >edma_pbuf_axi_fe_desc_buff</a><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s5"><td class="lf">TOTAL</td><td></td><td>101</td><td>60</td><td>59.41</td></tr>
<tr class="s8"><td class="lf">ALWAYS</td><td>270</td><td>9</td><td>8</td><td>88.89</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>344</td><td>1</td><td>1</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>360</td><td>5</td><td>5</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>516</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s6"><td class="lf">ALWAYS</td><td>611</td><td>5</td><td>3</td><td>60.00</td></tr>
<tr class="s2"><td class="lf">ALWAYS</td><td>664</td><td>25</td><td>7</td><td>28.00</td></tr>
<tr class="s6"><td class="lf">ALWAYS</td><td>716</td><td>3</td><td>2</td><td>66.67</td></tr>
<tr class="s4"><td class="lf">ALWAYS</td><td>752</td><td>7</td><td>3</td><td>42.86</td></tr>
<tr class="s6"><td class="lf">ALWAYS</td><td>779</td><td>3</td><td>2</td><td>66.67</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>828</td><td>1</td><td>1</td><td>100.00</td></tr>
<tr class="s7"><td class="lf">ALWAYS</td><td>834</td><td>9</td><td>7</td><td>77.78</td></tr>
<tr class="s6"><td class="lf">ALWAYS</td><td>863</td><td>3</td><td>2</td><td>66.67</td></tr>
<tr class="s3"><td class="lf">ALWAYS</td><td>949</td><td>6</td><td>2</td><td>33.33</td></tr>
<tr class="s4"><td class="lf">ALWAYS</td><td>967</td><td>10</td><td>4</td><td>40.00</td></tr>
<tr class="s9"><td class="lf">ALWAYS</td><td>998</td><td>10</td><td>9</td><td>90.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1047</td><td>1</td><td>1</td><td>100.00</td></tr>
</table>
<pre class="code"><br clear=all>
269                       begin
270        1/1              if (~n_areset)
271        1/1                db1_fill &lt;= {p_axi_tx_descr_rd_buff_bits+1{1'b0}};
272                         else
273                         begin
274        1/1                if (~enable_tx)
275        1/1                  db1_fill &lt;= {p_axi_tx_descr_rd_buff_bits+1{1'b0}};
276                           else
277        1/1                  case ({inc1_db1_fill, dec1_db1_fill, dec2_db1_fill})
278                     
279                               3'b100 : // inc1 only: increment by 1
280        1/1                      db1_fill &lt;= db1_fill_p1[p_axi_tx_descr_rd_buff_bits:0];
281                     
282                               3'b010, 3'b101 : // dec1 only, or inc1 and dec2: decrement by 1
283        1/1                      db1_fill &lt;= db1_fill - db1_fill_one;
284                     
285                               3'b001 : // dec2 only: decrement by 2
286        <font color = "red">0/1     ==>              db1_fill &lt;= db1_fill - db1_fill_two;</font>
287                     
288                               default : // inc1 and dec1, or no activity: no change
289        1/1                      db1_fill &lt;= db1_fill;
290                     
291                             endcase
292                         end
293                       end
294                     
295                       // Generate full flag from top bit of calculated fill value
296                       // The MAC can hold a maximum of 256 packets in the buffers. We need to make sure we
297                       // don't get near this value otherwise there is potential for some AXI fabrics to stall
298                       // due to GEM not being able to accept any more descriptor data.
299                       // Just look at top 2-bits so set full if 128+64 packets in GEM. This will only occur if
300                       // the SRAM is at least 16KBytes and we see a constant stream of minimum sized packets.
301                       assign db1_full = db1_fill[p_axi_tx_descr_rd_buff_bits] | (&amp;num_pkts_in_buf[7:6]);
302                     
303                     
304                       // ======================================================================================
305                       // Descriptor Generator Logic
306                       // ======================================================================================
307                     
308                       // Decode various bits of descriptor in primary buffer
309                       assign db1_out_last_bit     = db1_out[47];
310                       assign db1_out_used_bit     = db1_out[63];
311                       assign db1_out_tso_bit      = db1_out[50];
312                       assign db1_out_ufo_bit      = (db1_out[50:49] == 2'b01);
313                     
314                       // Validate TSO and UFO enable bits
315                       // Only valid if p_edma_lso parameter is set
316                       // Only valid if descriptor is the first descriptor of the frame i.e. the header descriptor
317                       // Ignore bit if descriptor length field is empty
318                       // Ignore bit if last bit is set - TSO/UFO requires a separate payload descriptor
319                       assign db1_out_tso_en = db1_out_tso_bit     &amp;&amp; (p_edma_lso == 1) &amp;&amp;
320                                               ~db1_empty          &amp;&amp; ~db1_out_used_bit &amp;&amp;
321                                               db1_out_first_descr &amp;&amp; ~db1_out_last_bit;
322                     
323                       assign db1_out_ufo_en = db1_out_ufo_bit     &amp;&amp; (p_edma_lso == 1) &amp;&amp;
324                                               ~db1_empty          &amp;&amp; ~db1_out_used_bit &amp;&amp;
325                                               db1_out_first_descr &amp;&amp; ~db1_out_last_bit;
326                     
327                       // Indicate when the descriptor in the primary buffer is the first descriptor
328                       // of software supplied frame
329                       generate if (p_edma_lso == 1'b1) begin : gen_first_descr
330                         always @ (posedge aclk or negedge n_areset)
331                         begin
332                           if (~n_areset)
333                             db1_out_first_descr &lt;= 1'b1;
334                           else
335                             if (~enable_tx)
336                               db1_out_first_descr &lt;= 1'b1;
337                             else
338                               if (db1_pop)
339                                 db1_out_first_descr &lt;= db1_out_last_bit || db1_out_used_bit;
340                         end
341                       end else begin : gen_no_first_descr
342                         wire zero;
343                         assign zero = 1'b0;
344        1/1              always @(zero) db1_out_first_descr = zero;
345                       end
346                       endgenerate
347                     
348                     
349                       // Flag TSO/UFO multi buffer error
350                       //  - descriptor currently in primary descriptor buffer has used bit set or has zero value
351                       //    length field and last bit set
352                       //  - only relevant when TSO/UFO is underway and descriptor in primary descriptor buffer
353                       //    is a payload descriptor
354                       assign multi_buffer_error = db1_out_used_bit || (db1_out_last_bit &amp;&amp; (db1_out[45:32] == 14'd0));
355                     
356                     
357                       // State machine state vector
358                       always @ (posedge aclk or negedge n_areset)
359                       begin
360        1/1              if (~n_areset)
361        1/1                dgen_sm_cs &lt;= DGEN_IDLE;
362                         else
363        1/1                if (~enable_tx)
364        1/1                  dgen_sm_cs &lt;= DGEN_IDLE;
365                           else
366        1/1                  dgen_sm_cs &lt;= dgen_sm_ns;
367                       end
368                     
369                     
370                       // State machine next state logic
371                       //  Only active if LSO is enabled via p_edma_lso
372                       //  When inactive functionality dependent on LSO states will be
373                       //  optimised out by synthesis
374                       generate
375                         if (p_edma_lso == 1)
376                         begin : gen_lso_sm
377                     
378                           reg   [3:0] dgen_sm_ns_i;
379                     
380                           assign dgen_sm_ns = dgen_sm_ns_i;
381                     
382                           always @ *
383                           begin
384                     
385                             dgen_sm_ns_i = dgen_sm_cs;
386                     
387                             case (dgen_sm_cs)
388                     
389                               DGEN_TSO_1ST_HDR :
390                                 // Proceed to payload state when header descriptor is pushed to
391                                 // secondary buffer
392                                 if (db2_push)
393                                   dgen_sm_ns_i = DGEN_TSO_PYLD;
394                     
395                               DGEN_TSO_PYLD :
396                                 // Return to IDLE for multi buffer errors - mid buffer used
397                                 // bit or zero length last buffer
398                                 // Return to IDLE when last SW payload descriptor for large TSO
399                                 // frame is processed - otherwise repeat header descriptor
400                                 // Differentiate between repeated header for the current SW payload
401                                 // descriptor and repeated header for next SW payload descriptor
402                                 // as differnet flags are set for each case
403                                 if (db2_push)
404                                 begin
405                                   if (multi_buffer_error)
406                                     dgen_sm_ns_i = DGEN_IDLE;
407                                   else
408                                     if (last_gen_pyld)
409                                     begin
410                                       if (db1_out_last_bit)
411                                         dgen_sm_ns_i = DGEN_IDLE;
412                                       else
413                                         dgen_sm_ns_i = DGEN_TSO_NXT_PYLD_HDR;
414                                     end
415                                     else
416                                       dgen_sm_ns_i = DGEN_TSO_RPT_HDR;
417                                 end
418                     
419                     
420                               DGEN_TSO_RPT_HDR :
421                                 // Return to TSO payload state to continue
422                                 // processing current payload TSO descriptor
423                                 if (db2_push)
424                                   dgen_sm_ns_i = DGEN_TSO_PYLD;
425                     
426                     
427                               DGEN_TSO_NXT_PYLD_HDR :
428                                 // Return to TSO payload state to start
429                                 // processing next payload TSO descriptor
430                                 if (db2_push)
431                                   dgen_sm_ns_i = DGEN_TSO_PYLD;
432                     
433                     
434                               DGEN_UFO_1ST_HDR :
435                                 // Proceed to payload state when header descriptor is pushed to
436                                 // secondary buffer
437                                 if (db2_push)
438                                   dgen_sm_ns_i = DGEN_UFO_PYLD;
439                     
440                     
441                               DGEN_UFO_PYLD :
442                                 // Return to IDLE for multi buffer errors - mid buffer used
443                                 // bit or zero length last buffer
444                                 // Return to IDLE when last SW payload descriptor for large UFO
445                                 // frame is processed - otherwise repeat header descriptor
446                                 // Differentiate between repeated header for current SW payload
447                                 // descriptor and repeated header for next SW payload descriptor
448                                 // as differnet flags are set for each case
449                                 if (db2_push)
450                                 begin
451                                   if (multi_buffer_error)
452                                     dgen_sm_ns_i = DGEN_IDLE;
453                                   else
454                                     if (last_gen_pyld)
455                                     begin
456                                       if (db1_out_last_bit)
457                                         dgen_sm_ns_i = DGEN_IDLE;
458                                       else
459                                         dgen_sm_ns_i = DGEN_UFO_NXT_PYLD_HDR;
460                                     end
461                                     else
462                                       dgen_sm_ns_i = DGEN_UFO_RPT_HDR;
463                                 end
464                     
465                     
466                               DGEN_UFO_RPT_HDR :
467                                 // Return to UFO payload state to continue
468                                 // processing current payload TSO descriptor
469                                 if (db2_push)
470                                   dgen_sm_ns_i = DGEN_UFO_PYLD;
471                     
472                     
473                               DGEN_UFO_NXT_PYLD_HDR :
474                                 // Return to UFO payload state to start
475                                 // processing next payload TSO descriptor
476                                 if (db2_push)
477                                   dgen_sm_ns_i = DGEN_UFO_PYLD;
478                     
479                     
480                               default : // DGEN_IDLE
481                                 // FSM remains in IDLE state for normal descriptors and moves to
482                                 // TSO/UFO 1st header states for TSO/UFO header descriptors
483                                 if (db1_out_tso_en)
484                                     dgen_sm_ns_i = DGEN_TSO_1ST_HDR;
485                                   else
486                                     if (db1_out_ufo_en)
487                                       dgen_sm_ns_i = DGEN_UFO_1ST_HDR;
488                     
489                             endcase
490                     
491                           end
492                     
493                         end
494                         else
495                         begin : gen_no_lso_sm
496                     
497                           assign dgen_sm_ns = DGEN_IDLE;
498                     
499                         end
500                       endgenerate
501                     
502                     
503                       // Generate secondary descriptor buffer push signals
504                       // Push whenever there is space in the secondary buffer and there is a descriptor in the
505                       // primary buffer - exception being that when the state machine is in the idle state the
506                       // push does not occur for TSO/UFO header descriptors. This is because the TSO/UFO
507                       // header descriptor is stored in the header descriptor register so that the
508                       // first payload descriptor can be examined and the appropriate flags set when pushing
509                       // the header descriptor to the secondary buffer. Pushing of the header descriptors for
510                       // subsequent gennerated frames is also dependent on the primary buffer not being empty
511                       // as again payload descriptor visibility is required to set the header descriptor flags
512                       // Do not push until there is enough space in the AHB DMA SRAM to hold the associated
513                       // data - indicated by sram_space_ok
514                       always @ *
515                       begin
516        1/1              if (dgen_sm_cs == DGEN_IDLE)
517        1/1                db2_push = ~db2_full_axi   &amp;&amp; ~db2_full_dma &amp;&amp;
518                                      ~db1_empty      &amp;&amp; sram_space_ok &amp;&amp;
519                                      ~db1_out_tso_en &amp;&amp; ~db1_out_ufo_en;
520                         else
521        1/1                db2_push = ~db2_full_axi &amp;&amp; ~db2_full_dma &amp;&amp;
522                                      ~db1_empty    &amp;&amp; sram_space_ok;
523                       end
524                     
525                     
526                       // Load header descriptor register
527                       // Only for TSO/UFO frames
528                       // Load as state machine leaves idle state
529                       generate if (p_edma_lso == 1) begin : gen_lso_dgen
530                         reg [p_descr_width-1:0] dgen_hdr_descr_r;
531                     
532                         always @ (posedge aclk or negedge n_areset)
533                         begin
534                           if (~n_areset)
535                             dgen_hdr_descr_r    &lt;= {p_descr_width{1'b0}};
536                           else
537                             if ((dgen_sm_cs == DGEN_IDLE) &amp;&amp; (db1_out_tso_en || db1_out_ufo_en))
538                               dgen_hdr_descr_r  &lt;= db1_out;
539                         end
540                         assign dgen_hdr_descr = dgen_hdr_descr_r;
541                         // TOIMPRV can protect dgen_len and dgen_addr
542                         assign db2_tso_ufo_in = {db1_out[p_descr_width-1:48], // word 2 (if present) and word 1 - unmodified
543                                                   1'b1,                       // always set last bit for payload descriptors
544                                                   db1_out[46],                // word 1 bit 14 - unmodified
545                                                   dgen_len,                   // word 1 bits [13:0] - length field
546                                                   dgen_addr                   // word 0 bits [31:0] - buffer address
547                                                 };
548                     
549                         if (p_edma_asf_dap_prot == 1) begin : gen_par
550                           reg [p_descr_pwidth-1:0]  dgen_hdr_descr_par_r;
551                           always @ (posedge aclk or negedge n_areset)
552                             begin
553                             if (~n_areset)
554                               dgen_hdr_descr_par_r  &lt;= {p_descr_pwidth{1'b0}};
555                             else
556                               if ((dgen_sm_cs == DGEN_IDLE) &amp;&amp; (db1_out_tso_en || db1_out_ufo_en))
557                                 dgen_hdr_descr_par_r  &lt;= db1_out_par;
558                           end
559                           assign dgen_hdr_descr_par = dgen_hdr_descr_par_r;
560                     
561                         // tx_descr_wr_data_par_clean is a combinatorial re-gen based on tx_descr_wr_data_clean
562                         // which is a transform of tx_descr_wr_data.
563                         gem_par_chk_regen #(.p_chk_dwid (p_descr_width)) i_regen_tx_descr_wr_data_par (
564                           .odd_par  (1'b0),
565                           .chk_dat  (db1_out),
566                           .chk_par  (db1_out_par),
567                           .new_dat  (db2_tso_ufo_in),
568                           .dat_out  (),
569                           .par_out  (db2_tso_ufo_in_par),
570                           .chk_err  (db1_out_par_err)
571                          );
572                         end else begin : gen_no_par
573                           assign dgen_hdr_descr_par = {p_descr_pwidth{1'b0}};
574                           assign db1_out_par_err    = 1'b0;
575                           assign db2_tso_ufo_in_par = {p_descr_pwidth{1'b0}};
576                         end
577                     
578                       end else begin : gen_no_lso_dgen
579                         assign dgen_hdr_descr     = {p_descr_width{1'b0}};
580                         assign dgen_hdr_descr_par = {p_descr_pwidth{1'b0}};
581                         assign db2_tso_ufo_in     = {p_descr_width{1'b0}};
582                         assign db2_tso_ufo_in_par = {p_descr_pwidth{1'b0}};
583                     
584                         if (p_edma_asf_dap_prot == 1) begin : gen_par_check
585                           cdnsdru_asf_parity_check_v1 #(
586                             .p_data_width (p_descr_width)
587                           ) i_par_chk (
588                             .odd_par    (1'b0),
589                             .data_in    (db1_out),
590                             .parity_in  (db1_out_par),
591                             .parity_err (db1_out_par_err)
592                           );
593                         end else begin : gen_no_par_check
594                           assign db1_out_par_err  = 1'b0;
595                         end
596                     
597                       end
598                       endgenerate
599                     
600                     
601                       // Generate primary descriptor buffer pop signals
602                       // Dependent on state machine state
603                       // DGEN_IDLE        - pop when delivering normal descriptor to secondary buffer
604                       //                    or when delivering TSO/UFO header to header register
605                       // DGEN_TSO_PYLD    - pop when last generated descriptor of SW descriptor
606                       //                    is pushed to secondary buffer
607                       // DGEN_UFO_PYLD    - pop when last generated descriptor of SW descriptor
608                       //                    is pushed to secondary buffer
609                       always @ *
610                       begin
611        1/1              case (dgen_sm_cs)
612        1/1                DGEN_IDLE         : db1_pop = db2_push || db1_out_tso_en || db1_out_ufo_en;
613        <font color = "red">0/1     ==>        DGEN_TSO_PYLD     : db1_pop = db2_push &amp;&amp; last_gen_pyld;</font>
614        <font color = "red">0/1     ==>        DGEN_UFO_PYLD     : db1_pop = db2_push &amp;&amp; last_gen_pyld;</font>
615        1/1                default           : db1_pop = 1'b0;
616                         endcase
617                       end
618                     
619                     
620                       // Modify descriptor data as it is transferred from primary descriptor buffer
621                       // or header register to secondary descriptor buffer
622                       // Set GH (generated header), FH (first leader) and LH (last header) flags for
623                       // TSO/UFO header descriptors depending on payload descriptor content
624                       // Set NI (no increment) flag (for debug and writeback descriptor pointer)
625                       // for TSO/UFO header and payload descriptors.
626                       //
627                       // Data modification is dependent on state machine state:
628                     
629                       // DGEN_IDLE             - Default case
630                       //                         Descriptor comes from primary buffer
631                       //                         No modification of descriptor fields
632                       //                         No setting of GH/FH/LH/NI
633                     
634                       // DGEN_*_1ST_HDR        - Descriptor comes from header descriptor register
635                       //                         No modification of descriptor fields
636                       //                         Set GH and FH
637                       //                         Set LH if new payload length does not exceed MSS/MFS
638                       //                         and the payload descriptor has the last bit set
639                       //                         Clear NI
640                     
641                       // DGEN_*_RPT_HDR        - Descriptor comes from header descriptor register
642                       //                         No modification of descriptor fields
643                       //                         Set GH
644                       //                         Clear FH
645                       //                         Set LH if remaining payload length does not exceed MSS/MFS
646                       //                         and the payload descriptor has the last bit set
647                       //                         Set NI
648                     
649                       // DGEN_*_NXT_PYLD_HDR   - Descriptor comes from header descriptor register
650                       //                         No modification of descriptor fields
651                       //                         Set GH
652                       //                         Clear FH
653                       //                         Set LH if new payload length does not exceed MSS/MFS
654                       //                         and the payload descriptor has the last bit set
655                       //                         Set NI
656                     
657                       // DGEN_*_PYLD           - Descriptor comes primary buffer
658                       //                         Modify descriptor address and length fields
659                       //                         Clear GH/FH/LH
660                       //                         Set NI if remaining payload length exceeds MSS/MFS
661                     
662                       always @ *
663                       begin
664        1/1              case (dgen_sm_cs)
665                           DGEN_TSO_1ST_HDR,
666                           DGEN_UFO_1ST_HDR :
667                           begin
668        <font color = "red">0/1     ==>          db2_in    = dgen_hdr_descr;</font>
669        <font color = "red">0/1     ==>          db2_in_par= dgen_hdr_descr_par;</font>
670        <font color = "red">0/1     ==>          db2_in_gh = 1'b1;</font>
671        <font color = "red">0/1     ==>          db2_in_fh = 1'b1;</font>
672        <font color = "red">0/1     ==>          db2_in_lh = multi_buffer_error || (last_gen_pyld &amp;&amp; db1_out_last_bit);</font>
673        <font color = "red">0/1     ==>          db2_in_ni = 1'b0;</font>
674                           end
675                     
676                           DGEN_TSO_RPT_HDR,
677                           DGEN_TSO_NXT_PYLD_HDR,
678                           DGEN_UFO_RPT_HDR,
679                           DGEN_UFO_NXT_PYLD_HDR :
680                           begin
681        <font color = "red">0/1     ==>          db2_in    = dgen_hdr_descr;</font>
682        <font color = "red">0/1     ==>          db2_in_par= dgen_hdr_descr_par;</font>
683        <font color = "red">0/1     ==>          db2_in_gh = 1'b1;</font>
684        <font color = "red">0/1     ==>          db2_in_fh = 1'b0;</font>
685        <font color = "red">0/1     ==>          db2_in_lh = multi_buffer_error || (last_gen_pyld &amp;&amp; db1_out_last_bit);</font>
686        <font color = "red">0/1     ==>          db2_in_ni = 1'b1;</font>
687                           end
688                     
689                           DGEN_TSO_PYLD,
690                           DGEN_UFO_PYLD :
691                           begin
692        <font color = "red">0/1     ==>          db2_in    = db2_tso_ufo_in;</font>
693        <font color = "red">0/1     ==>          db2_in_par= db2_tso_ufo_in_par; // Special recalculation.</font>
694        <font color = "red">0/1     ==>          db2_in_gh = 1'b0;</font>
695        <font color = "red">0/1     ==>          db2_in_fh = 1'b0;</font>
696        <font color = "red">0/1     ==>          db2_in_lh = 1'b0;</font>
697        <font color = "red">0/1     ==>          db2_in_ni = ~last_gen_pyld;</font>
698                           end
699                     
700                           default :
701                           begin
702        1/1                  db2_in    = db1_out;
703        1/1                  db2_in_par= db1_out_par;
704        1/1                  db2_in_gh = 1'b0;
705        1/1                  db2_in_fh = 1'b0;
706        1/1                  db2_in_lh = 1'b0;
707        1/1                  db2_in_ni = 1'b0;
708                           end
709                         endcase
710                       end
711                     
712                       // Get MSS or MFS value from payload descriptor word 1 bits 29:16
713                       // If programmed value is 0, MSS is 536 and MFS is 1518
714                       always @ *
715                       begin
716        1/1              if ((dgen_sm_cs == DGEN_TSO_1ST_HDR) ||
717                             (dgen_sm_cs == DGEN_TSO_RPT_HDR) ||
718                             (dgen_sm_cs == DGEN_TSO_NXT_PYLD_HDR) ||
719                             (dgen_sm_cs == DGEN_TSO_PYLD))
720        <font color = "red">0/1     ==>        dgen_mss_mfs = (db1_out[61:48] == 14'd0) ? 14'd536 : db1_out[61:48];</font>
721                         else
722        1/1                dgen_mss_mfs = (db1_out[61:48] == 14'd0) ? 14'd1518 : db1_out[61:48];
723                       end
724                     
725                       // Calculate the UDP max fragment value from the max frame size value
726                       // MFS includes header and FCS. Header size can be obtained from header
727                       // descriptor length field. FCS is 4 bytes.
728                     
729                       assign dgen_udp_max_frag = dgen_mss_mfs - dgen_hdr_descr[45:32] - 14'd4;
730                     
731                     
732                       // Flag if relationship between the max frame size and the header size results
733                       // in a negative fragment size or in a fragment size of less than 8 bytes
734                       // In this case no fragmentation will occur
735                       
736                       wire [14:0] dgen_hdr_descr_45_32_p4;
737                       assign      dgen_hdr_descr_45_32_p4 = (dgen_hdr_descr[45:32] + 14'd4);
738                       
739                       assign invalid_udp_max_frag = (dgen_hdr_descr_45_32_p4 &gt;= {1'b0,dgen_mss_mfs}) ||
740                                                      dgen_udp_max_frag &lt; 14'd8;
741                     
742                     
743                       // Calculate the generated payload descriptor length field value
744                       // For TCP this is the greater of MSS or the remaining SW payload
745                       // descriptor length
746                       // For UDP this is the greater of max fragment and the remaining SW payload
747                       // descriptor length. However, if the frame will not be the last fragment then
748                       // there is a further limitation that the payload buffer length is a multiple
749                       // of 8 bytes - this limitation is due to the encoding of the IPv4 fragment offset field
750                       always @ *
751                       begin
752        1/1              if ((dgen_sm_cs == DGEN_TSO_1ST_HDR) ||
753                             (dgen_sm_cs == DGEN_TSO_RPT_HDR) ||
754                             (dgen_sm_cs == DGEN_TSO_NXT_PYLD_HDR) ||
755                             (dgen_sm_cs == DGEN_TSO_PYLD))
756                         begin
757                           // TCP
758        <font color = "red">0/1     ==>        if (dgen_rem_len &gt; dgen_mss_mfs)</font>
759        <font color = "red">0/1     ==>          dgen_len = dgen_mss_mfs;</font>
760                           else
761        <font color = "red">0/1     ==>          dgen_len = dgen_rem_len;</font>
762                         end
763                         else
764                         begin
765                           // UDP
766        1/1                if ((dgen_rem_len &gt; dgen_udp_max_frag) &amp;&amp; ~invalid_udp_max_frag)
767        <font color = "red">0/1     ==>          dgen_len = dgen_udp_max_frag &amp; 14'h3FF8; // multiple of 8 bytes</font>
768                           else
769        1/1                  dgen_len = dgen_rem_len;
770                         end
771                       end
772                     
773                     
774                       // Flag when generated header/payload descriptor pair is the last for
775                       // a SW descriptor buffer
776                       // Flag will be valid during genration of both the header and payload descriptors
777                       always @ *
778                       begin
779        1/1              if ( (dgen_sm_cs == DGEN_TSO_1ST_HDR) ||
780                              (dgen_sm_cs == DGEN_TSO_RPT_HDR) ||
781                              (dgen_sm_cs == DGEN_TSO_NXT_PYLD_HDR) ||
782                              (dgen_sm_cs == DGEN_TSO_PYLD) )
783                           //TCP
784        <font color = "red">0/1     ==>        last_gen_pyld = dgen_rem_len &lt;= dgen_mss_mfs;</font>
785                         else
786                           //UDP
787        1/1                last_gen_pyld = (dgen_rem_len &lt;= dgen_udp_max_frag) || invalid_udp_max_frag;
788                       end
789                     
790                       // Address and remaining length counters for generated payload descriptors
791                       // Load when a new SW payload descriptor starts being processed
792                       // - actual load takes place when the header descriptor for first generated frame
793                       //   is pushed to the secondary buffer
794                       // Address counter is then incremented and remaining length counter is decremented
795                       // by the value of the generated payload descriptor length field as  the payload
796                       // descriptors are pushed into the secondary buffer
797                       generate if (p_edma_lso == 1'b1) begin : gen_dgen
798                         
799                         wire [32:0] dgen_addr_p_len;
800                         assign      dgen_addr_p_len = dgen_addr + {18'd0,dgen_len};
801                         
802                         always @ (posedge aclk or negedge n_areset)
803                         begin
804                           if (~n_areset)
805                             dgen_addr &lt;= 32'd0;
806                           else
807                             if (~enable_tx)
808                               dgen_addr &lt;= 32'd0;
809                             else
810                               if (db2_push)
811                               begin
812                                 if ((dgen_sm_cs == DGEN_TSO_1ST_HDR) ||
813                                     (dgen_sm_cs == DGEN_TSO_NXT_PYLD_HDR) ||
814                                     (dgen_sm_cs == DGEN_UFO_1ST_HDR) ||
815                                     (dgen_sm_cs == DGEN_UFO_NXT_PYLD_HDR))
816                                   // Load counters from new SW payload descriptor
817                                   dgen_addr &lt;= db1_out[31:0];
818                                 else
819                                   if ((dgen_sm_cs == DGEN_TSO_PYLD) ||
820                                       (dgen_sm_cs == DGEN_UFO_PYLD))
821                                     // Increment/decrement
822                                     dgen_addr &lt;= dgen_addr_p_len[31:0];
823                               end
824                         end
825                       end else begin : gen_no_dgen
826                         wire   zero;
827                         assign zero = 1'b0;
828        1/1              always @(zero) dgen_addr = {32{zero}};
829                       end
830                       endgenerate
831                     
832                       always @ (posedge aclk or negedge n_areset)
833                       begin
834        1/1              if (~n_areset)
835        1/1                dgen_rem_len_r &lt;= 14'd0;
836                         else
837        1/1                if (~enable_tx)
838        1/1                  dgen_rem_len_r &lt;= 14'd0;
839                           else
840        1/1                  if (db2_push)
841                             begin
842        1/1                    if ((dgen_sm_cs == DGEN_TSO_1ST_HDR) ||
843                                   (dgen_sm_cs == DGEN_TSO_NXT_PYLD_HDR) ||
844                                   (dgen_sm_cs == DGEN_UFO_1ST_HDR) ||
845                                   (dgen_sm_cs == DGEN_UFO_NXT_PYLD_HDR))
846                                   // Load counters from new SW payload descriptor
847        <font color = "red">0/1     ==>              dgen_rem_len_r  &lt;= db1_out[45:32];</font>
848                               else
849        1/1                      if ((dgen_sm_cs == DGEN_TSO_PYLD) ||
850                                     (dgen_sm_cs == DGEN_UFO_PYLD))
851                                   // Increment/decrement
852        <font color = "red">0/1     ==>                dgen_rem_len_r &lt;= dgen_rem_len - dgen_len;</font>
                        MISSING_ELSE
853                             end
                        MISSING_ELSE
854                       end
855                     
856                       // Combinational version of remaining length counter
857                       //  - used by logic which determines length field value of generated descriptors
858                       //  - takes value of SW payload descriptopr length field when the header descriptor
859                       //    is being processed. This is necessary so header descriptor LH flag can be
860                       //    set as the header descriptor is pushed to the secondary buffer
861                       always @ *
862                       begin
863        1/1              if ((dgen_sm_cs == DGEN_TSO_1ST_HDR) ||
864                             (dgen_sm_cs == DGEN_TSO_NXT_PYLD_HDR) ||
865                             (dgen_sm_cs == DGEN_UFO_1ST_HDR) ||
866                             (dgen_sm_cs == DGEN_UFO_NXT_PYLD_HDR))
867        <font color = "red">0/1     ==>        dgen_rem_len  = db1_out[45:32];</font>
868                         else
869        1/1                dgen_rem_len  = dgen_rem_len_r;
870                       end
871                     
872                     
873                       // ======================================================================================
874                       // Secondary descriptor buffer
875                       // FIFO has 2 read ports - 1 for AXI TX data request logic and 1 for responses to
876                       // AHB DMA descriptor read requests. AHB DMA can lag AXI TX data request logic significantly
877                       // AXI read port outputs both current and next values - when FIFO has at least 2 enties and
878                       // the current value is a header descriptor the next value will be the payload descriptor
879                       // ======================================================================================
880                       edma_gen_fifo_2rp #(
881                     
882                         .FIFO_WIDTH       (p_pri_buf_width+4),
883                         .FIFO_DEPTH       (p_axi_tx_descr_rd_buff_depth),
884                         .FIFO_ADDR_WIDTH  (p_axi_tx_descr_rd_buff_bits)
885                     
886                       ) i_tx_descr_sec_buff (
887                     
888                         .clk_pcie      (aclk),
889                         .rst_n         (n_areset),
890                     
891                         .flush         (~enable_tx),
892                     
893                         .din           (sec_buf_in),
894                         .push          (db2_push),
895                     
896                         // port 1 is the AXI port
897                         .qout_1        (sec_buf_out_1),
898                         .qout_nxt_1    (sec_buf_out_1_nxt),
899                         .pop_1         (db2_pop_axi),
900                         .qempty_1      (db2_empty_axi),
901                         .qfull_1       (db2_full_axi),
902                         .qlevel_1      (db2_fill_axi),
903                     
904                         // port 2 is the DMA port
905                         .qout_2        (sec_buf_out_2),
906                         .pop_2         (db2_pop_dma),
907                         .qempty_2      (db2_empty_dma),
908                         .qfull_2       (db2_full_dma),
909                         .qlevel_2      ()
910                     
911                       );
912                     
913                     
914                       //=====================================================================
915                       // Calculate if there is enough space in AHB SRAM for the data associated
916                       // with the descriptor which is about to be pushed into the secondary buffer
917                       //=====================================================================
918                     
919                       // Extract the number of bytes required for the buffer data from the
920                       // descriptor length field
921                       assign required_sram_bytes_db2_in  = db2_in[63]      ? 14'd0 : db2_in[45:32];
922                       assign required_sram_bytes_db2_out = db2_out_axi[63] ? 14'd0 : db2_out_axi[45:32];
923                     
924                     
925                       // Calculate the number of SRAM locations needed to accomodate the data for the
926                       // descriptor
927                       // For 128 bit SRAM, can always have 4 words per location
928                       // For 64 bit SRAM, will only get 1 word per location if DMA bus width is 32-bit
929                       // For 32 bit SRAM, will always get 1 word per location
930                     
931                       // Need to add some stripes onto this (up to 4 for status words and
932                       // 2 due to delay in underlying AHB DMA in updating the sram_fill_lvl.
933                       // The number of status words is 2 for 128bit DPRAM, 3 for 64 and 4 for 32.
934                       // Add one more stripe to reserved stipres to take into accound the MOD on
935                       // required_sram_bytes_db2_in. EG in 32 bit mode, if required_sram_bytes_db2_in
936                       // = 1-3 bytes, you will need a single stripe to hold it. But we only look at
937                       // bits [1:0] of required_sram_bytes_db2_in in the code below, so that would
938                       // be ignored.
939                       // there are additional status words associated with the previous
940                       // frame that we also need to take into account here if the previous frame
941                       // was sent to the same queue as the current
942                       // frame. This is because the decision on the required sram stripes for
943                       // the current frame occurs before the status words for the previous frame
944                       // have actually been written to the SRAM (occurs in lower level AHB DMA)).
945                       // The number of status words is 2 for 128bit DPRAM, 3 for 64 and 4 for 32.
946                       reg   [1:0]                           tx_fill_lvl_multiplier;
947                       always @*
948                       begin
949        1/1              if (p_edma_tx_pbuf_data == 32'd128)
950        <font color = "red">0/1     ==>        case (dma_bus_width)</font>
951        <font color = "red">0/1     ==>          2'd0    : tx_fill_lvl_multiplier = 2'd2; // Four 32b words per 128b word</font>
952        <font color = "red">0/1     ==>          2'd1    : tx_fill_lvl_multiplier = 2'd1; // Two 64b words per 128b word</font>
953        <font color = "red">0/1     ==>          default : tx_fill_lvl_multiplier = 2'd0;</font>
954                           endcase
955                         else
956        1/1                tx_fill_lvl_multiplier = 2'd0;
957                       end
958                     
959                       assign reserved_stripes       = p_edma_tx_pbuf_data == 32'd128 ? (15'd2 &lt;&lt; tx_fill_lvl_multiplier) + 15'd3 : 15'd7;
960                       assign reserved_stripes_xtra  = {{28{1'b0}},ahb_dma_queue_ptr} == p_this_queue ?
961                                                         p_edma_tx_pbuf_data == 32'd128  ? (15'd4 &lt;&lt; tx_fill_lvl_multiplier) + 15'd3
962                                                                                         : 15'd11
963                                                                                         : reserved_stripes;
964                     
965                       always @ *
966                       begin
967        1/1              case (dma_bus_width)
968                           2'b00 : // 32-bit
969                           begin
970        1/1                  required_sram_stripes_db2_in    = {3'd0, required_sram_bytes_db2_in[13:2]}  + reserved_stripes;
971        1/1                  required_sram_stripes_db2_out   = {3'd0, required_sram_bytes_db2_out[13:2]} + reserved_stripes;
972        1/1                  required_sram_stripes_db2_in_x  = {3'd0, required_sram_bytes_db2_in[13:2]}  + reserved_stripes_xtra;
973                           end
974                           2'b01 : // 64-bit
975                           begin
976        <font color = "red">0/1     ==>          required_sram_stripes_db2_in    = {4'd0, required_sram_bytes_db2_in[13:3]}  + reserved_stripes;</font>
977        <font color = "red">0/1     ==>          required_sram_stripes_db2_out   = {4'd0, required_sram_bytes_db2_out[13:3]} + reserved_stripes;</font>
978        <font color = "red">0/1     ==>          required_sram_stripes_db2_in_x  = {4'd0, required_sram_bytes_db2_in[13:3]}  + reserved_stripes_xtra;</font>
979                           end
980                           default : // 128-bit
981                           begin
982        <font color = "red">0/1     ==>          required_sram_stripes_db2_in    = {5'd0, required_sram_bytes_db2_in[13:4]}  + reserved_stripes;</font>
983        <font color = "red">0/1     ==>          required_sram_stripes_db2_out   = {5'd0, required_sram_bytes_db2_out[13:4]} + reserved_stripes;</font>
984        <font color = "red">0/1     ==>          required_sram_stripes_db2_in_x  = {5'd0, required_sram_bytes_db2_in[13:4]}  + reserved_stripes_xtra;</font>
985                           end
986                         endcase
987                       end
988                     
989                       // Count the number of sram stripes required for the descriptors currently in the secondary buffer
990                       // Increment as buffer is pushed and decrement as buffer is popped
991                       // Push and pop can occur simultaneously
992                       
993                       wire [16:0] required_sram_striped_db2_p_in;
994                       assign      required_sram_striped_db2_p_in = required_sram_stripes_db2 + required_sram_stripes_db2_in;
995                       
996                       always @ (posedge aclk or negedge n_areset)
997                       begin
998        1/1              if (~n_areset)
999        1/1                required_sram_stripes_db2 &lt;= 16'd0;
1000       1/1              else if (~enable_tx)
1001       1/1                required_sram_stripes_db2 &lt;= 16'd0;
1002       1/1              else if (db2_push &amp;&amp; ~db2_pop_axi)
1003       1/1                required_sram_stripes_db2 &lt;= required_sram_striped_db2_p_in[15:0];
1004       1/1              else if (~db2_push &amp;&amp; db2_pop_axi)
1005       1/1                required_sram_stripes_db2 &lt;= required_sram_stripes_db2 - required_sram_stripes_db2_out;
1006       1/1              else if (db2_push &amp;&amp; db2_pop_axi)
1007       <font color = "red">0/1     ==>        required_sram_stripes_db2 &lt;= required_sram_stripes_db2 + required_sram_stripes_db2_in - required_sram_stripes_db2_out;</font>
                        MISSING_ELSE
1008                      end
1009                    
1010                      // Calculate total space required to allow a buffer push.
1011                      // Include the threshold value whic AXI DMA requires to be available before issuing an AXI read
1012                      //  - otherwise the situation will arise where the descriptor is pushed into the buffer but the
1013                      //    AXI DMA cannot immediately fetch the associated data
1014                      
1015                      // The following is done for LINT purposes
1016                      wire                    [16:0] required_sram_stripes_tmp1;
1017                      wire [p_edma_tx_pbuf_addr+2:0] required_sram_stripes_tmp2;
1018                      wire                    [19:0] required_sram_stripes_tmp1_pad;
1019                      wire                    [19:0] required_sram_stripes_tmp2_pad;
1020                      
1021                      // Calculating the individual addends adding elements with the same size with each other
1022                      assign required_sram_stripes_tmp1     = required_sram_stripes_db2 + required_sram_stripes_db2_in_x;
1023                      assign required_sram_stripes_tmp2     = requested_axi_data        + axi_tx_full_adj_0;
1024                      
1025                      // Will pad both addends to be the all the same size before do the add to avoid any LINT warnings
1026                      assign required_sram_stripes_tmp1_pad = {3'd0,required_sram_stripes_tmp1};
1027                      assign required_sram_stripes_tmp2_pad = {{(20-(p_edma_tx_pbuf_addr+3)){1'b0}},required_sram_stripes_tmp2};
1028                      
1029                      // Now do the add
1030                      assign required_sram_stripes          = required_sram_stripes_tmp1_pad + required_sram_stripes_tmp2_pad;
1031                      
1032                      // In non-priority queuing implementations, we can assume there is enough space if we are in full duplex
1033                      // This is because the MAC side will free up DPRAM resources as the frame is being transmitted so we can simply keep the DPRAM topped up
1034                      // In half duplex, this is not the case, so we should simply not attempt to start requesting the frame until there is sufficient space for
1035                      // the full packet.
1036                      // With priority queueing enabled, it is more complex.  we want to avoid any possibility that the underlying DMA can
1037                      // get into DATA state requesting data for a long time while we are unable to complete it due to lack of DPRAM space
1038                    
1039                      // If we are in cuthru mode then we will always state there is enough space available as the payload is greater than the buffers size
1040                    
1041                      // Calculate if there is enough space in the AHB DMA SRAM buffer for the data associated with the descriptor that is ready to be pushed into the
1042                      // secondary buffer descriptor
1043                      always @ *
1044                      begin
1045                          // Note. The &gt; calculation below is expanded to 16 bits as the edma_tx_pbuf_addr size can be of varying lengths, and it can sometimes
1046                          // be greater than or less than the required_sram_stripes
1047       1/1                sram_space_ok = (db2_in[63] &amp; ~q0_dpram_full) || // used bit set - we cant commit that to db2 if Q0 is already full as it will cause a used-bit
</pre>
<hr>
<a name="Cond"></a>
Cond Coverage for Module : <a href="mod534.html" >edma_pbuf_axi_fe_desc_buff</a><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s2"><td class="lf">Conditions</td><td>104</td><td>27</td><td>25.96</td></tr>
<tr class="s2"><td class="lf">Logical</td><td>104</td><td>27</td><td>25.96</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       246
 EXPRESSION (db1_pop &amp;&amp; descr_rd_resp_end &amp;&amp; ((~db1_push)))
             ---1---    --------2--------    ------3------
</pre>
<table class="noborder">
<col span="3" width="40">
<tr><th>-1-</th><th>-2-</th><th>-3-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>1</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       354
 EXPRESSION (db1_out_used_bit || (db1_out_last_bit &amp;&amp; (db1_out[45:32] == 14'b0)))
             --------1-------    -----------------------2-----------------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       354
 SUB-EXPRESSION (db1_out_last_bit &amp;&amp; (db1_out[45:32] == 14'b0))
                 --------1-------    ------------2------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       517
 EXPRESSION (((~db2_full_axi)) &amp;&amp; ((~db2_full_dma)) &amp;&amp; ((~db1_empty)) &amp;&amp; sram_space_ok &amp;&amp; ((~db1_out_tso_en)) &amp;&amp; ((~db1_out_ufo_en)))
             --------1--------    --------2--------    -------3------    ------4------    ---------5---------    ---------6---------
</pre>
<table class="noborder">
<col span="6" width="40">
<tr><th>-1-</th><th>-2-</th><th>-3-</th><th>-4-</th><th>-5-</th><th>-6-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       521
 EXPRESSION (((~db2_full_axi)) &amp;&amp; ((~db2_full_dma)) &amp;&amp; ((~db1_empty)) &amp;&amp; sram_space_ok)
             --------1--------    --------2--------    -------3------    ------4------
</pre>
<table class="noborder">
<col span="4" width="40">
<tr><th>-1-</th><th>-2-</th><th>-3-</th><th>-4-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       612
 EXPRESSION (db2_push || db1_out_tso_en || db1_out_ufo_en)
             ----1---    -------2------    -------3------
</pre>
<table class="noborder">
<col span="3" width="40">
<tr><th>-1-</th><th>-2-</th><th>-3-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>0</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>0</td><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td>0</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       613
 EXPRESSION (db2_push &amp;&amp; last_gen_pyld)
             ----1---    ------2------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       614
 EXPRESSION (db2_push &amp;&amp; last_gen_pyld)
             ----1---    ------2------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       672
 EXPRESSION (multi_buffer_error || (last_gen_pyld &amp;&amp; db1_out_last_bit))
             ---------1--------    -----------------2-----------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       672
 SUB-EXPRESSION (last_gen_pyld &amp;&amp; db1_out_last_bit)
                 ------1------    --------2-------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       685
 EXPRESSION (multi_buffer_error || (last_gen_pyld &amp;&amp; db1_out_last_bit))
             ---------1--------    -----------------2-----------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       685
 SUB-EXPRESSION (last_gen_pyld &amp;&amp; db1_out_last_bit)
                 ------1------    --------2-------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       716
 EXPRESSION ((dgen_sm_cs == DGEN_TSO_1ST_HDR) || (dgen_sm_cs == DGEN_TSO_RPT_HDR) || (dgen_sm_cs == DGEN_TSO_NXT_PYLD_HDR) || (dgen_sm_cs == DGEN_TSO_PYLD))
             ----------------1---------------    ----------------2---------------    ------------------3------------------    --------------4--------------
</pre>
<table class="noborder">
<col span="4" width="40">
<tr><th>-1-</th><th>-2-</th><th>-3-</th><th>-4-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>0</td><td>0</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>0</td><td>0</td><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>0</td><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       720
 EXPRESSION ((db1_out[61:48] == 14'b0) ? 14'd536 : db1_out[61:48])
             ------------1------------
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       722
 EXPRESSION ((db1_out[61:48] == 14'b0) ? 14'd1518 : db1_out[61:48])
             ------------1------------
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       739
 EXPRESSION ((dgen_hdr_descr_45_32_p4 &gt;= {1'b0, dgen_mss_mfs}) || (dgen_udp_max_frag &lt; 14'd8))
             ------------------------1------------------------    -------------2-------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       752
 EXPRESSION ((dgen_sm_cs == DGEN_TSO_1ST_HDR) || (dgen_sm_cs == DGEN_TSO_RPT_HDR) || (dgen_sm_cs == DGEN_TSO_NXT_PYLD_HDR) || (dgen_sm_cs == DGEN_TSO_PYLD))
             ----------------1---------------    ----------------2---------------    ------------------3------------------    --------------4--------------
</pre>
<table class="noborder">
<col span="4" width="40">
<tr><th>-1-</th><th>-2-</th><th>-3-</th><th>-4-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>0</td><td>0</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>0</td><td>0</td><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>0</td><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       766
 EXPRESSION ((dgen_rem_len &gt; dgen_udp_max_frag) &amp;&amp; ((~invalid_udp_max_frag)))
             -----------------1----------------    ------------2------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       779
 EXPRESSION ((dgen_sm_cs == DGEN_TSO_1ST_HDR) || (dgen_sm_cs == DGEN_TSO_RPT_HDR) || (dgen_sm_cs == DGEN_TSO_NXT_PYLD_HDR) || (dgen_sm_cs == DGEN_TSO_PYLD))
             ----------------1---------------    ----------------2---------------    ------------------3------------------    --------------4--------------
</pre>
<table class="noborder">
<col span="4" width="40">
<tr><th>-1-</th><th>-2-</th><th>-3-</th><th>-4-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>0</td><td>0</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>0</td><td>0</td><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>0</td><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       787
 EXPRESSION ((dgen_rem_len &lt;= dgen_udp_max_frag) || invalid_udp_max_frag)
             -----------------1-----------------    ----------2---------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       842
 EXPRESSION 
 Number  Term
      1  (dgen_sm_cs == DGEN_TSO_1ST_HDR) || 
      2  (dgen_sm_cs == DGEN_TSO_NXT_PYLD_HDR) || 
      3  (dgen_sm_cs == DGEN_UFO_1ST_HDR) || 
      4  (dgen_sm_cs == DGEN_UFO_NXT_PYLD_HDR))
</pre>
<table class="noborder">
<col span="4" width="40">
<tr><th>-1-</th><th>-2-</th><th>-3-</th><th>-4-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>0</td><td>0</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>0</td><td>0</td><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>0</td><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       849
 EXPRESSION ((dgen_sm_cs == DGEN_TSO_PYLD) || (dgen_sm_cs == DGEN_UFO_PYLD))
             --------------1--------------    --------------2--------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       863
 EXPRESSION 
 Number  Term
      1  (dgen_sm_cs == DGEN_TSO_1ST_HDR) || 
      2  (dgen_sm_cs == DGEN_TSO_NXT_PYLD_HDR) || 
      3  (dgen_sm_cs == DGEN_UFO_1ST_HDR) || 
      4  (dgen_sm_cs == DGEN_UFO_NXT_PYLD_HDR))
</pre>
<table class="noborder">
<col span="4" width="40">
<tr><th>-1-</th><th>-2-</th><th>-3-</th><th>-4-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>0</td><td>0</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>0</td><td>0</td><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>0</td><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       921
 EXPRESSION (db2_in[63] ? 14'b0 : db2_in[45:32])
             -----1----
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       922
 EXPRESSION (db2_out_axi[63] ? 14'b0 : db2_out_axi[45:32])
             -------1-------
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       960
 EXPRESSION 
 Number  Term
      1  ({{28 {1'b0}}, ahb_dma_queue_ptr} == p_this_queue) ? (((p_edma_tx_pbuf_data == 32'd128) ? ((15'd4 &lt;&lt; tx_fill_lvl_multiplier) + 15'd3) : 15'd11)) : reserved_stripes)
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1002
 EXPRESSION (db2_push &amp;&amp; ((~db2_pop_axi)))
             ----1---    --------2-------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1004
 EXPRESSION (((~db2_push)) &amp;&amp; db2_pop_axi)
             ------1------    -----2-----
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1006
 EXPRESSION (db2_push &amp;&amp; db2_pop_axi)
             ----1---    -----2-----
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1047
 EXPRESSION 
 Number  Term
      1  ((db2_in[63] &amp; (~q0_dpram_full))) || 
      2  (((({{(17 - p_edma_tx_pbuf_addr) {1'b0}}, sram_fill_lvl} &gt; {3'b0, required_sram_stripes[15:0]}) &amp; (~sram_full)) &amp; (!db2_in[63]))) || 
      3  tx_cutthru)
</pre>
<table class="noborder">
<col span="3" width="40">
<tr><th>-1-</th><th>-2-</th><th>-3-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>0</td><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<hr>
<a name="Toggle"></a>
Toggle Coverage for Module : <a href="mod534.html" >edma_pbuf_axi_fe_desc_buff</a><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s2">
<td>Totals</td>
<td class="rt">33</td>
<td class="rt">8</td>
<td class="rt">24.24 </td>
</tr><tr class="s2">
<td>Total Bits</td>
<td class="rt">1058</td>
<td class="rt">222</td>
<td class="rt">20.98 </td>
</tr><tr class="s2">
<td nowrap>Total Bits 0->1</td>
<td class="rt">529</td>
<td class="rt">116</td>
<td class="rt">21.93 </td>
</tr><tr class="s2">
<td nowrap>Total Bits 1->0</td>
<td class="rt">529</td>
<td class="rt">106</td>
<td class="rt">20.04 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s2">
<td>Ports</td>
<td class="rt">33</td>
<td class="rt">8</td>
<td class="rt">24.24 </td>
</tr><tr class="s2">
<td>Port Bits</td>
<td class="rt">1058</td>
<td class="rt">222</td>
<td class="rt">20.98 </td>
</tr><tr class="s2">
<td nowrap>Port Bits 0->1</td>
<td class="rt">529</td>
<td class="rt">116</td>
<td class="rt">21.93 </td>
</tr><tr class="s2">
<td nowrap>Port Bits 1->0</td>
<td class="rt">529</td>
<td class="rt">106</td>
<td class="rt">20.04 </td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>aclk</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>n_areset</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>enable_tx</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>db1_in[63:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>db1_in[96:64]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>db1_in_par[12:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>db1_push</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>descr_rd_req_end</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>descr_rd_resp_end</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>db1_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_out_axi[25:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_out_axi[26]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_out_axi[30:27]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_out_axi[38:31]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_out_axi[46:39]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_out_axi[47]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_out_axi[100:48]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_out_axi_par[12:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_out_nxt_axi[25:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_out_nxt_axi[26]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_out_nxt_axi[30:27]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_out_nxt_axi[38:31]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_out_nxt_axi[46:39]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_out_nxt_axi[47]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_out_nxt_axi[100:48]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_out_nxt_axi_par[12:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_pop_axi</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>db2_fill_axi[0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_fill_axi[1]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_empty_axi</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_out_dma[25:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_out_dma[26]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_out_dma[30:27]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_out_dma[38:31]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_out_dma[46:39]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_out_dma[47]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_out_dma[100:48]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_out_dma_par[12:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_pop_dma</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>db2_empty_dma</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>sram_fill_lvl[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>sram_fill_lvl[7:6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>sram_fill_lvl[8]</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>sram_fill_lvl[10:9]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>sram_max_fill_lvl[7:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>sram_max_fill_lvl[8]</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>sram_max_fill_lvl[10:9]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>sram_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>q0_dpram_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>num_pkts_in_buf[0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>num_pkts_in_buf[7:1]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>dma_bus_width[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>tx_cutthru</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>requested_axi_data[3:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>requested_axi_data[10:4]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>axi_tx_full_adj_0[10:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>ahb_dma_queue_ptr[3:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>single_frame_too_big</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>db1_out_par_err</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>db2_out_par_err</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<hr>
<a name="Branch"></a>
Branch Coverage for Module : <a href="mod534.html" >edma_pbuf_axi_fe_desc_buff</a><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s5">
<td>Branches</td>
<td></td>
<td class="rt">56</td>
<td class="rt">31</td>
<td class="rt">55.36 </td>
</tr><tr class="s5">
<td>TERNARY</td>
<td class="rt">921</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s5">
<td>TERNARY</td>
<td class="rt">922</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s5">
<td>TERNARY</td>
<td class="rt">960</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s8">
<td>IF</td>
<td class="rt">270</td>
<td class="rt">6</td>
<td class="rt">5</td>
<td class="rt">83.33 </td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">360</td>
<td class="rt">3</td>
<td class="rt">3</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">516</td>
<td class="rt">2</td>
<td class="rt">2</td>
<td class="rt">100.00</td>
</tr><tr class="s5">
<td>CASE</td>
<td class="rt">611</td>
<td class="rt">4</td>
<td class="rt">2</td>
<td class="rt">50.00 </td>
</tr><tr class="s2">
<td>CASE</td>
<td class="rt">664</td>
<td class="rt">4</td>
<td class="rt">1</td>
<td class="rt">25.00 </td>
</tr><tr class="s2">
<td>IF</td>
<td class="rt">716</td>
<td class="rt">4</td>
<td class="rt">1</td>
<td class="rt">25.00 </td>
</tr><tr class="s2">
<td>IF</td>
<td class="rt">752</td>
<td class="rt">4</td>
<td class="rt">1</td>
<td class="rt">25.00 </td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">779</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s6">
<td>IF</td>
<td class="rt">834</td>
<td class="rt">6</td>
<td class="rt">4</td>
<td class="rt">66.67 </td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">863</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s2">
<td>IF</td>
<td class="rt">949</td>
<td class="rt">4</td>
<td class="rt">1</td>
<td class="rt">25.00 </td>
</tr><tr class="s3">
<td>CASE</td>
<td class="rt">967</td>
<td class="rt">3</td>
<td class="rt">1</td>
<td class="rt">33.33 </td>
</tr><tr class="s8">
<td>IF</td>
<td class="rt">998</td>
<td class="rt">6</td>
<td class="rt">5</td>
<td class="rt">83.33 </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
921          assign required_sram_bytes_db2_in  = db2_in[63]      ? 14'd0 : db2_in[45:32];
                                                                  <font color = "red">-1-</font>  
                                                                  <font color = "red">==></font>  
                                                                  <font color = "green">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
922          assign required_sram_bytes_db2_out = db2_out_axi[63] ? 14'd0 : db2_out_axi[45:32];
                                                                  <font color = "red">-1-</font>  
                                                                  <font color = "red">==></font>  
                                                                  <font color = "green">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
960          assign reserved_stripes_xtra  = {{28{1'b0}},ahb_dma_queue_ptr} == p_this_queue ?
961                                            p_edma_tx_pbuf_data == 32'd128  ? (15'd4 &lt;&lt; tx_fill_lvl_multiplier) + 15'd3
962                                                                            : 15'd11
963                                                                            : reserved_stripes;

ID         LINE       
-1-        960        ({{28 {1'b0}}, ahb_dma_queue_ptr} == p_this_queue)
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
270            if (~n_areset)
               <font color = "green">-1-</font>  
271              db1_fill <= {p_axi_tx_descr_rd_buff_bits+1{1'b0}};
           <font color = "green">      ==></font>
272            else
273            begin
274              if (~enable_tx)
                 <font color = "green">-2-</font>  
275                db1_fill <= {p_axi_tx_descr_rd_buff_bits+1{1'b0}};
           <font color = "green">        ==></font>
276              else
277                case ({inc1_db1_fill, dec1_db1_fill, dec2_db1_fill})
                   <font color = "red">-3-</font>  
278        
279                  3'b100 : // inc1 only: increment by 1
280                    db1_fill <= db1_fill_p1[p_axi_tx_descr_rd_buff_bits:0];
           <font color = "green">            ==></font>
281        
282                  3'b010, 3'b101 : // dec1 only, or inc1 and dec2: decrement by 1
283                    db1_fill <= db1_fill - db1_fill_one;
           <font color = "green">            ==></font>
284        
285                  3'b001 : // dec2 only: decrement by 2
286                    db1_fill <= db1_fill - db1_fill_two;
           <font color = "red">            ==></font>
287        
288                  default : // inc1 and dec1, or no activity: no change
289                    db1_fill <= db1_fill;
           <font color = "green">            ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>3'b100 </td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>3'b010 3'b101 </td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>3'b001 </td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>default</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
360            if (~n_areset)
               <font color = "green">-1-</font>  
361              dgen_sm_cs <= DGEN_IDLE;
           <font color = "green">      ==></font>
362            else
363              if (~enable_tx)
                 <font color = "green">-2-</font>  
364                dgen_sm_cs <= DGEN_IDLE;
           <font color = "green">        ==></font>
365              else
366                dgen_sm_cs <= dgen_sm_ns;
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
516            if (dgen_sm_cs == DGEN_IDLE)
               <font color = "green">-1-</font>  
517              db2_push = ~db2_full_axi   && ~db2_full_dma &&
           <font color = "green">      ==></font>
518                         ~db1_empty      && sram_space_ok &&
519                         ~db1_out_tso_en && ~db1_out_ufo_en;
520            else
521              db2_push = ~db2_full_axi && ~db2_full_dma &&
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
611            case (dgen_sm_cs)
               <font color = "red">-1-</font>  
612              DGEN_IDLE         : db1_pop = db2_push || db1_out_tso_en || db1_out_ufo_en;
           <font color = "green">      ==></font>
613              DGEN_TSO_PYLD     : db1_pop = db2_push && last_gen_pyld;
           <font color = "red">      ==></font>
614              DGEN_UFO_PYLD     : db1_pop = db2_push && last_gen_pyld;
           <font color = "red">      ==></font>
615              default           : db1_pop = 1'b0;
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>DGEN_IDLE </td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>DGEN_TSO_PYLD </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>DGEN_UFO_PYLD </td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>default</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
664            case (dgen_sm_cs)
               <font color = "red">-1-</font>  
665              DGEN_TSO_1ST_HDR,
666              DGEN_UFO_1ST_HDR :
667              begin
668                db2_in    = dgen_hdr_descr;
           <font color = "red">        ==></font>
669                db2_in_par= dgen_hdr_descr_par;
670                db2_in_gh = 1'b1;
671                db2_in_fh = 1'b1;
672                db2_in_lh = multi_buffer_error || (last_gen_pyld && db1_out_last_bit);
673                db2_in_ni = 1'b0;
674              end
675        
676              DGEN_TSO_RPT_HDR,
677              DGEN_TSO_NXT_PYLD_HDR,
678              DGEN_UFO_RPT_HDR,
679              DGEN_UFO_NXT_PYLD_HDR :
680              begin
681                db2_in    = dgen_hdr_descr;
           <font color = "red">        ==></font>
682                db2_in_par= dgen_hdr_descr_par;
683                db2_in_gh = 1'b1;
684                db2_in_fh = 1'b0;
685                db2_in_lh = multi_buffer_error || (last_gen_pyld && db1_out_last_bit);
686                db2_in_ni = 1'b1;
687              end
688        
689              DGEN_TSO_PYLD,
690              DGEN_UFO_PYLD :
691              begin
692                db2_in    = db2_tso_ufo_in;
           <font color = "red">        ==></font>
693                db2_in_par= db2_tso_ufo_in_par; // Special recalculation.
694                db2_in_gh = 1'b0;
695                db2_in_fh = 1'b0;
696                db2_in_lh = 1'b0;
697                db2_in_ni = ~last_gen_pyld;
698              end
699        
700              default :
701              begin
702                db2_in    = db1_out;
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>DGEN_TSO_1ST_HDR DGEN_UFO_1ST_HDR </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center nowrap>CASEITEM-2: DGEN_TSO_RPT_HDR DGEN_TSO_NXT_PYLD_HDR DGEN_UFO_RPT_HDR DGEN_UFO_NXT_PYLD_HDR </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>DGEN_TSO_PYLD DGEN_UFO_PYLD </td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>default</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
716            if ((dgen_sm_cs == DGEN_TSO_1ST_HDR) ||
               <font color = "red">-1-</font>  
717                (dgen_sm_cs == DGEN_TSO_RPT_HDR) ||
718                (dgen_sm_cs == DGEN_TSO_NXT_PYLD_HDR) ||
719                (dgen_sm_cs == DGEN_TSO_PYLD))
720              dgen_mss_mfs = (db1_out[61:48] == 14'd0) ? 14'd536 : db1_out[61:48];
                                                          <font color = "red">-2-</font>  
                                                          <font color = "red">==></font>  
                                                          <font color = "red">==></font>  
721            else
722              dgen_mss_mfs = (db1_out[61:48] == 14'd0) ? 14'd1518 : db1_out[61:48];
                                                          <font color = "red">-3-</font>  
                                                          <font color = "green">==></font>  
                                                          <font color = "red">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
752            if ((dgen_sm_cs == DGEN_TSO_1ST_HDR) ||
               <font color = "red">-1-</font>  
753                (dgen_sm_cs == DGEN_TSO_RPT_HDR) ||
754                (dgen_sm_cs == DGEN_TSO_NXT_PYLD_HDR) ||
755                (dgen_sm_cs == DGEN_TSO_PYLD))
756            begin
757              // TCP
758              if (dgen_rem_len > dgen_mss_mfs)
                 <font color = "red">-2-</font>  
759                dgen_len = dgen_mss_mfs;
           <font color = "red">        ==></font>
760              else
761                dgen_len = dgen_rem_len;
           <font color = "red">        ==></font>
762            end
763            else
764            begin
765              // UDP
766              if ((dgen_rem_len > dgen_udp_max_frag) && ~invalid_udp_max_frag)
                 <font color = "red">-3-</font>  
767                dgen_len = dgen_udp_max_frag & 14'h3FF8; // multiple of 8 bytes
           <font color = "red">        ==></font>
768              else
769                dgen_len = dgen_rem_len;
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
779            if ( (dgen_sm_cs == DGEN_TSO_1ST_HDR) ||
               <font color = "red">-1-</font>  
780                 (dgen_sm_cs == DGEN_TSO_RPT_HDR) ||
781                 (dgen_sm_cs == DGEN_TSO_NXT_PYLD_HDR) ||
782                 (dgen_sm_cs == DGEN_TSO_PYLD) )
783              //TCP
784              last_gen_pyld = dgen_rem_len <= dgen_mss_mfs;
           <font color = "red">      ==></font>
785            else
786              //UDP
787              last_gen_pyld = (dgen_rem_len <= dgen_udp_max_frag) || invalid_udp_max_frag;
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
834            if (~n_areset)
               <font color = "green">-1-</font>  
835              dgen_rem_len_r <= 14'd0;
           <font color = "green">      ==></font>
836            else
837              if (~enable_tx)
                 <font color = "green">-2-</font>  
838                dgen_rem_len_r <= 14'd0;
           <font color = "green">        ==></font>
839              else
840                if (db2_push)
                   <font color = "green">-3-</font>  
841                begin
842                  if ((dgen_sm_cs == DGEN_TSO_1ST_HDR) ||
                     <font color = "red">-4-</font>  
843                      (dgen_sm_cs == DGEN_TSO_NXT_PYLD_HDR) ||
844                      (dgen_sm_cs == DGEN_UFO_1ST_HDR) ||
845                      (dgen_sm_cs == DGEN_UFO_NXT_PYLD_HDR))
846                      // Load counters from new SW payload descriptor
847                    dgen_rem_len_r  <= db1_out[45:32];
           <font color = "red">            ==></font>
848                  else
849                    if ((dgen_sm_cs == DGEN_TSO_PYLD) ||
                       <font color = "red">-5-</font>  
850                        (dgen_sm_cs == DGEN_UFO_PYLD))
851                      // Increment/decrement
852                      dgen_rem_len_r <= dgen_rem_len - dgen_len;
           <font color = "red">              ==></font>
                         MISSING_ELSE
           <font color = "green">              ==></font>
853                end
                   MISSING_ELSE
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
863            if ((dgen_sm_cs == DGEN_TSO_1ST_HDR) ||
               <font color = "red">-1-</font>  
864                (dgen_sm_cs == DGEN_TSO_NXT_PYLD_HDR) ||
865                (dgen_sm_cs == DGEN_UFO_1ST_HDR) ||
866                (dgen_sm_cs == DGEN_UFO_NXT_PYLD_HDR))
867              dgen_rem_len  = db1_out[45:32];
           <font color = "red">      ==></font>
868            else
869              dgen_rem_len  = dgen_rem_len_r;
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
949            if (p_edma_tx_pbuf_data == 32'd128)
               <font color = "red">-1-</font>  
950              case (dma_bus_width)
                 <font color = "red">-2-</font>  
951                2'd0    : tx_fill_lvl_multiplier = 2'd2; // Four 32b words per 128b word
           <font color = "red">        ==></font>
952                2'd1    : tx_fill_lvl_multiplier = 2'd1; // Two 64b words per 128b word
           <font color = "red">        ==></font>
953                default : tx_fill_lvl_multiplier = 2'd0;
           <font color = "red">        ==></font>
954              endcase
955            else
956              tx_fill_lvl_multiplier = 2'd0;
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center>2'b0 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>2'b1 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>default</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
967            case (dma_bus_width)
               <font color = "red">-1-</font>  
968              2'b00 : // 32-bit
969              begin
970                required_sram_stripes_db2_in    = {3'd0, required_sram_bytes_db2_in[13:2]}  + reserved_stripes;
           <font color = "green">        ==></font>
971                required_sram_stripes_db2_out   = {3'd0, required_sram_bytes_db2_out[13:2]} + reserved_stripes;
972                required_sram_stripes_db2_in_x  = {3'd0, required_sram_bytes_db2_in[13:2]}  + reserved_stripes_xtra;
973              end
974              2'b01 : // 64-bit
975              begin
976                required_sram_stripes_db2_in    = {4'd0, required_sram_bytes_db2_in[13:3]}  + reserved_stripes;
           <font color = "red">        ==></font>
977                required_sram_stripes_db2_out   = {4'd0, required_sram_bytes_db2_out[13:3]} + reserved_stripes;
978                required_sram_stripes_db2_in_x  = {4'd0, required_sram_bytes_db2_in[13:3]}  + reserved_stripes_xtra;
979              end
980              default : // 128-bit
981              begin
982                required_sram_stripes_db2_in    = {5'd0, required_sram_bytes_db2_in[13:4]}  + reserved_stripes;
           <font color = "red">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>2'b00 </td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>2'b01 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>default</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
998            if (~n_areset)
               <font color = "green">-1-</font>  
999              required_sram_stripes_db2 <= 16'd0;
           <font color = "green">      ==></font>
1000           else if (~enable_tx)
                    <font color = "green">-2-</font>  
1001             required_sram_stripes_db2 <= 16'd0;
           <font color = "green">      ==></font>
1002           else if (db2_push && ~db2_pop_axi)
                    <font color = "green">-3-</font>  
1003             required_sram_stripes_db2 <= required_sram_striped_db2_p_in[15:0];
           <font color = "green">      ==></font>
1004           else if (~db2_push && db2_pop_axi)
                    <font color = "green">-4-</font>  
1005             required_sram_stripes_db2 <= required_sram_stripes_db2 - required_sram_stripes_db2_out;
           <font color = "green">      ==></font>
1006           else if (db2_push && db2_pop_axi)
                    <font color = "red">-5-</font>  
1007             required_sram_stripes_db2 <= required_sram_stripes_db2 + required_sram_stripes_db2_in - required_sram_stripes_db2_out;
           <font color = "red">      ==></font>
                 MISSING_ELSE
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
</div>
</div>
<div class="ui-layout-center-inner-north">
<div id="center-bread-crumb" class="breadCrumb module urg-margin-bottom">
  <ul name="tag_edma_pbuf_axi_fe_desc_buff">
    <li>
      <a href="#Line">Line</a>    </li>
    <li>
      <a href="#Cond">Cond</a>    </li>
    <li>
      <a href="#Toggle">Toggle</a>    </li>
    <li>
      <a href="#Branch">Branch</a>    </li>
  </ul>
</div>
</div>
</div>
<div class="ui-layout-south">
<table align=center><tr><td class="s0 cl">0%</td>
<td class="s1 cl">10%</td>
<td class="s2 cl">20%</td>
<td class="s3 cl">30%</td>
<td class="s4 cl">40%</td>
<td class="s5 cl">50%</td>
<td class="s6 cl">60%</td>
<td class="s7 cl">70%</td>
<td class="s8 cl">80%</td>
<td class="s9 cl">90%</td>
<td class="s10 cl">100%</td></tr></table></div>
</body>
</html>
