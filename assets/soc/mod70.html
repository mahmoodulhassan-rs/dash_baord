<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="Author" content="<username>"> <meta name="GENERATOR" content="urg/version [en] (platform name) [urg]">
<title>Unified Coverage Report :: Module :: edma_pbuf_tx_align</title>
<link type="text/css" rel="stylesheet" href="css/.urg.css">
<link type="text/css" rel="stylesheet" href="css/.layout.css">
<link type="text/css" rel="stylesheet" href="css/.breadcrumb.css">
<script type="text/javascript" src="js/.jquery.js"></script>
<script type="text/javascript" src="js/.jquery-ui.js"></script>
<script type="text/javascript" src="js/.sortable.js"></script>
<script type="text/javascript" src="js/.layout.js"></script>
<script type="text/javascript" src="js/.breadcrumb.js"></script>
<script type="text/javascript">
var layout, westLayout, centerLayout;
$(document).ready(function () {
  if ($("#north-bread-crumb")) {
    $("#north-bread-crumb").jBreadCrumb({easing:'swing'})
  }
  layout = $("body").layout({ 
    resizable: true,
    spacing_open: 4,
    spacing_closed: 4,
    north: {
      size: 76
    },
    south: {
      size: 45,
      initClosed: true
    },
    west: {
      size: 500,
      resizable: true,
      initClosed: false
    }
  });
  centerLayout = $('div.ui-layout-center').layout({
    north__paneSelector: ".ui-layout-center-inner-north",
    center__paneSelector: ".ui-layout-center-inner-center", 
    north__size: 50,
    spacing_open: 4,
    spacing_closed: 4
  });
});
</script>
</head>
<body onLoad="initPage();"><div class="ui-layout-north">
<div class="logo"></div>
<center class="pagetitle">Module Definition</center>
<div align="center"><a href="dashboard.html" ><b>dashboard</b></a> | <a href="hierarchy.html" ><b>hierarchy</b></a> | <a href="modlist.html" ><b>modlist</b></a> | groups | <a href="tests.html" ><b>tests</b></a> | <a href="asserts.html" ><b>asserts</b></a></div>

</div>
<div class="ui-layout-west">
<div name='tag_edma_pbuf_tx_align'>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module : <a href="#"  onclick="showContent('tag_edma_pbuf_tx_align')">edma_pbuf_tx_align</a></span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s4 cl rt"> 41.45</td>
<td class="s5 cl rt"><a href="mod70.html#Line" > 55.61</a></td>
<td class="wht cl rt"></td>
<td class="s2 cl rt"><a href="mod70.html#Toggle" > 23.84</a></td>
<td class="wht cl rt"></td>
<td class="s4 cl rt"><a href="mod70.html#Branch" > 44.92</a></td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<span class=repname>Source File(s) : </span>
<br clear=all>
<a href="javascript:void(0);"  onclick="openSrcFile('/nfs_project/gemini/DV/nadeem/dv/night_reg/gemini/design/ip/GbE/hdl/edma_pbuf_tx_align.v')">/nfs_project/gemini/DV/nadeem/dv/night_reg/gemini/design/ip/GbE/hdl/edma_pbuf_tx_align.v</a><br clear=all>
<br clear=all>
<span class=repname>Module self-instances :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="wht cl wordwrap"><a href="mod70.html#inst_tag_11285"  onclick="showContent('inst_tag_11285')">config_ss_tb.DUT.config_ss.gbe_u.gem_top_u.i_gem_ss.i_gem_top.gen_dma.gen_pbuf_axi_dma.i_edma_pbuf_axi_top.i_edma_pbuf_axi_tx.i_edma_pbuf_axi_tx_wr.i_edma_pbuf_tx_align<img src="fx.gif" class="icon"></a></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
</tr></table></div>
</div>
<br clear=all>
</div>
<div class="ui-layout-center">
<div class="ui-layout-center-inner-center">
<div name='tag_edma_pbuf_tx_align'>
<a name="Line"></a>
Line Coverage for Module : <a href="mod70.html" >edma_pbuf_tx_align</a><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s5"><td class="lf">TOTAL</td><td></td><td>205</td><td>114</td><td>55.61</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>198</td><td>11</td><td>11</td><td>100.00</td></tr>
<tr class="s2"><td class="lf">ALWAYS</td><td>231</td><td>19</td><td>4</td><td>21.05</td></tr>
<tr class="s2"><td class="lf">ALWAYS</td><td>261</td><td>19</td><td>4</td><td>21.05</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>287</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>312</td><td>11</td><td>11</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>342</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s7"><td class="lf">ALWAYS</td><td>357</td><td>12</td><td>9</td><td>75.00</td></tr>
<tr class="s4"><td class="lf">ALWAYS</td><td>395</td><td>7</td><td>3</td><td>42.86</td></tr>
<tr class="s8"><td class="lf">ALWAYS</td><td>417</td><td>9</td><td>8</td><td>88.89</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>433</td><td>7</td><td>7</td><td>100.00</td></tr>
<tr class="s7"><td class="lf">ALWAYS</td><td>451</td><td>14</td><td>10</td><td>71.43</td></tr>
<tr class="s1"><td class="lf">ALWAYS</td><td>509</td><td>44</td><td>7</td><td>15.91</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>626</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>663</td><td>7</td><td>7</td><td>100.00</td></tr>
<tr class="s5"><td class="lf">ALWAYS</td><td>687</td><td>13</td><td>7</td><td>53.85</td></tr>
<tr class="s7"><td class="lf">ALWAYS</td><td>722</td><td>14</td><td>10</td><td>71.43</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>769</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s6"><td class="lf">ALWAYS</td><td>793</td><td>3</td><td>2</td><td>66.67</td></tr>
<tr class="s6"><td class="lf">ALWAYS</td><td>809</td><td>3</td><td>2</td><td>66.67</td></tr>
</table>
<pre class="code"><br clear=all>
197                       begin
198        1/1              if (~n_hreset)
199                         begin
200        1/1                first_txd_data  &lt;= 1'b1;
201        1/1                last_txd_data   &lt;= 1'b0;
202                         end
203                     
204                         // If flushing next data must be first in buffer
205        1/1              else if(dma_w_flush)
206                         begin
207        1/1                first_txd_data  &lt;= 1'b1;
208        1/1                last_txd_data   &lt;= 1'b0;
209                         end
210                     
211                         // at every data strobe in data state, check to see if buffer is done
212        1/1              else if(tx_data_strobe &amp; tx_dma_state_data)
213                         begin
214        1/1                first_txd_data  &lt;= buffer_done_decode;
215        1/1                last_txd_data   &lt;= last_buf_done_decode;
216                         end
217                     
218                         // else maintain value for first_txd_data or zero last_txd_data
219                         else
220                         begin
221        1/1                first_txd_data  &lt;= first_txd_data;
222        1/1                last_txd_data   &lt;= 1'b0;
223                         end
224                       end
225                     
226                     
227                       // right justify incoming new hrdata. Only applies to first data in
228                       // a buffer as indicated by first_txd_data.
229                       always @(*)
230                       begin
231        1/1              if (first_txd_data)
232        1/1                case (tx_buffer_offset)
233        <font color = "red">0/1     ==>          4'b0001 : txd_data_in = {8'h00, hrdata[127:8]};</font>
234        <font color = "red">0/1     ==>          4'b0010 : txd_data_in = {16'd0, hrdata[127:16]};</font>
235        <font color = "red">0/1     ==>          4'b0011 : txd_data_in = {24'd0, hrdata[127:24]};</font>
236        <font color = "red">0/1     ==>          4'b0100 : txd_data_in = {32'd0, hrdata[127:32]};</font>
237        <font color = "red">0/1     ==>          4'b0101 : txd_data_in = {40'd0, hrdata[127:40]};</font>
238        <font color = "red">0/1     ==>          4'b0110 : txd_data_in = {48'd0, hrdata[127:48]};</font>
239        <font color = "red">0/1     ==>          4'b0111 : txd_data_in = {56'd0, hrdata[127:56]};</font>
240        <font color = "red">0/1     ==>          4'b1000 : txd_data_in = {64'd0, hrdata[127:64]};</font>
241        <font color = "red">0/1     ==>          4'b1001 : txd_data_in = {72'd0, hrdata[127:72]};</font>
242        <font color = "red">0/1     ==>          4'b1010 : txd_data_in = {80'd0, hrdata[127:80]};</font>
243        <font color = "red">0/1     ==>          4'b1011 : txd_data_in = {88'd0, hrdata[127:88]};</font>
244        <font color = "red">0/1     ==>          4'b1100 : txd_data_in = {96'd0, hrdata[127:96]};</font>
245        <font color = "red">0/1     ==>          4'b1101 : txd_data_in = {104'd0,hrdata[127:104]};</font>
246        <font color = "red">0/1     ==>          4'b1110 : txd_data_in = {112'd0,hrdata[127:112]};</font>
247        <font color = "red">0/1     ==>          4'b1111 : txd_data_in = {120'd0,hrdata[127:120]};</font>
248        1/1                  default : txd_data_in =         hrdata[127:0];
249                           endcase
250                         else
251        1/1                txd_data_in = hrdata;
252                       end
253                       // The input should be first extended to take in the parity bits.
254                       // In this module, the databus is realigned. Some bytes of “hrdata”
255                       // are passed to “txd_data_in” bus. Sometimes bytes of 0x0 are passed.
256                       // In the case where “hrdata” is passed, the parity bytes should
257                       // be simply passed through directly.  Where 0x0 is passed, a parity
258                       // bit of ‘0’ should be used.
259                       always @(*)
260                       begin
261        1/1              if (first_txd_data)
262        1/1                case (tx_buffer_offset)
263        <font color = "red">0/1     ==>          4'b0001 : txd_par_in  = {1'b0,  hrdata_par[15:1]};</font>
264        <font color = "red">0/1     ==>          4'b0010 : txd_par_in  = {2'd0,  hrdata_par[15:2]};</font>
265        <font color = "red">0/1     ==>          4'b0011 : txd_par_in  = {3'd0,  hrdata_par[15:3]};</font>
266        <font color = "red">0/1     ==>          4'b0100 : txd_par_in  = {4'd0,  hrdata_par[15:4]};</font>
267        <font color = "red">0/1     ==>          4'b0101 : txd_par_in  = {5'd0,  hrdata_par[15:5]};</font>
268        <font color = "red">0/1     ==>          4'b0110 : txd_par_in  = {6'd0,  hrdata_par[15:6]};</font>
269        <font color = "red">0/1     ==>          4'b0111 : txd_par_in  = {7'd0,  hrdata_par[15:7]};</font>
270        <font color = "red">0/1     ==>          4'b1000 : txd_par_in  = {8'd0,  hrdata_par[15:8]};</font>
271        <font color = "red">0/1     ==>          4'b1001 : txd_par_in  = {9'd0,  hrdata_par[15:9]};</font>
272        <font color = "red">0/1     ==>          4'b1010 : txd_par_in  = {10'd0, hrdata_par[15:10]};</font>
273        <font color = "red">0/1     ==>          4'b1011 : txd_par_in  = {11'd0, hrdata_par[15:11]};</font>
274        <font color = "red">0/1     ==>          4'b1100 : txd_par_in  = {12'd0, hrdata_par[15:12]};</font>
275        <font color = "red">0/1     ==>          4'b1101 : txd_par_in  = {13'd0, hrdata_par[15:13]};</font>
276        <font color = "red">0/1     ==>          4'b1110 : txd_par_in  = {14'd0, hrdata_par[15:14]};</font>
277        <font color = "red">0/1     ==>          4'b1111 : txd_par_in  = {15'd0, hrdata_par[15]};</font>
278        1/1                  default : txd_par_in  = hrdata_par;
279                           endcase
280                         else
281        1/1                txd_par_in  = hrdata_par;
282                       end
283                     
284                       // register incoming data after justifying.
285                       always @(posedge hclk or negedge n_hreset)
286                       begin
287        1/1              if (~n_hreset)
288        1/1                txd_data  &lt;= 128'd0;
289                         else
290        1/1                txd_data  &lt;= txd_data_in;
291                       end
292                     
293                       // Store the parity
294                       generate if (p_edma_asf_dap_prot == 1) begin : gen_txd_par
295                         reg [15:0]  txd_par_r;
296                         always@(posedge hclk or negedge n_hreset)
297                         begin
298                           if (~n_hreset)
299                             txd_par_r &lt;= 16'd0;
300                           else
301                             txd_par_r &lt;= txd_par_in;
302                         end
303                         assign txd_par  = txd_par_r;
304                       end else begin : gen_no_txd_par
305                         assign txd_par  = 16'd0;
306                       end
307                       endgenerate
308                     
309                       // work out how many valid bytes there are in the new txd_data.
310                       always@(posedge hclk or negedge n_hreset)
311                       begin
312        1/1              if (~n_hreset)
313        1/1                no_txd_data &lt;= 5'b00000;
314                     
315                         // clear on a flush
316        1/1              else if (dma_w_flush)
317        1/1                no_txd_data &lt;= 5'b00000;
318                     
319                         // final data phase in buffer, so take how much is left.
320        1/1              else if (tx_data_strobe &amp; buffer_done_decode &amp; tx_dma_state_data)
321        1/1                no_txd_data &lt;= last_access_bytes[4:0];
322                     
323                         // first data phase in buffer, so calculate amount of
324                         // data for full word minus the offset.
325        1/1              else if (tx_data_strobe &amp; first_txd_data &amp; tx_dma_state_data)
326        1/1                no_txd_data &lt;= (tx_length_decrement[4:0] - {1'b0, tx_buffer_offset});
327                     
328                         // data transfer in middle of buffer, so full transfer
329        1/1              else if (tx_data_strobe &amp; tx_dma_state_data)
330        1/1                no_txd_data &lt;= tx_length_decrement[4:0];
331                     
332                         // else maintain value
333                         else
334        1/1                no_txd_data &lt;= no_txd_data[4:0];
335                       end
336                     
337                     
338                       // new txd_data is available on registered hready strobe when in the
339                       // data state.
340                       always @(posedge hclk or negedge n_hreset)
341                       begin
342        1/1              if (~n_hreset)
343        1/1                new_txd_data  &lt;= 1'b0;
344                         else
345        1/1                new_txd_data  &lt;= tx_data_strobe &amp; tx_dma_state_data;
346                       end
347                     
348                     
349                     //******************************************************************************
350                     // 128-bit alignment buffer plus 120-bit residue.
351                     //******************************************************************************
352                     
353                       // Keep an offset pointer to keep track of current byte being
354                       // written to in 128 bit alignment buffer (16 possible bytes)
355                       always @(posedge hclk or negedge n_hreset)
356                       begin
357        1/1              if (~n_hreset)
358        1/1                align_pntr  &lt;= 4'h0;
359                     
360                         // If main state machine is idle, or last aligned data has been
361                         // processed, then reset alignment pointer to byte 0
362        1/1              else if (dma_w_flush | force_fifo_eop_err | last_aligned_data)
363        1/1                align_pntr  &lt;= 4'h0;
364                     
365                         // If last data transfered has overflowed a new transfer will
366                         // be initiated. Zero pointer after this event
367                         // Note that if this event doesn't happen then the pointer will
368                         // already be zero (no overflow)
369        1/1              else if (force_over_align)
370        <font color = "red">0/1     ==>        align_pntr  &lt;= 4'h0;</font>
371                     
372                         // When new txd data available, assign align_pntr to new value
373        1/1              else if (new_txd_data)
374        1/1                case (dma_bus_width)
375        1/1                  2'b00   : align_pntr  &lt;= {2'b00,next_align_pntr[1:0]};
376        <font color = "red">0/1     ==>          2'b01   : align_pntr  &lt;= {1'b0, next_align_pntr[2:0]};</font>
377        <font color = "red">0/1     ==>          default : align_pntr  &lt;= next_align_pntr[3:0];</font>
378                           endcase
379                     
380                         // Else maintain value
381                         else
382        1/1                align_pntr  &lt;= align_pntr;
383                       end
384                     
385                     
386                       // work out how many bytes will be present in the alignment buffer
387                       // after the next load (equals the current plus the incoming new bytes)
388                       assign next_align_pntr = ({1'b0, align_pntr[3:0]} + no_txd_data[4:0]);
389                     
390                     
391                       // detect when the alignemnt buffer will be full or have overflow when
392                       // the next load is completed.
393                       always @(*)
394                       begin
395        1/1              case (dma_bus_width)
396                           2'b00   : begin
397        1/1                  next_align_full     = next_align_pntr[2];
398        1/1                  next_align_overflow = next_align_pntr[2] &amp; (next_align_pntr[1:0] != 2'b00);
399                           end
400                           2'b01   : begin
401        <font color = "red">0/1     ==>          next_align_full     = next_align_pntr[3];</font>
402        <font color = "red">0/1     ==>          next_align_overflow = next_align_pntr[3] &amp; (next_align_pntr[2:0] != 3'b000);</font>
403                           end
404                           default : begin
405        <font color = "red">0/1     ==>          next_align_full     = next_align_pntr[4];</font>
406        <font color = "red">0/1     ==>          next_align_overflow = next_align_pntr[4] &amp; (next_align_pntr[3:0] != 4'h0);</font>
407                           end
408                         endcase
409                       end
410                     
411                     
412                       // Indicate when there has been an overflow of the alignment buffer.
413                       // This will be used to force the residue back into the alignment buffer,
414                       // ready for the next new data or at the end of a frame.
415                       always@(posedge hclk or negedge n_hreset)
416                       begin
417        1/1              if (~n_hreset)
418        1/1                prev_align_overflowd  &lt;= 1'b0;
419        1/1              else if (dma_w_flush | force_fifo_eop_err | last_aligned_data)
420        1/1                prev_align_overflowd  &lt;= 1'b0;
421        1/1              else if (new_txd_data &amp; next_align_overflow)
422        <font color = "red">0/1     ==>        prev_align_overflowd  &lt;= 1'b1;</font>
423        1/1              else if (new_txd_data | force_over_align)
424        1/1                prev_align_overflowd  &lt;= 1'b0;
425                         else
426        1/1                prev_align_overflowd  &lt;= prev_align_overflowd;
427                       end
428                     
429                     
430                       // detect when final data in frame is at the output of the alignment buffer.
431                       always@(posedge hclk or negedge n_hreset)
432                       begin
433        1/1              if (~n_hreset)
434        1/1                last_aligned_data &lt;= 1'b0;
435        1/1              else if (dma_w_flush | force_fifo_eop_err)
436        1/1                last_aligned_data &lt;= 1'b0;
437        1/1              else if ((last_txd_data &amp; ~next_align_overflow) | force_over_align)
438        1/1                last_aligned_data &lt;= 1'b1;
439                         else
440        1/1                last_aligned_data &lt;= 1'b0;
441                       end
442                     
443                     
444                       // force overflow to be transfered to alignment buffer at last_txd_data.
445                       // If the last txd data load caused an overflow and then force it
446                       // into the alignment buffer.
447                       // If there is not enough slots in the FIFO, then store the force
448                       // overflow until there is room.
449                       always@(posedge hclk or negedge n_hreset)
450                       begin
451        1/1              if (~n_hreset)
452                         begin
453        1/1                force_over_align  &lt;= 1'b0;
454        1/1                force_over_store  &lt;= 1'b0;
455                         end
456                     
457                         // reset if main state machine is idle or there is a flush
458        1/1              else if (dma_w_flush | force_fifo_eop_err)
459                         begin
460        1/1                force_over_align  &lt;= 1'b0;
461        1/1                force_over_store  &lt;= 1'b0;
462                         end
463                     
464                         // if a force overflow has been stored and there is now enough room,
465                         // then we can now force the final push.
466        1/1              else if (force_over_store &amp; fifo_free_slots_one)
467                         begin
468        <font color = "red">0/1     ==>        force_over_align  &lt;= 1'b1;</font>
469        <font color = "red">0/1     ==>        force_over_store  &lt;= 1'b0;</font>
470                         end
471                     
472                         // Last data has now been loaded into the alignment buffer. If it
473                         // overflowed then we will need to force the overflow as the final write.
474                         // Can only signal this when we know there are enough free slots,
475                         // otherwise store until there is.
476        1/1              else if (last_txd_data &amp; next_align_overflow)
477                         begin
478        <font color = "red">0/1     ==>        force_over_align  &lt;= fifo_free_slots_one;</font>
479        <font color = "red">0/1     ==>        force_over_store  &lt;= ~fifo_free_slots_one;</font>
480                         end
481                     
482                         // else continue to hold stored value, but zero force_over_align, to
483                         // ensure that it is only a pulse.
484                         else
485                         begin
486        1/1                force_over_align  &lt;= 1'b0;
487        1/1                force_over_store  &lt;= force_over_store;
488                         end
489                       end
490                     
491                     
492                       // txd_data_align data alignment buffer
493                       // Used to re-align data into 128 bit chunks after stripping out offset.
494                       // This buffer is split into two portions. The lower portion is for
495                       // the alignment buffer itself, that will be used to present aligned
496                       // data for further processing.
497                       // The upper portion forms the residue for overspill from the lower portion.
498                       // This residue is moved back into the lower portion when an overflow
499                       // is detected.
500                       // For 32-bit DMA bus width, the lower portion is bits[31:0], and the
501                       // residue is in bits [63:32] (bits[247:64] are unused).
502                       // For 64-bit DMA bus width, the lower portion is bits[63:0], and the
503                       // residue is in bits [127:64] (bits[247:128] are unused).
504                       // For 128-bit DMA bus width, the lower portion is bits[127:0], and the
505                       // residue is in bits [247:128] (all bits are used).
506                       always @(*)
507                       begin
508                         // default
509        1/1              txd_data_align_nxt  = txd_data_align;
510        1/1              txd_par_align_nxt   = txd_par_align;
511                     
512                         // if previous store overflowed need to ensure residue is placed
513                         // in the bottom bytes (marked as used by this point). To
514                         // simplify statements the whole of the residue is copied down
515                         // and then overwritten by new txd data if appropriate.
516        1/1              if ((new_txd_data &amp; prev_align_overflowd) | force_over_align)
517                         begin
518        <font color = "red">0/1     ==>        case (dma_bus_width)</font>
519                             2'b00   : begin
520        <font color = "red">0/1     ==>            txd_data_align_nxt[31:0]  = txd_data_align_nxt[63:32];</font>
521        <font color = "red">0/1     ==>            txd_par_align_nxt[3:0]    = txd_par_align_nxt[7:4];</font>
522                             end
523                             2'b01   : begin
524        <font color = "red">0/1     ==>            txd_data_align_nxt[63:0]  = txd_data_align_nxt[127:64];</font>
525        <font color = "red">0/1     ==>            txd_par_align_nxt[7:0]    = txd_par_align_nxt[15:8];</font>
526                             end
527                             default : begin
528        <font color = "red">0/1     ==>            txd_data_align_nxt[119:0] = txd_data_align_nxt[247:128];</font>
529        <font color = "red">0/1     ==>            txd_par_align_nxt[14:0]   = txd_par_align_nxt[30:16];</font>
530                             end
531                           endcase
532                         end
                        MISSING_ELSE
533                         // if new txd data is available load up the correct number
534                         // of valid bytes into the buffer, beginning at the byte
535                         // pointed to by align_pntr. Always load the full 128 bits so that
536                         // any residue is stored.
537        1/1              if (new_txd_data)
538                         begin
539        1/1                case (align_pntr)
540                             4'h1:
541                             begin
542        <font color = "red">0/1     ==>            txd_data_align_nxt[135:8]   = txd_data[127:0];</font>
543        <font color = "red">0/1     ==>            txd_par_align_nxt[16:1]     = txd_par[15:0];</font>
544                             end
545                             4'h2:
546                             begin
547        <font color = "red">0/1     ==>            txd_data_align_nxt[143:16]  = txd_data[127:0];</font>
548        <font color = "red">0/1     ==>            txd_par_align_nxt[17:2]     = txd_par[15:0];</font>
549                             end
550                             4'h3:
551                             begin
552        <font color = "red">0/1     ==>            txd_data_align_nxt[151:24]  = txd_data[127:0];</font>
553        <font color = "red">0/1     ==>            txd_par_align_nxt[18:3]     = txd_par[15:0];</font>
554                             end
555                             4'h4:
556                             begin
557        <font color = "red">0/1     ==>            txd_data_align_nxt[159:32]  = txd_data[127:0];</font>
558        <font color = "red">0/1     ==>            txd_par_align_nxt[19:4]     = txd_par[15:0];</font>
559                             end
560                             4'h5:
561                             begin
562        <font color = "red">0/1     ==>            txd_data_align_nxt[167:40]  = txd_data[127:0];</font>
563        <font color = "red">0/1     ==>            txd_par_align_nxt[20:5]     = txd_par[15:0];</font>
564                             end
565                             4'h6:
566                             begin
567        <font color = "red">0/1     ==>            txd_data_align_nxt[175:48]  = txd_data[127:0];</font>
568        <font color = "red">0/1     ==>            txd_par_align_nxt[21:6]     = txd_par[15:0];</font>
569                             end
570                             4'h7:
571                             begin
572        <font color = "red">0/1     ==>            txd_data_align_nxt[183:56]  = txd_data[127:0];</font>
573        <font color = "red">0/1     ==>            txd_par_align_nxt[22:7]     = txd_par[15:0];</font>
574                             end
575                             4'h8:
576                             begin
577        <font color = "red">0/1     ==>            txd_data_align_nxt[191:64]  = txd_data[127:0];</font>
578        <font color = "red">0/1     ==>            txd_par_align_nxt[23:8]     = txd_par[15:0];</font>
579                             end
580                             4'h9:
581                             begin
582        <font color = "red">0/1     ==>            txd_data_align_nxt[199:72]  = txd_data[127:0];</font>
583        <font color = "red">0/1     ==>            txd_par_align_nxt[24:9]     = txd_par[15:0];</font>
584                             end
585                             4'ha:
586                             begin
587        <font color = "red">0/1     ==>            txd_data_align_nxt[207:80]  = txd_data[127:0];</font>
588        <font color = "red">0/1     ==>            txd_par_align_nxt[25:10]    = txd_par[15:0];</font>
589                             end
590                             4'hb:
591                             begin
592        <font color = "red">0/1     ==>            txd_data_align_nxt[215:88]  = txd_data[127:0];</font>
593        <font color = "red">0/1     ==>            txd_par_align_nxt[26:11]    = txd_par[15:0];</font>
594                             end
595                             4'hc:
596                             begin
597        <font color = "red">0/1     ==>            txd_data_align_nxt[223:96]  = txd_data[127:0];</font>
598        <font color = "red">0/1     ==>            txd_par_align_nxt[27:12]    = txd_par[15:0];</font>
599                             end
600                             4'hd:
601                             begin
602        <font color = "red">0/1     ==>            txd_data_align_nxt[231:104] = txd_data[127:0];</font>
603        <font color = "red">0/1     ==>            txd_par_align_nxt[28:13]    = txd_par[15:0];</font>
604                             end
605                             4'he:
606                             begin
607        <font color = "red">0/1     ==>            txd_data_align_nxt[239:112] = txd_data[127:0];</font>
608        <font color = "red">0/1     ==>            txd_par_align_nxt[29:14]    = txd_par[15:0];</font>
609                             end
610                             4'hf:
611                             begin
612        <font color = "red">0/1     ==>            txd_data_align_nxt[247:120] = txd_data[127:0];</font>
613        <font color = "red">0/1     ==>            txd_par_align_nxt[30:15]    = txd_par[15:0];</font>
614                             end
615                             default:
616                             begin
617        1/1                    txd_data_align_nxt[127:0]   = txd_data[127:0];
618        1/1                    txd_par_align_nxt[15:0]     = txd_par[15:0];
619                             end
620                           endcase
621                         end
                        MISSING_ELSE
622                       end
623                     
624                       always @(posedge hclk or negedge n_hreset)
625                       begin
626        1/1              if (~n_hreset)
627        1/1                txd_data_align  &lt;= 248'd0;
628                         else
629        1/1                txd_data_align  &lt;= txd_data_align_nxt;
630                       end
631                     
632                       generate if (p_edma_asf_dap_prot == 1) begin : gen_txd_par_align
633                         reg [30:0]  txd_par_align_r;
634                     
635                         always @(posedge hclk or negedge n_hreset)
636                         begin
637                           if (~n_hreset)
638                             txd_par_align_r &lt;= 31'd0;
639                           else
640                             txd_par_align_r &lt;= txd_par_align_nxt;
641                         end
642                         assign txd_par_align = txd_par_align_r;
643                       end else begin : gen_no_txd_par_align
644                         assign txd_par_align  = 31'd0;
645                       end
646                       endgenerate
647                     
648                     //******************************************************************************
649                     // TX DMA FIFO write interface
650                     //******************************************************************************
651                     
652                     
653                       // FIFO write data is always the bottom 128 bits of the aligned data
654                       assign dma_w_data     = txd_data_align[127:0];
655                       assign dma_w_data_par = txd_par_align[15:0];
656                     
657                       // Indicate when new aligned data is available to write into the FIFO.
658                       // Either when the alignment buffer is filled, or when the last data in
659                       // a frame has not forced an overflow of the alignment buffer, or when
660                       // a forced overflow is active.
661                       always@(posedge hclk or negedge n_hreset)
662                       begin
663        1/1              if (~n_hreset)
664        1/1                dma_w_wr_gen  &lt;= 1'b0;
665        1/1              else if (dma_w_flush | force_fifo_eop_err | last_aligned_data)
666        1/1                dma_w_wr_gen  &lt;= 1'b0;
667        1/1              else if ((next_align_full &amp; new_txd_data) |
668                                  (last_txd_data &amp; ~next_align_overflow) |
669                                  force_over_align)
670        1/1                dma_w_wr_gen  &lt;= 1'b1;
671                         else
672        1/1                dma_w_wr_gen  &lt;= 1'b0;
673                       end
674                     
675                       // dma_w_wr output is also forced when an ERR/EOP combination is
676                       // required to be forced into the FIFO.
677                       assign dma_w_wr = dma_w_wr_gen | force_eop_err;
678                     
679                     
680                       // Indicate how many bytes are valid in the last aligned data.
681                       // If the last txd data is about to be loaded into the align buffer
682                       // and doesn't overflow it, or if there is a force overflow, then MOD
683                       // is indicated by the next alignment pointer value.
684                       // Zero upper bits depending on bus width
685                       always@(posedge hclk or negedge n_hreset)
686                       begin
687        1/1              if (~n_hreset)
688        1/1                dma_w_mod &lt;= 4'h0;
689                     
690                         // if last data is not going to overflow buffer then take next_align_pntr.
691        1/1              else if (last_txd_data &amp; ~next_align_overflow)
692        1/1                case (dma_bus_width)
693        1/1                  2'b00   : dma_w_mod &lt;= {2'b00,next_align_pntr[1:0]};
694        <font color = "red">0/1     ==>          2'b01   : dma_w_mod &lt;= {1'b0, next_align_pntr[2:0]};</font>
695        <font color = "red">0/1     ==>          default : dma_w_mod &lt;= next_align_pntr[3:0];</font>
696                           endcase
697                     
698                         // if last data overflowed the buffer then take align_pntr.
699        1/1              else if (force_over_align)
700        <font color = "red">0/1     ==>        case (dma_bus_width)</font>
701        <font color = "red">0/1     ==>          2'b00   : dma_w_mod &lt;= {2'b00,align_pntr[1:0]};</font>
702        <font color = "red">0/1     ==>          2'b01   : dma_w_mod &lt;= {1'b0, align_pntr[2:0]};</font>
703        <font color = "red">0/1     ==>          default : dma_w_mod &lt;= align_pntr[3:0];</font>
704                           endcase
705                     
706                         // Else indicate full 16 bytes
707                         else
708        1/1                dma_w_mod &lt;= 4'h0;
709                       end
710                     
711                     
712                       // end of packet set when last aligned data is being presented
713                       // dma_w_eop output is also forced when an ERR/EOP combination is
714                       // required to be forced into the FIFO.
715                       assign dma_w_eop = last_aligned_data | force_eop_err;
716                     
717                     
718                       // If there is not enough slots in the FIFO to do the force_fifo_eop_err,
719                       // then store until there is room.
720                       always@(posedge hclk or negedge n_hreset)
721                       begin
722        1/1              if (~n_hreset)
723                         begin
724        1/1                force_eop_err_store &lt;= 1'b0;
725        1/1                force_eop_err       &lt;= 1'b0;
726                         end
727                     
728                         // clear on a flush
729        1/1              else if(dma_w_flush)
730                         begin
731        1/1                force_eop_err_store &lt;= 1'b0;
732        1/1                force_eop_err       &lt;= 1'b0;
733                         end
734                     
735                         // if a force_fifo_eop_err has been stored and there is now enough room,
736                         // then we can now force the final push.
737        1/1              else if ((force_fifo_eop_err | force_eop_err_store) &amp; fifo_free_slots_one)
738                         begin
739        <font color = "red">0/1     ==>        force_eop_err_store &lt;= 1'b0;</font>
740        <font color = "red">0/1     ==>        force_eop_err       &lt;= 1'b1;</font>
741                         end
742                     
743                         // if a force_fifo_eop_err happens and there is not enough room,
744                         // then store as force_eop_err_store.
745        1/1              else if (force_fifo_eop_err)
746                         begin
747        <font color = "red">0/1     ==>        force_eop_err_store &lt;= 1'b1;</font>
748        <font color = "red">0/1     ==>        force_eop_err       &lt;= 1'b0;</font>
749                         end
750                     
751                         // else continue to hold stored value
752                         else
753                         begin
754        1/1                force_eop_err_store &lt;= force_eop_err_store;
755        1/1                force_eop_err       &lt;= 1'b0;
756                         end
757                       end
758                     
759                     
760                     
761                     //******************************************************************************
762                     // FIFO level monitor
763                     //******************************************************************************
764                     
765                       // delay FIFO write strobe to detect when another word is being written to
766                       // the FIFO (allows for delay in fifo count output)
767                       always@(posedge hclk or negedge n_hreset)
768                       begin
769        1/1              if (~n_hreset)
770        1/1                dma_w_wr_del  &lt;= 1'b0;
771                         else
772        1/1                dma_w_wr_del  &lt;= dma_w_wr;
773                       end
774                     
775                       // calculate how many on-going AHB or data store accesses have still to
776                       // be acccounted for in the fifo count.
777                       assign accesses_left = {3'b000, dma_w_wr} +              // +1 if writing
778                                              {3'b000, dma_w_wr_del} +          // +1 if just written
779                                              {3'b000, new_txd_data} +          // +1 if new data
780                                              {2'b00, frm_val_data_phase,1'b0}; // +2 if ongoing
781                                                                                // AHB access
782                     
783                       wire [TX_FIFO_CNT_WIDTH:0] dma_w_fifo_count_p_accesses_left;
784                       
785                       assign dma_w_fifo_count_p_accesses_left = (dma_w_fifo_count[(TX_FIFO_CNT_WIDTH -1):0] + accesses_left);
786                       
787                       // calculate the number of real FIFO slots available once on-going accesses
788                       // from the AHB or data store have completed
789                       always @(*)
790                       begin
791                         // if current count plus the ajustment for on-going activity is
792                         // greater than the fifo depth, then there are no free slots.
793        1/1              if (dma_w_fifo_count_p_accesses_left[TX_FIFO_CNT_WIDTH-1:0] &gt; TX_BASE2_FIFO_SIZE)
794        <font color = "red">0/1     ==>        next_free_slots = {(TX_FIFO_CNT_WIDTH + 1){1'b0}};</font>
795                     
796                         // else take away the adjusted count value from the depth to get the
797                         // number of free slots available
798                         else
799        1/1                next_free_slots = TX_BASE2_FIFO_SIZE - (dma_w_fifo_count[(TX_FIFO_CNT_WIDTH -1):0] + accesses_left);
800                       end
801                     
802                     
803                       // signal when there are one or more free slots in the FIFO.
804                       // Used to do an alignment buffer forced overflow.
805                       always@(*)
806                       begin
807                         // if adjustment count is greater than or equal to one, then
808                         // signal last free slots.
809        1/1              if (next_free_slots &gt;= {{TX_FIFO_CNT_WIDTH{1'b0}},1'b1})
810        1/1                fifo_free_slots_one = 1'b1;
811                     
812                         // else block any requests for more DMA activity.
813                         else
814        <font color = "red">0/1     ==>        fifo_free_slots_one = 1'b0;</font>
</pre>
<hr>
<a name="Toggle"></a>
Toggle Coverage for Module : <a href="mod70.html" >edma_pbuf_tx_align</a><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s3">
<td>Totals</td>
<td class="rt">21</td>
<td class="rt">7</td>
<td class="rt">33.33 </td>
</tr><tr class="s2">
<td>Total Bits</td>
<td class="rt">646</td>
<td class="rt">154</td>
<td class="rt">23.84 </td>
</tr><tr class="s2">
<td nowrap>Total Bits 0->1</td>
<td class="rt">323</td>
<td class="rt">78</td>
<td class="rt">24.15 </td>
</tr><tr class="s2">
<td nowrap>Total Bits 1->0</td>
<td class="rt">323</td>
<td class="rt">76</td>
<td class="rt">23.53 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s3">
<td>Ports</td>
<td class="rt">21</td>
<td class="rt">7</td>
<td class="rt">33.33 </td>
</tr><tr class="s2">
<td>Port Bits</td>
<td class="rt">646</td>
<td class="rt">154</td>
<td class="rt">23.84 </td>
</tr><tr class="s2">
<td nowrap>Port Bits 0->1</td>
<td class="rt">323</td>
<td class="rt">78</td>
<td class="rt">24.15 </td>
</tr><tr class="s2">
<td nowrap>Port Bits 1->0</td>
<td class="rt">323</td>
<td class="rt">76</td>
<td class="rt">23.53 </td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>hclk</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>n_hreset</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>dma_bus_width[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>tx_dma_state_data</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>tx_data_strobe</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>frm_val_data_phase</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>hrdata[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>hrdata[127:32]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>hrdata_par[15:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>buffer_done_decode</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>last_buf_done_decode</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>last_access_bytes[2:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>last_access_bytes[4:3]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>tx_length_decrement[4:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>tx_buffer_offset[3:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>dma_w_fifo_count[3:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>dma_w_flush</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>force_fifo_eop_err</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>dma_w_data[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>dma_w_data[127:32]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>dma_w_data_par[15:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>dma_w_wr</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>dma_w_eop</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>dma_w_mod[1:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>dma_w_mod[3:2]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<hr>
<a name="Branch"></a>
Branch Coverage for Module : <a href="mod70.html" >edma_pbuf_tx_align</a><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s4">
<td>Branches</td>
<td></td>
<td class="rt">118</td>
<td class="rt">53</td>
<td class="rt">44.92 </td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">198</td>
<td class="rt">4</td>
<td class="rt">4</td>
<td class="rt">100.00</td>
</tr><tr class="s1">
<td>IF</td>
<td class="rt">231</td>
<td class="rt">17</td>
<td class="rt">2</td>
<td class="rt">11.76 </td>
</tr><tr class="s1">
<td>IF</td>
<td class="rt">261</td>
<td class="rt">17</td>
<td class="rt">2</td>
<td class="rt">11.76 </td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">287</td>
<td class="rt">2</td>
<td class="rt">2</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">312</td>
<td class="rt">6</td>
<td class="rt">6</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">342</td>
<td class="rt">2</td>
<td class="rt">2</td>
<td class="rt">100.00</td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">357</td>
<td class="rt">7</td>
<td class="rt">4</td>
<td class="rt">57.14 </td>
</tr><tr class="s3">
<td>CASE</td>
<td class="rt">395</td>
<td class="rt">3</td>
<td class="rt">1</td>
<td class="rt">33.33 </td>
</tr><tr class="s8">
<td>IF</td>
<td class="rt">417</td>
<td class="rt">5</td>
<td class="rt">4</td>
<td class="rt">80.00 </td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">433</td>
<td class="rt">4</td>
<td class="rt">4</td>
<td class="rt">100.00</td>
</tr><tr class="s6">
<td>IF</td>
<td class="rt">451</td>
<td class="rt">5</td>
<td class="rt">3</td>
<td class="rt">60.00 </td>
</tr><tr class="s2">
<td>IF</td>
<td class="rt">516</td>
<td class="rt">4</td>
<td class="rt">1</td>
<td class="rt">25.00 </td>
</tr><tr class="s1">
<td>IF</td>
<td class="rt">537</td>
<td class="rt">17</td>
<td class="rt">2</td>
<td class="rt">11.76 </td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">626</td>
<td class="rt">2</td>
<td class="rt">2</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">663</td>
<td class="rt">4</td>
<td class="rt">4</td>
<td class="rt">100.00</td>
</tr><tr class="s3">
<td>IF</td>
<td class="rt">687</td>
<td class="rt">8</td>
<td class="rt">3</td>
<td class="rt">37.50 </td>
</tr><tr class="s6">
<td>IF</td>
<td class="rt">722</td>
<td class="rt">5</td>
<td class="rt">3</td>
<td class="rt">60.00 </td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">769</td>
<td class="rt">2</td>
<td class="rt">2</td>
<td class="rt">100.00</td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">793</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">809</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
198            if (~n_hreset)
               <font color = "green">-1-</font>  
199            begin
200              first_txd_data  <= 1'b1;
           <font color = "green">      ==></font>
201              last_txd_data   <= 1'b0;
202            end
203        
204            // If flushing next data must be first in buffer
205            else if(dma_w_flush)
                    <font color = "green">-2-</font>  
206            begin
207              first_txd_data  <= 1'b1;
           <font color = "green">      ==></font>
208              last_txd_data   <= 1'b0;
209            end
210        
211            // at every data strobe in data state, check to see if buffer is done
212            else if(tx_data_strobe & tx_dma_state_data)
                    <font color = "green">-3-</font>  
213            begin
214              first_txd_data  <= buffer_done_decode;
           <font color = "green">      ==></font>
215              last_txd_data   <= last_buf_done_decode;
216            end
217        
218            // else maintain value for first_txd_data or zero last_txd_data
219            else
220            begin
221              first_txd_data  <= first_txd_data;
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
231            if (first_txd_data)
               <font color = "green">-1-</font>  
232              case (tx_buffer_offset)
                 <font color = "red">-2-</font>  
233                4'b0001 : txd_data_in = {8'h00, hrdata[127:8]};
           <font color = "red">        ==></font>
234                4'b0010 : txd_data_in = {16'd0, hrdata[127:16]};
           <font color = "red">        ==></font>
235                4'b0011 : txd_data_in = {24'd0, hrdata[127:24]};
           <font color = "red">        ==></font>
236                4'b0100 : txd_data_in = {32'd0, hrdata[127:32]};
           <font color = "red">        ==></font>
237                4'b0101 : txd_data_in = {40'd0, hrdata[127:40]};
           <font color = "red">        ==></font>
238                4'b0110 : txd_data_in = {48'd0, hrdata[127:48]};
           <font color = "red">        ==></font>
239                4'b0111 : txd_data_in = {56'd0, hrdata[127:56]};
           <font color = "red">        ==></font>
240                4'b1000 : txd_data_in = {64'd0, hrdata[127:64]};
           <font color = "red">        ==></font>
241                4'b1001 : txd_data_in = {72'd0, hrdata[127:72]};
           <font color = "red">        ==></font>
242                4'b1010 : txd_data_in = {80'd0, hrdata[127:80]};
           <font color = "red">        ==></font>
243                4'b1011 : txd_data_in = {88'd0, hrdata[127:88]};
           <font color = "red">        ==></font>
244                4'b1100 : txd_data_in = {96'd0, hrdata[127:96]};
           <font color = "red">        ==></font>
245                4'b1101 : txd_data_in = {104'd0,hrdata[127:104]};
           <font color = "red">        ==></font>
246                4'b1110 : txd_data_in = {112'd0,hrdata[127:112]};
           <font color = "red">        ==></font>
247                4'b1111 : txd_data_in = {120'd0,hrdata[127:120]};
           <font color = "red">        ==></font>
248                default : txd_data_in =         hrdata[127:0];
           <font color = "green">        ==></font>
249              endcase
250            else
251              txd_data_in = hrdata;
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b0001 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b0010 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b0011 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b0100 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b0101 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b0110 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b0111 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b1000 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b1001 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b1010 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b1011 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b1100 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b1101 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b1110 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b1111 </td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>default</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
261            if (first_txd_data)
               <font color = "green">-1-</font>  
262              case (tx_buffer_offset)
                 <font color = "red">-2-</font>  
263                4'b0001 : txd_par_in  = {1'b0,  hrdata_par[15:1]};
           <font color = "red">        ==></font>
264                4'b0010 : txd_par_in  = {2'd0,  hrdata_par[15:2]};
           <font color = "red">        ==></font>
265                4'b0011 : txd_par_in  = {3'd0,  hrdata_par[15:3]};
           <font color = "red">        ==></font>
266                4'b0100 : txd_par_in  = {4'd0,  hrdata_par[15:4]};
           <font color = "red">        ==></font>
267                4'b0101 : txd_par_in  = {5'd0,  hrdata_par[15:5]};
           <font color = "red">        ==></font>
268                4'b0110 : txd_par_in  = {6'd0,  hrdata_par[15:6]};
           <font color = "red">        ==></font>
269                4'b0111 : txd_par_in  = {7'd0,  hrdata_par[15:7]};
           <font color = "red">        ==></font>
270                4'b1000 : txd_par_in  = {8'd0,  hrdata_par[15:8]};
           <font color = "red">        ==></font>
271                4'b1001 : txd_par_in  = {9'd0,  hrdata_par[15:9]};
           <font color = "red">        ==></font>
272                4'b1010 : txd_par_in  = {10'd0, hrdata_par[15:10]};
           <font color = "red">        ==></font>
273                4'b1011 : txd_par_in  = {11'd0, hrdata_par[15:11]};
           <font color = "red">        ==></font>
274                4'b1100 : txd_par_in  = {12'd0, hrdata_par[15:12]};
           <font color = "red">        ==></font>
275                4'b1101 : txd_par_in  = {13'd0, hrdata_par[15:13]};
           <font color = "red">        ==></font>
276                4'b1110 : txd_par_in  = {14'd0, hrdata_par[15:14]};
           <font color = "red">        ==></font>
277                4'b1111 : txd_par_in  = {15'd0, hrdata_par[15]};
           <font color = "red">        ==></font>
278                default : txd_par_in  = hrdata_par;
           <font color = "green">        ==></font>
279              endcase
280            else
281              txd_par_in  = hrdata_par;
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b0001 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b0010 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b0011 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b0100 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b0101 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b0110 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b0111 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b1000 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b1001 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b1010 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b1011 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b1100 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b1101 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b1110 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'b1111 </td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>default</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
287            if (~n_hreset)
               <font color = "green">-1-</font>  
288              txd_data  <= 128'd0;
           <font color = "green">      ==></font>
289            else
290              txd_data  <= txd_data_in;
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
312            if (~n_hreset)
               <font color = "green">-1-</font>  
313              no_txd_data <= 5'b00000;
           <font color = "green">      ==></font>
314        
315            // clear on a flush
316            else if (dma_w_flush)
                    <font color = "green">-2-</font>  
317              no_txd_data <= 5'b00000;
           <font color = "green">      ==></font>
318        
319            // final data phase in buffer, so take how much is left.
320            else if (tx_data_strobe & buffer_done_decode & tx_dma_state_data)
                    <font color = "green">-3-</font>  
321              no_txd_data <= last_access_bytes[4:0];
           <font color = "green">      ==></font>
322        
323            // first data phase in buffer, so calculate amount of
324            // data for full word minus the offset.
325            else if (tx_data_strobe & first_txd_data & tx_dma_state_data)
                    <font color = "green">-4-</font>  
326              no_txd_data <= (tx_length_decrement[4:0] - {1'b0, tx_buffer_offset});
           <font color = "green">      ==></font>
327        
328            // data transfer in middle of buffer, so full transfer
329            else if (tx_data_strobe & tx_dma_state_data)
                    <font color = "green">-5-</font>  
330              no_txd_data <= tx_length_decrement[4:0];
           <font color = "green">      ==></font>
331        
332            // else maintain value
333            else
334              no_txd_data <= no_txd_data[4:0];
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
342            if (~n_hreset)
               <font color = "green">-1-</font>  
343              new_txd_data  <= 1'b0;
           <font color = "green">      ==></font>
344            else
345              new_txd_data  <= tx_data_strobe & tx_dma_state_data;
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
357            if (~n_hreset)
               <font color = "green">-1-</font>  
358              align_pntr  <= 4'h0;
           <font color = "green">      ==></font>
359        
360            // If main state machine is idle, or last aligned data has been
361            // processed, then reset alignment pointer to byte 0
362            else if (dma_w_flush | force_fifo_eop_err | last_aligned_data)
                    <font color = "green">-2-</font>                         
363              align_pntr  <= 4'h0;
           <font color = "green">      ==></font>
364        
365            // If last data transfered has overflowed a new transfer will
366            // be initiated. Zero pointer after this event
367            // Note that if this event doesn't happen then the pointer will
368            // already be zero (no overflow)
369            else if (force_over_align)
                    <font color = "red">-3-</font>  
370              align_pntr  <= 4'h0;
           <font color = "red">      ==></font>
371        
372            // When new txd data available, assign align_pntr to new value
373            else if (new_txd_data)
                    <font color = "green">-4-</font>  
374              case (dma_bus_width)
                 <font color = "red">-5-</font>  
375                2'b00   : align_pntr  <= {2'b00,next_align_pntr[1:0]};
           <font color = "green">        ==></font>
376                2'b01   : align_pntr  <= {1'b0, next_align_pntr[2:0]};
           <font color = "red">        ==></font>
377                default : align_pntr  <= next_align_pntr[3:0];
           <font color = "red">        ==></font>
378              endcase
379        
380            // Else maintain value
381            else
382              align_pntr  <= align_pntr;
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>2'b00 </td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>2'b01 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>default</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
395            case (dma_bus_width)
               <font color = "red">-1-</font>  
396              2'b00   : begin
397                next_align_full     = next_align_pntr[2];
           <font color = "green">        ==></font>
398                next_align_overflow = next_align_pntr[2] & (next_align_pntr[1:0] != 2'b00);
399              end
400              2'b01   : begin
401                next_align_full     = next_align_pntr[3];
           <font color = "red">        ==></font>
402                next_align_overflow = next_align_pntr[3] & (next_align_pntr[2:0] != 3'b000);
403              end
404              default : begin
405                next_align_full     = next_align_pntr[4];
           <font color = "red">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>2'b00 </td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>2'b01 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>default</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
417            if (~n_hreset)
               <font color = "green">-1-</font>  
418              prev_align_overflowd  <= 1'b0;
           <font color = "green">      ==></font>
419            else if (dma_w_flush | force_fifo_eop_err | last_aligned_data)
                    <font color = "green">-2-</font>                         
420              prev_align_overflowd  <= 1'b0;
           <font color = "green">      ==></font>
421            else if (new_txd_data & next_align_overflow)
                    <font color = "red">-3-</font>  
422              prev_align_overflowd  <= 1'b1;
           <font color = "red">      ==></font>
423            else if (new_txd_data | force_over_align)
                    <font color = "green">-4-</font>  
424              prev_align_overflowd  <= 1'b0;
           <font color = "green">      ==></font>
425            else
426              prev_align_overflowd  <= prev_align_overflowd;
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
433            if (~n_hreset)
               <font color = "green">-1-</font>  
434              last_aligned_data <= 1'b0;
           <font color = "green">      ==></font>
435            else if (dma_w_flush | force_fifo_eop_err)
                    <font color = "green">-2-</font>                         
436              last_aligned_data <= 1'b0;
           <font color = "green">      ==></font>
437            else if ((last_txd_data & ~next_align_overflow) | force_over_align)
                    <font color = "green">-3-</font>  
438              last_aligned_data <= 1'b1;
           <font color = "green">      ==></font>
439            else
440              last_aligned_data <= 1'b0;
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
451            if (~n_hreset)
               <font color = "green">-1-</font>  
452            begin
453              force_over_align  <= 1'b0;
           <font color = "green">      ==></font>
454              force_over_store  <= 1'b0;
455            end
456        
457            // reset if main state machine is idle or there is a flush
458            else if (dma_w_flush | force_fifo_eop_err)
                    <font color = "green">-2-</font>                         
459            begin
460              force_over_align  <= 1'b0;
           <font color = "green">      ==></font>
461              force_over_store  <= 1'b0;
462            end
463        
464            // if a force overflow has been stored and there is now enough room,
465            // then we can now force the final push.
466            else if (force_over_store & fifo_free_slots_one)
                    <font color = "red">-3-</font>                        
467            begin
468              force_over_align  <= 1'b1;
           <font color = "red">      ==></font>
469              force_over_store  <= 1'b0;
470            end
471        
472            // Last data has now been loaded into the alignment buffer. If it
473            // overflowed then we will need to force the overflow as the final write.
474            // Can only signal this when we know there are enough free slots,
475            // otherwise store until there is.
476            else if (last_txd_data & next_align_overflow)
                    <font color = "red">-4-</font>  
477            begin
478              force_over_align  <= fifo_free_slots_one;
           <font color = "red">      ==></font>
479              force_over_store  <= ~fifo_free_slots_one;
480            end
481        
482            // else continue to hold stored value, but zero force_over_align, to
483            // ensure that it is only a pulse.
484            else
485            begin
486              force_over_align  <= 1'b0;
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
516            if ((new_txd_data & prev_align_overflowd) | force_over_align)
               <font color = "red">-1-</font>  
517            begin
518              case (dma_bus_width)
                 <font color = "red">-2-</font>  
519                2'b00   : begin
520                  txd_data_align_nxt[31:0]  = txd_data_align_nxt[63:32];
           <font color = "red">          ==></font>
521                  txd_par_align_nxt[3:0]    = txd_par_align_nxt[7:4];
522                end
523                2'b01   : begin
524                  txd_data_align_nxt[63:0]  = txd_data_align_nxt[127:64];
           <font color = "red">          ==></font>
525                  txd_par_align_nxt[7:0]    = txd_par_align_nxt[15:8];
526                end
527                default : begin
528                  txd_data_align_nxt[119:0] = txd_data_align_nxt[247:128];
           <font color = "red">          ==></font>
529                  txd_par_align_nxt[14:0]   = txd_par_align_nxt[30:16];
530                end
531              endcase
532            end
               MISSING_ELSE
           <font color = "green">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center>2'b00 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>2'b01 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>default</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
537            if (new_txd_data)
               <font color = "green">-1-</font>  
538            begin
539              case (align_pntr)
                 <font color = "red">-2-</font>  
540                4'h1:
541                begin
542                  txd_data_align_nxt[135:8]   = txd_data[127:0];
           <font color = "red">          ==></font>
543                  txd_par_align_nxt[16:1]     = txd_par[15:0];
544                end
545                4'h2:
546                begin
547                  txd_data_align_nxt[143:16]  = txd_data[127:0];
           <font color = "red">          ==></font>
548                  txd_par_align_nxt[17:2]     = txd_par[15:0];
549                end
550                4'h3:
551                begin
552                  txd_data_align_nxt[151:24]  = txd_data[127:0];
           <font color = "red">          ==></font>
553                  txd_par_align_nxt[18:3]     = txd_par[15:0];
554                end
555                4'h4:
556                begin
557                  txd_data_align_nxt[159:32]  = txd_data[127:0];
           <font color = "red">          ==></font>
558                  txd_par_align_nxt[19:4]     = txd_par[15:0];
559                end
560                4'h5:
561                begin
562                  txd_data_align_nxt[167:40]  = txd_data[127:0];
           <font color = "red">          ==></font>
563                  txd_par_align_nxt[20:5]     = txd_par[15:0];
564                end
565                4'h6:
566                begin
567                  txd_data_align_nxt[175:48]  = txd_data[127:0];
           <font color = "red">          ==></font>
568                  txd_par_align_nxt[21:6]     = txd_par[15:0];
569                end
570                4'h7:
571                begin
572                  txd_data_align_nxt[183:56]  = txd_data[127:0];
           <font color = "red">          ==></font>
573                  txd_par_align_nxt[22:7]     = txd_par[15:0];
574                end
575                4'h8:
576                begin
577                  txd_data_align_nxt[191:64]  = txd_data[127:0];
           <font color = "red">          ==></font>
578                  txd_par_align_nxt[23:8]     = txd_par[15:0];
579                end
580                4'h9:
581                begin
582                  txd_data_align_nxt[199:72]  = txd_data[127:0];
           <font color = "red">          ==></font>
583                  txd_par_align_nxt[24:9]     = txd_par[15:0];
584                end
585                4'ha:
586                begin
587                  txd_data_align_nxt[207:80]  = txd_data[127:0];
           <font color = "red">          ==></font>
588                  txd_par_align_nxt[25:10]    = txd_par[15:0];
589                end
590                4'hb:
591                begin
592                  txd_data_align_nxt[215:88]  = txd_data[127:0];
           <font color = "red">          ==></font>
593                  txd_par_align_nxt[26:11]    = txd_par[15:0];
594                end
595                4'hc:
596                begin
597                  txd_data_align_nxt[223:96]  = txd_data[127:0];
           <font color = "red">          ==></font>
598                  txd_par_align_nxt[27:12]    = txd_par[15:0];
599                end
600                4'hd:
601                begin
602                  txd_data_align_nxt[231:104] = txd_data[127:0];
           <font color = "red">          ==></font>
603                  txd_par_align_nxt[28:13]    = txd_par[15:0];
604                end
605                4'he:
606                begin
607                  txd_data_align_nxt[239:112] = txd_data[127:0];
           <font color = "red">          ==></font>
608                  txd_par_align_nxt[29:14]    = txd_par[15:0];
609                end
610                4'hf:
611                begin
612                  txd_data_align_nxt[247:120] = txd_data[127:0];
           <font color = "red">          ==></font>
613                  txd_par_align_nxt[30:15]    = txd_par[15:0];
614                end
615                default:
616                begin
617                  txd_data_align_nxt[127:0]   = txd_data[127:0];
           <font color = "green">          ==></font>
618                  txd_par_align_nxt[15:0]     = txd_par[15:0];
619                end
620              endcase
621            end
               MISSING_ELSE
           <font color = "green">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'h1 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'h2 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'h3 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'h4 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'h5 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'h6 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'h7 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'h8 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'h9 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'ha </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'hb </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'hc </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'hd </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'he </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>1</td>
<td align=center>4'hf </td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>1</td>
<td align=center>default</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
626            if (~n_hreset)
               <font color = "green">-1-</font>  
627              txd_data_align  <= 248'd0;
           <font color = "green">      ==></font>
628            else
629              txd_data_align  <= txd_data_align_nxt;
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
663            if (~n_hreset)
               <font color = "green">-1-</font>  
664              dma_w_wr_gen  <= 1'b0;
           <font color = "green">      ==></font>
665            else if (dma_w_flush | force_fifo_eop_err | last_aligned_data)
                    <font color = "green">-2-</font>                         
666              dma_w_wr_gen  <= 1'b0;
           <font color = "green">      ==></font>
667            else if ((next_align_full & new_txd_data) |
                    <font color = "green">-3-</font>  
668                     (last_txd_data & ~next_align_overflow) |
669                     force_over_align)
670              dma_w_wr_gen  <= 1'b1;
           <font color = "green">      ==></font>
671            else
672              dma_w_wr_gen  <= 1'b0;
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
687            if (~n_hreset)
               <font color = "green">-1-</font>  
688              dma_w_mod <= 4'h0;
           <font color = "green">      ==></font>
689        
690            // if last data is not going to overflow buffer then take next_align_pntr.
691            else if (last_txd_data & ~next_align_overflow)
                    <font color = "green">-2-</font>  
692              case (dma_bus_width)
                 <font color = "red">-3-</font>  
693                2'b00   : dma_w_mod <= {2'b00,next_align_pntr[1:0]};
           <font color = "green">        ==></font>
694                2'b01   : dma_w_mod <= {1'b0, next_align_pntr[2:0]};
           <font color = "red">        ==></font>
695                default : dma_w_mod <= next_align_pntr[3:0];
           <font color = "red">        ==></font>
696              endcase
697        
698            // if last data overflowed the buffer then take align_pntr.
699            else if (force_over_align)
                    <font color = "red">-4-</font>  
700              case (dma_bus_width)
                 <font color = "red">-5-</font>  
701                2'b00   : dma_w_mod <= {2'b00,align_pntr[1:0]};
           <font color = "red">        ==></font>
702                2'b01   : dma_w_mod <= {1'b0, align_pntr[2:0]};
           <font color = "red">        ==></font>
703                default : dma_w_mod <= align_pntr[3:0];
           <font color = "red">        ==></font>
704              endcase
705        
706            // Else indicate full 16 bytes
707            else
708              dma_w_mod <= 4'h0;
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center>2'b00 </td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td align=center>2'b01 </td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td align=center>default</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>2'b00 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>2'b01 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>default</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
722            if (~n_hreset)
               <font color = "green">-1-</font>  
723            begin
724              force_eop_err_store <= 1'b0;
           <font color = "green">      ==></font>
725              force_eop_err       <= 1'b0;
726            end
727        
728            // clear on a flush
729            else if(dma_w_flush)
                    <font color = "green">-2-</font>  
730            begin
731              force_eop_err_store <= 1'b0;
           <font color = "green">      ==></font>
732              force_eop_err       <= 1'b0;
733            end
734        
735            // if a force_fifo_eop_err has been stored and there is now enough room,
736            // then we can now force the final push.
737            else if ((force_fifo_eop_err | force_eop_err_store) & fifo_free_slots_one)
                    <font color = "red">-3-</font>                                                  
738            begin
739              force_eop_err_store <= 1'b0;
           <font color = "red">      ==></font>
740              force_eop_err       <= 1'b1;
741            end
742        
743            // if a force_fifo_eop_err happens and there is not enough room,
744            // then store as force_eop_err_store.
745            else if (force_fifo_eop_err)
                    <font color = "red">-4-</font>           
746            begin
747              force_eop_err_store <= 1'b1;
           <font color = "red">      ==></font>
748              force_eop_err       <= 1'b0;
749            end
750        
751            // else continue to hold stored value
752            else
753            begin
754              force_eop_err_store <= force_eop_err_store;
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
769            if (~n_hreset)
               <font color = "green">-1-</font>  
770              dma_w_wr_del  <= 1'b0;
           <font color = "green">      ==></font>
771            else
772              dma_w_wr_del  <= dma_w_wr;
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
793            if (dma_w_fifo_count_p_accesses_left[TX_FIFO_CNT_WIDTH-1:0] > TX_BASE2_FIFO_SIZE)
               <font color = "red">-1-</font>           
794              next_free_slots = {(TX_FIFO_CNT_WIDTH + 1){1'b0}};
           <font color = "red">      ==></font>
795        
796            // else take away the adjusted count value from the depth to get the
797            // number of free slots available
798            else
799              next_free_slots = TX_BASE2_FIFO_SIZE - (dma_w_fifo_count[(TX_FIFO_CNT_WIDTH -1):0] + accesses_left);
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
809            if (next_free_slots >= {{TX_FIFO_CNT_WIDTH{1'b0}},1'b1})
               <font color = "red">-1-</font>  
810              fifo_free_slots_one = 1'b1;
           <font color = "green">      ==></font>
811        
812            // else block any requests for more DMA activity.
813            else
814              fifo_free_slots_one = 1'b0;
           <font color = "red">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
</div>
</div>
<div class="ui-layout-center-inner-north">
<div id="center-bread-crumb" class="breadCrumb module urg-margin-bottom">
  <ul name="tag_edma_pbuf_tx_align">
    <li>
      <a href="#Line">Line</a>    </li>
    <li>
      <a href="#Toggle">Toggle</a>    </li>
    <li>
      <a href="#Branch">Branch</a>    </li>
  </ul>
</div>
</div>
</div>
<div class="ui-layout-south">
<table align=center><tr><td class="s0 cl">0%</td>
<td class="s1 cl">10%</td>
<td class="s2 cl">20%</td>
<td class="s3 cl">30%</td>
<td class="s4 cl">40%</td>
<td class="s5 cl">50%</td>
<td class="s6 cl">60%</td>
<td class="s7 cl">70%</td>
<td class="s8 cl">80%</td>
<td class="s9 cl">90%</td>
<td class="s10 cl">100%</td></tr></table></div>
</body>
</html>
