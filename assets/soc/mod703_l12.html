<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="Author" content="<username>"> <meta name="GENERATOR" content="urg/version [en] (platform name) [urg]">
<title>Unified Coverage Report :: Line split page</title>
<link type="text/css" rel="stylesheet" href="css/.urg.css">
<link type="text/css" rel="stylesheet" href="css/.layout.css">
<script type="text/javascript" src="js/.jquery.js"></script>
<script type="text/javascript" src="js/.jquery-ui.js"></script>
<script type="text/javascript" src="js/.sortable.js"></script>
<script type="text/javascript" src="js/.colResizable.js"></script>
<script type="text/javascript" src="js/.layout.js"></script>
<script type="text/javascript">
var layout, westLayout, centerLayout;
$(document).ready(function () {
  layout = $("body").layout({ 
    resizable: true,
    spacing_open: 4,
    spacing_closed: 4,
    north: {
      size: 76
    },
    south: {
      size: 45,
      initClosed: true
    }  });
  $("table").colResizable({    liveDrag:true,
    fixed:false,
    draggingClass:"dragging"
  });
});
</script>
</head>
<body><div class="ui-layout-north">
<div class="logo"></div>
<center class="pagetitle">Line split page</center>
<div align="center"><a href="dashboard.html" ><b>dashboard</b></a> | <a href="hierarchy.html" ><b>hierarchy</b></a> | <a href="modlist.html" ><b>modlist</b></a> | groups | <a href="tests.html" ><b>tests</b></a> | <a href="asserts.html" ><b>asserts</b></a></div>

</div>
<div class="ui-layout-center">
Go <a href="mod703.html#l12">back</a>
<pre class="code"><br clear=all>
951                       always@(posedge hclk or negedge n_hreset)
952        1/1              if (~n_hreset) begin
953        1/1                rxdpram_dob_reg &lt;= {p_edma_rx_pbuf_data{1'b0}};
954        1/1                status_word_read &lt;= 1'b0;
955                         end
956                         else begin
957        1/1                if (rxdpram_enb)
958                           begin
959        1/1                  if ( dpram_rd_state == P_STATUS_WORD_1 ||
960                                  dpram_rd_state == P_STATUS_WORD_2 ||
961                                  dpram_rd_state == P_STATUS_WORD_3 ||
962                                  dpram_rd_state == P_STATUS_WORD_4 )
963        1/1                    status_word_read &lt;= 1'b1;
964                             else
965        1/1                    status_word_read &lt;= 1'b0;
966                           end
                        MISSING_ELSE
967        1/1                if (!status_word_read &amp;&amp; rxdpram_enb_d1)
968        1/1                  rxdpram_dob_reg &lt;= rxdpram_dob;
                        MISSING_ELSE
969                         end
970                     
971                       generate if (p_edma_asf_dap_prot == 1) begin : gen_dpram_dob_par
972                         reg [p_edma_rx_pbuf_pwid-1:0] rxdpram_dob_par_r;
973                         always@(posedge hclk or negedge n_hreset)
974                         begin
975                           if (~n_hreset)
976                             rxdpram_dob_par_r &lt;= {p_edma_rx_pbuf_pwid{1'b0}};
977                           else if (!status_word_read &amp;&amp; rxdpram_enb_d1)
978                             rxdpram_dob_par_r &lt;= rxdpram_dob_par;
979                         end
980                         assign rxdpram_dob_par_reg  = rxdpram_dob_par_r;
981                       end else begin : gen_no_dpram_dob_par
982                         assign rxdpram_dob_par_reg  = {p_edma_rx_pbuf_pwid{1'b0}};
983                       end
984                       endgenerate
985                     
986                       assign rxdpram_dob_status_muxed     = (status_word_read | !rxdpram_enb_d1) ? rxdpram_dob_reg      : rxdpram_dob;
987                       assign rxdpram_dob_status_par_muxed = (status_word_read | !rxdpram_enb_d1) ? rxdpram_dob_par_reg  : rxdpram_dob_par;
988                     
989                     
990                     
991                       // Create a handy array to keep the base addresses in - makes coding slightly
992                       // neater. Also pass the current descriptor pointer back to the register block
993                       // Similar handy uncrompressing of the array for the fill level
994                       wire [p_awid_par-1:0] rx_dma_base_addr_arr[15:0]; // Handy array to de-serialise the incoming signal
995                       wire [7:0] rx_buffer_size_array [15:0]; // Handy array to de-serialise the incoming signal
996                       generate for (g=0; g&lt;p_edma_queues; g=g+1) begin : gen_rx_dma_descr_base_addr
997                         if (p_edma_asf_dap_prot == 1) begin : gen_base_arr_par
998                           assign rx_dma_base_addr_arr[g] = {rx_dma_descr_base_par[(g*4)+3:(g*4)],
999                                                                       rx_dma_descr_base_addr[(g*32)+31:(g*32)]};
1000                        end else begin : gen_no_base_arr_par
1001                          assign rx_dma_base_addr_arr[g] = rx_dma_descr_base_addr[(g*32)+31:(g*32)];
1002                        end
1003                        assign rx_buffer_size_array[g] = rx_dma_buffer_size[(g*8)+7:g*8];
1004                      end
1005                      endgenerate
1006                    
1007                    
1008                      // The purpose of the pad signals is to stop a number of warnings that occur
1009                      // when data bus width are less than the maximum size.
1010                      generate if (p_edma_bus_width &lt; 32'd128) begin : gen_dsz_pad
1011                        assign rxdpram_dob_downsize_pad     = {{(128-p_edma_bus_width){1'b0}},rxdpram_dob_downsize};
1012                        assign rxdpram_dob_downsize_par_pad = {{(16-p_edma_bus_pwid){1'b0}},rxdpram_dob_downsize_par};
1013                      end else begin : gen_no_dsz_pad
1014                        assign rxdpram_dob_downsize_pad     = rxdpram_dob_downsize;
1015                        assign rxdpram_dob_downsize_par_pad = rxdpram_dob_downsize_par;
1016                      end
1017                      endgenerate
1018                    
1019                      // Similarly for the RAM data
1020                      assign rxdpram_dob_pad     = {{(129-p_edma_rx_pbuf_data){1'b0}},rxdpram_dob};
1021                      assign rxdpram_dob_par_pad = {{(17-p_edma_rx_pbuf_pwid){1'b0}},rxdpram_dob_par};
1022                    
1023                      // Create 32-bit data words for rxdpram_dob_pad with optional parity
1024                      // for easier assignment later
1025                      wire  [35:0]  rxdpram_dob_w0p;
1026                      wire  [35:0]  rxdpram_dob_w1p;
1027                      wire  [35:0]  rxdpram_dob_w2p;
1028                      wire  [35:0]  rxdpram_dob_w3p;
1029                      assign rxdpram_dob_w0p  = {rxdpram_dob_par_pad[3:0],  rxdpram_dob_pad[31:0]};
1030                      assign rxdpram_dob_w1p  = {rxdpram_dob_par_pad[7:4],  rxdpram_dob_pad[63:32]};
1031                      assign rxdpram_dob_w2p  = {rxdpram_dob_par_pad[11:8], rxdpram_dob_pad[95:64]};
1032                      assign rxdpram_dob_w3p  = {rxdpram_dob_par_pad[15:12],rxdpram_dob_pad[127:96]};
1033                    
1034                      // Similarly for the cutthru data
1035                      wire  [35:0]  ct_fifo_w0p;
1036                      wire  [35:0]  ct_fifo_w1p;
1037                      wire  [35:0]  ct_fifo_w2p;
1038                      wire  [35:0]  ct_fifo_w3p;
1039                      assign ct_fifo_w0p  = {cutthru_status_word_par[3:0],  cutthru_status_word[31:0]};
1040                      assign ct_fifo_w1p  = {cutthru_status_word_par[7:4],  cutthru_status_word[63:32]};
1041                      assign ct_fifo_w2p  = {cutthru_status_word_par[11:8], cutthru_status_word[95:64]};
1042                    
1043                      // The next status word only exists if TSU is present
1044                      generate if (p_edma_tsu == 1) begin : gen_ct_ts_sw
1045                        assign ct_fifo_w3p  = {cutthru_status_word_par[15:12],cutthru_status_word[127:96]};
1046                      end else begin : gen_no_ct_ts_sw
1047                        assign ct_fifo_w3p  = {36{1'b0}};
1048                      end
1049                      endgenerate
1050                    
1051                      // Based on the incoming AHB signals, we can create some strobes that
1052                      // relate to the request phase, address phase and data phases for the
1053                      // specific MASTER's.  Note that internally, there is only 1 MASTER
1054                      // that drives 2 MASTER ports based on the state of the main state machine
1055                      // in this module - this is done so that the AHB system arbiter can
1056                      // prioritise TX descriptors over RX data, etc
1057                      //
1058                      // Firstly create the request phase strobes for the management descriptors ...
1059                      // the Descriptor RD state stays active until the data associated with the
1060                      // descriptor has been returned + 1 cycle
1061                      // When we are in 32 bit mode, the man_rd state
1062                      assign        ahbreqph_strobe_descr  =    (hready &amp; hbusreq &amp; hgrant_descr &amp;
1063                                                                (rx_dma_state_man_rd | rx_dma_state_man_wr));
1064                    
1065                      assign        ahbreqph_strobe_descr_rd  = (hready &amp; hbusreq &amp; hgrant_descr &amp;
1066                                                                (rx_dma_state_man_rd |
1067                                                                 (rx_dma_state_man_wr &amp; rx_dma_next_man_rd)));
1068                    
1069                      //
1070                      // Firstly create the request phase strobes for the pkt data ...
1071                      assign        ahbreqph_strobe_data  =
1072                                           (hready &amp;
1073                                           (~last_data_to_buff_aph | padding_rph) &amp;// Block last address phase
1074                                            hbusreq &amp;
1075                                            rx_dma_state == RX_DMA_DATA_STORE &amp;
1076                                            hgrant_data);
1077                    
1078                      always@(posedge hclk or negedge n_hreset)
1079                      begin
1080       1/1              if (~n_hreset)
1081                        begin
1082       1/1                ahbaddph_strobe_en_descr  &lt;= 1'b0;
1083       1/1                ahbdataph_strobe_en_descr &lt;= 1'b0;
1084       1/1                ahbaddph_strobe_en_data   &lt;= 1'b0;
1085       1/1                ahbdataph_strobe_en_data  &lt;= 1'b0;
1086       1/1                ahbaddph_strobe_en_descr_rd  &lt;= 1'b0;
1087       1/1                ahbdataph_strobe_en_descr_rd  &lt;= 1'b0;
1088                        end
1089                        else
1090                        begin
1091       1/1                if (hready)
1092                          begin
1093                            // Descriptor reads and writes
1094       1/1                  ahbaddph_strobe_en_descr &lt;= ahbreqph_strobe_descr;
1095       1/1                  ahbdataph_strobe_en_descr &lt;= ahbaddph_strobe_en_descr;
1096       1/1                  ahbaddph_strobe_en_data  &lt;= ahbreqph_strobe_data;
1097       1/1                  ahbdataph_strobe_en_data  &lt;= ahbaddph_strobe_en_data;
1098                    
1099                            // Descriptor reads only
1100       1/1                  ahbaddph_strobe_en_descr_rd  &lt;= ahbreqph_strobe_descr_rd;
1101       1/1                  ahbdataph_strobe_en_descr_rd &lt;= ahbaddph_strobe_en_descr_rd;
1102                    
1103                          end
                        MISSING_ELSE
1104                        end
1105                      end
1106                    
1107                    
1108                      assign ahbaddph_strobe_descr_rd   = ahbaddph_strobe_en_descr_rd &amp; hready;
1109                      assign ahbdataph_strobe_descr_rd   = ahbdataph_strobe_en_descr_rd &amp; hready;
1110                    
1111                      assign ahbaddph_strobe_descr   = ahbaddph_strobe_en_descr &amp; hready;
1112                      assign ahbdataph_strobe_descr   = ahbdataph_strobe_en_descr &amp; hready;
1113                      assign ahbaddph_strobe_data    = ahbaddph_strobe_en_data &amp; hready;
1114                      assign ahbdataph_strobe_data    = ahbdataph_strobe_en_data &amp; hready;
1115                    
1116                      assign hresp_not_ok           = (hresp != 2'b00) &amp; (ahbdataph_strobe_descr |
1117                                                                          ahbdataph_strobe_data)
1118                                                                          &amp; ~hresp_notok_hold;
1119                    
1120                      // HRESP is only taken into account at the end of the current burst ...
1121                      always @(*)
1122                      begin
1123       1/1              if (hresp_not_ok | hresp_notok_hold)
1124                        begin
1125       <font color = "red">0/1     ==>        if (|hburst[2:1])</font>
1126       <font color = "red">0/1     ==>          hresp_notok_eob  = (ahb_access_cnt == 4'h0 &amp; ahbdataph_strobe_data);</font>
1127                          else
1128       <font color = "red">0/1     ==>          hresp_notok_eob  = ahbdataph_strobe_data | ahbdataph_strobe_descr;</font>
1129                        end
1130                        else
1131       1/1                hresp_notok_eob  = 1'b0;
1132                      end
1133                    
1134                      always @(*)
1135                      begin
1136       1/1              if (hresp_not_ok | hresp_notok_hold)
1137                        begin
1138       <font color = "red">0/1     ==>        if (|hburst[2:1])</font>
1139       <font color = "red">0/1     ==>          hresp_notok_eob_rph  = ((last_access_burst_req | ahb_access_cnt == 4'h0) &amp;</font>
1140                                                    ahbdataph_strobe_data);
1141                          else
1142       <font color = "red">0/1     ==>          hresp_notok_eob_rph  = ahbdataph_strobe_data | ahbdataph_strobe_descr;</font>
1143                        end
1144                        else
1145       1/1                hresp_notok_eob_rph  = 1'b0;
1146                      end
1147                    
1148                    
1149                    // -----------------------------------------------------------------------------
1150                    // AHB read and write databus handling
1151                    // -----------------------------------------------------------------------------
1152                    
1153                       // Work out whether to endian swap on this access depending on the programmed
1154                       // mode. endian_swap[0] indicates the desired endianism for management
1155                       // operations and endian_swap[1] indicates the endianism for data operations.
1156                       assign endian_swap_now = ((endian_swap[0] &amp; ~rx_dma_state_data) |
1157                                                 (endian_swap[1] &amp;  rx_dma_state_data));
1158                    
1159                    
1160                       // dma_data_out_endian - Byte endian swapped version of write data.
1161                       //                       Bytes only swapped within each 32-bit word
1162                       //                       and then each word is later aligned to correct
1163                       //                       word within the wider bus.
1164                       //                         byte 0  =&gt; byte 3
1165                       //                         byte 1  =&gt; byte 2
1166                       //                         byte 2  =&gt; byte 1
1167                       //                         byte 3  =&gt; byte 0
1168                       //                         byte 4  =&gt; byte 7
1169                       //                         byte 5  =&gt; byte 6
1170                       //                         byte 6  =&gt; byte 5
1171                       //                         byte 7  =&gt; byte 4
1172                       //------------------------------------------------
1173                       always @(*)
1174                        begin
1175       1/1                if (endian_swap_now)
1176                           begin
1177       <font color = "red">0/1     ==>           dma_data_out_endian = {rx_dma_data_out[103:96],</font>
1178                                                    rx_dma_data_out[111:104],
1179                                                    rx_dma_data_out[119:112],
1180                                                    rx_dma_data_out[127:120],
1181                                                    rx_dma_data_out[71:64],
1182                                                    rx_dma_data_out[79:72],
1183                                                    rx_dma_data_out[87:80],
1184                                                    rx_dma_data_out[95:88],
1185                                                    rx_dma_data_out[39:32],
1186                                                    rx_dma_data_out[47:40],
1187                                                    rx_dma_data_out[55:48],
1188                                                    rx_dma_data_out[63:56],
1189                                                    rx_dma_data_out[7:0],
1190                                                    rx_dma_data_out[15:8],
1191                                                    rx_dma_data_out[23:16],
1192                                                    rx_dma_data_out[31:24]};
1193                           end
1194                          else
1195                           begin
1196       1/1                   dma_data_out_endian = rx_dma_data_out;
1197                           end
1198                        end
1199                       //   Bit endian swapped version of parity off write data.
1200                       always @(*)
1201                        begin
1202       1/1                if (endian_swap_now)
1203                           begin
1204       <font color = "red">0/1     ==>           dma_data_out_endian_par = {rx_dma_data_out_par[12],</font>
1205                                                    rx_dma_data_out_par[13],
1206                                                    rx_dma_data_out_par[14],
1207                                                    rx_dma_data_out_par[15],
1208                                                    rx_dma_data_out_par[8],
1209                                                    rx_dma_data_out_par[9],
1210                                                    rx_dma_data_out_par[10],
1211                                                    rx_dma_data_out_par[11],
1212                                                    rx_dma_data_out_par[4],
1213                                                    rx_dma_data_out_par[5],
1214                                                    rx_dma_data_out_par[6],
1215                                                    rx_dma_data_out_par[7],
1216                                                    rx_dma_data_out_par[0],
1217                                                    rx_dma_data_out_par[1],
1218                                                    rx_dma_data_out_par[2],
1219                                                    rx_dma_data_out_par[3]};
1220                           end
1221                          else
1222                           begin
1223       1/1                   dma_data_out_endian_par = rx_dma_data_out_par;
1224                           end
1225                        end
1226                       //------------------------------------------------
1227                    
1228                    
1229                       // sel_word_lane - bus lane corresponding to the accessed words
1230                       //------------------------------------------------
1231                       always@(*)
1232                          // Big endian order: least significant word @ highest address
1233       1/1                if (endian_swap_now)
1234       <font color = "red">0/1     ==>           casex({dma_bus_width, haddr[3:2]})</font>
1235       <font color = "red">0/1     ==>              4'b10_xx : sel_word_lane = ~haddr[3:2];</font>
1236       <font color = "red">0/1     ==>              4'b01_x0 : sel_word_lane = 2'b01;</font>
1237       <font color = "red">0/1     ==>              default : sel_word_lane  = 2'b00;</font>
1238                             endcase
1239                          // Little endian order: least significant word @ lowest address
1240                          else
1241       1/1                   casex({dma_bus_width, haddr[3:2]})
1242       <font color = "red">0/1     ==>              4'b10_xx : sel_word_lane = haddr[3:2];</font>
1243       <font color = "red">0/1     ==>              4'b01_x1 : sel_word_lane = 2'b01;</font>
1244       1/1                      default : sel_word_lane  = 2'b00;
1245                             endcase
1246                       //------------------------------------------------
1247                    
1248                    
1249                       // rd_enable_word - registered version of sel_word_lane.
1250                       //                  required because data phase is one cycle after the
1251                       //                  address phase, therefore we must register the
1252                       //                  word address offset information
1253                       //------------------------------------------------
1254                       always@(posedge hclk or negedge n_hreset)
1255                        begin
1256       1/1                if (~n_hreset)
1257                           begin
1258       1/1                   rd_enable_word &lt;= 2'b00;
1259       1/1                   rd_endian_swap_now &lt;= 1'b0;
1260                           end
1261                    
1262                          // hold version of sel_word_lane at end of address phase
1263       1/1                else if (ahbaddph_strobe_descr | ahbaddph_strobe_data)
1264                           begin
1265       1/1                   rd_enable_word &lt;= sel_word_lane;
1266       1/1                   rd_endian_swap_now &lt;= endian_swap_now;
1267                           end
1268                    
1269                          // Else default is lane 0 (bits[31:0])
1270       1/1                else if (hready)
1271                           begin
1272       1/1                   rd_enable_word &lt;= 2'b00;
1273       1/1                   rd_endian_swap_now &lt;= 1'b0;
1274                           end
                        MISSING_ELSE
1275                        end
1276                       //------------------------------------------------
1277                    
1278                    
1279                       // hwdata - ahb data output register
1280                       reg  [127:0] dpram_do_str;
1281                       wire [15:0]  dpram_do_str_par;
1282                       reg  [127:0] hwdata_nxt;
1283                       reg  [15:0]  hwdata_par_nxt;
1284                       wire         use_data_imm;
1285                    
1286                       // Useful signal identifying an AHB phase when we arent padding ...
1287                       wire ahbreqph_strobe_data_nopad;
1288                       wire ahbaddph_strobe_data_nopad;
1289                       assign ahbreqph_strobe_data_nopad = ahbreqph_strobe_data &amp; ~padding_rph;
1290                       assign ahbaddph_strobe_data_nopad = ahbaddph_strobe_data &amp; ~padding_aph;
1291                    
1292                      // Combinatorial generation of dpram_do_str_nxt and hwdata_nxt with
1293                      // corresponding parity.
1294                      always@(*)
1295                      begin
1296       1/1              hwdata_nxt     = hwdata;
1297       1/1              hwdata_par_nxt = hwdata_par;
1298       1/1              if (use_data_imm)
1299       1/1                casex ({dma_bus_width,sel_word_lane,endian_swap_now})
1300                            5'b10010: begin
1301       <font color = "red">0/1     ==>                      hwdata_nxt      = {dma_data_out_endian[31:0],    dma_data_out_endian[127:96],   dma_data_out_endian[95:64],    dma_data_out_endian[63:32]};</font>
1302       <font color = "red">0/1     ==>                      hwdata_par_nxt  = {dma_data_out_endian_par[3:0], dma_data_out_endian_par[15:12], dma_data_out_endian_par[11:8], dma_data_out_endian_par[7:4]};</font>
1303                                      end
1304                            5'b10100: begin
1305       <font color = "red">0/1     ==>                      hwdata_nxt      = {dma_data_out_endian[63:32],   dma_data_out_endian[31:0],    dma_data_out_endian[127:96],    dma_data_out_endian[95:64]};</font>
1306       <font color = "red">0/1     ==>                      hwdata_par_nxt  = {dma_data_out_endian_par[7:4], dma_data_out_endian_par[3:0], dma_data_out_endian_par[15:12], dma_data_out_endian_par[11:8]};</font>
1307                                      end
1308                            5'b10110: begin
1309       <font color = "red">0/1     ==>                      hwdata_nxt      = {dma_data_out_endian[95:64],    dma_data_out_endian[63:32],   dma_data_out_endian[31:0],    dma_data_out_endian[127:96]};</font>
1310       <font color = "red">0/1     ==>                      hwdata_par_nxt  = {dma_data_out_endian_par[11:8], dma_data_out_endian_par[7:4], dma_data_out_endian_par[3:0], dma_data_out_endian_par[15:12]};</font>
1311                                      end
1312                            5'b10001: begin
1313       <font color = "red">0/1     ==>                      hwdata_nxt      = {dma_data_out_endian[63:32],   dma_data_out_endian[95:64],    dma_data_out_endian[127:96],    dma_data_out_endian[31:0]}; // Addr 11</font>
1314       <font color = "red">0/1     ==>                      hwdata_par_nxt  = {dma_data_out_endian_par[7:4], dma_data_out_endian_par[11:8], dma_data_out_endian_par[15:12], dma_data_out_endian_par[3:0]};</font>
1315                                      end
1316                            5'b10011: begin
1317       <font color = "red">0/1     ==>                      hwdata_nxt      = {dma_data_out_endian[95:64],    dma_data_out_endian[127:96],    dma_data_out_endian[31:0],    dma_data_out_endian[63:32]}; // Addr 10</font>
1318       <font color = "red">0/1     ==>                      hwdata_par_nxt  = {dma_data_out_endian_par[11:8], dma_data_out_endian_par[15:12], dma_data_out_endian_par[3:0], dma_data_out_endian_par[7:4]};</font>
1319                                      end
1320                            5'b10101: begin
1321       <font color = "red">0/1     ==>                      hwdata_nxt      = {dma_data_out_endian[127:96],    dma_data_out_endian[31:0],    dma_data_out_endian[63:32],   dma_data_out_endian[95:64]}; // Addr 01</font>
1322       <font color = "red">0/1     ==>                      hwdata_par_nxt  = {dma_data_out_endian_par[15:12], dma_data_out_endian_par[3:0], dma_data_out_endian_par[7:4], dma_data_out_endian_par[11:8]};</font>
1323                                      end
1324                            5'b10111: begin
1325       <font color = "red">0/1     ==>                      hwdata_nxt      = {dma_data_out_endian[31:0],   dma_data_out_endian[63:32],    dma_data_out_endian[95:64],    dma_data_out_endian[127:96]}; // Addr 00</font>
1326       <font color = "red">0/1     ==>                      hwdata_par_nxt  = {dma_data_out_endian_par[3:0], dma_data_out_endian_par[7:4], dma_data_out_endian_par[11:8], dma_data_out_endian_par[15:12]};</font>
1327                                      end
1328                            5'b0101x: begin
1329       <font color = "red">0/1     ==>                      hwdata_nxt[63:32]   = dma_data_out_endian[31:0];</font>
1330       <font color = "red">0/1     ==>                      hwdata_par_nxt[7:4] = dma_data_out_endian_par[3:0];</font>
1331       <font color = "red">0/1     ==>                      hwdata_nxt[31:0]    = dma_data_out_endian[63:32];</font>
1332       <font color = "red">0/1     ==>                      hwdata_par_nxt[3:0] = dma_data_out_endian_par[7:4];</font>
1333                                      end
1334                            default : begin
1335       1/1                              hwdata_nxt      = dma_data_out_endian;
1336       1/1                              hwdata_par_nxt  = dma_data_out_endian_par;
1337                                      end
1338                          endcase
1339       1/1              else if (ahbaddph_strobe_data)
1340       1/1                casex ({dma_bus_width,sel_word_lane,endian_swap_now})
1341                            5'b10010: begin
1342       <font color = "red">0/1     ==>                      hwdata_nxt      = {dpram_do_str[31:0],    dpram_do_str[127:96],    dpram_do_str[95:64],    dpram_do_str[63:32]};</font>
1343       <font color = "red">0/1     ==>                      hwdata_par_nxt  = {dpram_do_str_par[3:0], dpram_do_str_par[15:12], dpram_do_str_par[11:8], dpram_do_str_par[7:4]};</font>
1344                                      end
1345                            5'b10100: begin
1346       <font color = "red">0/1     ==>                      hwdata_nxt      = {dpram_do_str[63:32],   dpram_do_str[31:0],    dpram_do_str[127:96],    dpram_do_str[95:64]};</font>
1347       <font color = "red">0/1     ==>                      hwdata_par_nxt  = {dpram_do_str_par[7:4], dpram_do_str_par[3:0], dpram_do_str_par[15:12], dpram_do_str_par[11:8]};</font>
1348                                      end
1349                            5'b10110: begin
1350       <font color = "red">0/1     ==>                      hwdata_nxt      = {dpram_do_str[95:64],    dpram_do_str[63:32],  dpram_do_str[31:0],     dpram_do_str[127:96]};</font>
1351       <font color = "red">0/1     ==>                      hwdata_par_nxt  = {dpram_do_str_par[11:8], dpram_do_str_par[7:4], dpram_do_str_par[3:0], dpram_do_str_par[15:12]};</font>
1352                                      end
1353                            5'b10001: begin
1354       <font color = "red">0/1     ==>                      hwdata_nxt      = {dpram_do_str[63:32],   dpram_do_str[95:64],    dpram_do_str[127:96],    dpram_do_str[31:0]}; // Addr 11</font>
1355       <font color = "red">0/1     ==>                      hwdata_par_nxt  = {dpram_do_str_par[7:4], dpram_do_str_par[11:8], dpram_do_str_par[15:12], dpram_do_str_par[3:0]};</font>
1356                                      end
1357                            5'b10011: begin
1358       <font color = "red">0/1     ==>                      hwdata_nxt      = {dpram_do_str[95:64],    dpram_do_str[127:96],  dpram_do_str[31:0],      dpram_do_str[63:32]}; // Addr 10</font>
1359       <font color = "red">0/1     ==>                      hwdata_par_nxt  = {dpram_do_str_par[11:8], dpram_do_str_par[15:12], dpram_do_str_par[3:0], dpram_do_str_par[7:4]};</font>
1360                                      end
1361                            5'b10101: begin
1362       <font color = "red">0/1     ==>                      hwdata_nxt      = {dpram_do_str[127:96],    dpram_do_str[31:0],    dpram_do_str[63:32],  dpram_do_str[95:64]}; // Addr 01</font>
1363       <font color = "red">0/1     ==>                      hwdata_par_nxt  = {dpram_do_str_par[15:12], dpram_do_str_par[3:0], dpram_do_str_par[7:4], dpram_do_str_par[11:8]};</font>
1364                                      end
1365                            5'b10111: begin
1366       <font color = "red">0/1     ==>                      hwdata_nxt      = {dpram_do_str[31:0],    dpram_do_str[63:32],  dpram_do_str[95:64],     dpram_do_str[127:96]}; // Addr 00</font>
1367       <font color = "red">0/1     ==>                      hwdata_par_nxt  = {dpram_do_str_par[3:0], dpram_do_str_par[7:4], dpram_do_str_par[11:8], dpram_do_str_par[15:12]};</font>
1368                                      end
1369                            5'b0101x: begin
1370       <font color = "red">0/1     ==>                      hwdata_nxt[63:32]   = dpram_do_str[31:0];</font>
1371       <font color = "red">0/1     ==>                      hwdata_par_nxt[7:4] = dpram_do_str_par[3:0];</font>
1372       <font color = "red">0/1     ==>                      hwdata_nxt[31:0]    = dpram_do_str[63:32];</font>
1373       <font color = "red">0/1     ==>                      hwdata_par_nxt[3:0] = dpram_do_str_par[7:4];</font>
1374                                      end
1375                            default : begin
1376       1/1                              hwdata_nxt      = dpram_do_str;
1377       1/1                              hwdata_par_nxt  = dpram_do_str_par;
1378                                      end
                        MISSING_ELSE
1379                          endcase
1380                      end
1381                    
1382                       //------------------------------------------------
1383                       always@(posedge hclk or negedge n_hreset)
1384                        begin
1385       1/1                if (~n_hreset)
1386                          begin
1387       1/1                   hwdata &lt;= {128{1'b0}};
1388       1/1                   dpram_do_str &lt;= {128{1'b0}};
1389       1/1                   prev_ahbreqph_strobe &lt;= 1'b0;
1390       1/1                   prev_ahbaddph_strobe &lt;= 1'b0;
1391                          end
1392                          // The AHB write data will always be available the cycle after
1393                          // the DPRAM is read
1394                          else
1395                          begin
1396       1/1                  if (enable_rx_hclk)
1397       1/1                    hwdata              &lt;= hwdata_nxt;
                        MISSING_ELSE
1398       1/1                  prev_ahbaddph_strobe  &lt;= hready;
1399                    
1400       1/1                  if (hresp_notok_eob | rx_buffer_used_bit | (mac_err_vld &amp; rx_cutthru) | mac_err_vld_pending)
1401       <font color = "red">0/1     ==>            prev_ahbreqph_strobe &lt;= 1'b0;</font>
1402                            else
1403       1/1                    prev_ahbreqph_strobe &lt;= ahbreqph_strobe_data_nopad;
1404                    
1405       1/1                  if (prev_ahbreqph_strobe)
1406       1/1                    dpram_do_str     &lt;= dma_data_out_endian;
                        MISSING_ELSE
1407                    
1408                          end
1409                        end
1410                        assign use_data_imm = (prev_ahbaddph_strobe &amp; ahbaddph_strobe_data) |
1411                                               ahbaddph_strobe_descr;
1412                    
1413                       // Store dpram_do_str_par and hwdata_par if datapath protection defined
1414                       generate if (p_edma_asf_dap_prot == 1) begin : gen_hwdata_par
1415                        reg   [15:0]  dpram_do_str_par_r;
1416                        reg   [15:0]  hwdata_par_r;
1417                        always@(posedge hclk or negedge n_hreset)
1418                        begin
1419                          if (~n_hreset)
1420                          begin
1421                            dpram_do_str_par_r  &lt;= 16'h0000;
1422                            hwdata_par_r        &lt;= 16'h0000;
1423                          end
1424                          else
1425                          begin
1426                            if (enable_rx_hclk)
1427                              hwdata_par_r        &lt;= hwdata_par_nxt;
1428                            if (prev_ahbreqph_strobe)
1429                              dpram_do_str_par_r  &lt;= dma_data_out_endian_par;
1430                          end
1431                        end
1432                        assign hwdata_par       = hwdata_par_r;
1433                        assign dpram_do_str_par = dpram_do_str_par_r;
1434                       end else begin : gen_no_hwdata_par
1435                        assign hwdata_par       = 16'h0000;
1436                        assign dpram_do_str_par = 16'h0000;
1437                       end
1438                       endgenerate
1439                    
1440                       //------------------------------------------------
1441                    
1442                    
1443                       // rx_dma_data_in_endian - selected input data from AHB. This is transferred
1444                       //                      to both dma_rx and dma_tx blocks via an endian swap
1445                       //------------------------------------------------
1446                       always@(*)
1447                          begin
1448       1/1                   dma_data_in_endian     = hrdata; // default
1449       1/1                   dma_data_in_endian_par = hrdata_par;
1450       1/1                   casex ({dma_bus_width,rd_enable_word,rd_endian_swap_now})
1451                    
1452                                5'b10_01_0 :
1453                                begin
1454       <font color = "red">0/1     ==>                dma_data_in_endian      = {hrdata[31:0],  hrdata[127:96], hrdata[95:64],  hrdata[63:32]};</font>
1455       <font color = "red">0/1     ==>                dma_data_in_endian_par  = {hrdata_par[3:0], hrdata_par[15:12], hrdata_par[11:8], hrdata_par[7:4]};</font>
1456                                end
1457                                5'b10_10_0 :
1458                                begin
1459       <font color = "red">0/1     ==>                dma_data_in_endian      = {hrdata[63:32], hrdata[31:0],   hrdata[127:96], hrdata[95:64]};</font>
1460       <font color = "red">0/1     ==>                dma_data_in_endian_par  = {hrdata_par[7:4], hrdata_par[3:0], hrdata_par[15:12], hrdata_par[11:8]};</font>
1461                                end
1462                                5'b10_11_0 :
1463                                begin
1464       <font color = "red">0/1     ==>                dma_data_in_endian      = {hrdata[95:64], hrdata[63:32],  hrdata[31:0],   hrdata[127:96]};</font>
1465       <font color = "red">0/1     ==>                dma_data_in_endian_par  = {hrdata_par[11:8], hrdata_par[7:4], hrdata_par[3:0], hrdata_par[15:12]};</font>
1466                                end
1467                                5'b10_00_1 :
1468                                begin
1469       <font color = "red">0/1     ==>                dma_data_in_endian      = {hrdata[63:32],  hrdata[95:64],  hrdata[127:96], hrdata[31:0]}; // Addr 11</font>
1470       <font color = "red">0/1     ==>                dma_data_in_endian_par  = {hrdata_par[7:4], hrdata_par[11:8], hrdata_par[15:12], hrdata_par[3:0]};</font>
1471                                end
1472                                5'b10_01_1 :
1473                                begin
1474       <font color = "red">0/1     ==>                dma_data_in_endian      = {hrdata[95:64],  hrdata[127:96], hrdata[31:0],   hrdata[63:32]}; // Addr 10</font>
1475       <font color = "red">0/1     ==>                dma_data_in_endian_par  = {hrdata_par[11:8], hrdata_par[15:12], hrdata_par[3:0], hrdata_par[7:4]};</font>
1476                                end
1477                                5'b10_10_1 :
1478                                begin
1479       <font color = "red">0/1     ==>                dma_data_in_endian      = {hrdata[127:96], hrdata[31:0],   hrdata[63:32],  hrdata[95:64]}; // Addr 01</font>
1480       <font color = "red">0/1     ==>                dma_data_in_endian_par  = {hrdata_par[15:12], hrdata_par[3:0], hrdata_par[7:4], hrdata_par[11:8]};</font>
1481                                end
1482                                5'b10_11_1 :
1483                                begin
1484       <font color = "red">0/1     ==>                dma_data_in_endian      = {hrdata[31:0],   hrdata[63:32],  hrdata[95:64],  hrdata[127:96]}; // Addr 00</font>
1485       <font color = "red">0/1     ==>                dma_data_in_endian_par  = {hrdata_par[3:0], hrdata_par[7:4], hrdata_par[11:8], hrdata_par[15:12]};</font>
1486                                end
1487                                5'b01_01_x :
1488                                begin
1489       <font color = "red">0/1     ==>                dma_data_in_endian      = {hrdata[127:96],   hrdata[95:64],  hrdata[31:0],  hrdata[63:32]};</font>
1490       <font color = "red">0/1     ==>                dma_data_in_endian_par  = {hrdata_par[15:12], hrdata_par[11:8], hrdata_par[3:0], hrdata_par[7:4]};</font>
1491                                end
1492                    
1493                                default :
1494                                begin
1495       1/1                        dma_data_in_endian      = hrdata;
1496       1/1                        dma_data_in_endian_par  = hrdata_par;
1497                                end
1498                             endcase
1499                          end
1500                       //------------------------------------------------
1501                    
1502                    
1503                       // rx_dma_data_in - byte endian swapped version of read data.
1504                       //               Words are already aligned, so just need to
1505                       //               swap bytes within each 32-bit word.
1506                       //                 byte 0  =&gt; byte 3
1507                       //                 byte 1  =&gt; byte 2
1508                       //                 byte 2  =&gt; byte 1
1509                       //                 byte 3  =&gt; byte 0
1510                       //                 byte 4  =&gt; byte 7
1511                       //                 byte 5  =&gt; byte 6
1512                       //                 byte 6  =&gt; byte 5
1513                       //                 byte 7  =&gt; byte 4
1514                       //------------------------------------------------
1515                       always @( * )
1516                        begin
1517       1/1                if (rd_endian_swap_now)
1518                           begin
1519                    
1520       <font color = "red">0/1     ==>           rx_dma_data_in = {dma_data_in_endian[103:96],</font>
1521                                               dma_data_in_endian[111:104],
1522                                               dma_data_in_endian[119:112],
1523                                               dma_data_in_endian[127:120],
1524                                               dma_data_in_endian[71:64],
1525                                               dma_data_in_endian[79:72],
1526                                               dma_data_in_endian[87:80],
1527                                               dma_data_in_endian[95:88],
1528                                               dma_data_in_endian[39:32],
1529                                               dma_data_in_endian[47:40],
1530                                               dma_data_in_endian[55:48],
1531                                               dma_data_in_endian[63:56],
1532                                               dma_data_in_endian[7:0],
1533                                               dma_data_in_endian[15:8],
1534                                               dma_data_in_endian[23:16],
1535                                               dma_data_in_endian[31:24]};
1536       <font color = "red">0/1     ==>           rx_dma_data_in_par = {dma_data_in_endian_par[12],</font>
1537                                                    dma_data_in_endian_par[13],
1538                                                    dma_data_in_endian_par[14],
1539                                                    dma_data_in_endian_par[15],
1540                                                    dma_data_in_endian_par[8],
1541                                                    dma_data_in_endian_par[9],
1542                                                    dma_data_in_endian_par[10],
1543                                                    dma_data_in_endian_par[11],
1544                                                    dma_data_in_endian_par[4],
1545                                                    dma_data_in_endian_par[5],
1546                                                    dma_data_in_endian_par[6],
1547                                                    dma_data_in_endian_par[7],
1548                                                    dma_data_in_endian_par[0],
1549                                                    dma_data_in_endian_par[1],
1550                                                    dma_data_in_endian_par[2],
1551                                                    dma_data_in_endian_par[3]};
1552                           end
1553                          else
1554                           begin
1555       1/1                   rx_dma_data_in     = dma_data_in_endian;
1556       1/1                   rx_dma_data_in_par = dma_data_in_endian_par;
1557                           end
1558                        end
1559                    
1560                       // Separate out rx_dma_data_in into 32-bit words with parity for easier assignment
1561                       // Note that the last word (bits 127:96) is not actually needed so we do not have
1562                       // the assignment here.
1563                       assign rx_dma_data_in_w0_p = {rx_dma_data_in_par[3:0],rx_dma_data_in[31:0]};
1564                       assign rx_dma_data_in_w1_p = {rx_dma_data_in_par[7:4],rx_dma_data_in[63:32]};
1565                       assign rx_dma_data_in_w2_p = {rx_dma_data_in_par[11:8],rx_dma_data_in[95:64]};
1566                    
1567                       //------------------------------------------------
1568                    
1569                       // htrans encoding
1570                       parameter
1571                          p_htrans_idle   = 2'b00,         // AHB IDLE access
1572                          p_htrans_nseq   = 2'b10,         // AHB NONSEQ access
1573                          p_htrans_seq    = 2'b11;         // AHB SEQ access
1574                    
1575                       // hsize encoding
1576                       parameter
1577                          p_hsize_32b    = 3'b010,         // AHB 32-bit access
1578                          p_hsize_64b    = 3'b011,         // AHB 64-bit access
1579                          p_hsize_128b   = 3'b100;         // AHB 128-bit access
1580                    
1581                       // hburst encoding
1582                       parameter
1583                          p_hburst_single  = 3'b000,       // AHB single access
1584                          p_hburst_incr    = 3'b001,       // AHB INCR access
1585                          p_hburst_incr_4  = 3'b011,       // AHB INCR4 access
1586                          p_hburst_incr_8  = 3'b101,       // AHB INCR8 access
1587                          p_hburst_incr_16 = 3'b111;       // AHB INCR16 access
1588                    
1589                    
1590                    
1591                      // When 128b data bus width
1592                      // 128b accesses when rx_dma_state_data
1593                      // 32b access when rx_data_man_rd (This is to keep implementation complexity down)
1594                      assign hsize = (dma_bus_width[1] &amp; rx_dma_state_data)                       ? p_hsize_128b :
1595                                     (|dma_bus_width &amp; (rx_dma_state_man_wr | rx_dma_state_data)) ? p_hsize_64b
1596                                                                                                  : p_hsize_32b;
1597                    
1598                    
1599                      // In 32 bit mode, 2 AHB reads are required to obtain the buffer descriptors
1600                      // Just 1 access is required when in 64 bit mode
1601                      always@(posedge hclk or negedge n_hreset)
1602                      begin
1603       1/1              if (~n_hreset)
1604                        begin
1605       1/1                manwr_reqph1_done   &lt;= 1'b0;
1606       1/1                manwr_reqph2_done   &lt;= 1'b0;
1607       1/1                manwr_reqph3_done   &lt;= 1'b0;
1608       1/1                manwr_reqph4_done   &lt;= 1'b0;
1609                        end
1610                        else
1611                        begin
1612       1/1                if (~enable_rx_hclk)
1613       1/1                  manwr_reqph1_done  &lt;= 1'b0;
1614       1/1                else if (~rx_dma_state_man_wr &amp; rx_dma_next_man_wr)
1615       1/1                  manwr_reqph1_done  &lt;= 1'b0;
1616       1/1                else if (ahbreqph_strobe_descr)
1617       1/1                  manwr_reqph1_done  &lt;= 1'b1;
                        MISSING_ELSE
1618                    
1619       1/1                if (~enable_rx_hclk)
1620       1/1                  manwr_reqph2_done  &lt;= 1'b0;
1621       1/1                else if (~rx_dma_state_man_wr &amp; rx_dma_next_man_wr)
1622       1/1                  manwr_reqph2_done  &lt;= 1'b0;
1623       1/1                else if (ahbreqph_strobe_descr &amp; manwr_reqph1_done)
1624       1/1                  manwr_reqph2_done  &lt;= 1'b1;
                        MISSING_ELSE
1625                    
1626       1/1                if (~enable_rx_hclk)
1627       1/1                  manwr_reqph3_done  &lt;= 1'b0;
1628       1/1                else if (~rx_dma_state_man_wr &amp; rx_dma_next_man_wr)
1629       1/1                  manwr_reqph3_done  &lt;= 1'b0;
1630       1/1                else if (ahbreqph_strobe_descr &amp; manwr_reqph2_done)
1631       1/1                  manwr_reqph3_done  &lt;= 1'b1;
                        MISSING_ELSE
1632                    
1633       1/1                if (~enable_rx_hclk)
1634       1/1                  manwr_reqph4_done  &lt;= 1'b0;
1635       1/1                else if (~rx_dma_state_man_wr &amp; rx_dma_next_man_wr)
1636       1/1                  manwr_reqph4_done  &lt;= 1'b0;
1637       1/1                else if (ahbreqph_strobe_descr &amp; manwr_reqph3_done)
1638       <font color = "red">0/1     ==>          manwr_reqph4_done  &lt;= 1'b1;</font>
                        MISSING_ELSE
1639                        end
1640                      end
1641                    
1642                    
1643                      // Detect the address strobe on the second man write
1644                      always@(posedge hclk or negedge n_hreset)
1645                      begin
1646       1/1              if (~n_hreset)
1647                        begin
1648       1/1                manwr_astrobe2_en  &lt;= 1'b0;
1649       1/1                manwr_astrobe3_en  &lt;= 1'b0;
1650       1/1                manwr_astrobe4_en  &lt;= 1'b0;
1651       1/1                manwr_astrobe_cnt  &lt;= 4'h0;
1652                        end
1653       1/1              else if (~rx_dma_state_man_wr | (~rx_bd_extended_mode_en &amp;(|dma_bus_width)) )
1654                        begin
1655       1/1                manwr_astrobe2_en  &lt;= 1'b0;
1656       1/1                manwr_astrobe3_en  &lt;= 1'b0;
1657       1/1                manwr_astrobe4_en  &lt;= 1'b0;
1658       1/1                manwr_astrobe_cnt  &lt;= 4'h0;
1659                        end
1660                        else
1661                        begin
1662       1/1                if (ahbaddph_strobe_descr)
1663                          begin
1664       1/1                  manwr_astrobe2_en  &lt;= 1'b1;
1665       1/1                  manwr_astrobe_cnt  &lt;= manwr_astrobe_cnt + 4'h1;
1666                          end
                        MISSING_ELSE
1667       1/1                if (ahbaddph_strobe_descr &amp; manwr_astrobe2_en )
1668       1/1                  manwr_astrobe3_en  &lt;= 1'b1;
                        MISSING_ELSE
1669       1/1                if (ahbaddph_strobe_descr &amp; manwr_astrobe3_en )
1670       <font color = "red">0/1     ==>          manwr_astrobe4_en  &lt;= 1'b1;</font>
                        MISSING_ELSE
1671                        end
1672                      end
1673                    
1674                    assign astrobe_manwr_1st = rx_dma_state_man_wr &amp;
1675                                                ahbaddph_strobe_descr &amp; (manwr_astrobe_cnt == 4'h0);
1676                    
1677                    assign astrobe_manwr_2nd = rx_dma_state_man_wr &amp;
1678                                                ahbaddph_strobe_descr &amp; (manwr_astrobe_cnt == 4'h1);
1679                    
1680                    assign astrobe_manwr_3rd = rx_dma_state_man_wr &amp;
1681                                                ahbaddph_strobe_descr &amp; (manwr_astrobe_cnt == 4'h2);
1682                    
1683                    assign astrobe_manwr_4th = rx_dma_state_man_wr &amp;
1684                                                ahbaddph_strobe_descr &amp; (manwr_astrobe_cnt == 4'h3);
1685                    
1686                    assign manwr_rx_dma_addr_1 = rx_dma_state_man_wr &amp;
1687                                                ~ahbaddph_strobe_descr &amp; (manwr_astrobe_cnt == 4'h1);
1688                    
1689                    assign manwr_rx_dma_addr_2 = rx_dma_state_man_wr &amp;
1690                                                ~ahbaddph_strobe_descr &amp; (manwr_astrobe_cnt == 4'h2);
1691                    
1692                    assign manwr_rx_dma_addr_3 = rx_dma_state_man_wr &amp;
1693                                                ~ahbaddph_strobe_descr &amp; (manwr_astrobe_cnt == 4'h3);
1694                    
1695                    assign inc_rx_dma_mux_addr_1 = (astrobe_manwr_1st  | manwr_rx_dma_addr_1);
1696                    assign inc_rx_dma_mux_addr_2 = (astrobe_manwr_2nd  | manwr_rx_dma_addr_2);
1697                    assign inc_rx_dma_mux_addr_3 = (astrobe_manwr_3rd  | manwr_rx_dma_addr_3);
1698                    
1699                    // change astrobe_last for 32b / 64b / 128b address and data bus widths
1700                    assign  astrobe_manwr_last = ((descriptor_wr_4_access ? astrobe_manwr_4th: (descriptor_wr_2_access ? astrobe_manwr_2nd : astrobe_manwr_1st))|(~rx_bd_extended_mode_en &amp; astrobe_manwr_1st&amp;(|dma_bus_width)));
1701                    
1702                    
1703                    
1704                        // for MAN_RD
1705                        // Detect the address strobe
1706                        // Count ahbaddph_strobe_descr and ahbaddph_strobe_descr
1707                        //
1708                      always@(posedge hclk or negedge n_hreset)
1709                      begin
1710       1/1              if (~n_hreset)
1711       1/1                descr_rd_reqph_cnt     &lt;= 3'h0;
1712       1/1              else if (~rx_dma_state_man_rd &amp; ahbdataph_strobe_descr_rd)  // reset before man_rd state as count is used in first cycle of DATA read
1713       1/1                descr_rd_reqph_cnt     &lt;= 3'h0;
1714                        else
1715                        begin  // use _rd signals as these can occur in states other that man_rd
1716       1/1                if (ahbreqph_strobe_descr_rd)
1717       1/1                  descr_rd_reqph_cnt &lt;= descr_rd_reqph_cnt + 3'h1;
                        MISSING_ELSE
1718                        end
1719                      end
1720                    
1721                      generate if (p_edma_addr_width == 32'd64) begin : gen_descr_rd_dataph
1722                      always@(posedge hclk or negedge n_hreset)
1723                      begin
1724                        if (~n_hreset)
1725                        begin
1726                          descr_rd_addph_cnt     &lt;= 2'h0;
1727                          descr_rd_dataph_cnt    &lt;= 2'h0;
1728                        end
1729                        else if (~rx_dma_state_man_rd &amp; ahbdataph_strobe_descr_rd)  // reset before man_rd state as count is used in first cycle of DATA read
1730                        begin
1731                          descr_rd_addph_cnt     &lt;= 2'h0;
1732                          descr_rd_dataph_cnt    &lt;= 2'h0;
1733                        end
1734                        else
1735                        begin  // use _rd signals as these can occur in states other that man_rd
1736                          if (ahbaddph_strobe_descr_rd)
1737                            descr_rd_addph_cnt &lt;= descr_rd_addph_cnt + 2'h1;
1738                          if (ahbdataph_strobe_descr_rd)
1739                            descr_rd_dataph_cnt &lt;= descr_rd_dataph_cnt + 2'h1;
1740                        end
1741                      end
1742                      end else begin :gen_no_descr_rd_dataph
1743                        wire zero;
1744                        assign zero = 1'b0;
1745                        always @(*)
1746                        begin
1747       1/1                descr_rd_dataph_cnt = {2{zero}};
1748       1/1                descr_rd_addph_cnt = {2{zero}};
1749                        end
1750                      end
1751                      endgenerate
1752                    
1753                    
1754                    wire priq_descr_rd_safe;
1755                    wire priq_get_status_info;
1756                    // num_pkts-xfer is an rx-clk timed signal. It should only be sampled when pkt_written_dpram or part_pkt_written is set
1757                    // This useful signal makes the lint tools more easily detect the valid clk boundary and gating term.
1758                    wire  [3:0] num_pkts_xfer_fullpkt;
1759                    wire  [3:0] num_pkts_xfer_partpkt;
1760                    assign num_pkts_xfer_fullpkt = ({4{pkt_written_dpram}} &amp; num_pkts_xfer);
1761                    assign num_pkts_xfer_partpkt = ({4{part_pkt_written}} &amp; num_pkts_xfer);
1762                    generate if (p_edma_queues &gt; 32'd1) begin : set_priq_logic
1763                      // Set when it is safe to do a descriptor read in priority queue mode
1764                      assign priq_descr_rd_safe = ((((|num_pkts_needing_read | pkt_written_dpram) &amp; (early_queue_info_en || (status_word1_capt &amp; nxt_status_word_1[0]))) | reading_eop_dpram_aph_del)
1765                                                  || ((~(|num_pkts_needing_read)) &amp;&amp; (|num_parts_needing_read)));
1766                    
1767                      // When priority queueing is enabled, we want to obtain
1768                      // the status information asap, as the status holds the queue
1769                      // information.  This means we will be reading from the DPRAM
1770                      // more than we really need to, but it is the most efficient
1771                      // way
1772                      // The address should already be pointing to the status word,
1773                      // so we can just enable the DPRAM rd here
1774                      assign priq_get_status_info = (|num_pkts_needing_read &amp;&amp; |num_pkts_needing_read_nxt &amp; ~status_word2_capt) | (num_pkts_xfer_fullpkt !=4'd0);
1775                    
1776                    end else begin : set_no_priq_descr_rd_safe
1777                      assign priq_descr_rd_safe = 1'b1;
1778                      assign priq_get_status_info = 1'b0;
1779                    end
1780                    endgenerate
1781                    
1782                      always@(posedge hclk or negedge n_hreset)
1783                      begin
1784       1/1              if (~n_hreset)
1785                        begin
1786       1/1                htrans  &lt;= p_htrans_idle;
1787       1/1                hburst  &lt;= p_hburst_incr;
1788       1/1                hwrite  &lt;= 1'b0;
1789       1/1                haddr   &lt;= 64'd0;
1790       1/1                ahb_access_cnt &lt;= 4'h0;
1791                        end
1792                        else
1793                        begin
1794       1/1                if (~enable_rx_hclk)
1795       1/1                  haddr   &lt;= 64'd0;
1796       1/1                else if (hready)
1797       1/1                   haddr &lt;= {ahb_data_addr_2[31:0], rx_dma_burst_addr[31:0]}; // MS word is only used for data addr, not BD
                        MISSING_ELSE
1798                                                                                        // This is replace by fixed value for BD addr
1799                    
1800       1/1                if (~enable_rx_hclk)
1801                          begin
1802       1/1                  htrans  &lt;= p_htrans_idle;
1803       1/1                  hburst  &lt;= p_hburst_incr;
1804       1/1                  hwrite  &lt;= 1'b0;
1805       1/1                  ahb_access_cnt &lt;= 4'h0;
1806                          end
1807                          else
1808                    
1809       1/1                case (rx_dma_state)
1810                            RX_DMA_MAN_WR :
1811                            begin
1812       1/1                    ahb_access_cnt &lt;= 4'h0;
1813                              // RULE : Always 2 accesses in 32 bit mode, 2nd is always sequential
1814                              // RULE : Always 1 access in 64 bit mode
1815                              // RULE : Never breaks 1k boundary, always aligned to 8 byte boundary
1816       1/1                    if (hready &amp; hgrant_descr)
1817                              begin
1818       1/1                      if (hresp_notok_eob)
1819                                begin
1820       <font color = "red">0/1     ==>                hwrite  &lt;= 1'b0;</font>
1821       <font color = "red">0/1     ==>                htrans  &lt;= p_htrans_idle;</font>
1822       <font color = "red">0/1     ==>                hburst  &lt;= p_hburst_incr;</font>
1823                                end
1824       1/1                      else if (~manwr_reqph1_done)
1825                                begin
1826       1/1                        hwrite  &lt;= 1'b1;
1827       1/1                        htrans  &lt;= p_htrans_nseq;
1828       1/1                        hburst  &lt;= p_hburst_incr;
1829                                end
1830       1/1                      else if (descriptor_wr_4_access)
1831                                begin
1832       <font color = "red">0/1     ==>                if (manwr_reqph4_done)</font>
1833                                  begin
1834                                    // Jump straight into the next descriptor read ...
1835       <font color = "red">0/1     ==>                  hwrite  &lt;= 1'b0;</font>
1836       <font color = "red">0/1     ==>                  hburst  &lt;= p_hburst_incr;</font>
1837       <font color = "red">0/1     ==>                  if (priq_descr_rd_safe)</font>
1838       <font color = "red">0/1     ==>                    htrans  &lt;= p_htrans_nseq;</font>
1839                                    else
1840       <font color = "red">0/1     ==>                    htrans  &lt;= p_htrans_idle;</font>
1841                                  end
1842       <font color = "red">0/1     ==>                else if (manwr_reqph3_done)</font>
1843                                  begin
1844       <font color = "red">0/1     ==>                  htrans  &lt;= p_htrans_nseq;</font>
1845       <font color = "red">0/1     ==>                  hburst  &lt;= p_hburst_incr;</font>
1846       <font color = "red">0/1     ==>                  hwrite  &lt;= 1'b1;</font>
1847                                  end
1848                                  else
1849                                  begin
1850       <font color = "red">0/1     ==>                  htrans  &lt;= p_htrans_nseq;</font>
1851       <font color = "red">0/1     ==>                  hburst  &lt;= p_hburst_incr;</font>
1852       <font color = "red">0/1     ==>                  hwrite  &lt;= 1'b1;</font>
1853                                  end
1854                                end
1855       1/1                      else if (descriptor_wr_2_access)
1856                                begin
1857       1/1                        if (manwr_reqph2_done)
1858                                  begin
1859                                    // Jump straight into the next descriptor read ...
1860       1/1                          hwrite  &lt;= 1'b0;
1861       1/1                          hburst  &lt;= p_hburst_incr;
1862       1/1                          if (priq_descr_rd_safe)
1863       1/1                            htrans  &lt;= p_htrans_nseq;
1864                                    else
1865       <font color = "red">0/1     ==>                    htrans  &lt;= p_htrans_idle;</font>
1866                                  end
1867                                  else
1868                                  begin  // first access
1869       1/1                          htrans  &lt;= p_htrans_nseq;
1870       1/1                          hburst  &lt;= p_hburst_incr;
1871       1/1                          hwrite  &lt;= 1'b1;
1872                                  end
1873                                end
1874                                else // if (one_man_wr_access)
1875                                begin
1876                                  // Jump straight into the next descriptor read ...
1877       <font color = "red">0/1     ==>                hwrite  &lt;= 1'b0;</font>
1878       <font color = "red">0/1     ==>                hburst  &lt;= p_hburst_incr;</font>
1879       <font color = "red">0/1     ==>                if (priq_descr_rd_safe)</font>
1880       <font color = "red">0/1     ==>                  htrans  &lt;= p_htrans_nseq;</font>
1881                                  else
1882       <font color = "red">0/1     ==>                  htrans  &lt;= p_htrans_idle;</font>
1883                                end
1884                              end
1885       1/1                    else if (hready)
1886       <font color = "red">0/1     ==>              htrans  &lt;= p_htrans_idle;</font>
                        MISSING_ELSE
1887                            end
1888                    
1889                            RX_DMA_MAN_RD :
1890                            begin
1891                              // For 64b addressing we need to read Word 2 so depending on data bus width
1892                              // we will need to perform different no of accesses.
1893                              // For 32b data bus, 2 accesses
1894                              // For 64b data bus, 2 accesses
1895                              // For 128b data bus, 1 access
1896                    
1897                              // For 32b addressing the original rules still apply.
1898                              // RULE : Always 1 access or 32b addressing
1899                              // RULE : Never breaks 1k boundary, always aligned to 8 byte boundary
1900                              //
1901                              // Insert an IDLE at the end of the 2nd Request phase
1902                              // This is required because the arbiter uses htrans to
1903                              // change master - htrans is an address phase timed signal,
1904                              // while hgrant is request phase
1905       1/1                    if (hready &amp; hgrant_descr)
1906                              begin
1907       1/1                      hwrite  &lt;= 1'b0;
1908       1/1                      hburst  &lt;= p_hburst_incr;
1909       1/1                      if (hresp_notok_eob)
1910       <font color = "red">0/1     ==>                htrans  &lt;= p_htrans_idle;</font>
1911       1/1                      else if ((~ahbreqph_strobe_descr) &amp; descriptor_rd_1_access)  // single read access for 32b addr or 128b data bus
1912                                                                                           // single read access for 128b
1913       1/1                        htrans  &lt;= p_htrans_idle;
1914       1/1                      else if  (~ahbreqph_strobe_descr &amp; (descr_rd_reqph_cnt == 3'h2) &amp; descriptor_rd_2_access)   // 2 accesses for other cases
1915       <font color = "red">0/1     ==>                htrans  &lt;= p_htrans_idle;</font>
1916                                else
1917       1/1                        htrans  &lt;= p_htrans_nseq;
1918                              end
1919       <font color = "red">0/1     ==>            else if (hready)</font>
1920       <font color = "red">0/1     ==>              htrans  &lt;= p_htrans_idle;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
1921                            end
1922                    
1923                            RX_DMA_DATA_STORE :
1924                            begin
1925       1/1                    if (hready &amp; hgrant_data &amp; hbusreq)
1926                              begin
1927       1/1                      if (hresp_notok_eob)
1928       <font color = "red">0/1     ==>                hburst &lt;= p_hburst_incr;</font>
1929       1/1                      else if (brk1kbndry_burst &amp; ahb_access_cnt == 4'h0)
1930                                begin
1931       <font color = "red">0/1     ==>                casex (bndry1k_acc_size[3:0])</font>
1932       <font color = "red">0/1     ==>                   4'b01xx : hburst &lt;= p_hburst_incr_4; // &gt; 4 access</font>
1933       <font color = "red">0/1     ==>                   4'b1xxx : hburst &lt;= p_hburst_incr_8; // &gt; 8 accesses</font>
1934       <font color = "red">0/1     ==>                   default : hburst &lt;= p_hburst_incr;   // &gt; 2 access</font>
1935                                  endcase
1936                                end
1937       1/1                      else if (eop_burst &amp; ahb_access_cnt == 4'h0)
1938                                begin
1939                                  // If buffer_fill_lvl == 0, then eop_burst will be set
1940                                  // hburst must be set to p_hburst_single
1941       1/1                        casex (eop_burst_size[4:0])
1942       <font color = "red">0/1     ==>                   5'b001xx : hburst &lt;= p_hburst_incr_4;</font>
1943       <font color = "red">0/1     ==>                   5'b01xxx : hburst &lt;= p_hburst_incr_8;</font>
1944       1/1                           default  : hburst &lt;= p_hburst_incr;
1945                                  endcase
1946                                end
1947       1/1                      else if (ahb_access_cnt == 4'h0)
1948                                begin
1949       1/1                        case (ahb_burst_length[4:0])
1950       1/1                          5'd4    : hburst &lt;= p_hburst_incr_4;
1951       1/1                          5'd8    : hburst &lt;= p_hburst_incr_8;
1952       1/1                          5'd16   : hburst &lt;= p_hburst_incr_16;
1953       1/1                          default : hburst &lt;= p_hburst_incr;
1954                                  endcase
1955                                end
                        MISSING_ELSE
1956                    
1957                                // AHB error or end of buffer (as long as we're not padding the burst)
1958       1/1                      if (hresp_notok_eob | (last_data_to_buff_aph &amp; ~padding_rph))
1959                                begin
1960       1/1                        hwrite          &lt;= 1'b0;
1961       1/1                        htrans          &lt;= p_htrans_idle;
1962       1/1                        ahb_access_cnt  &lt;= 4'h0;
1963                                end
1964                    
1965                                // End of current burst (address phase)
1966       1/1                      else if (ahb_access_cnt == 4'h0)
1967                                begin
1968                                  // Insert an IDLE at the end of the DATA phase
1969                                  // This is required because the arbiter uses htrans to
1970                                  // change master - htrans is an address phase timed signal,
1971                                  // while hgrant is request phase
1972       1/1                        if (last_data_to_buff_aph | cutthru_wait4part | nxt_rx_dma_state == RX_DMA_IDLE)
1973                                  begin
1974       <font color = "red">0/1     ==>                  hwrite          &lt;= 1'b0;</font>
1975       <font color = "red">0/1     ==>                  htrans          &lt;= p_htrans_idle;</font>
1976       <font color = "red">0/1     ==>                  ahb_access_cnt  &lt;= ahb_access_cnt;</font>
1977                                  end
1978                                  else
1979                                  begin
1980       1/1                          hwrite          &lt;= 1'b1;
1981       1/1                          htrans          &lt;= p_htrans_nseq;
1982       1/1                          if ((eop_burst_size &gt; 5'h01 | ~eop_burst) &amp; ~breaks_1k_boundary)
1983       1/1                            ahb_access_cnt  &lt;= ahb_access_cnt + 4'h1;
                        MISSING_ELSE
1984                                  end
1985                                end
1986                    
1987                                // Break the current burst if
1988                                //  1) This is the last request phase for the current packet part
1989                                //    (cut through)
1990                                //  2) This is the last request phase for the current buffer
1991                                //  3) This is the last request phase for the current burst
1992       1/1                      else if  (last_access_burst_req | breaks_1k_boundary)
1993                                begin
1994       1/1                        hwrite          &lt;= 1'b1;
1995       1/1                        htrans          &lt;= p_htrans_seq;
1996       1/1                        ahb_access_cnt  &lt;= 4'h0;
1997                                end
1998                                else
1999                                begin
2000       1/1                        hwrite          &lt;= 1'b1;
2001       1/1                        htrans          &lt;= p_htrans_seq;
2002       1/1                        ahb_access_cnt  &lt;= ahb_access_cnt + 4'h1;
2003                                end
2004                              end
2005       1/1                    else if (hready | nxt_rx_dma_state == RX_DMA_IDLE)
2006                              begin
2007       1/1                      hwrite          &lt;= 1'b0;
2008       1/1                      htrans          &lt;= p_htrans_idle;
2009       1/1                      ahb_access_cnt  &lt;= 4'h0;
2010       1/1                      hburst &lt;= p_hburst_incr;
2011                              end
                        MISSING_ELSE
2012                            end
2013                    
2014                            default :
2015                            begin
2016       1/1                    hwrite          &lt;= 1'b0;
2017       1/1                    htrans          &lt;= p_htrans_idle;
2018       1/1                    ahb_access_cnt  &lt;= 4'h0;
2019       1/1                    hburst &lt;= p_hburst_incr;
2020                            end
2021                          endcase
2022                        end
2023                      end
2024                    
2025                      // Optional parity pipeline of haddr
2026                      generate if (p_edma_asf_dap_prot == 1) begin : gen_haddr_par
2027                        reg [7:0] haddr_par_r;
2028                        always@(posedge hclk or negedge n_hreset)
2029                        begin
2030                          if (~n_hreset)
2031                            haddr_par_r &lt;= 8'h00;
2032                          else if (~enable_rx_hclk)
2033                            haddr_par_r &lt;= 8'h00;
2034                          else if (hready)
2035                            haddr_par_r &lt;= {ahb_data_addr_2[35:32],rx_dma_burst_addr[35:32]};
2036                        end
2037                        assign haddr_par  = haddr_par_r;
2038                      end else begin : gen_no_haddr_par
2039                        assign haddr_par  = 8'h00;
2040                      end
2041                      endgenerate
2042                    
2043                      assign last_access_burst_req =
2044                                         (eop_burst &amp; eop_burst_size == 5'h01) |
2045                                          breaks_1k_boundary |
2046                                         (hburst == p_hburst_incr_16 &amp; ahb_access_cnt == 4'hf) |
2047                                         (hburst == p_hburst_incr_8  &amp; ahb_access_cnt == 4'h7)  |
2048                                         (hburst == p_hburst_incr_4  &amp; ahb_access_cnt == 4'h3);
2049                    
2050                    
2051                      // brk1kbndry_burst will be set if the upcoming burst will break the
2052                      //                      1K AHB address boundary.
2053                    
2054                      // Convert ahb_burst_length to a mask to make it easier to select
2055                      // correct bits for 1K boundary address comparison
2056                      // Note that by this stage ahb_burst_length is one-hot.
2057                      always @ ( * )
2058                      begin
2059       1/1              case (dma_bus_width)
2060                           2'b00  : begin // 32-bit wide access
2061       1/1                           ahb_burst_maskh = {3'b111,
2062                                                        |(ahb_burst_length[4:0]),
2063                                                        |(ahb_burst_length[3:0]),
2064                                                        |(ahb_burst_length[2:0]),
2065                                                        |(ahb_burst_length[1:0]),
2066                                                        ahb_burst_length[0]};
2067                                     end
2068                    
2069                           2'b01     : begin // 64-bit wide access
2070       <font color = "red">0/1     ==>                   ahb_burst_maskh = {2'b11,</font>
2071                                                        |(ahb_burst_length[4:0]),
2072                                                        |(ahb_burst_length[3:0]),
2073                                                        |(ahb_burst_length[2:0]),
2074                                                        |(ahb_burst_length[1:0]),
2075                                                        ahb_burst_length[0],
2076                                                        1'b0};
2077                                     end
2078                           default   : begin // 128-bit wide access
2079       <font color = "red">0/1     ==>                   ahb_burst_maskh = {1'b1,</font>
2080                                                        |(ahb_burst_length[4:0]),
2081                                                        |(ahb_burst_length[3:0]),
2082                                                        |(ahb_burst_length[2:0]),
2083                                                        |(ahb_burst_length[1:0]),
2084                                                        ahb_burst_length[0],
2085                                                        2'b00};
2086                                     end
2087                    
2088                        endcase
2089                      end
2090                    
2091                      assign brk1kbndry_burst =
2092                             // Full 16beat burst will cross the 1k boundary
2093                              ((((ahb_data_addr[9:2] &amp;  ahb_burst_maskh) == ahb_burst_maskh) &amp;
2094                                ((ahb_data_addr[9:2] &amp; ~ahb_burst_maskh) != 8'h00))
2095                    
2096                             // If PKT will end before reaching the 1k boundary ...
2097                              &amp; ~(eop_burst &amp; (eop_burst_size &lt; {1'b0,bndry1k_acc_size})));
2098                    
2099                    
2100                      // Calculate the number of accesses before 1k boundary
2101                      always @(*)
2102       1/1              casex (ahb_data_addr[5:2])
2103       1/1                4'b0xxx,4'b1000         : bndry1k_acc_size_32 = 4'd8;
2104       1/1                4'b1101,4'b1110         : bndry1k_acc_size_32 = 4'd2;
2105       1/1                4'b1111                 : bndry1k_acc_size_32 = 4'd1;
2106                    //      4'b1001,4'b101x,4'b1100 : bndry1k_acc_size_32 = 4'd4;
2107       1/1                default                : bndry1k_acc_size_32 = 4'd4;
2108                        endcase
2109                      always @(*)
2110       1/1              casex (ahb_data_addr[6:3])
2111       1/1                4'b0xxx,4'b1000         : bndry1k_acc_size_64 = 4'd8;
2112       1/1                4'b1101,4'b1110         : bndry1k_acc_size_64 = 4'd2;
2113       1/1                4'b1111                 : bndry1k_acc_size_64 = 4'd1;
2114                    //      4'b1001,4'b101x,4'b1100 : bndry1k_acc_size_64 = 4'd4;
2115       1/1                default                : bndry1k_acc_size_64 = 4'd4;
2116                        endcase
2117                      always @(*)
2118                      begin
2119       1/1              casex (ahb_data_addr[7:4])
2120       1/1                4'b0xxx,4'b1000         : bndry1k_acc_size_128 = 4'd8;
2121       <font color = "red">0/1     ==>        4'b1101,4'b1110         : bndry1k_acc_size_128 = 4'd2;</font>
2122       <font color = "red">0/1     ==>        4'b1111                 : bndry1k_acc_size_128 = 4'd1;</font>
2123       <font color = "red">0/1     ==>        default                 : bndry1k_acc_size_128 = 4'd4;</font>
2124                        endcase
2125                      end
2126                    
2127                      assign bndry1k_acc_size = dma_bus_width[1] ? bndry1k_acc_size_128 :
2128                                                dma_bus_width == 2'b01 ? bndry1k_acc_size_64
2129                                                                       : bndry1k_acc_size_32;
2130                    
2131                    
2132                      // breaks_1k_boundary should be set only on the request phase
2133                      assign breaks_1k_boundary = dma_bus_width[1]
2134                                                  ? (rx_dma_burst_addr[9:3] == 7'b1111110)
2135                                                  : (rx_dma_burst_addr[9:2] == {7'b1111111,~dma_bus_width[0]});
2136                    
2137                     // If we are in 128 bit DPRAM mode we need to consider that some data may
2138                     // currently be buffered in the downsize buffer. We also need to factor in if
2139                     // the status has been read. If the status has been read then we may need to subtract
2140                     // some words from the end....this is because the final 128b word read from
2141                     // the DPRAM may not use all bytes - i.e. only 4 bytes of the potential 16
2142                     // bytes could have been used, and we therefore need to factor this into the
2143                     // calculation.
2144                     // One thing that is of noteworthy point here, the dplocns signals (pkt_dplocns,
2145                     // part_dplocns and part_dplocns_left) are used to count dpram words and they
2146                     // count words regardless of the width of the dpram. The
2147                     // part_dplocns_left_downsize signal is however used to count words within
2148                     // the dma bus width - i.e. if the dpram width is 128b and the dma bus width
2149                     // is 32b then part_dplocns_left_downsize will count 4 for every dplocns
2150                     // value. The dplocns signals have a lot going on so it's worth adding a
2151                     // timing diagram to show the interaction of the dplocns signals (with a dma
2152                     // bus width of 64b, a dpram width of 128b and a packet of 32 bytes):
2153                     //
2154                     //                            _   _   _   _   _   _   _   _   _   _   _   _   _   _   _   _
2155                     //                      clk _| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_
2156                     //                           _ ___ ___ ___ ___ _______________________________________________
2157                     //            dpram_rd_state _X_0_X_1_X_2_X_3_X_5_____________________________________________
2158                     //                                         ___     ___     ___     ___
2159                     //               rd_downsize _____________|   |___|   |___|   |___|   |_______________________
2160                     //                                             ___             ___
2161                     //               rxdpram_enb _________________|   |___________|   |___________________________
2162                     //                                                 ___     ___     ___     ___
2163                     //      ahbreqph_strobe_data _____________________|   |___|   |___|   |___|   |_______________
2164                     //                           _________________         _______         _______________________
2165                     //            empty_downsize                  |_______|       |_______|
2166                     //                           _________________ _______________ _______________ _______________
2167                     //          pkt_dplocns_left _________________X________2______X______1________X____0__________
2168                     //                           _________________ _______ _______ ___ ___ ___ ___________________
2169                     // pkt_dplocns_left_downsize _________________X___3___X___2___X___1___X___0___________________
2170                     //                                                                         ___
2171                     //     reading_eop_dpram_rph _____________________________________________|   |_______________
2172                     //                           _________________________________ _______________ _______________
2173                     //               pkt_dplocns ______________________0__________X______1________X______0________
2174                    
2175                     
2176                     assign part_dplocns_left_m1 = part_dplocns_left - {{p_edma_rx_pbuf_addr-1{1'b0}}, 1'b1};
2177                    
2178                     // Create a modfied version of the byte count - subtract one from the end of
2179                     // packet count to make the particulare word slice easier to identify.
2180                     wire [3:0] pkt_end_mod = status_word_3[3:0] - 4'd1;
2181                     
2182                     // Note: in part_dplocns_left_downsize there is no possibility for the addends to produce an overflow, because
2183                     // they are padded such way that the part_dplocns can just be 19 bits. For example 
2184                     // {1'b0,{17-p_edma_rx_pbuf_addr{1'b0}}, part_dplocns_left_m1,1'b0} + {16'd0, size_downsize} 
2185                     // will assume the value of (assuming that p_edma_rx_pbuf_addr = 16 (max value) and all the bits of the 
2186                     // variables are 1s : 0011111111111111110 + 0000000000000000111 = 0100000000000000101
2187                    
2188                     always @(*)
2189       1/1             if (~gem_rx_pbuf_data_w_is_128 | dma_bus_width[1])
2190       1/1               part_dplocns_left_downsize = {{19-p_edma_rx_pbuf_addr{1'b0}}, part_dplocns_left};
2191       <font color = "red">0/1     ==>     else if (dma_bus_width[0]) begin</font>
2192       <font color = "red">0/1     ==>       if (status_word2_capt)</font>
2193       <font color = "red">0/1     ==>         part_dplocns_left_downsize = {1'b0,{17-p_edma_rx_pbuf_addr{1'b0}}, part_dplocns_left_m1,1'b0} + {16'd0, size_downsize} - {18'd0, ~pkt_end_mod[3]}; </font>
2194                         else
2195       <font color = "red">0/1     ==>         part_dplocns_left_downsize = {1'b0,{17-p_edma_rx_pbuf_addr{1'b0}}, part_dplocns_left_m1,1'b0} + {16'd0, size_downsize}; </font>
2196                       end
2197                       else
2198       <font color = "red">0/1     ==>       if (status_word2_capt)</font>
2199       <font color = "red">0/1     ==>         part_dplocns_left_downsize = {{17-p_edma_rx_pbuf_addr{1'b0}},part_dplocns_left_m1,2'b00} + {16'd0, size_downsize} - {17'd0, ~pkt_end_mod[3:2]}; </font>
2200                         else
2201       <font color = "red">0/1     ==>         part_dplocns_left_downsize = {{17-p_edma_rx_pbuf_addr{1'b0}},part_dplocns_left_m1,2'b00} + {16'd0, size_downsize}; </font>
2202                    
2203                    
2204                     // Identify when we are at the end of the data burst
2205                    
2206                     // Determine how many words have already been ready from the downsize block.
2207                     // The number of words used is the inverse of the current downsize buffer
2208                     // size.
2209                     assign num_used_words_downsize =  {1'b0, ~size_downsize[1], ~size_downsize[0]} + 3'b001;
2210                     always @(*)
2211       1/1             if (~gem_rx_pbuf_data_w_is_128 | dma_bus_width[1])
2212       1/1               near_endofpart_local = {{19-p_edma_rx_pbuf_addr{1'b0}},rx_cutthru_threshold} -
2213                                                {{19-p_edma_rx_pbuf_addr{1'b0}},part_dplocns};
2214       <font color = "red">0/1     ==>     else if (dma_bus_width[0])</font>
2215       <font color = "red">0/1     ==>       near_endofpart_local = {{18-p_edma_rx_pbuf_addr{1'b0}},rx_cutthru_threshold,1'b0} -</font>
2216                                                ({{18-p_edma_rx_pbuf_addr{1'b0}},part_dplocns,1'b0} + {17'd0,num_used_words_downsize[2:1]});
2217                       else
2218       <font color = "red">0/1     ==>       near_endofpart_local = {{17-p_edma_rx_pbuf_addr{1'b0}},rx_cutthru_threshold,2'b00} -</font>
2219                                                ({{17-p_edma_rx_pbuf_addr{1'b0}},part_dplocns,2'b00} + {16'd0,num_used_words_downsize});
2220                     // In case the near_endofpart_local wraps round, stop it wrapping round.
2221                     assign near_endofpart = (!rx_cutthru || status_word2_capt) ? {19{1'b1}} : near_endofpart_local[18] ? 19'd0 : near_endofpart_local;
2222                     assign endofpkt_burst = part_dplocns_left_downsize[16:0] &lt; {12'd0,ahb_burst_length[4:0]};
2223                     assign endofbuf_burst = buffer_fill_lvl  &lt; {7'd0, ahb_burst_length[4:0]};
2224                    
2225                     // Really only want to do this on the last part b4
2226                     // reading status, but that requires changes to 'cutthru_statavail'
2227                     assign endofpart_burst = (!rx_cutthru || status_word2_capt) ? 1'b0 : (near_endofpart &lt; {14'd0,ahb_burst_length[4:0]});
2228                    
2229                     always @(*)
2230                     begin
2231       1/1             if (force_max_ahb_burst_rx &amp; |ahb_burst_length[4:2])
2232       <font color = "red">0/1     ==>       eop_burst      = 1'b0;</font>
2233                    
2234                       else
2235       1/1               eop_burst      = endofpkt_burst            |
2236                                          reading_eop_dpram_rph_del |
2237                                          endofbuf_burst            |
2238                                          endofpart_burst;
2239                     end
2240                    
2241                     always @(*)
2242                     begin
2243       1/1             if (reading_eop_dpram_rph_del)
2244       <font color = "red">0/1     ==>       eop_burst_size = 5'h01;</font>
2245       1/1             else if (endofpkt_burst &amp; (part_dplocns_left_downsize[16:0] &lt; {5'd0, buffer_fill_lvl}) &amp;
2246                                                 (part_dplocns_left_downsize[16:0] &lt; near_endofpart[16:0]))
2247       1/1               eop_burst_size = part_dplocns_left_downsize[4:0];
2248       1/1             else if (endofpart_burst &amp; (near_endofpart[15:0] &lt; {4'd0, buffer_fill_lvl}))
2249       <font color = "red">0/1     ==>       eop_burst_size = near_endofpart[4:0];</font>
2250                       else
2251       1/1               eop_burst_size = buffer_fill_lvl[4:0];
2252                     end
2253                    
2254                    
2255                    // In 64b addr mode haddr_descr [63:32] comes from a fixed apb register descr_ptr_msb
2256                     assign haddr_descr_int[63:32]    = ~gem_dma_addr_w_is_64 ? 32'd0 : upper_rx_q_base_addr;
2257                     assign haddr_descr_par_int[7:4]  = ~gem_dma_addr_w_is_64 ? 4'd0  : upper_rx_q_base_par;
2258                     assign haddr_descr_int[31:0]     = haddr[31:0];
2259                     assign haddr_descr_par_int[3:0]  = haddr_par[3:0];
2260                    
2261                     assign hbusreq_descr = ~rx_dma_state_data ? hbusreq : 1'b0;
2262                    
2263                     assign hbusreq_descr_rd  = p_edma_rsc == 1 &amp;&amp; hbusreq &amp; (rx_dma_state_man_rd | (rx_dma_state_man_wr &amp; rx_dma_next_man_rd));
2264                     assign hbusreq_descr_wr  = p_edma_rsc == 1 &amp;&amp; hbusreq &amp; ~hbusreq_descr_rd &amp; ~rx_dma_state_data;
2265                    
2266                     assign hlock_descr       = 1'b0;
2267                     assign hburst_descr      = ~rx_dma_state_data ? hburst  : 3'b000;
2268                     assign htrans_descr      = ~rx_dma_state_data ? htrans  : 2'b00;
2269                     assign hsize_descr       = ~rx_dma_state_data ? hsize   : 3'b010;
2270                     assign hwrite_descr      = ~rx_dma_state_data ? hwrite  : 1'b0;
2271                     assign hprot_descr       = p_edma_hprot_value;
2272                     assign haddr_descr       = ~rx_dma_state_data ? haddr_descr_int[p_edma_addr_width-1:0]     : {p_edma_addr_width{1'b0}};
2273                     assign haddr_descr_par   = ~rx_dma_state_data ? haddr_descr_par_int[p_edma_addr_pwid-1:0]  : {p_edma_addr_pwid{1'b0}};
2274                     assign hwdata_descr      = hwdata;
2275                     assign hwdata_descr_par  = hwdata_par;
2276                    
2277                     assign hbusreq_data      = rx_dma_state_data ? hbusreq : 1'b0;
2278                     assign hlock_data        = 1'b0;
2279                     assign hburst_data       = rx_dma_state_data ? hburst  : 3'b000;
2280                     assign htrans_data       = rx_dma_state_data ? htrans  : 2'b00;
2281                     assign hsize_data        = rx_dma_state_data ? hsize   : 3'b010;
2282                     assign hwrite_data       = rx_dma_state_data ? hwrite  : 1'b0;
2283                     assign hprot_data        = p_edma_hprot_value;
2284                     assign haddr_data        = rx_dma_state_data ? haddr[p_edma_addr_width-1:0]    : {p_edma_addr_width{1'b0}};
2285                     assign haddr_data_par    = rx_dma_state_data ? haddr_par[p_edma_addr_pwid-1:0] : {p_edma_addr_pwid{1'b0}};
2286                     assign hwdata_data       = hwdata;
2287                     assign hwdata_data_par   = hwdata_par;
2288                    
2289                    
2290                    
2291                    //-------------------------------------------
2292                    // End of AHB Interface Logic
2293                    //-------------------------------------------
2294                    
2295                    
2296                    
2297                      // Communicate with Write side of PKT Buffer
2298                      // Count the packets as they are written into the DPRAM
2299                       edma_sync_toggle_detect # (
2300                         .DIN_W(2)
2301                       ) i_edma_sync_toggle_detect_packet_tog (
2302                         .clk(hclk),
2303                         .reset_n(n_hreset),
2304                         .din({end_of_packet_tog,part_of_packet_tog}),
2305                         .rise_edge(),
2306                         .fall_edge(),
2307                         .any_edge({pkt_written_dpram,part_pkt_written}));
2308                    
2309                      always@(posedge hclk or negedge n_hreset)
2310                      begin
2311       1/1              if (~n_hreset)
2312       1/1                pkt_captured         &lt;= 1'b0;
2313       1/1              else if (pkt_written_dpram | part_pkt_written)
2314       1/1                pkt_captured       &lt;= ~pkt_captured;
                        MISSING_ELSE
2315                      end
2316                      
2317                      // If there has been an EOP written in, we know there is a packet waiting
2318                      // to be read
2319                      always@(*)
2320                      begin
2321                        // Count the number of full packets that are sitting in the DPRAM
2322                        // waiting to be written to AHB memory - maximum 256
2323       1/1              if (pkt_written_dpram)
2324       1/1                num_pkts_needing_read_nxt = num_pkts_needing_read + num_pkts_xfer_fullpkt -
2325                                                      (reading_eop_dpram_rph | nxt_pkt_is_err);
2326                    
2327       1/1              else if (reading_eop_dpram_rph | nxt_pkt_is_err)
2328       1/1                num_pkts_needing_read_nxt = num_pkts_needing_read - {{p_edma_rx_pbuf_addr-1{1'b0}},1'b1};
2329                        else
2330       1/1                num_pkts_needing_read_nxt = num_pkts_needing_read;
2331                      end
2332                      
2333                      assign num_parts_needing_read_c = num_parts_needing_read + num_pkts_xfer_partpkt;
2334                      assign part_dplocns_pending_c   = part_dplocns_pending + rx_cutthru_threshold + {{(p_edma_rx_pbuf_addr-1){1'b0}},1'd1};
2335                      
2336                      always@(posedge hclk or negedge n_hreset)
2337                      begin
2338       1/1              if (~n_hreset)
2339                        begin
2340       1/1                num_pkts_needing_read              &lt;= {p_edma_rx_pbuf_addr{1'b0}};
2341       1/1                num_parts_needing_read             &lt;= 8'h00;
2342       1/1                part_dplocns_pending               &lt;= {p_edma_rx_pbuf_addr{1'b0}};
2343       1/1                part_dplocns_pending_for_new_frame &lt;= 1'b1;
2344       1/1                fetch_rem_part                     &lt;= 1'b0;
2345                        end
2346       1/1              else if (~enable_rx_hclk)
2347                        begin
2348       1/1                num_pkts_needing_read              &lt;= {p_edma_rx_pbuf_addr{1'b0}};
2349       1/1                num_parts_needing_read             &lt;= 8'h00;
2350       1/1                part_dplocns_pending               &lt;= {p_edma_rx_pbuf_addr{1'b0}};
2351       1/1                part_dplocns_pending_for_new_frame &lt;= 1'b1;
2352       1/1                fetch_rem_part                     &lt;= 1'b0;
2353                        end
2354                        else
2355                        begin
2356                    
2357       1/1                num_pkts_needing_read &lt;= num_pkts_needing_read_nxt;
2358                    
2359                          // Indicate if the part pkt request coming in are for a new
2360                          // frame or for the current frame.
2361       1/1                if (pkt_written_dpram)
2362       1/1                  part_dplocns_pending_for_new_frame &lt;= 1'b1;
2363       1/1                else if (start_reading_at_risk)
2364       <font color = "red">0/1     ==>          part_dplocns_pending_for_new_frame &lt;= 1'b0;</font>
                        MISSING_ELSE
2365                    
2366                          // Count the number of packet fragements (size equal to value stored
2367                          // in cut-thru threshold register).  This applies to the most recent
2368                          // packet written in only.  Eg. if num_pkts_needing_read  = 3 and
2369                          // num_parts_needing_read = 7, then there are 3 full packets and 7
2370                          // fragments  of the 4th packet available for reading
2371       1/1                if (pkt_written_dpram) begin
2372       1/1                  num_parts_needing_read &lt;= 8'h00;
2373       1/1                  part_dplocns_pending   &lt;= {p_edma_rx_pbuf_addr{1'b0}};
2374                          end
2375                          
2376       1/1                else if (part_pkt_written)
2377                          begin
2378                            // Only allow a decrement if non-zero
2379       <font color = "red">0/1     ==>          if (|num_parts_needing_read &amp; num_pkts_needing_read == {p_edma_rx_pbuf_addr{1'b0}})</font>
2380       <font color = "red">0/1     ==>            num_parts_needing_read &lt;= num_parts_needing_read + num_pkts_xfer_partpkt - last_partpkt_rph;</font>
2381                            else
2382       <font color = "red">0/1     ==>            num_parts_needing_read &lt;= num_parts_needing_read_c[7:0];</font>
2383       <font color = "red">0/1     ==>            part_dplocns_pending   &lt;= part_dplocns_pending_c[p_edma_rx_pbuf_addr-1:0];</font>
2384                          end
2385                    
2386       1/1                else if (last_partpkt_rph &amp; (|num_parts_needing_read) &amp;
2387                                   num_pkts_needing_read == {p_edma_rx_pbuf_addr{1'b0}})
2388       <font color = "red">0/1     ==>          num_parts_needing_read &lt;= num_parts_needing_read - 8'h01;</font>
                        MISSING_ELSE
2389                    
2390                    
2391                          // If we have started fetching a 'part_of_packet' from the DPRAM and the
2392                          // 'pkt_written_dpram' signal is set, we want to make sure we continue to
2393                          // fetch the remainder of that 'part' before we go read the status.  We
2394                          // recognise this time using the fetch_rem_part signal ...
2395       1/1                if (last_partpkt_rph)
2396       <font color = "red">0/1     ==>          fetch_rem_part  &lt;= 1'b0;</font>
2397       1/1                else if (|num_parts_needing_read &amp; pkt_written_dpram &amp;
2398                                    num_pkts_needing_read == {p_edma_rx_pbuf_addr{1'b0}})
2399       <font color = "red">0/1     ==>          fetch_rem_part  &lt;= 1'b1;</font>
                        MISSING_ELSE
2400                         end
2401                      end
2402                    
2403                    
2404                      // When we read the status word for the next packet and it is showing
2405                      // that there is no data associated with the packet,
2406                      assign mac_err_vld = (~status_word_1[0] &amp; status_word1_capt &amp; (~(hbusreq | ahbaddph_strobe_en_data | ahbaddph_strobe_en_descr) | hready));
2407                      assign nxt_pkt_is_err = ((mac_err_vld |
2408                                                ahb_err_pktdiscarded_wait4end | hresp_data_cutthru | flush_next_packet) &amp;
2409                                                status_word1_capt);
2410                    
2411                    
2412                      // generate condition that will cause the next packet in the DPRAM to be flushed
2413                      // This can be immediately if flush_rx_pkt_hclk is set when in an IDLE state
2414                      // or it can use a delayed version of the flush input if we are currently performing
2415                      // or about to perform a descriptor read and the outcome of that is a used bit read
2416                      // only do a flush if there is at nleast 1 packet in the DPRAM.  Dont do it if
2417                      // ahb_err_discard_recover occurs, as this performs a packet flush by itself
2418                      // Ignore if currently writing a frame to memory (state = DATA)
2419                      // Block out flush_rx_pkt_hclk when last_dpram_rd_state == P_STATUS_WORD_4 since
2420                      // this cycle is required to recover the status words from dpram_fill_lvl
2421                      assign flush_next_packet =
2422                             (((flush_rx_pkt_hclk &amp; num_pkts_needing_read !={p_edma_rx_pbuf_addr{1'b0}} &amp;
2423                                rx_dma_state == RX_DMA_IDLE &amp; last_dpram_rd_state != P_STATUS_WORD_4) |
2424                                flush_wait_for_manrd) &amp;
2425                                ~ahb_err_discard_recover &amp; status_word1_capt);
2426                    
2427                    
2428                      always@(posedge hclk or negedge n_hreset)
2429                      begin
2430       1/1              if (~n_hreset)
2431                        begin
2432       1/1                flush_wait_for_manrd  &lt;= 1'b0;
2433       1/1                rx_dma_pkt_flushed &lt;= 1'b0;
2434                        end
2435                        else
2436                        begin
2437       1/1                if (flush_wait_for_manrd &amp;
2438                              (status_word1_capt | (ahbdataph_strobe_descr_rd &amp; ~rx_buffer_used_bit) | ahb_err_discard))
2439       <font color = "red">0/1     ==>          flush_wait_for_manrd &lt;= 1'b0;</font>
2440       1/1                else if (flush_rx_pkt_hclk &amp; num_pkts_needing_read != {p_edma_rx_pbuf_addr{1'b0}} &amp;
2441                                  (nxt_rx_dma_state == RX_DMA_WAIT_STATUS |
2442                                   nxt_rx_dma_state == RX_DMA_MAN_RD |
2443                                   rx_dma_state     == RX_DMA_MAN_RD))
2444       <font color = "red">0/1     ==>          flush_wait_for_manrd &lt;= 1'b1;</font>
                        MISSING_ELSE
2445                    
2446                          // Create a toggle on flush_next_packet, which will be used by
2447                          // the registers block to increment the flush stats counter
2448       1/1                if (flush_next_packet | ahb_err_discard_recover)
2449       <font color = "red">0/1     ==>          rx_dma_pkt_flushed &lt;= ~rx_dma_pkt_flushed;</font>
                        MISSING_ELSE
2450                        end
2451                      end
2452                    
2453                    
2454                      assign reading_eop_dpram_rph = (ahbreqph_strobe_data_nopad &amp;
2455                                                      status_word1_capt &amp;
2456                                                      ~hresp_notok_eob_rph &amp;
2457                                                      pkt_dplocns == (status_word_1[26:15] - 12'h001) &amp;
2458                                                      eop_downsize);
2459                    
2460                      always@(posedge hclk or negedge n_hreset)
2461                      begin
2462       1/1              if (~n_hreset)
2463       1/1                reading_eop_dpram_aph &lt;= 1'b0;
2464       1/1              else if (~enable_rx_hclk)
2465       1/1                reading_eop_dpram_aph &lt;= 1'b0;
2466       1/1              else if (reading_eop_dpram_rph)
2467       1/1                reading_eop_dpram_aph &lt;= 1'b1;
2468       1/1              else if (ahbaddph_strobe_data)
2469       1/1                reading_eop_dpram_aph &lt;= 1'b0;
                        MISSING_ELSE
2470                      end
2471                    
2472                      // Setup some useful cut-thru signals
2473                      // 1) cutthru_statavail gets set as soon as the status for a packet
2474                      //    becomes available. The intention is to finish reading the current
2475                      //    packet fragment and then go fetch the packet status. Once we have
2476                      ///   obtained that, we can progress to the end of the packet as normal
2477                      //    Note that we only need to do this if we are actually reading the
2478                      //    packet at risk - this only happens if we are already in the DATA
2479                      //    state and num_pkts_needing_read == 0
2480                      // 2) cutthru_revertdata is just a simple signal that identifies that
2481                      //    the statemachine must revert back to the data state once the
2482                      //    status has been obtained
2483                      // 3) cutthru_wait4part is a signal used to identify that we have
2484                      //    run out of packet fragments to read, and we need to wait for
2485                      //    either more fragments to become available, or a full packet
2486                      //    to become available
2487                      always@(posedge hclk or negedge n_hreset)
2488                      begin
2489       1/1              if (~n_hreset)
2490                        begin
2491       1/1                cutthru_statavail   &lt;= 1'b0;
2492       1/1                cutthru_revertdata  &lt;= 1'b0;
2493       1/1                cutthru_wait4part   &lt;= 1'b0;
2494       1/1                cutthru_wait4part_reg &lt;= 1'b0;
2495                        end
2496       1/1              else if (~enable_rx_hclk)
2497                        begin
2498       1/1                cutthru_statavail &lt;= 1'b0;
2499       1/1                cutthru_revertdata &lt;= 1'b0;
2500       1/1                cutthru_wait4part_reg &lt;= 1'b0;
2501                        end
2502                        else
2503                        begin
2504       1/1                if (pkt_written_dpram &amp; num_pkts_needing_read == {p_edma_rx_pbuf_addr{1'b0}} &amp; rx_cutthru)
2505       <font color = "red">0/1     ==>          cutthru_statavail &lt;= 1'b1;</font>
2506       1/1                else if (dpram_rd_state == P_STATUS_WORD_4)
2507       1/1                  cutthru_statavail &lt;= 1'b0;
                        MISSING_ELSE
2508                    
2509                          // Wait until the end of the current burst before fetching the status ...
2510       1/1                if (cutthru_statavail &amp; ( dpram_rd_state == P_WAIT_FOR_BUFFER |
2511                                                    dpram_rd_state == P_PKT_DATA))
2512       <font color = "red">0/1     ==>          cutthru_revertdata &lt;= 1'b1;</font>
2513       1/1                else if (dpram_rd_state == P_STATUS_WORD_4)
2514       1/1                  cutthru_revertdata &lt;= 1'b0;
                        MISSING_ELSE
2515                    
2516       1/1                if (num_parts_needing_read == 8'h01 &amp; num_pkts_needing_read == {p_edma_rx_pbuf_addr{1'b0}} &amp;
2517                              last_partpkt_rph &amp; ~part_pkt_written)
2518       <font color = "red">0/1     ==>          cutthru_wait4part &lt;= 1'b1;</font>
2519       1/1                else if (part_pkt_written | dpram_rd_state == P_STATUS_WORD_4)
2520       1/1                  cutthru_wait4part &lt;= 1'b0;
                        MISSING_ELSE
2521                          // Create a delayed verstion of cutthru_wait4part so that we can
2522                          // detected the negative edge, at which point we will read the DPRAM.
2523       1/1                if (dpram_rd_state == P_PKT_DATA)
2524       1/1                  cutthru_wait4part_reg &lt;= cutthru_wait4part;
2525                          else
2526       1/1                  cutthru_wait4part_reg &lt;= 1'b0;
2527                        end
2528                      end
2529                    
2530                    
2531                      // If we have cut-thru operation then monitor for the write side pushing data
2532                      // to the status word FIFO. If data is there then compare the status word
2533                      // with the current frame start address. If there is a match then flag a
2534                      // match and pop the FIFO once the status words have been read.
2535                    
2536                      generate if (p_edma_pbuf_cutthru == 1) begin : gen_cutthru
2537                        wire [p_edma_rx_pbuf_addr-1:0] ct_fifo_addr;
2538                        reg                            cutthru_status_word_pop_r;
2539                        reg                            cutthru_status_word_valid_r;
2540                        assign ct_fifo_addr = cutthru_status_word[p_edma_rx_pbuf_addr+p_ct_fifo_sw-1:p_ct_fifo_sw];
2541                    
2542                        always@(posedge hclk or negedge n_hreset)
2543                        begin
2544       1/1                if (~n_hreset)
2545                          begin
2546       1/1                  cutthru_status_word_valid_r &lt;= 1'b0;
2547       1/1                  cutthru_status_word_pop_r &lt;= 1'b0;
2548                          end
2549                          else
2550                          begin
2551                            // Dont allow 2 pops back to back. The reason is that we pop the FIFO 1 cycle after
2552                            // we use the data to break a data to pop CDC path
2553       1/1                  if (cutthru_status_word_pop) begin
2554       <font color = "red">0/1     ==>            cutthru_status_word_valid_r &lt;= 1'b0;</font>
2555       <font color = "red">0/1     ==>            cutthru_status_word_pop_r &lt;= 1'b0;</font>
2556                            end
2557                    
2558                            // If the state machine is in idle them just pop the FIFO.
2559       1/1                  else if (!cutthru_status_word_empty &amp;&amp; dpram_rd_state == P_IDLE)
2560                            begin
2561       <font color = "red">0/1     ==>            cutthru_status_word_valid_r &lt;= 1'b0;</font>
2562       <font color = "red">0/1     ==>            cutthru_status_word_pop_r &lt;= 1'b1;</font>
2563                            end
2564                            // Determine if the status words in the cutthru status word FIFO match the
2565                            // current frame. Additionally if we have captured the status words then
2566                            // pop the FIFO.
2567       1/1                  else if (!cutthru_status_word_empty &amp;&amp; ct_fifo_addr == saved_start)
2568                            begin
2569       <font color = "red">0/1     ==>            cutthru_status_word_valid_r &lt;= 1'b1;</font>
2570                              // If we have read all of the status words then pop the FIFO
2571       <font color = "red">0/1     ==>            if (dpram_rd_state == P_STATUS_WORD_4)</font>
2572       <font color = "red">0/1     ==>              cutthru_status_word_pop_r &lt;= 1'b1;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
2573                            end
                        MISSING_ELSE
2574                          end
2575                        end
2576                        assign cutthru_status_word_valid = cutthru_status_word_valid_r;
2577                        assign cutthru_status_word_pop = cutthru_status_word_pop_r;
2578                      end else begin : gen_no_cutthru
2579                        assign cutthru_status_word_valid  = 1'b0;
2580                        assign cutthru_status_word_pop    = 1'b0;
2581                      end
2582                      endgenerate
2583                      
2584                      wire [13:0] full_pkt_size_1;
2585                      wire [14:0] full_pkt_size_2;
2586                      wire [13:0] full_pkt_size_3;
2587                      
2588                      assign full_pkt_size_1 = {1'b0,(status_word_1[26:15]-(|status_word_3[3:0])),status_word_3[3]} + {13'h0000,|status_word_3[2:0]} + {12'h000,words_in_residue[1:0]};
2589                      assign full_pkt_size_2 = {     (status_word_1[26:15]-(|status_word_3[3:0])),status_word_3[3:2]} + {13'h0000,|status_word_3[1:0]} + {12'h000,words_in_residue[1:0]};
2590                      assign full_pkt_size_3 = {2'h0,(status_word_1[26:15])}                                          + {12'h000,words_in_residue[1:0]};
2591                      
2592                       // Synchronous store state machine assignments
2593                       // rx disabled = soft reset
2594                      always@(posedge hclk or negedge n_hreset)
2595                      begin
2596       1/1              if (~n_hreset)
2597                        begin
2598       1/1                dpram_rd_state                 &lt;= P_IDLE;
2599       1/1                last_dpram_rd_state            &lt;= P_IDLE;
2600       1/1                rxdpram_web                    &lt;= 1'b0;
2601       1/1                rxdpram_enb                    &lt;= 1'b0;
2602       1/1                rxdpram_enb_d1                 &lt;= 1'b0;
2603       1/1                rxdpram_addrb                  &lt;= {p_edma_rx_pbuf_addr{1'b0}};
2604       1/1                status_word_1                  &lt;= {p_sw_wid{1'b0}};
2605       1/1                status_word_2                  &lt;= {p_sw_wid{1'b0}};
2606       1/1                status_word_3                  &lt;= {p_sw_wid{1'b0}};
2607       1/1                full_pkt_size                  &lt;= 14'h0000;
2608       1/1                status_word2_capt              &lt;= 1'b0;
2609       1/1                status_word3_capt              &lt;= 1'b0;
2610       1/1                saved_addr                     &lt;= {p_edma_rx_pbuf_addr{1'b0}};
2611       1/1                saved_start                    &lt;= {p_edma_rx_pbuf_addr{1'b0}};
2612       1/1                have_performed_read            &lt;= 1'b0;
2613       1/1                status_word_early_fetch_count  &lt;= 3'd0;
2614       1/1                last_partpkt_rph_seen_at_error &lt;= 1'b0;
2615                        end
2616       1/1              else if (~enable_rx_hclk)
2617                        begin
2618       1/1                dpram_rd_state                 &lt;= P_IDLE;
2619       1/1                last_dpram_rd_state            &lt;= P_IDLE;
2620       1/1                rxdpram_web                    &lt;= 1'b0;
2621       1/1                rxdpram_enb                    &lt;= 1'b0;
2622       1/1                rxdpram_enb_d1                 &lt;= 1'b0;
2623       1/1                rxdpram_addrb                  &lt;= {p_edma_rx_pbuf_addr{1'b0}};
2624       1/1                status_word_1                  &lt;= {p_sw_wid{1'b0}};
2625       1/1                status_word_2                  &lt;= {p_sw_wid{1'b0}};
2626       1/1                status_word_3                  &lt;= {p_sw_wid{1'b0}};
2627       1/1                full_pkt_size                  &lt;= 14'h0000;
2628       1/1                status_word2_capt              &lt;= 1'b0;
2629       1/1                status_word3_capt              &lt;= 1'b0;
2630       1/1                saved_addr                     &lt;= {p_edma_rx_pbuf_addr{1'b0}};
2631       1/1                saved_start                    &lt;= {p_edma_rx_pbuf_addr{1'b0}};
2632       1/1                have_performed_read            &lt;= 1'b0;
2633       1/1                status_word_early_fetch_count  &lt;= 3'd0;
2634       1/1                last_partpkt_rph_seen_at_error &lt;= 1'b0;
2635                        end
2636                        else
2637                        begin
2638       1/1                dpram_rd_state      &lt;= dpram_rd_state_nxt;
2639       1/1                last_dpram_rd_state &lt;= dpram_rd_state;
2640       1/1                rxdpram_web         &lt;= rxdpram_web_nxt;
2641       1/1                rxdpram_enb         &lt;= rxdpram_enb_nxt &amp; ~hresp_notok_eob;  // Don't care about SRAM data when major error occurs.
2642       1/1                rxdpram_enb_d1      &lt;= rxdpram_enb;
2643       1/1                rxdpram_addrb       &lt;= rxdpram_addrb_nxt;
2644       1/1                status_word_1       &lt;= nxt_status_word_1;
2645       1/1                status_word_2       &lt;= nxt_status_word_2;
2646       1/1                status_word_3       &lt;= nxt_status_word_3;
2647       1/1                if (p_edma_axi == 1)
2648       1/1                  full_pkt_size     &lt;= (p_edma_rx_pbuf_data == 32'd128 &amp; dma_bus_width == 2'b01) ? full_pkt_size_1:
                   <font color = "red">==>  MISSING_ELSE</font>
2649                                                 (p_edma_rx_pbuf_data == 32'd128 &amp; dma_bus_width == 2'b00) ? full_pkt_size_2[13:0]:
2650                                                                                                             full_pkt_size_3;
2651       1/1                if (real_eop_ahb_rph | nxt_pkt_is_err)
2652                          begin
2653       1/1                  status_word2_capt &lt;= 1'b0;
2654       1/1                  status_word3_capt &lt;= 1'b0;
2655                          end
2656                          else
2657                          begin
2658       1/1                  status_word2_capt &lt;= status_word1_capt;
2659       1/1                  status_word3_capt &lt;= status_word2_capt;
2660                          end
2661       1/1                saved_addr                     &lt;= saved_addr_nxt;
2662       1/1                saved_start                    &lt;= saved_start_nxt;
2663       1/1                have_performed_read            &lt;= have_performed_read_nxt;
2664       1/1                status_word_early_fetch_count  &lt;= status_word_early_fetch_count_nxt;
2665       1/1                last_partpkt_rph_seen_at_error &lt;= last_partpkt_rph_seen_at_error_nxt;
2666                        end
2667                      end
2668                    
2669                      generate if (p_edma_tsu == 1) begin: gen_status_word_4_tsu
2670                        reg [p_sw_wid-1:0] status_word_4_r;
2671                        always@(posedge hclk or negedge n_hreset)
2672                        begin
2673       1/1                if (~n_hreset)
2674       1/1                  status_word_4_r     &lt;= {p_sw_wid{1'b0}};
2675       1/1                else if (~enable_rx_hclk)
2676       1/1                  status_word_4_r    &lt;= {p_sw_wid{1'b0}};
2677                          else
2678       1/1                  status_word_4_r    &lt;= nxt_status_word_4;
2679                        end
2680                        assign status_word_4 = status_word_4_r;
2681                      end else begin: gen_status_word_4_no_tsu
2682                        assign status_word_4 = {p_sw_wid{1'b0}};
2683                      end
2684                      endgenerate
2685                    
2686                    
2687                      // The eop address can be calculated using the formula:
2688                      // eop address = start address + packet length + pkt eop address mod
2689                      // Note. The calculation has been extended to 16 bits to account for the
2690                      // cases where the pbuf address with is larger or smaller than the packet
2691                      // length
2692                    
2693                      // capture the packets lengths and the end address mod from the status wrods
2694                      // coming from the rx_wr side.
2695                      // We also detect if the incoming frame has an error. If this is the case then
2696                      // the frame will be discarded and the pkt_length is only valid for recovering
2697                      // locations and not for calculating the packet end address.
2698                      // Note. The above differs for partial store and forward mode, as this mode doesn't
2699                      // silently drop frames, so the pkt length must be used to calculate the end address.
2700                    
2701                      always @(*) begin
2702                    
2703                        // Is there an error on the frame
2704       1/1              if (status_word_1[0] || rx_cutthru)
2705       1/1                pkt_length_corrected = {5'd0,status_word_1[26:15]};
2706                        else
2707       1/1                pkt_length_corrected = 17'd0;
2708                    
2709                        // Depending on the dma bus width the pkt_end_addr_mod is valid at differing
2710                        // times
2711       1/1              if (dma_bus_width[0] || gem_rx_pbuf_data_w_is_128 || |status_word_early_fetch_count || rx_bd_extended_mode_en )
2712       <font color = "red">0/1     ==>        pkt_end_addr_mod = {{9{status_word_2[7]}}, status_word_2[7:0]};</font>
2713                    
2714       1/1              else if (cutthru_status_word_valid)
2715       <font color = "red">0/1     ==>        pkt_end_addr_mod = {{9{ct_fifo_w1p[7]}}, ct_fifo_w1p[7:0]};</font>
2716                    
2717                        else
2718       1/1                pkt_end_addr_mod = {{9{rxdpram_dob_w0p[7]}}, rxdpram_dob_w0p[7:0]};
2719                    
2720                      end
2721                    
2722                      assign pkt_end_addr = {{17-p_edma_rx_pbuf_addr{1'b0}},saved_start} + pkt_length_corrected + pkt_end_addr_mod;
2723                    
2724                      // Helper funciton to stop code bloat. The address increment is implemented in
2725                      // a number of place, so this function is used to keep the code tidy.
2726                      function [p_edma_rx_pbuf_addr-1:0] get_next_addr;
2727                        input                           inc;
2728                        input [p_edma_rx_pbuf_addr-1:0] saved_addr;
2729                        input [p_edma_rx_pbuf_addr-1:0] current_addr;
2730                        input                     [1:0] dma_bus_width;
2731                        input                           rx_bd_extended_mode_en;
2732                        
2733                        reg   [p_edma_rx_pbuf_addr:0] current_addr_p1;
2734                        reg   [p_edma_rx_pbuf_addr:0] current_addr_p2;
2735                        reg   [p_edma_rx_pbuf_addr:0] current_addr_p3;
2736                        reg   [p_edma_rx_pbuf_addr:0] current_addr_p4;
2737                        reg   [p_edma_rx_pbuf_addr:0] current_addr_p5;
2738                        
2739                        begin
2740                          // First off we calculate some values before getting into the core of
2741                          // this function. This is done for LINT purposes
2742       1/1                current_addr_p1 = current_addr + {{(p_edma_rx_pbuf_addr-1){1'b0}},1'b1};
2743       1/1                current_addr_p2 = current_addr + {{(p_edma_rx_pbuf_addr-2){1'b0}},2'd2};
2744       1/1                current_addr_p3 = current_addr + {{(p_edma_rx_pbuf_addr-2){1'b0}},2'd3};
2745       1/1                current_addr_p4 = current_addr + {{(p_edma_rx_pbuf_addr-3){1'b0}},3'd4};
2746       1/1                current_addr_p5 = current_addr + {{(p_edma_rx_pbuf_addr-3){1'b0}},3'd5};
2747                          
2748                          // If the next address matches the start address - i.e. we have wrapped
2749                          // round in cut-thru mode when we have a relatively small packet buffer,
2750                          // then jump over the saved address.
2751       1/1                if ((current_addr_p1[p_edma_rx_pbuf_addr-1:0]) == saved_addr &amp; inc)
2752       <font color = "red">0/1     ==>          if (p_edma_rx_pbuf_data == 32'd128)</font>
2753       <font color = "red">0/1     ==>            get_next_addr = current_addr_p2[p_edma_rx_pbuf_addr-1:0];</font>
2754       <font color = "red">0/1     ==>          else if (dma_bus_width[0])</font>
2755       <font color = "red">0/1     ==>            get_next_addr = current_addr_p3[p_edma_rx_pbuf_addr-1:0];</font>
2756       <font color = "red">0/1     ==>          else if (~rx_bd_extended_mode_en)</font>
2757       <font color = "red">0/1     ==>            get_next_addr = current_addr_p4[p_edma_rx_pbuf_addr-1:0];</font>
2758                            else
2759       <font color = "red">0/1     ==>            get_next_addr = current_addr_p5[p_edma_rx_pbuf_addr-1:0];</font>
2760                    
2761                          // Increment if we are doing an increment.
2762       1/1                else if (inc)
2763       1/1                  get_next_addr = current_addr_p1[p_edma_rx_pbuf_addr-1:0];
2764                          else
2765       <font color = "red">0/1     ==>          get_next_addr = current_addr;</font>
2766                        end
2767                      endfunction
2768                    
2769                      // Helper signal that used below in a number of places to identify when no
2770                      // frame data is pending.
2771                      assign no_data_pending = (reading_eop_dpram_rph | cutthru_wait4part | ahb_err_pktdiscarded_wait4end |
2772                                                  (rx_cutthru &amp;
2773                                                  last_partpkt_rph &amp;
2774                                                    (~(|num_pkts_needing_read) |
2775                                                    // At an error frame the entire frame won't be written by the write side, so at the last part pkt it
2776                                                    // could well be the last part of the frame, as there will be no more data. In this case we need to
2777                                                    // block the next reads to the RAM. An error occurred here when there was only one frame and the read side
2778                                                    // was writing the end of a new (small) frame as the rd side read past the end of the current frame.
2779                                                    // In this case a DPRAM clash occurred. We therefore now block the write in this case.
2780                                                   ((num_pkts_needing_read == {{p_edma_rx_pbuf_addr-1{1'b0}},1'd1}) &amp; (status_word_early_fetch_count &gt;= 3'd1) &amp; (dpram_rd_state != P_STATUS_WORD_1) &amp; ~status_word_1[0] &amp; (part_dplocns_left_downsize[16:0] == 17'd0))) &amp;
2781                                                  num_parts_needing_read[7:1] == 7'h00 &amp;
2782                                                  ~part_pkt_written));
2783                    
2784                    
2785                      // DPRAM read state machine
2786                      // Note. As part of the 128b DPRAM changes quite a few edits were made to
2787                      // the DPRAM addressing to make accesses more predictable. The original
2788                      // design read the same locations multiple times and the dpram enable and
2789                      // address didn't need to step at the same time. The 128b changes required
2790                      // a read, only when data was needed, rather than continually reading the
2791                      // same location. This was needed as a read to the downsize buffer would
2792                      // increment to the next data slices and it's effectively not possible to
2793                      // read and re-read the same data more than once. There are therefore
2794                      // a number of changes around the DPRAM addressing.
2795                      
2796                      // Here there are a few signals created to store the result of 
2797                      // additions that according to AFL can potentially bring to overflow
2798                      wire   [p_edma_rx_pbuf_addr:0] rxdpram_addrb_p1;
2799                      wire   [p_edma_rx_pbuf_addr:0] rxdpram_addrb_p2;
2800                      wire   [p_edma_rx_pbuf_addr:0] rxdpram_addrb_p3;
2801                      wire   [p_edma_rx_pbuf_addr:0] rxdpram_addrb_p4;
2802                      wire   [p_edma_rx_pbuf_addr:0] rxdpram_addrb_nxt_c1;
2803                      wire   [p_edma_rx_pbuf_addr:0] rxdpram_addrb_nxt_c2;
2804                      wire   [p_edma_rx_pbuf_addr:0] saved_start_p2;
2805                      wire   [p_edma_rx_pbuf_addr:0] saved_start_p3;
2806                      wire   [p_edma_rx_pbuf_addr:0] part_dplocns_p2;
2807                      wire   [p_edma_rx_pbuf_addr:0] part_dplocns_p3;
2808                      wire   [p_edma_rx_pbuf_addr:0] part_dplocns_p4;
2809                      wire   [p_edma_rx_pbuf_addr:0] part_dplocns_p5;
2810                      wire   [p_edma_rx_pbuf_addr:0] recover_dplocns_err_p1;
2811                      wire   [p_edma_rx_pbuf_addr:0] recover_dplocns_err_p2;
2812                      wire   [p_edma_rx_pbuf_addr:0] recover_dplocns_err_p3;
2813                      wire   [p_edma_rx_pbuf_addr:0] recover_dplocns_err_p4;
2814                      wire   [p_edma_rx_pbuf_addr:0] part_dplocns_left_c1;
2815                      wire   [p_edma_rx_pbuf_addr:0] part_dplocns_left_c2;
2816                      wire   [p_edma_rx_pbuf_addr:0] part_dplocns_left_c3;
2817                      wire   [p_edma_rx_pbuf_addr:0] pkt_dplocns_str_c1;
2818                      wire   [p_edma_rx_pbuf_addr:0] pkt_dplocns_str_c2;
2819                      wire   [p_edma_rx_pbuf_addr:0] pkt_dplocns_str_c3;
2820                      wire                     [3:0] status_word_early_fetch_count_p2;
2821                      wire   [p_edma_rx_pbuf_addr:0] rx_cutthru_threshold_p1;
2822                      wire                    [11:0] pkt_dplocns_c1;
2823                      
2824                      assign rxdpram_addrb_p1                 = rxdpram_addrb + {{p_edma_rx_pbuf_addr-1{1'b0}},1'd1};
2825                      assign rxdpram_addrb_p2                 = rxdpram_addrb + {{p_edma_rx_pbuf_addr-2{1'b0}},2'd2};
2826                      assign rxdpram_addrb_p3                 = rxdpram_addrb + {{p_edma_rx_pbuf_addr-2{1'b0}},2'd3};
2827                      assign rxdpram_addrb_p4                 = rxdpram_addrb + {{p_edma_rx_pbuf_addr-3{1'b0}},3'd4};
2828                      assign rxdpram_addrb_nxt_c1             = rxdpram_addrb + part_dplocns_left + {{p_edma_rx_pbuf_addr-1{1'b0}},~have_performed_read};
2829                      assign rxdpram_addrb_nxt_c2             = rxdpram_addrb + part_dplocns_left;
2830                      assign saved_start_p2                   = saved_start   + {{p_edma_rx_pbuf_addr-2{1'b0}},2'd2};
2831                      assign saved_start_p3                   = saved_start   + {{p_edma_rx_pbuf_addr-2{1'b0}},2'd3};
2832                      assign part_dplocns_p2                  = part_dplocns  + {{p_edma_rx_pbuf_addr-2{1'b0}},2'd2};
2833                      assign part_dplocns_p3                  = part_dplocns  + {{p_edma_rx_pbuf_addr-2{1'b0}},2'd3};
2834                      assign part_dplocns_p4                  = part_dplocns  + {{p_edma_rx_pbuf_addr-3{1'b0}},3'd4};
2835                      assign part_dplocns_p5                  = part_dplocns  + {{p_edma_rx_pbuf_addr-3{1'b0}},3'd5};
2836                      assign recover_dplocns_err_p1           = recover_dplocns_err[p_edma_rx_pbuf_addr-1:0] + {{p_edma_rx_pbuf_addr-1{1'b0}},1'd1};
2837                      assign recover_dplocns_err_p2           = recover_dplocns_err[p_edma_rx_pbuf_addr-1:0] + {{p_edma_rx_pbuf_addr-2{1'b0}},2'd2};
2838                      assign recover_dplocns_err_p3           = recover_dplocns_err[p_edma_rx_pbuf_addr-1:0] + {{p_edma_rx_pbuf_addr-2{1'b0}},2'd3};
2839                      assign recover_dplocns_err_p4           = recover_dplocns_err[p_edma_rx_pbuf_addr-1:0] + {{p_edma_rx_pbuf_addr-3{1'b0}},3'd4};
2840                      assign part_dplocns_left_c1             = part_dplocns_pending + rx_cutthru_threshold + {{p_edma_rx_pbuf_addr-1{1'b0}},1'd1};
2841                      assign part_dplocns_left_c2             = part_dplocns_left    + rx_cutthru_threshold;
2842                      assign part_dplocns_left_c3             = part_dplocns_left    + rx_cutthru_threshold + {{p_edma_rx_pbuf_addr-1{1'b0}},1'd1};
2843                      assign pkt_dplocns_str_c1               = pkt_dplocns_str      + status_word_1[p_edma_rx_pbuf_addr+14:15];
2844                      assign pkt_dplocns_str_c2               = pkt_dplocns_str      + pkt_dplocns_to_flush_plus_st;
2845                      assign pkt_dplocns_str_c3               = pkt_dplocns_str      + part_dplocns + {{p_edma_rx_pbuf_addr-1{1'b0}},1'b1};
2846                      assign rx_cutthru_threshold_p1          = rx_cutthru_threshold + {{p_edma_rx_pbuf_addr-1{1'b0}},1'b1};
2847                      assign status_word_early_fetch_count_p2 = status_word_early_fetch_count + 3'd2;
2848                      
2849                      // This whole generate if statement is because we want to avoid LINT warnings...
2850                      generate if(p_edma_rx_pbuf_addr &gt; 32'd11) begin: gen_pkt_dplocns_c1_1
2851                      
2852                        wire [p_edma_rx_pbuf_addr+1:0] pkt_dplocns_aux;
2853                        assign                         pkt_dplocns_aux = rx_cutthru_threshold_p1 + {{(p_edma_rx_pbuf_addr-11){1'b0}},pkt_dplocns};
2854                        assign                         pkt_dplocns_c1  = pkt_dplocns_aux[11:0];
2855                        
2856                      end else if(p_edma_rx_pbuf_addr == 32'd11) begin: gen_pkt_dplocns_c1_2
2857                      
2858                        wire [p_edma_rx_pbuf_addr+1:0] pkt_dplocns_aux;
2859                        assign                         pkt_dplocns_aux = rx_cutthru_threshold_p1 + pkt_dplocns;
2860                        assign                         pkt_dplocns_c1  = pkt_dplocns_aux[11:0];
2861                        
2862                      end else begin: gen_pkt_dplocns_c1_3
2863                      
2864                        wire [12:0] pkt_dplocns_aux2;  
2865                        assign      pkt_dplocns_aux2 = {{(11-p_edma_rx_pbuf_addr){1'b0}},rx_cutthru_threshold_p1} + pkt_dplocns;
2866                        assign      pkt_dplocns_c1   = pkt_dplocns_aux2[11:0];
2867                        
2868                      end
2869                      endgenerate  
2870                      
2871                      always @ ( * )
2872                      begin
2873       1/1              rxdpram_enb_nxt                    = 1'b0;
2874       1/1              rxdpram_web_nxt                    = 1'b0;
2875       1/1              rxdpram_addrb_nxt                  = rxdpram_addrb;
2876       1/1              status_word1_capt                  = status_word2_capt;
2877       1/1              saved_addr_nxt                     = saved_addr;
2878       1/1              saved_start_nxt                    = saved_start;
2879       1/1              dpram_rd_state_nxt                 = dpram_rd_state;
2880       1/1              rd_downsize                        = 1'b0;
2881       1/1              flush_downsize                     = 1'b0;
2882       1/1              have_performed_read_nxt            = have_performed_read;
2883       1/1              cutthru_status_word_override       = 1'b0;
2884       1/1              status_word_early_fetch_count_nxt  = status_word_early_fetch_count;
2885       1/1              last_partpkt_rph_seen_at_error_nxt = last_partpkt_rph_seen_at_error;
2886       1/1              start_reading_at_risk = 1'b0;
2887                    
2888       1/1              case (dpram_rd_state)
2889                          P_IDLE  :
2890                          begin
2891       1/1                  flush_downsize                     = 1'b1;
2892       1/1                  have_performed_read_nxt            = 1'b0;
2893       1/1                  status_word_early_fetch_count_nxt  = 3'd0;
2894       1/1                  last_partpkt_rph_seen_at_error_nxt = 1'b0;
2895                    
2896       1/1                  if (priq_get_status_info) begin
2897       <font color = "red">0/1     ==>            rxdpram_enb_nxt = 1'b1;</font>
2898                            end
                        MISSING_ELSE
2899                    
2900       1/1                  if (
2901                                // Wait until the stats for previous pkt have been
2902                                // captured by REG block
2903                                prev_stats_captured &amp; last_dpram_rd_state != P_STATUS_WORD_4 &amp;
2904                    
2905                                // Cant start reading the next status until we are
2906                                // sure we are done with the current status - some bits
2907                                // are needed for the writeback so wait until the
2908                                // writeback is compeleted before starting a new read
2909                                rx_dma_state != RX_DMA_MAN_WR &amp; ~reading_eop_dpram_aph &amp;
2910                                ~reading_eop_dpram_aph_del &amp; ~padding_aph &amp;
2911                    
2912                                ~status_word1_capt)
2913                            begin
2914       1/1                    saved_addr_nxt     = rxdpram_addrb;
2915       1/1                    saved_start_nxt    = rxdpram_addrb;
2916                    
2917       1/1                    if (|num_pkts_needing_read)
2918                              begin
2919       1/1                      dpram_rd_state_nxt = P_STATUS_WORD_1;
2920       1/1                      rxdpram_enb_nxt    = (~cutthru_status_word_valid &amp; p_edma_queues == 32'd1) | priq_get_status_info;
2921                              end
2922       1/1                    else if (|num_parts_needing_read)
2923                              begin
2924                    
2925                                // Record that we have status words pending to read.
2926       <font color = "red">0/1     ==>              start_reading_at_risk = 1'b1;</font>
2927                    
2928                                //  we are going to write the
2929                                // data to memory 'at risk' because we are in cutthru.  Since the
2930                                // status is not available yet, we just jump straight to data state
2931                                // and set bit zero of statusword1 for now - this bit identifies
2932                                // there is valid data to reasd from the dpram
2933       <font color = "red">0/1     ==>              cutthru_status_word_override = 1'b1;</font>
2934       <font color = "red">0/1     ==>              if (buffer_available)</font>
2935                                begin
2936       <font color = "red">0/1     ==>                flush_downsize      = 1'b0;</font>
2937       <font color = "red">0/1     ==>                dpram_rd_state_nxt  = P_PKT_DATA;</font>
2938       <font color = "red">0/1     ==>                saved_start_nxt     = rxdpram_addrb;</font>
2939       <font color = "red">0/1     ==>                rxdpram_enb_nxt     = 1'b1;</font>
2940       <font color = "red">0/1     ==>                rd_downsize         = 1'b1;</font>
2941       <font color = "red">0/1     ==>                rxdpram_addrb_nxt = gem_rx_pbuf_data_w_is_128 ? rxdpram_addrb_p1[p_edma_rx_pbuf_addr-1:0]</font>
2942                                                      : dma_bus_width[0]        ? rxdpram_addrb_p2[p_edma_rx_pbuf_addr-1:0]
2943                                                      : ~rx_bd_extended_mode_en ? rxdpram_addrb_p3[p_edma_rx_pbuf_addr-1:0]
2944                                                                                : rxdpram_addrb_p4[p_edma_rx_pbuf_addr-1:0];
2945                                end
2946                                else
2947                                begin
2948       <font color = "red">0/1     ==>                dpram_rd_state_nxt = P_WAIT_FOR_BUFFER;</font>
2949       <font color = "red">0/1     ==>                rxdpram_enb_nxt    = 1'b0;</font>
2950       <font color = "red">0/1     ==>                saved_start_nxt    = rxdpram_addrb;</font>
2951                                  // If We don't have a buffer available then position the address pointer at
2952                                  // the last status word location. The wait_for_buffer state will then
2953                                  // increment the address to the first data word.
2954       <font color = "red">0/1     ==>                rxdpram_addrb_nxt = gem_rx_pbuf_data_w_is_128 ? rxdpram_addrb</font>
2955                                                      : dma_bus_width[0]        ? rxdpram_addrb_p1[p_edma_rx_pbuf_addr-1:0]
2956                                                      : ~rx_bd_extended_mode_en ? rxdpram_addrb_p2[p_edma_rx_pbuf_addr-1:0]
2957                                                                                : rxdpram_addrb_p3[p_edma_rx_pbuf_addr-1:0];
2958                                end
2959                              end
2960                              else
2961                              // When priority queueing is enabled, we want to obtain
2962                              // the status information asap, as the status holds the queue
2963                              // information.  This means we will be reading from the DPRAM
2964                              // more than we really need to, but it is the most efficient
2965                              // way
2966                              // The address should already be pointing to the status word,
2967                              // so we can just enable the DPRAM rd here
2968       1/1                      rxdpram_enb_nxt = priq_get_status_info;
2969                            end
2970                            else
2971       1/1                    rxdpram_enb_nxt = priq_get_status_info;
2972                          end
2973                    
2974                          P_STATUS_WORD_1 :
2975                          begin
2976                    
2977                    
2978                            // If we are in status_word_early_fetch_count mode then we are only fetching
2979                            // one status word at a time so we go back to the state we came from, in case
2980                            // any AHB or AXI accesses are taking place
2981       1/1                  if (|status_word_early_fetch_count) begin
2982                    
2983       <font color = "red">0/1     ==>            rxdpram_addrb_nxt = saved_addr;</font>
2984       <font color = "red">0/1     ==>            if (last_dpram_rd_state == P_WAIT_FOR_BUFFER)</font>
2985       <font color = "red">0/1     ==>              dpram_rd_state_nxt = P_WAIT_FOR_BUFFER;</font>
2986                              else begin
2987       <font color = "red">0/1     ==>              dpram_rd_state_nxt  = P_PKT_DATA;</font>
2988                                  // Read the RAM if a new AXI REquest has come in
2989       <font color = "red">0/1     ==>              if (ahbreqph_strobe_data_nopad)</font>
2990                                begin
2991       <font color = "red">0/1     ==>                rxdpram_addrb_nxt = get_next_addr(empty_downsize,saved_start,saved_addr,dma_bus_width,rx_bd_extended_mode_en);</font>
2992       <font color = "red">0/1     ==>                rxdpram_enb_nxt   = empty_downsize &amp; ~no_data_pending;</font>
2993       <font color = "red">0/1     ==>                rd_downsize       = 1'b1;</font>
2994                                end
                   <font color = "red">==>  MISSING_ELSE</font>
2995                              end
2996                    
2997                            end
2998                            else begin
2999       1/1                    dpram_rd_state_nxt  = P_STATUS_WORD_2;
3000       1/1                    if (~gem_rx_pbuf_data_w_is_128) begin
3001       1/1                      rxdpram_addrb_nxt = rxdpram_addrb_p1[p_edma_rx_pbuf_addr-1:0];
3002       1/1                      rxdpram_enb_nxt   = ~cutthru_status_word_valid;
3003                              end
                   <font color = "red">==>  MISSING_ELSE</font>
3004                            end
3005                    
3006                          end
3007                    
3008                          P_STATUS_WORD_2 :
3009                          begin
3010                    
3011                            // If we are in status_word_early_fetch_count mode then we are only fetching
3012                            // one status word at a time so we go back to the state we came from, in case
3013                            // any AHB or AXI accesses are taking place
3014       1/1                  if (|status_word_early_fetch_count) begin
3015                    
3016       <font color = "red">0/1     ==>            rxdpram_addrb_nxt = saved_addr;</font>
3017       <font color = "red">0/1     ==>            if (last_dpram_rd_state == P_WAIT_FOR_BUFFER)</font>
3018       <font color = "red">0/1     ==>              dpram_rd_state_nxt = P_WAIT_FOR_BUFFER;</font>
3019                              else begin
3020       <font color = "red">0/1     ==>              dpram_rd_state_nxt  = P_PKT_DATA;</font>
3021                                // Read the RAM if a new AXI REquest has come in
3022       <font color = "red">0/1     ==>              if (ahbreqph_strobe_data_nopad)</font>
3023                                begin
3024       <font color = "red">0/1     ==>                rxdpram_addrb_nxt = get_next_addr(empty_downsize,saved_start,saved_addr,dma_bus_width,rx_bd_extended_mode_en);</font>
3025       <font color = "red">0/1     ==>                rxdpram_enb_nxt = empty_downsize &amp; ~no_data_pending;</font>
3026       <font color = "red">0/1     ==>                rd_downsize = 1'b1;</font>
3027                                end
                   <font color = "red">==>  MISSING_ELSE</font>
3028                              end
3029                    
3030                            end
3031                    
3032                            else begin
3033                              // Setup Request phase of STATUS WORD3
3034                              // Setup Address phase of STATUS WORD2
3035                              // Data phase of STATUS WORD1
3036       1/1                    if (gem_rx_pbuf_data_w_is_128) begin
3037       <font color = "red">0/1     ==>              rxdpram_addrb_nxt = rxdpram_addrb;</font>
3038       <font color = "red">0/1     ==>              rxdpram_enb_nxt   = 1'b0;</font>
3039                              end
3040       1/1                    else if (dma_bus_width[0]) begin
3041       <font color = "red">0/1     ==>              rxdpram_addrb_nxt = rxdpram_addrb;</font>
3042       <font color = "red">0/1     ==>              rxdpram_enb_nxt   = 1'b0;</font>
3043                              end
3044                              else
3045                              begin
3046       1/1                      rxdpram_enb_nxt   = ~cutthru_status_word_valid;
3047       1/1                      rxdpram_addrb_nxt = rxdpram_addrb_p1[p_edma_rx_pbuf_addr-1:0];
3048                              end
3049       1/1                    if (~rx_bd_extended_mode_en)
3050       1/1                      dpram_rd_state_nxt= P_STATUS_WORD_4; // jump STATUS_3 for legacy mode
3051                              else
3052       <font color = "red">0/1     ==>              dpram_rd_state_nxt= P_STATUS_WORD_3;</font>
3053                            end
3054                    
3055                          end
3056                    
3057                          P_STATUS_WORD_3 : // only used for extra status word read
3058                          begin
3059                    
3060                            // If we are in status_word_early_fetch_count mode then we are only fetching
3061                            // one status word at a time so we go back to the state we came from, in case
3062                            // any AHB or AXI accesses are taking place
3063       <font color = "red">0/1     ==>          if (|status_word_early_fetch_count) begin</font>
3064                    
3065       <font color = "red">0/1     ==>            rxdpram_addrb_nxt = saved_addr;</font>
3066       <font color = "red">0/1     ==>            if (last_dpram_rd_state == P_WAIT_FOR_BUFFER)</font>
3067       <font color = "red">0/1     ==>              dpram_rd_state_nxt = P_WAIT_FOR_BUFFER;</font>
3068                              else begin
3069       <font color = "red">0/1     ==>              dpram_rd_state_nxt  = P_PKT_DATA;</font>
3070                                // Read the RAM if a new AXI REquest has come in
3071       <font color = "red">0/1     ==>              if (ahbreqph_strobe_data_nopad)</font>
3072                                begin
3073       <font color = "red">0/1     ==>                rxdpram_addrb_nxt = get_next_addr(empty_downsize,saved_start,saved_addr,dma_bus_width,rx_bd_extended_mode_en);</font>
3074       <font color = "red">0/1     ==>                rxdpram_enb_nxt = empty_downsize &amp; ~no_data_pending;</font>
3075       <font color = "red">0/1     ==>                rd_downsize = 1'b1;</font>
3076                                end
                   <font color = "red">==>  MISSING_ELSE</font>
3077                              end
3078                    
3079                            end
3080                    
3081                            else begin
3082       <font color = "red">0/1     ==>            if (~gem_rx_pbuf_data_w_is_128)</font>
3083                              begin
3084       <font color = "red">0/1     ==>              if (dma_bus_width[0])</font>
3085                                begin
3086       <font color = "red">0/1     ==>                rxdpram_addrb_nxt = rxdpram_addrb;</font>
3087       <font color = "red">0/1     ==>                rxdpram_enb_nxt   = 1'b0;</font>
3088                                end
3089                                else
3090                                begin
3091       <font color = "red">0/1     ==>                rxdpram_enb_nxt   = ~cutthru_status_word_valid;</font>
3092       <font color = "red">0/1     ==>                rxdpram_addrb_nxt = rxdpram_addrb_p1[p_edma_rx_pbuf_addr-1:0];</font>
3093                                end
3094                              end
                   <font color = "red">==>  MISSING_ELSE</font>
3095       <font color = "red">0/1     ==>            dpram_rd_state_nxt= P_STATUS_WORD_4;</font>
3096                            end
3097                          end
3098                    
3099                          P_STATUS_WORD_4 :   // last status word state
3100                          begin
3101                    
3102       1/1                  status_word1_capt = 1'b1;
3103       1/1                  last_partpkt_rph_seen_at_error_nxt = 1'b0;
3104                    
3105                            // If there is an error with the data, then when cutthru is OFF,
3106                            // there will be no data associated with the packet.  If cut-thru
3107                            // is ON, there will be rubbish data in the dpram that we need
3108                            // to clear out - we dont need to pass this to AHB however ...
3109                            // Jump the address to the end of the packet
3110       1/1                  if (((~status_word_1[0] | ahb_err_pktdiscarded_wait4end) &amp; (rx_cutthru | force_discard_on_error))
3111                                | flush_next_packet | ahb_err_discard_recover)
3112       <font color = "red">0/1     ==>            rxdpram_addrb_nxt = pkt_end_addr[p_edma_rx_pbuf_addr-1:0];</font>
3113                    
3114                            // If we are doing the early fetch then we will do a read
3115                            // if a new axi requests comes in.
3116       1/1                  else if (|status_word_early_fetch_count) begin
3117       <font color = "red">0/1     ==>            rxdpram_addrb_nxt = saved_addr;</font>
3118                              // Read the RAM if a new AXI REquest has come in
3119       <font color = "red">0/1     ==>            if (ahbreqph_strobe_data_nopad)</font>
3120       <font color = "red">0/1     ==>              rxdpram_addrb_nxt = get_next_addr(empty_downsize,saved_start,saved_addr,dma_bus_width,rx_bd_extended_mode_en);</font>
                   <font color = "red">==>  MISSING_ELSE</font>
3121                            end
3122                    
3123       1/1                  else if (cutthru_revertdata)
3124                            begin
3125                              // If we have come from the pkt_data state (we must have done so if
3126                              // cutthru_revertdata is active), when we are in cut through mode,
3127                              // then the status has become available at the end of part packet. When
3128                              // we go pack to the packet data state then the buffer must be available,
3129                              // so we will increment to the next address read.
3130       <font color = "red">0/1     ==>            rxdpram_addrb_nxt = get_next_addr(1'b1, saved_start, saved_addr , dma_bus_width, rx_bd_extended_mode_en);</font>
3131       <font color = "red">0/1     ==>            if (gem_rx_pbuf_data_w_is_128)</font>
3132       <font color = "red">0/1     ==>              saved_addr_nxt = rxdpram_addrb;</font>
3133       <font color = "red">0/1     ==>            else if (dma_bus_width[0])</font>
3134       <font color = "red">0/1     ==>              saved_addr_nxt = rxdpram_addrb-{{p_edma_rx_pbuf_addr-1{1'b0}},1'd1};</font>
3135                              else
3136       <font color = "red">0/1     ==>              if (rx_bd_extended_mode_en)</font>
3137       <font color = "red">0/1     ==>                saved_addr_nxt = rxdpram_addrb-{{p_edma_rx_pbuf_addr-2{1'b0}},2'd3};</font>
3138                                else
3139       <font color = "red">0/1     ==>                saved_addr_nxt = rxdpram_addrb-{{p_edma_rx_pbuf_addr-2{1'b0}},2'd2};</font>
3140                            end
3141                    
3142                            // When a part packet is sent and we can get status, we will retrieve the status.
3143                            // Once the status has been obtained a new buffer may not be available, so we
3144                            // will wait for new data (i.e. go to the P_WAIT_FOR_BUFFER state). If this is
3145                            // the case then we won't increment the ram address. When a buffer is
3146                            // available, we will read the next data within the P_WAIT_FOR_BUFFER state.
3147       1/1                  else if (status_word_1[0] &amp; ~ahb_err_pktdiscarded_wait4end &amp; ~flush_next_packet &amp; ~ahb_err_discard_recover) begin
3148       1/1                    if (buffer_available)
3149       1/1                      rxdpram_addrb_nxt = get_next_addr(empty_downsize,saved_start,rxdpram_addrb,dma_bus_width,rx_bd_extended_mode_en);
3150                              else
3151       <font color = "red">0/1     ==>              rxdpram_addrb_nxt = rxdpram_addrb;</font>
3152                            end
3153                            // The packet was received with an error, so we will just increment the
3154                            // address and will move back to idle
3155                            else
3156       <font color = "red">0/1     ==>            rxdpram_addrb_nxt = rxdpram_addrb_p1[p_edma_rx_pbuf_addr-1:0];</font>
3157                    
3158                            // [31] set means that we dont have status info, but can
3159                            // start reading the data at risk ...
3160                            // [0] means that the status is available and data is available
3161       1/1                  if (status_word_1[0] &amp; ~ahb_err_pktdiscarded_wait4end &amp; ~flush_next_packet &amp; ~ahb_err_discard_recover)
3162                            begin
3163       1/1                    if (|status_word_early_fetch_count) begin
3164       <font color = "red">0/1     ==>              if (last_dpram_rd_state == P_WAIT_FOR_BUFFER)</font>
3165       <font color = "red">0/1     ==>                dpram_rd_state_nxt = P_WAIT_FOR_BUFFER;</font>
3166                                else begin
3167       <font color = "red">0/1     ==>                dpram_rd_state_nxt = P_PKT_DATA;</font>
3168       <font color = "red">0/1     ==>                if (ahbreqph_strobe_data_nopad &amp;&amp; !no_data_pending) begin</font>
3169       <font color = "red">0/1     ==>                  rxdpram_enb_nxt = empty_downsize;</font>
3170       <font color = "red">0/1     ==>                  rd_downsize = 1'b1;</font>
3171                                  end
                   <font color = "red">==>  MISSING_ELSE</font>
3172                                end
3173                              end
3174       1/1                    else if (buffer_available)
3175                              begin
3176       1/1                      dpram_rd_state_nxt = P_PKT_DATA;
3177       1/1                      rxdpram_enb_nxt = empty_downsize;
3178       1/1                      rd_downsize = 1'b1;
3179                              end
3180                              else
3181                              begin
3182       <font color = "red">0/1     ==>              dpram_rd_state_nxt = P_WAIT_FOR_BUFFER;</font>
3183       <font color = "red">0/1     ==>              rxdpram_enb_nxt = 1'b0;</font>
3184                              end
3185                            end
3186                            else
3187                            begin
3188       <font color = "red">0/1     ==>            dpram_rd_state_nxt = P_IDLE;</font>
3189       <font color = "red">0/1     ==>            rxdpram_enb_nxt = 1'b0;</font>
3190                            end
3191                          end
3192                    
3193                          P_WAIT_FOR_BUFFER :
3194                          begin
3195                    
3196       <font color = "red">0/1     ==>          if (flush_next_packet | (ahb_err_discard_recover &amp; status_word1_capt))</font>
3197                            begin
3198       <font color = "red">0/1     ==>            dpram_rd_state_nxt = P_IDLE;</font>
3199       <font color = "red">0/1     ==>            rxdpram_enb_nxt = 1'b0;</font>
3200                              // The DPRAM state machine is designed to perform an address increment when we
3201                              // actually need the next data. If we have for example 8 locations left
3202                              // (part_dplocns_left) then we have 8 increments left to do, but we will also
3203                              // need 1 extra increment to put us to the start of the next packet - this is why
3204                              // the have_performed_read signal is added to the end.
3205       <font color = "red">0/1     ==>            rxdpram_addrb_nxt = rxdpram_addrb_nxt_c1[p_edma_rx_pbuf_addr-1:0];</font>
3206                            end
3207       <font color = "red">0/1     ==>          else if (buffer_available | ahb_err_pktdiscarded_wait4end | ahb_err_discard_recover)</font>
3208                            begin
3209       <font color = "red">0/1     ==>            dpram_rd_state_nxt = P_PKT_DATA;</font>
3210       <font color = "red">0/1     ==>            have_performed_read_nxt = 1'b0;</font>
3211                              // It's possible that we may have run out of buffer data at the same time as
3212                              // a part packet has finished. In this case, we could have fetched a new buffer
3213                              // location but may not have part packet ready. If this is the case then we will
3214                              // only do a DPRAM read if a part packet or full packet is available.
3215       <font color = "red">0/1     ==>            if ((|num_parts_needing_read &amp; rx_cutthru) | (|num_pkts_needing_read)) begin</font>
3216       <font color = "red">0/1     ==>              rxdpram_enb_nxt = empty_downsize &amp; ~have_performed_read;</font>
3217       <font color = "red">0/1     ==>              rd_downsize = ~have_performed_read;</font>
3218       <font color = "red">0/1     ==>              rxdpram_addrb_nxt = get_next_addr(empty_downsize &amp; ~have_performed_read,saved_start,rxdpram_addrb,dma_bus_width,rx_bd_extended_mode_en);</font>
3219                              end
                   <font color = "red">==>  MISSING_ELSE</font>
3220                            end
3221                            // Fix for CUTTHRU_BUG (28/8/2013) - same fix as within the p_pkt_data section
3222       <font color = "red">0/1     ==>          else if (cutthru_statavail &amp;&amp; status_word_early_fetch_count != 3'd4) begin</font>
3223                    
3224       <font color = "red">0/1     ==>            saved_addr_nxt = rxdpram_addrb;</font>
3225                    
3226       <font color = "red">0/1     ==>            case (status_word_early_fetch_count)</font>
3227                    
3228                                3'b000 : begin
3229       <font color = "red">0/1     ==>                rxdpram_enb_nxt = ~cutthru_status_word_valid;</font>
3230       <font color = "red">0/1     ==>                rxdpram_addrb_nxt = saved_start;</font>
3231       <font color = "red">0/1     ==>                dpram_rd_state_nxt = P_STATUS_WORD_1;</font>
3232       <font color = "red">0/1     ==>                status_word_early_fetch_count_nxt = status_word_early_fetch_count + 3'd1;</font>
3233                                end
3234                                3'b001 : begin
3235       <font color = "red">0/1     ==>                rxdpram_enb_nxt = ~gem_rx_pbuf_data_w_is_128 &amp; ~cutthru_status_word_valid; // Only do a read if we are not in 128b mode</font>
3236       <font color = "red">0/1     ==>                rxdpram_addrb_nxt = saved_start + {{p_edma_rx_pbuf_addr-1{1'b0}},1'd1};</font>
3237       <font color = "red">0/1     ==>                dpram_rd_state_nxt = P_STATUS_WORD_2;</font>
3238       <font color = "red">0/1     ==>                status_word_early_fetch_count_nxt = status_word_early_fetch_count + 3'd1;</font>
3239                                end
3240                                // If rx_bd_extended_mode_en is off then we jump over P_STATUS_WORD_3.
3241                                // However, there is a bit of a complication here for errored
3242                                // frames. All existing code is designed to recover frames
3243                                // locations at an errored frame in P_STATUS_WORD_4, and once this
3244                                // state has been reached we go back to IDLE straight away as the
3245                                // frame is errored. This doesn't work for status_word_early_fetch
3246                                // mode as we may have been mid-way through an AMBA burst when we
3247                                // read the status words, so we want to finish the burst before
3248                                // going back to idle. When a frame is errored we therefore avoid
3249                                // reading the last status word until the end of a part packet.
3250                                // The 4th status word is redundant for errored frames - only
3251                                // status words 1-3 are needed, so we can hold off moving into the
3252                                // 4th status word state until a noticeable boundary has passed
3253                                // (part packet for example). If the write side overwrites the
3254                                // 4th status word then it doesn't matter as it's not used anyway.
3255                                3'b010 : begin
3256       <font color = "red">0/1     ==>                rxdpram_enb_nxt   = ~gem_rx_pbuf_data_w_is_128 &amp; ~dma_bus_width[0] &amp; ~cutthru_status_word_valid; // Only do a read if we are in 32b mode;</font>
3257       <font color = "red">0/1     ==>                rxdpram_addrb_nxt = saved_start_p2[p_edma_rx_pbuf_addr-1:0];</font>
3258                                  // At an error always move to P_STATUS_WORD_3
3259       <font color = "red">0/1     ==>                if (!status_word_1[0]) begin</font>
3260       <font color = "red">0/1     ==>                  dpram_rd_state_nxt = P_STATUS_WORD_3;</font>
3261       <font color = "red">0/1     ==>                  status_word_early_fetch_count_nxt = status_word_early_fetch_count + 3'd1;</font>
3262                                  end
3263                                  // If we are in extended bd mode then move to read status word 3
3264                                  // or jump over P_STATUS_WORD_3
3265                                  else begin
3266       <font color = "red">0/1     ==>                  if (!rx_bd_extended_mode_en) begin</font>
3267       <font color = "red">0/1     ==>                    dpram_rd_state_nxt = P_STATUS_WORD_4;</font>
3268       <font color = "red">0/1     ==>                    status_word_early_fetch_count_nxt = status_word_early_fetch_count_p2[2:0];</font>
3269                                    end
3270                                    else begin
3271       <font color = "red">0/1     ==>                    dpram_rd_state_nxt = P_STATUS_WORD_3;</font>
3272       <font color = "red">0/1     ==>                    status_word_early_fetch_count_nxt = status_word_early_fetch_count + 3'd1;</font>
3273                                    end
3274                                  end
3275                                end
3276                    
3277                                default : begin // 3'b011
3278       <font color = "red">0/1     ==>                if (!status_word_1[0]) begin</font>
3279       <font color = "red">0/1     ==>                  dpram_rd_state_nxt                = P_STATUS_WORD_4;</font>
3280       <font color = "red">0/1     ==>                  status_word_early_fetch_count_nxt = status_word_early_fetch_count + 3'd1;</font>
3281                                  end
3282                                  else begin
3283       <font color = "red">0/1     ==>                  rxdpram_enb_nxt    = ~gem_rx_pbuf_data_w_is_128 &amp; ~dma_bus_width[0] &amp; ~cutthru_status_word_valid; // Only do a read if we are in 32b mode;</font>
3284       <font color = "red">0/1     ==>                  rxdpram_addrb_nxt  = saved_start_p3[p_edma_rx_pbuf_addr-1:0];</font>
3285       <font color = "red">0/1     ==>                  dpram_rd_state_nxt = P_STATUS_WORD_4;</font>
3286       <font color = "red">0/1     ==>                  status_word_early_fetch_count_nxt = status_word_early_fetch_count + 3'd1;</font>
3287                                  end
3288                                end
3289                    
3290                              endcase
3291                    
3292                            end
3293                            else
3294                            begin
3295       <font color = "red">0/1     ==>            dpram_rd_state_nxt = P_WAIT_FOR_BUFFER;</font>
3296       <font color = "red">0/1     ==>            rxdpram_enb_nxt = 1'b0;</font>
3297                            end
3298                          end
3299                    
3300                          P_PKT_DATA :
3301                          begin
3302                    
3303                            // When there is an HRESP error after the status has been
3304                            // captured in cut thru modes, then we just jump the packet
3305                            // to the end of the current packet and move to an IDLE
3306                            // state
3307       1/1                  if ((hresp_data_cutthru &amp; status_word1_capt) | flush_next_packet)
3308                            begin
3309       <font color = "red">0/1     ==>            rxdpram_enb_nxt   = 1'b0;</font>
3310       <font color = "red">0/1     ==>            rxdpram_addrb_nxt = rxdpram_addrb_nxt_c2[p_edma_rx_pbuf_addr-1:0];</font>
3311                            end
3312                    
3313                            // If there are major errors, like an hresp error
3314                            // we will just restart the packet.  To do this, we jump the
3315                            // dpram address back to the start of the packet and move to
3316                            // the P_WAIT_FOR_BUFFER state
3317       1/1                  else if (hresp_notok_eob_rph &amp; ~rx_cutthru)
3318                            begin
3319       <font color = "red">0/1     ==>            rxdpram_enb_nxt   = 1'b0;</font>
3320                              // At a hresp error, we should set the address to the last status word location.
3321                              // When the packet re-starts (it will re-start because of the error) then the
3322                              // next read access will increment the address to the first data word, as the
3323                              // DPRAM state machine is designed to incrmenet to the next address when the
3324                              // next data has to be used.
3325       <font color = "red">0/1     ==>            flush_downsize = 1'b1;</font>
3326       <font color = "red">0/1     ==>            if (gem_rx_pbuf_data_w_is_128)</font>
3327       <font color = "red">0/1     ==>              rxdpram_addrb_nxt = saved_addr;</font>
3328       <font color = "red">0/1     ==>            else if (dma_bus_width[0])</font>
3329       <font color = "red">0/1     ==>              rxdpram_addrb_nxt = saved_addr + {{p_edma_rx_pbuf_addr-2{1'b0}},2'b01};</font>
3330                              else
3331       <font color = "red">0/1     ==>              rxdpram_addrb_nxt = saved_start_p2[p_edma_rx_pbuf_addr-1:0];</font>
3332                            end
3333                    
3334                            // If we are currently using cut through mode and
3335                            // the status is now available, wait until the end of the current
3336                            // packet part, and then go read the status.  Also can fetch the
3337                            // status if we are IDLE
3338       1/1                  else if (cutthru_statavail &amp;&amp; status_word_early_fetch_count == 3'd0 &amp;&amp; (last_partpkt_rph ||
3339                                                                                                    cutthru_wait4part ||
3340                                                                                                    ahb_err_pktdiscarded_wait4end))
3341                            begin
3342       <font color = "red">0/1     ==>            rxdpram_enb_nxt = ~cutthru_status_word_valid;</font>
3343       <font color = "red">0/1     ==>            saved_addr_nxt = rxdpram_addrb;</font>
3344       <font color = "red">0/1     ==>            rxdpram_addrb_nxt = saved_addr;</font>
3345                            end
3346                    
3347                            // Cut-thru bug  (28/8/2013) - referred to as CUTTHRU_BUG
3348                            // Using the SOC environment cutthru mode had a big issue, where the fabric
3349                            // would back off for a period of time mid cutthru frame. If this back-off happened
3350                            // to be in the middle of a part packet then all state machines, and in particular
3351                            // status word fetches, are on hold until the part packet is finished. While
3352                            // waiting on the part packet to finish a number of frames may be received.
3353                            // It's therefore possible to have the scenario where the cut-thru frame currently
3354                            // being sent over AXI has almost been sent and we are at position 900 out of
3355                            // a 1000 byte frame when the fabric backs-off. The status words are written at the
3356                            // start of the frame but these status words cannot be accessed until the part packet
3357                            // is complete, even although they are available. The rx_wr side will however
3358                            // re-claim the 900 bytes as it correctly believes these have been sent on. By
3359                            // writing to this 900 byte area the rx_wr side also overwrites the status words
3360                            // for the current cutthru frame.
3361                            // To resolve this issue we fetch status words much earlier if the AXI or AHB
3362                            // is not doing an access. In normal operation (before this fix) we will fetch
3363                            // all 4 status words in a row as we have a known big gap. For this fix we
3364                            // we could be in the middle of an AHB/AXI burst so we will fetch one status word
3365                            // at a time.
3366                            //
3367       1/1                  else if ((cutthru_statavail &amp;&amp; status_word_early_fetch_count != 3'd4 &amp;&amp; ~last_data_to_buff_rph) &amp;&amp;
3368                                        // We are not currently reading data
3369                                      ( !(ahbreqph_strobe_data_nopad &amp;&amp; empty_downsize) ||
3370                                        // We are currently at the last part pkt of an error frame so we will abort the frame
3371                                        (ahbreqph_strobe_data_nopad &amp;&amp; last_partpkt_rph &amp;&amp; !status_word_1[0])) )
3372                            begin
3373       <font color = "red">0/1     ==>            saved_addr_nxt = rxdpram_addrb;</font>
3374       <font color = "red">0/1     ==>            rd_downsize = ahbreqph_strobe_data;</font>
3375                    
3376       <font color = "red">0/1     ==>            case (status_word_early_fetch_count)</font>
3377                    
3378                                3'b000 : begin
3379       <font color = "red">0/1     ==>                rxdpram_enb_nxt = ~cutthru_status_word_valid;</font>
3380       <font color = "red">0/1     ==>                rxdpram_addrb_nxt = saved_start;</font>
3381       <font color = "red">0/1     ==>                status_word_early_fetch_count_nxt = status_word_early_fetch_count + 3'd1;</font>
3382                                end
3383                                3'b001 : begin
3384       <font color = "red">0/1     ==>                rxdpram_enb_nxt = ~gem_rx_pbuf_data_w_is_128 &amp; ~cutthru_status_word_valid; // Only do a read if we are not in 128b mode</font>
3385       <font color = "red">0/1     ==>                rxdpram_addrb_nxt = saved_start + {{p_edma_rx_pbuf_addr-1{1'b0}},1'd1};</font>
3386       <font color = "red">0/1     ==>                status_word_early_fetch_count_nxt = status_word_early_fetch_count + 3'd1;</font>
3387                                end
3388                                // If rx_bd_extended_mode_en is off then we jump over P_STATUS_WORD_3.
3389                                // However, there is a bit of a complication here for errored
3390                                // frames. All existing code is designed to recover frames
3391                                // locations at an errored frame in P_STATUS_WORD_4, and once this
3392                                // state has been reached we go back to IDLE straight away as the
3393                                // frame is errored. This doesn't work for status_word_early_fetch
3394                                // mode as we may have been mid-way through an AMBA burst when we
3395                                // read the status words, so we want to finish the burst before
3396                                // going back to idle. When a frame is errored we therefore avoid
3397                                // reading the last status word until the end of a part packet.
3398                                // The 4th status word is redundant for errored frames - only
3399                                // status words 1-3 are needed, so we can hold off moving into the
3400                                // 4th status word state until a noticeable boundary has passed
3401                                // (part packet for example). If the write side overwrites the
3402                                // 4th status word then it doesn't matter as it's not used anyway.
3403                                3'b010 : begin
3404       <font color = "red">0/1     ==>                rxdpram_enb_nxt   = ~gem_rx_pbuf_data_w_is_128 &amp; ~dma_bus_width[0] &amp; ~cutthru_status_word_valid; // Only do a read if we are in 32b mode;</font>
3405       <font color = "red">0/1     ==>                rxdpram_addrb_nxt = saved_start_p2[p_edma_rx_pbuf_addr-1:0];</font>
3406                                  // At an error always move to P_STATUS_WORD_3
3407       <font color = "red">0/1     ==>                if (!status_word_1[0]) begin</font>
3408       <font color = "red">0/1     ==>                  status_word_early_fetch_count_nxt = status_word_early_fetch_count + 3'd1;</font>
3409                                  end
3410                                  // If we are in extended bd mode then move to read status word 3
3411                                  // or jump over P_STATUS_WORD_3
3412                                  else begin
3413       <font color = "red">0/1     ==>                  if (!rx_bd_extended_mode_en) begin</font>
3414       <font color = "red">0/1     ==>                    status_word_early_fetch_count_nxt = status_word_early_fetch_count_p2[2:0];</font>
3415                                    end
3416                                    else begin
3417       <font color = "red">0/1     ==>                    status_word_early_fetch_count_nxt = status_word_early_fetch_count + 3'd1;</font>
3418                                    end
3419                                  end
3420                                end
3421                    
3422                                default : begin // 3'b011
3423                                  // If the frame is errored then we will wait until a
3424                                  // recongisable boundary before moving to P_STATUS_WORD_4 to
3425                                  // allow us to clean up neatly.
3426       <font color = "red">0/1     ==>                if (!status_word_1[0]) begin</font>
3427                                    // Don't need the last data so don't bother doing the read.
3428       <font color = "red">0/1     ==>                  if (last_partpkt_rph ||</font>
3429                                        cutthru_wait4part ||
3430                                        ahb_err_pktdiscarded_wait4end ||
3431                                        last_partpkt_rph_seen_at_error ||
3432                                        (part_dplocns_left == {p_edma_rx_pbuf_addr{1'b0}} &amp;&amp; rx_cutthru)) begin
3433       <font color = "red">0/1     ==>                    status_word_early_fetch_count_nxt = status_word_early_fetch_count + 3'd1;</font>
3434                                    end
                   <font color = "red">==>  MISSING_ELSE</font>
3435                                  end
3436                                  else begin
3437       <font color = "red">0/1     ==>                  rxdpram_enb_nxt   = ~gem_rx_pbuf_data_w_is_128 &amp; ~dma_bus_width[0] &amp; ~cutthru_status_word_valid; // Only do a read if we are in 32b mode;</font>
3438       <font color = "red">0/1     ==>                  rxdpram_addrb_nxt = saved_start_p3[p_edma_rx_pbuf_addr-1:0];</font>
3439       <font color = "red">0/1     ==>                  status_word_early_fetch_count_nxt = status_word_early_fetch_count + 3'd1;</font>
3440                                  end
3441                                end
3442                    
3443                              endcase
3444                    
3445                            end
3446                    
3447       1/1                  else if (ahbreqph_strobe_data_nopad)
3448                            begin
3449                              // Don't read the RAM as there is currenlty no data to be read.
3450       1/1                    if (no_data_pending) begin
3451       1/1                      rxdpram_enb_nxt   = 1'b0;
3452                                // If the last access was an eop then move the address on.
3453       1/1                      rxdpram_addrb_nxt = reading_eop_dpram_rph ? rxdpram_addrb_p1[p_edma_rx_pbuf_addr-1:0] : rxdpram_addrb;
3454                              end
3455                    
3456                              // Move to the next address at a read.
3457                              else begin
3458       1/1                      rxdpram_enb_nxt   = empty_downsize;
3459       1/1                      rd_downsize       = 1'b1;
3460       1/1                      rxdpram_addrb_nxt = get_next_addr(empty_downsize,saved_start,rxdpram_addrb,dma_bus_width,rx_bd_extended_mode_en);
3461                              end
3462                    
3463                            end
3464                    
3465                            else
3466                            begin
3467                              // At the falling edge of cutthru_wait4part new data has become available as
3468                              // a result of part pkt being availble. When this occurs we will read the next
3469                              // word, so that it's ready for the ahb/axi side.
3470       1/1                    if (rx_cutthru) begin
3471       <font color = "red">0/1     ==>              if ((|num_parts_needing_read | (|num_pkts_needing_read)) &amp; ((~cutthru_wait4part)&amp;cutthru_wait4part_reg)</font>
3472                                    &amp; ~ahb_err_pktdiscarded_wait4end) begin
3473       <font color = "red">0/1     ==>                rxdpram_enb_nxt   = empty_downsize;</font>
3474       <font color = "red">0/1     ==>                rd_downsize       = 1'b1;</font>
3475       <font color = "red">0/1     ==>                rxdpram_addrb_nxt = get_next_addr(empty_downsize,saved_start,rxdpram_addrb,dma_bus_width,rx_bd_extended_mode_en);</font>
3476                                end
                   <font color = "red">==>  MISSING_ELSE</font>
3477                              end
                        MISSING_ELSE
3478                              // Corner case. Padding is signalled once cycle later than what it should be
3479                              // - i.e. we read data for the next access and then padding is signalled once
3480                              // cycle later. If we happen to run out of buffer space at this point then we
3481                              // will move to the P_WAIT_FOR_BUFFER state. The P_WAIT_FOR_BUFFER state
3482                              // automatically increments the address to the next location when a buffer
3483                              // becomes available. We don't want this to happen though as we have already
3484                              // fetched the data.
3485       1/1                    if (padding_rph)
3486       <font color = "red">0/1     ==>               have_performed_read_nxt = 1'b1;</font>
                        MISSING_ELSE
3487                            end
3488                    
3489       1/1                  if (reading_eop_dpram_rph)
3490       1/1                    dpram_rd_state_nxt  = P_IDLE;
3491       1/1                  else if ((status_word1_capt &amp; hresp_data_cutthru) | flush_next_packet)
3492       <font color = "red">0/1     ==>            dpram_rd_state_nxt  = P_IDLE;</font>
3493       1/1                  else if (hresp_notok_eob_rph &amp; ~rx_cutthru)
3494       <font color = "red">0/1     ==>            dpram_rd_state_nxt  = P_WAIT_FOR_BUFFER;</font>
3495       1/1                  else if (cutthru_statavail &amp;&amp; status_word_early_fetch_count == 3'd0 &amp;&amp; (last_partpkt_rph ||
3496                                                                                                    cutthru_wait4part ||
3497                                                                                                    ahb_err_pktdiscarded_wait4end))
3498       <font color = "red">0/1     ==>            dpram_rd_state_nxt  = P_STATUS_WORD_1;</font>
3499       1/1                  else if (last_data_to_buff_rph)
3500                            begin
3501       <font color = "red">0/1     ==>            dpram_rd_state_nxt  = P_WAIT_FOR_BUFFER;</font>
3502                              // Address override. When we run out of buffer space, don't increment the
3503                              // address or perform a read. We only want to perform a read or increment
3504                              // the address when a buffer becomes available.
3505       <font color = "red">0/1     ==>            rd_downsize       = 1'b0;</font>
3506       <font color = "red">0/1     ==>            rxdpram_enb_nxt   = 1'b0;</font>
3507       <font color = "red">0/1     ==>            rxdpram_addrb_nxt = rxdpram_addrb ;</font>
3508       <font color = "red">0/1     ==>            saved_addr_nxt    = saved_addr;</font>
3509                            end
3510       1/1                  else if ((cutthru_statavail &amp;&amp; status_word_early_fetch_count != 3'd4 &amp;&amp; ~last_data_to_buff_rph) &amp;&amp;
3511                                        // We are not currently reading data
3512                                      ( !(ahbreqph_strobe_data_nopad &amp;&amp; empty_downsize) ||
3513                                        // We are currently at the last part pkt of an errored frame so we will abort the frame
3514                                        (ahbreqph_strobe_data_nopad &amp;&amp; last_partpkt_rph &amp;&amp; !status_word_1[0])) )
3515                            begin
3516                    
3517                              // Record if we have already seen the last_partpkt_rph signal whilst
3518                              // mid-way through reading the status words.
3519       <font color = "red">0/1     ==>            if (last_partpkt_rph &amp;&amp; !status_word_1[0] &amp;&amp; status_word_early_fetch_count &gt;= 3'd1)</font>
3520       <font color = "red">0/1     ==>              last_partpkt_rph_seen_at_error_nxt = 1'b1;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
3521                    
3522                    
3523       <font color = "red">0/1     ==>            case (status_word_early_fetch_count)</font>
3524                    
3525                                3'b000 : begin
3526       <font color = "red">0/1     ==>                dpram_rd_state_nxt = P_STATUS_WORD_1;</font>
3527                                end
3528                                3'b001 : begin
3529       <font color = "red">0/1     ==>                dpram_rd_state_nxt = P_STATUS_WORD_2;</font>
3530                                end
3531                                3'b010 : begin
3532                                  // At an error always move to P_STATUS_WORD_3
3533       <font color = "red">0/1     ==>                if (!status_word_1[0]) begin</font>
3534       <font color = "red">0/1     ==>                  dpram_rd_state_nxt = P_STATUS_WORD_3;</font>
3535                                  end
3536                                  // If we are in extended bd mode then move to read status word 3
3537                                  // or jump over P_STATUS_WORD_3
3538                                  else begin
3539       <font color = "red">0/1     ==>                  if (!rx_bd_extended_mode_en) begin</font>
3540       <font color = "red">0/1     ==>                    dpram_rd_state_nxt = P_STATUS_WORD_4;</font>
3541                                    end
3542                                    else begin
3543       <font color = "red">0/1     ==>                    dpram_rd_state_nxt = P_STATUS_WORD_3;</font>
3544                                    end
3545                                  end
3546                                end
3547                    
3548                                default : begin // 3'b011
3549       <font color = "red">0/1     ==>                 if (!status_word_1[0]) begin</font>
3550                                    // Don't need the last data so don't bother doing the read.
3551       <font color = "red">0/1     ==>                  if (last_partpkt_rph ||</font>
3552                                        cutthru_wait4part ||
3553                                        ahb_err_pktdiscarded_wait4end ||
3554                                        last_partpkt_rph_seen_at_error ||
3555                                        (part_dplocns_left == {p_edma_rx_pbuf_addr{1'b0}} &amp;&amp; rx_cutthru)) begin
3556       <font color = "red">0/1     ==>                    dpram_rd_state_nxt = P_STATUS_WORD_4;</font>
3557                                    end
                   <font color = "red">==>  MISSING_ELSE</font>
3558                                  end
3559                                  else begin
3560       <font color = "red">0/1     ==>                  dpram_rd_state_nxt = P_STATUS_WORD_4;</font>
3561                                  end
3562                                end
3563                    
3564                              endcase
3565                            end
3566                            else
3567       1/1                    dpram_rd_state_nxt  = P_PKT_DATA;
3568                          end
3569                    
3570       1/1                default : dpram_rd_state_nxt  = P_IDLE; // Default
3571                        endcase
3572                      end
3573                    
3574                      // For cut thru modes, if there are errors that stop us reading all
3575                      // the packet from DPRAM, we must have a means to identify how much
3576                      // space we need to recover.  It is possible that some of the packet
3577                      // will have been read and this pkt data will have already been
3578                      // recovered before we realisd there was an error - we want to recover
3579                      // the remainder of total pkt length in terms of dpram locns - num of
3580                      // locns that have already been recovered
3581                      wire  [16:0] tmp_recovery_bus;
3582                      assign tmp_recovery_bus =  {5'd0,status_word_1[26:15]} - {5'd0,pkt_dplocns};
3583                      always@(posedge hclk or negedge n_hreset)
3584                      begin
3585       1/1              if (~n_hreset)
3586                        begin
3587       1/1                recover_dplocns_err &lt;= {p_edma_rx_pbuf_addr+1{1'b0}};
3588                        end
3589                        else
3590                        begin
3591       1/1                if (dpram_rd_state == P_STATUS_WORD_4)
3592                          begin
3593       1/1                  if ((~status_word_1[0] | ahb_err_pktdiscarded_wait4end | ahb_err_discard_recover) &amp; rx_cutthru &amp; !reading_eop_dpram_rph) begin
3594       <font color = "red">0/1     ==>            if (|status_word_early_fetch_count) begin</font>
3595       <font color = "red">0/1     ==>              if (~last_partpkt_rph)</font>
3596       <font color = "red">0/1     ==>                recover_dplocns_err &lt;=  tmp_recovery_bus[p_edma_rx_pbuf_addr-1:0] + part_dplocns;</font>
3597                                else
3598       <font color = "red">0/1     ==>                recover_dplocns_err &lt;=  {1'b0,tmp_recovery_bus[p_edma_rx_pbuf_addr-1:0]};</font>
3599                              end
3600                              else
3601       <font color = "red">0/1     ==>              recover_dplocns_err &lt;=  {1'b0,tmp_recovery_bus[p_edma_rx_pbuf_addr-1:0]};</font>
3602                            end
3603                            else
3604       1/1                    recover_dplocns_err &lt;=  {p_edma_rx_pbuf_addr+1{1'b0}};
3605                          end
                        MISSING_ELSE
3606                        end
3607                      end
3608                    
3609                    
3610                      always@(posedge hclk or negedge n_hreset)
3611                      begin
3612       1/1              if (~n_hreset)
3613       1/1                ahb_err_pktdiscarded_wait4end &lt;= 1'b0;
3614                        else
3615                        begin
3616       1/1                if (status_word1_capt | last_data_to_buff_aph)
3617       1/1                  ahb_err_pktdiscarded_wait4end &lt;= 1'b0;
3618       1/1                else if (ahb_err_discard_recover)
3619       <font color = "red">0/1     ==>          ahb_err_pktdiscarded_wait4end &lt;= 1'b1;</font>
                        MISSING_ELSE
3620                        end
3621                      end
3622                    
3623                      wire  [35:0]  sts_val_1p; // Pad 1 with parity.
3624                      assign sts_val_1p = 36'h100000001;
3625                    
3626                      // Sample the status words after they have been read from the RAM. This code
3627                      // was originally in the P_STATUS_WORD_N states but was removed to be
3628                      // common as the status_word_early_fetch mode can have the status words valid
3629                      // in the P_PKT_DATA state.
3630                      // Depending on the various bus widths the status words are sampled at
3631                      // differing times.
3632                    
3633                      always @(*) begin
3634                    
3635       1/1              nxt_status_word_1   = status_word_1;
3636       1/1              nxt_status_word_2   = status_word_2;
3637       1/1              nxt_status_word_3   = status_word_3;
3638       1/1              nxt_status_word_4   = status_word_4;
3639                    
3640       1/1              if (cutthru_status_word_override)
3641       <font color = "red">0/1     ==>        nxt_status_word_1 = sts_val_1p[p_sw_wid-1:0];</font>
3642                    
3643                        else
3644       1/1                case (last_dpram_rd_state)
3645                    
3646                            P_STATUS_WORD_1 : begin
3647                    
3648       <font color = "red">2/3     ==>            if (cutthru_status_word_valid) nxt_status_word_1  = ct_fifo_w0p[p_sw_wid-1:0]; else nxt_status_word_1 = rxdpram_dob_w0p[p_sw_wid-1:0];</font>
3649       1/1                    if (gem_rx_pbuf_data_w_is_128) begin
3650       <font color = "red">0/3     ==>              if (cutthru_status_word_valid) nxt_status_word_2  = ct_fifo_w1p[p_sw_wid-1:0]; else nxt_status_word_2 = rxdpram_dob_w1p[p_sw_wid-1:0];</font>
3651       <font color = "red">0/3     ==>              if (cutthru_status_word_valid) nxt_status_word_3  = ct_fifo_w2p[p_sw_wid-1:0]; else nxt_status_word_3 = rxdpram_dob_w2p[p_sw_wid-1:0];</font>
3652       <font color = "red">0/3     ==>              if (cutthru_status_word_valid) nxt_status_word_4  = ct_fifo_w3p[p_sw_wid-1:0]; else nxt_status_word_4 = rxdpram_dob_w3p[p_sw_wid-1:0];</font>
3653                              end
3654       1/1                    else if (dma_bus_width[0]) begin
3655       <font color = "red">0/3     ==>              if (cutthru_status_word_valid) nxt_status_word_2  = ct_fifo_w1p[p_sw_wid-1:0]; else nxt_status_word_2 = rxdpram_dob_w1p[p_sw_wid-1:0];</font>
3656                              end
                        MISSING_ELSE
3657                            end
3658                    
3659                            P_STATUS_WORD_2 :
3660                    
3661       1/1                    if (~gem_rx_pbuf_data_w_is_128)
3662                              begin
3663       1/1                      if (dma_bus_width[0])
3664                                begin
3665       <font color = "red">0/3     ==>                if (cutthru_status_word_valid) nxt_status_word_3 = ct_fifo_w2p[p_sw_wid-1:0]; else nxt_status_word_3  = rxdpram_dob_w0p[p_sw_wid-1:0];</font>
3666       <font color = "red">0/3     ==>                if (cutthru_status_word_valid) nxt_status_word_4 = ct_fifo_w3p[p_sw_wid-1:0]; else nxt_status_word_4 = rxdpram_dob_w1p[p_sw_wid-1:0];</font>
3667                                end
3668       <font color = "red">2/3     ==>              else if (cutthru_status_word_valid) nxt_status_word_2 = ct_fifo_w1p[p_sw_wid-1:0]; else nxt_status_word_2  = rxdpram_dob_w0p[p_sw_wid-1:0];</font>
3669                              end
                   <font color = "red">==>  MISSING_ELSE</font>
3670                    
3671                            P_STATUS_WORD_3 :
3672                    
3673       <font color = "red">0/1     ==>            if (~gem_rx_pbuf_data_w_is_128 &amp; ~dma_bus_width[0])</font>
3674                              begin
3675       <font color = "red">0/1     ==>              if (cutthru_status_word_valid)</font>
3676       <font color = "red">0/1     ==>                nxt_status_word_3 = ct_fifo_w2p[p_sw_wid-1:0];</font>
3677                                else
3678       <font color = "red">0/1     ==>                nxt_status_word_3  = rxdpram_dob_w0p[p_sw_wid-1:0];</font>
3679                              end
                   <font color = "red">==>  MISSING_ELSE</font>
3680                    
3681                    
3682                            P_STATUS_WORD_4 :
3683                    
3684       1/1                    if (dma_bus_width==2'b00 &amp; ~gem_rx_pbuf_data_w_is_128)
3685                              begin
3686       1/1                      if ((~|status_word_early_fetch_count) || status_word_1[0])
3687                                begin
3688       1/1                        if(~rx_bd_extended_mode_en)
3689                                  begin
3690       1/1                          if (cutthru_status_word_valid)
3691       <font color = "red">0/1     ==>                    nxt_status_word_3 = ct_fifo_w2p[p_sw_wid-1:0];</font>
3692                                    else
3693       1/1                            nxt_status_word_3  = rxdpram_dob_w0p[p_sw_wid-1:0];
3694                                  end
3695                                  else
3696                                  begin
3697       <font color = "red">0/1     ==>                  if (cutthru_status_word_valid)</font>
3698       <font color = "red">0/1     ==>                    nxt_status_word_4 = ct_fifo_w3p[p_sw_wid-1:0];</font>
3699                                    else
3700       <font color = "red">0/1     ==>                    nxt_status_word_4 = rxdpram_dob_w0p[p_sw_wid-1:0];</font>
3701                                  end
3702                                end
                   <font color = "red">==>  MISSING_ELSE</font>
3703                              end
                   <font color = "red">==>  MISSING_ELSE</font>
                        MISSING_DEFAULT
3704                          endcase
3705                    
3706                        end
3707                    
3708                    //******************************************************************************
3709                    // Main state machine
3710                    //******************************************************************************
3711                    
3712                      // rx_dma_state - current state of the state machine
3713                      //------------------------------------------------
3714                      always@(posedge hclk or negedge n_hreset)
3715                      begin
3716       1/1              if (~n_hreset)
3717                        begin
3718       1/1                rx_dma_state        &lt;= RX_DMA_IDLE;
3719       1/1                last_rx_dma_state   &lt;= RX_DMA_IDLE;
3720       1/1                mac_err_vld_pending &lt;= 1'b0;
3721                        end
3722                        else
3723                        begin
3724       1/1                rx_dma_state        &lt;= nxt_rx_dma_state;
3725                          // last_rx_dma_state is only used to indicate when to generate interrupts
3726                          // for normal frames or frames that require a writeback
3727                          // Since hresp_notok_eob can generate an interrupt itself, we dont
3728                          // need to generate a 2nd interrupt
3729       1/1                if (hresp_notok_eob)
3730       <font color = "red">0/1     ==>          last_rx_dma_state &lt;= RX_DMA_IDLE;</font>
3731       1/1                else if (hready)
3732       1/1                  last_rx_dma_state &lt;= rx_dma_state;
                        MISSING_ELSE
3733                    
3734       1/1                mac_err_vld_pending &lt;= nxt_mac_err_vld_pending;
3735                        end
3736                      end
3737                    
3738                      // Use  'pkt_written_dpram' as an event to get a descriptor. Also routinely trigger an RX descriptor read
3739                      // if there are frames waiting to be received and a pkt_written_dpram is not forthcoming. This avoids
3740                      // packets being kept in the internal SRAm for prolonged periods of time.
3741                      assign new_descr_fetch_trig = (pkt_written_dpram | (restart_trigger &amp; (|num_pkts_needing_read)));
3742                    
3743                      // nxt_rx_dma_state - next state evaluation for the dma_rx state machine
3744                      always@( * )
3745                      begin
3746       1/1              nxt_mac_err_vld_pending = hready ? 1'b0 : mac_err_vld_pending;
3747                        // If receive is disabled return to idle
3748       1/1              if (~enable_rx_hclk)
3749       1/1                nxt_rx_dma_state = RX_DMA_IDLE;
3750                    
3751                        else
3752                        begin
3753                          // ... IMPORTANT ...
3754                          // Note this statemachine works in the address phase.  This has
3755                          // implications when using data-phase timed signals, like data.
3756                          // For example, the first data strobe in RX_DMA_DATA_STORE actually
3757                          // relates to the data strobe for the RX_DMA_MAN_RD
3758                          // state -
3759       1/1                case (rx_dma_state)
3760                    
3761                            // After a error event or after RX is enabled
3762                            // we need to get a buffer ...
3763                            RX_DMA_IDLE:
3764                    
3765                              // If the packet was discarded, just wait in IDLE for the packet
3766                              // to end ...
3767       1/1                    if (ahb_err_discard_recover | ahb_err_pktdiscarded_wait4end | hresp_data_cutthru | flush_rx_pkt_hclk)
3768       <font color = "red">0/1     ==>              nxt_rx_dma_state = RX_DMA_IDLE;</font>
3769                    
3770                              // Use  'pkt_written_dpram' as an event to get a descriptor. Also routinely trigger an RX descriptor read
3771                              // if there are frames waiting to be received and a pkt_written_dpram is not forthcoming. This avoids
3772                              // packets being kept in the internal SRAm for prolonged periods of time.
3773       1/1                    else if (new_descr_fetch_trig &amp;
3774                                        ~(ahb_err_discard_recover | ahb_sf_err_hold)) // ETH-252 block if waiting for previous status from last dropped frame
3775                              // For priority queues we always have to read the status words to get the
3776                              // priority queue when it's a full frame.
3777                              begin
3778       1/1                      if (p_edma_queues == 32'd1)
3779       1/1                        nxt_rx_dma_state = RX_DMA_MAN_RD;
3780                                else
3781       <font color = "red">0/1     ==>                nxt_rx_dma_state = RX_DMA_WAIT_STATUS;</font>
3782                              end
3783       1/1                    else if (part_pkt_written &amp; ~(ahb_err_discard_recover | ahb_sf_err_hold)) begin // ETH-252 block if waiting for previous status from last dropped frame
3784       <font color = "red">0/1     ==>              if (p_edma_queues == 32'd1 || early_queue_info_en)</font>
3785       <font color = "red">0/1     ==>                nxt_rx_dma_state = RX_DMA_MAN_RD;</font>
3786                                else
3787       <font color = "red">0/1     ==>                nxt_rx_dma_state = RX_DMA_WAIT_STATUS;</font>
3788                              end
3789                    
3790                              // Otherwise wait for rx_buffer_required
3791                              else
3792       1/1                      nxt_rx_dma_state = RX_DMA_IDLE;
3793                    
3794                            RX_DMA_WAIT_STATUS :
3795                            begin
3796       <font color = "red">0/1     ==>            if (early_queue_info_en |</font>
3797                                  (status_word1_capt &amp; nxt_status_word_1[0]))
3798       <font color = "red">0/1     ==>              nxt_rx_dma_state = RX_DMA_MAN_RD;</font>
3799                              else
3800       <font color = "red">0/1     ==>              nxt_rx_dma_state = RX_DMA_WAIT_STATUS;</font>
3801                            end
3802                    
3803                            // RX_DMA_MAN_RD:
3804                            // read current buffer descriptor word_0; ahb read burst and
3805                            // transition according to the state of the ownership bit:
3806                            RX_DMA_MAN_RD: begin
3807                    
3808                               // bus err from previous state
3809       1/1                    if (hresp_notok_eob)
3810       <font color = "red">0/1     ==>               nxt_rx_dma_state = RX_DMA_IDLE;</font>
3811                    
3812                              // not used so go to data state
3813                              // Only transfer if all queues have been updated
3814       1/1                    else if ( (ahbaddph_strobe_descr_rd &amp; descriptor_rd_1_access)                                     // single read
3815                                      | ((ahbaddph_strobe_descr_rd &amp; (descr_rd_addph_cnt == 2'h1)) &amp; descriptor_rd_2_access))     // 2 reads
3816       1/1                       nxt_rx_dma_state = RX_DMA_DATA_STORE;
3817                    
3818                              // buffer descriptor not read yet
3819                              else
3820       1/1                       nxt_rx_dma_state = RX_DMA_MAN_RD;
3821                    
3822                              // It's possible in cutthru mode that the status can be fetched and an error can be
3823                              // detected while the we are waiting for the descriptor read data. If this is the
3824                              // case then we will let the descritpor read finish and abort after that.
3825       1/1                    if (mac_err_vld)
3826       <font color = "red">0/1     ==>              nxt_mac_err_vld_pending = rx_cutthru;</font>
3827                              else
3828       1/1                      nxt_mac_err_vld_pending = mac_err_vld_pending;
3829                    
3830                            end
3831                    
3832                            // RX_DMA_DATA_STORE:
3833                            //
3834                            RX_DMA_DATA_STORE:
3835                    
3836                              // bus err or rx_buffer_used_bit (remember the first address
3837                              // phase here is actually
3838                              // the data phase of the management read
3839       1/1                    if (hresp_notok_eob | rx_buffer_used_bit | (mac_err_vld &amp; rx_cutthru) | (mac_err_vld_pending &amp; hready))
3840       <font color = "red">0/1     ==>                nxt_rx_dma_state = RX_DMA_IDLE;</font>
3841                    
3842                              // current buffer full or whole frame transferred and last addr
3843                              // phase of the bus transaction
3844       1/1                    else if ((last_data_to_buff_aph &amp; ~padding_rph) |
3845                                       (ahb_access_cnt == 4'h0 &amp; padding_aph))
3846                              begin
3847                                // Buffer is full, or pkt is fully written to memory,
3848                                // so do the writeback
3849       1/1                      nxt_rx_dma_state = RX_DMA_MAN_WR;
3850                              end
3851                    
3852                              // more frame data to be transferred and space is available
3853                              else
3854       1/1                       nxt_rx_dma_state = RX_DMA_DATA_STORE;
3855                    
3856                    
3857                            // write back the buffer descriptor according to the frame storage
3858                            // status ahb write burst
3859                            default : // RX_DMA_MAN_WR:
3860                    
3861                              // hresp or other error in writeback, can't recover buffer.
3862       1/1                    if (hresp_notok_eob)
3863       <font color = "red">0/1     ==>               nxt_rx_dma_state = RX_DMA_IDLE;</font>
3864                    
3865                              //
3866       1/1                    else if (astrobe_manwr_last)
3867                              begin
3868       1/1                      if (p_edma_queues &gt; 32'd1)
3869                                begin
3870       <font color = "red">0/1     ==>                if ((|num_pkts_needing_read) | pkt_written_dpram | reading_eop_dpram_aph_del | (|num_parts_needing_read) | part_pkt_written)</font>
3871                                  begin
3872       <font color = "red">0/1     ==>                  if (early_queue_info_en | (status_word1_capt &amp; nxt_status_word_1[0]) | reading_eop_dpram_aph_del)</font>
3873       <font color = "red">0/1     ==>                    nxt_rx_dma_state = RX_DMA_MAN_RD;</font>
3874                                    else
3875       <font color = "red">0/1     ==>                    nxt_rx_dma_state = RX_DMA_WAIT_STATUS;</font>
3876                                  end
3877                                  else
3878       <font color = "red">0/1     ==>                  nxt_rx_dma_state = RX_DMA_IDLE;</font>
3879                                end
3880                                else
3881       1/1                        nxt_rx_dma_state = RX_DMA_MAN_RD;
3882                              end
3883                    
3884                              // status for current buff not written yet
3885                              else
3886       1/1                       nxt_rx_dma_state = RX_DMA_MAN_WR;
3887                    
3888                          endcase
3889                        end
3890                      end
3891                    
3892                    
3893                       // Determine if an error condition has occured in the state machine and pass this to the rsc
3894                       assign rx_dma_err  = (rx_dma_state == RX_DMA_DATA_STORE &amp; rx_buffer_used_bit);
3895                    
3896                       // Decoding of the current and next state
3897                       assign rx_dma_state_data   = rx_dma_state==RX_DMA_DATA_STORE;
3898                       assign rx_dma_state_man_rd = rx_dma_state==RX_DMA_MAN_RD;
3899                       assign rx_dma_state_man_wr = rx_dma_state==RX_DMA_MAN_WR;
3900                       assign rx_dma_next_man_rd  = nxt_rx_dma_state==RX_DMA_MAN_RD;
3901                       assign rx_dma_next_man_wr  = nxt_rx_dma_state==RX_DMA_MAN_WR;
3902                       assign rx_dma_next_data    = nxt_rx_dma_state==RX_DMA_DATA_STORE;
3903                    
3904                    
3905                      always @(*)
3906                      begin
3907       1/1              if (cutthru_status_word_valid)
3908                        begin
3909       <font color = "red">0/1     ==>        early_fld_offset_info_nxt[11:0]   = ct_fifo_w2p[25:14];//[cutthru_status_word[89:78];</font>
3910       <font color = "red">0/1     ==>        early_fld_offset_info_nxt[23:12]  = ct_fifo_w0p[12:1];</font>
3911       <font color = "red">0/1     ==>        early_fld_offset_info_nxt[28:24]  =  // l3 and rest from sw3</font>
3912                                                               ct_fifo_w1p[23] &amp; ct_fifo_w1p[9] ? 5'd26 : // VLAN and SNAP
3913                                                               ct_fifo_w1p[23]                  ? 5'd18 : // VLAN
3914                                                               ct_fifo_w1p[9]                   ? 5'd22 : // SNAP
3915                                                                                                  5'd14;
3916                    //      Currently RSC is not supported with cutthru operation
3917                    //      if (p_edma_rsc == 1)
3918                    //        early_fld_offset_info_nxt[30:29] = ct_fifo_w2p[27:26];
3919                    //      else
3920       <font color = "red">0/1     ==>          early_fld_offset_info_nxt[30:29] = 2'b00;</font>
3921                        end
3922                        else
3923                        begin
3924       1/1                early_fld_offset_info_nxt[11:0]   = 12'h000; // l4_offset from sw3 (not needed early)
3925       1/1                early_fld_offset_info_nxt[23:12]  = rxdpram_dob_w0p[12:1]; // pld_offset from sw1
3926       1/1                early_fld_offset_info_nxt[28:24]  =  5'h1f;
3927       1/1                if (p_edma_rsc == 1)
3928       <font color = "red">0/1     ==>          early_fld_offset_info_nxt[30:29] = rxdpram_dob_w0p[14:13];</font>
3929                          else
3930       1/1                  early_fld_offset_info_nxt[30:29] = 2'b00;
3931                        end
3932                      end
3933                    
3934                    // Priority Queue Number
3935                    // Use the Queue from the screener logic (if priority queuing is enabled)
3936                      always@(posedge hclk or negedge n_hreset)
3937                      begin
3938       1/1              if (~n_hreset)
3939                        begin
3940       1/1                early_fld_offset_info &lt;= 31'd0;
3941       1/1                nxt_early_queue_info_en &lt;= 1'b0;
3942       1/1                part_of_packet_fld_offsets_pending &lt;= 31'd0;
3943       1/1                num_pkts_needing_read_neq_zero_reg &lt;= 1'b0;
3944                        end
3945       1/1              else if (~enable_rx_hclk)
3946                        begin
3947       1/1                early_fld_offset_info &lt;= 31'd0;
3948       1/1                nxt_early_queue_info_en &lt;= 1'b0;
3949       1/1                part_of_packet_fld_offsets_pending &lt;= 31'd0;
3950       1/1                num_pkts_needing_read_neq_zero_reg &lt;= 1'b0;
3951                        end
3952                        else
3953                        begin
3954       1/1                nxt_early_queue_info_en &lt;= (rx_dma_state == RX_DMA_MAN_WR &amp;
3955                                                      rxdpram_enb &amp;
3956                                                     (|num_pkts_needing_read) &amp; first_buffer_of_pkt);
3957                    
3958       1/1                num_pkts_needing_read_neq_zero_reg &lt;= |num_pkts_needing_read;
3959                    
3960                          // An early read of the DPRAM is running, so store the queue info.
3961       1/1                if (rx_dma_state == RX_DMA_MAN_WR &amp; nxt_early_queue_info_en)
3962                          begin
3963       <font color = "red">0/1     ==>          early_fld_offset_info &lt;= early_fld_offset_info_nxt;</font>
3964                          end
3965                          // A part packet has been written and there are no pending frames.
3966       1/1                else if (part_pkt_written &amp;&amp; (pkt_written_dpram == 1'b0 &amp;&amp; !(|num_pkts_needing_read))) begin
3967       <font color = "red">0/1     ==>          early_fld_offset_info &lt;= part_of_packet_fld_offsets;</font>
3968                          end
3969                          // When the num_pkts_needing_read hits empty and there are part packets pending then
3970                          // use the pending pointer address.
3971       1/1                else if (!(|num_pkts_needing_read) &amp;&amp; num_pkts_needing_read_neq_zero_reg &amp;&amp; |num_parts_needing_read &amp;&amp; !pkt_written_dpram) begin
3972       <font color = "red">0/1     ==>          early_fld_offset_info &lt;= part_of_packet_fld_offsets_pending;</font>
3973                          end
                        MISSING_ELSE
3974                    
3975                          // A part packet has been written and there are pending frames. In this
3976                          // case we store the part packet pointers, which can be used once the full
3977                          // frame has been sent.
3978       1/1                if (part_pkt_written)
3979       <font color = "red">0/1     ==>          part_of_packet_fld_offsets_pending &lt;= part_of_packet_fld_offsets;</font>
                        MISSING_ELSE
3980                        end
3981                      end
3982                    
3983                    // This code should reflect the combi and sync processes above, but are specific for priority queues
3984                    // They were separated just for LINT reasons
3985                    // Priority Queue Number
3986                    // Use the Queue from the screener logic (if priority queuing is enabled)
3987                    generate if (p_edma_queues &gt; 32'd1) begin : gen_set_early_queue_id
3988                      reg          early_queue_info_en_nxt;
3989                      reg [3:0]    early_queue_info_nxt;
3990                      reg [3:0]    part_of_packet_queue_ptr_pending; // A part packet is pending for after the full
3991                                                                     // stored frame has been transmitted.
3992                    
3993                      always @(*)
3994                      begin
3995                        if (cutthru_status_word_valid)
3996                        begin
3997                          early_queue_info_nxt              = ct_fifo_w0p[30:27];
3998                          early_queue_info_en_nxt           = ct_fifo_w0p[0];
3999                        end
4000                        else
4001                        begin
4002                          early_queue_info_nxt              = rxdpram_dob_w0p[30:27];
4003                          early_queue_info_en_nxt           = rxdpram_dob_w0p[0];
4004                        end
4005                      end
4006                    
4007                      always@(posedge hclk or negedge n_hreset)
4008                      begin
4009                        if (~n_hreset)
4010                        begin
4011                          early_queue_info                 &lt;= 4'h0;
4012                          early_queue_info_en              &lt;= 1'h0;
4013                          part_of_packet_queue_ptr_pending &lt;= 4'd0;
4014                        end
4015                        else if (~enable_rx_hclk)
4016                        begin
4017                          early_queue_info                 &lt;= 4'h0;
4018                          early_queue_info_en              &lt;= 1'h0;
4019                          part_of_packet_queue_ptr_pending &lt;= 4'd0;
4020                        end
4021                        else
4022                        begin
4023                          // An early read of the DPRAM is running, so store the queue info.
4024                          if (rx_dma_state == RX_DMA_MAN_WR &amp; nxt_early_queue_info_en)
4025                          begin
4026                            early_queue_info    &lt;= early_queue_info_nxt;
4027                            early_queue_info_en &lt;= early_queue_info_en_nxt;
4028                          end
4029                          // A part packet has been written and there are no pending frames.
4030                          else if (part_pkt_written &amp;&amp; (pkt_written_dpram == 1'b0 &amp;&amp; !(|num_pkts_needing_read))) begin
4031                            early_queue_info    &lt;= part_of_packet_queue_ptr;
4032                            early_queue_info_en &lt;= 1'b1;
4033                          end
4034                          // When the num_pkts_needing_read hits empty and there are part packets pending then
4035                          // use the pending pointer address.
4036                          else if (!(|num_pkts_needing_read) &amp;&amp; num_pkts_needing_read_neq_zero_reg &amp;&amp; |num_parts_needing_read &amp;&amp; !pkt_written_dpram) begin
4037                            early_queue_info    &lt;= part_of_packet_queue_ptr_pending;
4038                            early_queue_info_en &lt;= 1'b1;
4039                          end
4040                          else if (dpram_rd_state == P_STATUS_WORD_2 | status_word1_capt)
4041                            early_queue_info_en &lt;= 1'h0;
4042                    
4043                          // A part packet has been written and there are pending frames. In this
4044                          // case we store the part packet pointers, which can be used once the full
4045                          // frame has been sent.
4046                          if (part_pkt_written)
4047                            part_of_packet_queue_ptr_pending &lt;= part_of_packet_queue_ptr;
4048                        end
4049                      end
4050                      end else begin : gen_set_early_no_queue
4051                        wire   zero;
4052                        assign zero = 1'b0;
4053                        always @(*)
4054                        begin
4055       1/1                early_queue_info_en = zero;
4056       1/1                early_queue_info    = {4{zero}};
4057                        end
4058                      end
4059                      endgenerate
4060                    
4061                      always @(*)
4062                        // The status words haven't been updated yet, so use the early queue
4063                        // info - dont do this for the descriptor write state
4064       1/1              if (early_queue_info_en &amp; ~real_eop_ahb_dph_reg)
4065                        begin
4066       <font color = "red">0/1     ==>        pld_offset                      = early_fld_offset_info[23:12];</font>
4067       <font color = "red">0/1     ==>        l4_offset                       = early_fld_offset_info[11:0];</font>
4068       <font color = "red">0/1     ==>        l3_offset                       = early_fld_offset_info[28:24];</font>
4069       <font color = "red">0/1     ==>        rsc_stop_from_dma               = p_edma_rsc == 1 &amp;&amp; early_fld_offset_info[29];</font>
4070       <font color = "red">0/1     ==>        rsc_push_from_dma               = p_edma_rsc == 1 &amp;&amp; early_fld_offset_info[30];</font>
4071       <font color = "red">0/1     ==>        offset_has_become_available     = ~(rx_dma_next_man_wr &amp; first_buffer_of_pkt);</font>
4072                        end
4073                    
4074                        else
4075                        begin
4076       1/1                rsc_stop_from_dma = p_edma_rsc == 1 &amp;&amp; status_word_1[13];
4077       1/1                rsc_push_from_dma = p_edma_rsc == 1 &amp;&amp; status_word_1[14];
4078       1/1                pld_offset = status_word_1[12:1];
4079       1/1                l4_offset = status_word_3[25:14];
4080       1/1                l3_offset = status_word_2[23] &amp; status_word_2[9]  ? 5'd26 : // VLAN and SNAP
4081                                      status_word_2[23]                     ? 5'd18 : // VLAN
4082                                      status_word_2[9]                      ? 5'd22 : // SNAP
4083                                                                              5'd14;
4084       1/1                offset_has_become_available = status_word3_capt;
4085                        end
4086                    
4087                    
4088                    generate if (p_edma_queues &gt; 32'd1) begin : gen_set_queues
4089                      reg [3:0] queue_ptr_rx_rph_r;
4090                      reg [3:0] queue_ptr_rx_aph_r;
4091                      reg [3:0] queue_ptr_rx_dph_r;
4092                      always @(*)
4093                        // If we are doing the descriptor writeback for the previous frame,
4094                        // hold the old data.
4095                        if (rx_dma_next_man_wr &amp; first_buffer_of_pkt)
4096                          queue_ptr_rx_rph_r = status_word_1[30:27];
4097                        // The status words haven't been ready yet, so use the early queue
4098                        // info
4099                        else if (early_queue_info_en)
4100                          queue_ptr_rx_rph_r = early_queue_info;
4101                        else
4102                          queue_ptr_rx_rph_r = status_word_1[30:27];
4103                    
4104                      always@(posedge hclk or negedge n_hreset)
4105                      begin
4106                        if (~n_hreset)
4107                        begin
4108                          queue_ptr_rx_aph_r &lt;= 4'h0;
4109                          queue_ptr_rx_dph_r &lt;= 4'h0;
4110                        end
4111                        else
4112                        begin
4113                          if (hready)
4114                          begin
4115                            queue_ptr_rx_aph_r &lt;= queue_ptr_rx_rph;
4116                            queue_ptr_rx_dph_r &lt;= queue_ptr_rx_aph;
4117                          end
4118                        end
4119                      end
4120                      assign  queue_ptr_rx_rph = queue_ptr_rx_rph_r;
4121                      assign  queue_ptr_rx_aph = queue_ptr_rx_aph_r;
4122                      assign  queue_ptr_rx_dph = queue_ptr_rx_dph_r;
4123                    
4124                    end else begin : gen_set_no_queues
4125                      assign  queue_ptr_rx_rph = 4'd0;
4126                      assign  queue_ptr_rx_aph = 4'd0;
4127                      assign  queue_ptr_rx_dph = 4'd0;
4128                    end
4129                    endgenerate
4130                    
4131                      edma_sync_toggle_detect i_edma_sync_toggle_detect_dma_addr_or_mask (
4132                        .clk(hclk),
4133                        .reset_n(n_hreset),
4134                        .din(dma_addr_or_mask[8]),
4135                        .rise_edge(),
4136                        .fall_edge(),
4137                        .any_edge(dma_addr_or_mask_edge));
4138                    
4139                      always@(posedge hclk or negedge n_hreset)
4140       1/1              if (~n_hreset)
4141       1/1                dma_addr_or_mask_hclk  &lt;= 8'h00;
4142                        else
4143       1/1                if (dma_addr_or_mask_edge)
4144       <font color = "red">0/1     ==>          dma_addr_or_mask_hclk  &lt;= dma_addr_or_mask[7:0];</font>
                        MISSING_ELSE
4145                    
4146                      always@(posedge hclk or negedge n_hreset)
4147                      begin
4148       1/1              if (~n_hreset)
4149                        begin
4150       1/1                descriptor_captured &lt;= 1'b0;
4151       1/1                hbusreq      &lt;= 1'b0;
4152       1/1                for (i=0; i&lt;p_edma_queues; i=i+1) begin
4153       1/1                  nxt_descr_ptr[i] &lt;= {p_awid_par{1'b0}};
4154       1/1                  str_descriptor[i] &lt;= {p_awid_par{1'b0}};
4155                          end
4156       1/1                rx_dma_descr_ptr_tog   &lt;= 1'b0;
4157       1/1                ahb_data_addr       &lt;= {p_awid_par{1'b0}};
4158       1/1                ahb_data_addr_2     &lt;= {p_awid_par{1'b0}};
4159       1/1                bit3n2data_add_64   &lt;= 2'd0;
4160       1/1                first_buffer_of_pkt &lt;= 1'b1;
4161       1/1                rx_sof_written      &lt;= 1'b0;
4162       1/1                rx_eof_written      &lt;= 1'b0;
4163                        end
4164                        else
4165                        begin
4166       1/1                if (~enable_rx_hclk)
4167                          begin
4168       1/1                  descriptor_captured &lt;= 1'b0;
4169       1/1                  hbusreq               &lt;= 1'b0;
4170       1/1                  for (i=0; i&lt;p_edma_queues; i=i+1)
4171                            begin
4172       1/1                    str_descriptor[i] &lt;= {p_awid_par{1'b0}};
4173       1/1                    if (i == 0)
4174                              begin
4175       1/1                      if (new_rx_q_ptr_pulse)
4176       1/1                        nxt_descr_ptr[i] &lt;= rx_dma_base_addr_arr[0];
                        MISSING_ELSE
4177                              end
4178                              else
4179       <font color = "red">0/1     ==>              nxt_descr_ptr[i] &lt;= rx_dma_base_addr_arr[i];</font>
4180                            end
4181       1/1                  ahb_data_addr         &lt;= {p_awid_par{1'b0}};
4182       1/1                  ahb_data_addr_2       &lt;= {p_awid_par{1'b0}};
4183       1/1                  bit3n2data_add_64     &lt;= 2'd0;
4184       1/1                  first_buffer_of_pkt   &lt;= 1'b1;
4185       1/1                  rx_sof_written        &lt;= 1'b0;
4186       1/1                  rx_eof_written        &lt;= 1'b0;
4187                          end
4188                          else
4189                          begin
4190       1/1                  case (rx_dma_state)
4191                    
4192                              RX_DMA_IDLE,RX_DMA_WAIT_STATUS :
4193                              begin
4194       1/1                      descriptor_captured &lt;= 1'b0;
4195       1/1                      if (ahbdataph_strobe_descr &amp; p_edma_queues &gt; 32'd1)
4196                                begin
4197       <font color = "red">0/1     ==>                rx_sof_written  &lt;= 1'b0;</font>
4198       <font color = "red">0/1     ==>                rx_eof_written  &lt;= 1'b0;</font>
4199                                end
                        MISSING_ELSE
4200       1/1                      for (i=0; i&lt;p_edma_queues; i=i+1) begin
4201       1/1                        str_descriptor[i] &lt;= {p_awid_par{1'b0}};
4202                                end
4203                                // request the bus to obtain the data buffer address
4204       1/1                      if (nxt_rx_dma_state == RX_DMA_MAN_RD)
4205       1/1                        hbusreq &lt;= 1'b1;
                        MISSING_ELSE
4206                                /* Following code removed because it cannot currently be hit due to the rx enable blocking the pulse
4207                                from being generated. commenting code rather than removing it because it might be reversed in the future
4208                    
4209                                if (new_rx_q_ptr_pulse)
4210                                  for (i=0; i&lt;p_edma_queues; i=i+1)
4211                                    nxt_descr_ptr[i] &lt;= rx_dma_base_addr_arr[i][31:2];*/
4212                              end
4213                    
4214                              RX_DMA_MAN_RD :
4215                              begin
4216       1/1                      descriptor_captured &lt;= 1'b0;
4217       1/1                      if (ahbdataph_strobe_descr)
4218                                begin
4219       1/1                        rx_sof_written  &lt;= 1'b0;
4220       1/1                        rx_eof_written  &lt;= 1'b0;
4221                                end
                        MISSING_ELSE
4222                    
4223       1/1                      if (hresp_notok_eob)
4224       <font color = "red">0/1     ==>                first_buffer_of_pkt   &lt;= 1'b1;</font>
                        MISSING_ELSE
4225                    
4226                                // If hbusreq is high in this state, then it means that the request
4227                                // for the descriptor read has not started yet - as this state
4228                                // machine is address phase timed, the request will usually
4229                                // start in the preceding state, which is usually the dma
4230                                // writeback state.
4231                                // Now, since we dont know yet if there is a buffer available
4232                                // to write to yet (indicated via used bit in buffer descriptor),
4233                                // we will want to just perform 1 access - therefore hbusreq
4234                                // always set low here.
4235       1/1                      if ((ahbreqph_strobe_descr &amp; descriptor_rd_1_access)                                   // 1 accesses needed
4236                                   | (ahbreqph_strobe_descr &amp; (descr_rd_reqph_cnt == 3'h1) &amp; descriptor_rd_2_access))  // extend when 2 accesses needed
4237       1/1                                hbusreq &lt;= 1'b0;
                        MISSING_ELSE
4238                                // For the case where the previous state was the manwr state,
4239                                // then there will be 1 further data strobe here
4240                                // reset the nxt_descr_ptr to the start of the packet if
4241                                // there was a hresp error
4242                                /* Following code removed because it cannot currently be hit due to the rx enable blocking the pulse
4243                                   from being generated. commenting code rather than removing it because it might be reversed in the future
4244                    
4245                                if (new_rx_q_ptr_pulse)
4246                                  for (i=0; i&lt;p_edma_queues; i=i+1)
4247                                    nxt_descr_ptr[i] &lt;= rx_dma_base_addr_arr[i][31:2];
4248                                */
4249                    
4250                    
4251       1/1                      if  ((ahbdataph_strobe_descr_rd &amp; descriptor_rd_1_access)
4252                                    | (ahbdataph_strobe_descr_rd &amp; (descr_rd_addph_cnt == 2'h1) &amp; descriptor_rd_2_access))
4253       <font color = "red">0/1     ==>                for (i=0; i&lt;p_edma_queues; i=i+1)</font>
4254       <font color = "red">0/2     ==>                  if (i[3:0] == queue_ptr_rx_dph) str_descriptor[i] &lt;= rx_dma_data_in_w0_p[p_awid_par-1:0];</font>
                   <font color = "red">==>  MISSING_ELSE</font>
                        MISSING_ELSE
4255                              end
4256                    
4257                    
4258                              RX_DMA_DATA_STORE :
4259                              begin
4260                    
4261                                // The last data phase of the descriptor is actually in this state
4262                                // If there is an AHB error in the descr rd or the pkt data,
4263                                // reset the next descriptor AHB address to the start of the
4264                                // current packet
4265                                /* Following code removed because it cannot currently be hit due to the rx enable blocking the pulse
4266                                   from being generated. commenting code rather than removing it because it might be reversed in the future
4267                                if (new_rx_q_ptr_pulse)
4268                                  nxt_descr_ptr[queue_ptr_rx_aph] &lt;= rx_dma_base_addr_arr[queue_ptr_rx_aph][31:2];
4269                                */
4270                    
4271       1/1                      if (ahbreqph_strobe_data) // increment ahb_address (after initially setup in else below) for each data write
4272       1/1                        ahb_data_addr  &lt;= ahb_data_addr_incr[p_awid_par-1:0];
4273                    
4274                                // set first data address from last man_rd data (as last man_rd data arrives in data state
4275                                // for 64b addr this is word 2 ie MSB addr
4276                                // but word 0 has already been captured in  str_descriptor so use that as well here
4277       1/1                      else if (ahbdataph_strobe_descr)
4278                                begin
4279       1/1                        descriptor_captured &lt;= 1'b1;
4280                    
4281       1/1                        if (descriptor_rd_1_access)
4282                                  begin
4283       1/1                          ahb_data_addr &lt;= rx_dma_data_in_addr_msk[p_awid_par-1:0];
4284       1/1                          if (p_edma_axi == 1)
4285       1/1                            ahb_data_addr_2 &lt;= rx_dma_data_in_w1_p[p_awid_par-1:0];
4286                                    else
4287       <font color = "red">0/1     ==>                    ahb_data_addr_2 &lt;= rx_dma_data_in_w2_p[p_awid_par-1:0];</font>
4288       1/1                          if ((|dma_bus_width &amp; first_buffer_of_pkt) | (p_edma_rsc == 1 &amp; ~rsc_first_frame))
4289       <font color = "red">0/1     ==>                    bit3n2data_add_64   &lt;= rx_dma_data_in_w0_p[3:2];</font>
                        MISSING_ELSE
4290                                  end
4291                                  else  // descriptor_rd_2_access
4292                                  begin
4293       <font color = "red">0/1     ==>                  ahb_data_addr &lt;= str_descriptor_addr_msk[p_awid_par-1:0];</font>
4294       <font color = "red">0/1     ==>                  if (p_edma_axi == 1)</font>
4295       <font color = "red">0/1     ==>                    ahb_data_addr_2 &lt;= rx_dma_data_in_w1_p[p_awid_par-1:0];</font>
4296                                    else
4297       <font color = "red">0/1     ==>                    ahb_data_addr_2 &lt;= rx_dma_data_in_w0_p[p_awid_par-1:0];</font>
4298       <font color = "red">0/1     ==>                  if ((|dma_bus_width &amp; first_buffer_of_pkt) | (p_edma_rsc == 1 &amp; ~rsc_first_frame))</font>
4299       <font color = "red">0/1     ==>                    bit3n2data_add_64   &lt;= str_descriptor_pad[queue_ptr_rx_dph][3:2];</font>
                   <font color = "red">==>  MISSING_ELSE</font>
4300                                  end
4301                                end
                        MISSING_ELSE
4302                    
4303       1/1                      if (ahbdataph_strobe_descr_rd &amp; descriptor_rd_1_access)
4304       1/1                        for (i=0; i&lt;p_edma_queues; i=i+1)
4305       2/2                          if (i[3:0]==queue_ptr_rx_dph) str_descriptor[i] &lt;= rx_dma_data_in_w0_p[p_awid_par-1:0];
                   <font color = "red">==>  MISSING_ELSE</font>
                        MISSING_ELSE
4306                    
4307                                // hbusreq cears when there is an AHB error,
4308                                // or when are in cut-thru mode and the status has
4309                                // been read (with error) whilst in this state
4310                                // Note that under normal conditons, the bus request
4311                                // will just stay active because we will always go into
4312                                // the descripor read or write state after this, unless there
4313                                // is a hresp error
4314       1/1                      if (hresp_notok_eob | (status_word1_capt &amp; ~status_word_1[0] &amp; hready))
4315                                begin
4316       <font color = "red">0/1     ==>                hbusreq &lt;= 1'b0;</font>
4317                                end
4318                    
4319                                // Also clears if the used bit was read
4320       1/1                      else if (rx_buffer_used_bit)
4321       <font color = "red">0/1     ==>                hbusreq &lt;= 1'b0;</font>
4322                    
4323                                // Drop hbusreq while we wait for the next part or while we wait for
4324                                // the status to be fetched
4325       1/1                      else if (last_partpkt_rph &amp; ~last_data_to_buff_rph &amp;
4326                                        ~status_word1_capt &amp;
4327                                          num_parts_needing_read[7:1] == 7'h00 &amp; ~part_pkt_written)
4328       <font color = "red">0/1     ==>                hbusreq &lt;= 1'b0;</font>
4329                    
4330                                // Drive high for fetching the packet parts,
4331                                // or the full packet if the status has been captured
4332                                // (dpram_rd_state == P_PKT_DATA) is added here as this ensures
4333                                // hbusreq is driven high a cycle later than if that condition
4334                                // was removed - this ensures that we dont have 2 conditions
4335                                // within the resource freeing logic happening at the same
4336                                // time - simpler
4337       1/1                      else if (
4338                                          // dont start until descriptor is fetched!
4339                                         (descriptor_captured | ahbdataph_strobe_descr) &amp;
4340                    
4341                                         ((dpram_rd_state == P_PKT_DATA &amp;
4342                    
4343                                         // Something to receive ...
4344                                        ((|num_parts_needing_read | fetch_rem_part) |
4345                                         (|num_pkts_needing_read &amp; status_word1_capt))) |
4346                                         reading_eop_dpram_aph_del))
4347       1/1                        hbusreq &lt;= 1'b1;
                        MISSING_ELSE
4348                    
4349                    
4350       1/1                      if (hresp_notok_eob |
4351                                   (rx_buffer_used_bit &amp; (rx_cutthru | force_discard_on_error)) |
4352                                    mac_err_vld | mac_err_vld_pending)
4353                                begin
4354       <font color = "red">0/1     ==>                rx_eof_written      &lt;= 1'b0;</font>
4355       <font color = "red">0/1     ==>                first_buffer_of_pkt &lt;= 1'b1;</font>
4356                                end
4357                                // To set rx_eof_written, we want to use the EOP read from the DPRAM
4358                                // When we are padding the burst however, we need to wait until the
4359                                // end of the padding
4360       1/1                      else if (real_eop_ahb_aph)
4361                                begin
4362       1/1                        rx_eof_written      &lt;= 1'b1;
4363       1/1                        first_buffer_of_pkt &lt;= 1'b1;
4364                                end
4365       1/1                      else if (ahbaddph_strobe_data_nopad)
4366                                begin
4367       1/1                        first_buffer_of_pkt &lt;= 1'b0;
4368       1/1                        if (first_buffer_of_pkt)
4369       1/1                          rx_sof_written    &lt;= 1'b1;
                        MISSING_ELSE
4370                                end
                        MISSING_ELSE
4371                    
4372                    
4373                              end
4374                    
4375                    
4376                            // write back the buffer descriptor according to the frame storage
4377                            // status ahb write burst
4378                            default : // RX_DMA_MAN_WR:
4379                            begin
4380                              // Reset hbusreq once the request phase for the next descriptor
4381                              // is completed - this is the same time as the address phase
4382                              // of the 2nd MANWR (assuming we are still granted at this stage
4383                              // - we can gate in ahbreqph_strobe_descr to ensure this)
4384       1/1                    if (astrobe_manwr_last | hresp_notok_eob)
4385                              begin
4386       1/1                      if (ahbreqph_strobe_descr)
4387                                begin
4388       1/1                        if (descriptor_rd_2_access)
4389       <font color = "red">0/1     ==>                  hbusreq &lt;= 1'b1;           //  extend if 64b addressing (when not 128b data bus)</font>
4390                                  else
4391       1/1                          hbusreq &lt;= 1'b0;           // set to 0 for single rd here ie 32b addressing
4392                                end
                   <font color = "red">==>  MISSING_ELSE</font>
4393       1/1                      rx_dma_descr_ptr_tog   &lt;= ~rx_dma_descr_ptr_tog;
4394                              end
                        MISSING_ELSE
4395       1/1                    descriptor_captured &lt;= 1'b0;
4396                    
4397       1/1                    if (hresp_notok_eob)
4398       <font color = "red">0/1     ==>              first_buffer_of_pkt &lt;= 1'b1;</font>
4399                              else
4400       1/1                      first_buffer_of_pkt &lt;= rx_eof_written;
4401                    
4402                              /* Following code removed because it cannot currently be hit due to the rx enable blocking the pulse
4403                                  from being generated. commenting code rather than removing it because it might be reversed in the future
4404                              if (new_rx_q_ptr_pulse)
4405                                nxt_descr_ptr[queue_ptr_rx_aph] &lt;= rx_dma_base_addr_arr[queue_ptr_rx_aph][31:2];
4406                              */
4407                    
4408                              // Once the descriptor has been finished with, increment
4409                              // (unless wrap bit  was set, in which case, reset to base)
4410       1/1                    for (i=0; i&lt;p_edma_queues; i=i+1)
4411       1/1                      if  (astrobe_manwr_last &amp; update_databuf_add &amp;&amp; i[3:0] == queue_ptr_rx_aph)
4412                                begin
4413       1/1                        if (current_wrap_bit_aph)
4414       <font color = "red">0/1     ==>                  nxt_descr_ptr[i] &lt;= rx_dma_base_addr_arr[queue_ptr_rx_aph];</font>
4415                                  else
4416       1/1                          nxt_descr_ptr[i] &lt;= nxt_descr_ptr_aph_inc[p_awid_par-1:0];
4417                                end
                        MISSING_ELSE
4418                            end
4419                            endcase
4420                          end
4421                        end
4422                      end
4423                    
4424                      // Optional modification based on dma_addr_or_mask_hclk
4425                      assign str_descriptor_addr_msk[31]  = dma_addr_or_mask_hclk[3]  ? dma_addr_or_mask_hclk[7]  : str_descriptor_pad[queue_ptr_rx_dph][31];
4426                      assign str_descriptor_addr_msk[30]  = dma_addr_or_mask_hclk[2]  ? dma_addr_or_mask_hclk[6]  : str_descriptor_pad[queue_ptr_rx_dph][30];
4427                      assign str_descriptor_addr_msk[29]  = dma_addr_or_mask_hclk[1]  ? dma_addr_or_mask_hclk[5]  : str_descriptor_pad[queue_ptr_rx_dph][29];
4428                      assign str_descriptor_addr_msk[28]  = dma_addr_or_mask_hclk[0]  ? dma_addr_or_mask_hclk[4]  : str_descriptor_pad[queue_ptr_rx_dph][28];
4429                      assign str_descriptor_addr_msk[27:0]= str_descriptor_pad[queue_ptr_rx_dph][27:0];
4430                      assign rx_dma_data_in_addr_msk[31]  = dma_addr_or_mask_hclk[3]  ? dma_addr_or_mask_hclk[7]  : rx_dma_data_in_w0_p[31];
4431                      assign rx_dma_data_in_addr_msk[30]  = dma_addr_or_mask_hclk[2]  ? dma_addr_or_mask_hclk[6]  : rx_dma_data_in_w0_p[30];
4432                      assign rx_dma_data_in_addr_msk[29]  = dma_addr_or_mask_hclk[1]  ? dma_addr_or_mask_hclk[5]  : rx_dma_data_in_w0_p[29];
4433                      assign rx_dma_data_in_addr_msk[28]  = dma_addr_or_mask_hclk[0]  ? dma_addr_or_mask_hclk[4]  : rx_dma_data_in_w0_p[28];
4434                      assign rx_dma_data_in_addr_msk[27:0]= rx_dma_data_in_w0_p[27:0];
4435                    
4436                      // If parity protection, then regenerate parity
4437                      generate if (p_edma_asf_dap_prot == 1) begin : gen_addr_or_mask_par
4438                        gem_par_chk_regen #(.p_chk_dwid (64)) i_regen_par (
4439                          .odd_par  (1'b0),
4440                          .chk_dat  ({rx_dma_data_in_w0_p[31:0],str_descriptor_pad[queue_ptr_rx_dph][31:0]}),
4441                          .chk_par  ({rx_dma_data_in_w0_p[35:32],str_descriptor_pad[queue_ptr_rx_dph][35:32]}),
4442                          .new_dat  ({str_descriptor_addr_msk[31:0],rx_dma_data_in_addr_msk[31:0]}),
4443                          .dat_out  (),
4444                          .par_out  ({str_descriptor_addr_msk[35:32],rx_dma_data_in_addr_msk[35:32]}),
4445                          .chk_err  (dap_err_addr_or_mask)
4446                        );
4447                      end else begin : gen_no_addr_or_mask_par
4448                        assign dap_err_addr_or_mask = 1'b0;
4449                      end
4450                      endgenerate
4451                    
4452                      // Determine how much ahb_data_addr should increment for each data write
4453                      always@(*)
4454                      begin
4455       1/1              if (dma_bus_width[1])
4456       <font color = "red">0/1     ==>        ahb_data_addr_inc_val = 32'h00000010;</font>
4457       1/1              else if (dma_bus_width==2'b01)
4458       <font color = "red">0/1     ==>        ahb_data_addr_inc_val = 32'h00000008;</font>
4459                        else
4460       1/1                ahb_data_addr_inc_val = 32'h00000004;
4461                      end
4462                    
4463                      // Increment of ahb_data_addr by ahb_data_addr_inc_val taking into account
4464                      // possible parity
4465                      edma_arith_par #(
4466                        .p_dwidth (32),
4467                        .p_pwidth (4),
4468                        .p_has_par(p_edma_asf_dap_prot)
4469                      ) i_arith_ahb_data_addr_incr (
4470                        .in_val (ahb_data_addr[31:0]),
4471                        .in_par (ahb_data_addr[p_awid_par-1:p_awid_par-4]),
4472                        .op_val (ahb_data_addr_inc_val),
4473                        .op_add (1'b1),
4474                        .out_val(ahb_data_addr_incr[31:0]),
4475                        .out_par(ahb_data_addr_incr[35:32])
4476                      );
4477                    
4478                      // Increment of nxt_descr_ptr[queue_ptr_rx_aph] by next_descr_ptr_inc_val taking into account
4479                      // possible parity
4480                      edma_arith_par #(
4481                        .p_dwidth (32),
4482                        .p_pwidth (4),
4483                        .p_has_par(p_edma_asf_dap_prot)
4484                      ) i_arith_rx_descr_ptr_aph_inc (
4485                        .in_val (nxt_descr_ptr_pad[queue_ptr_rx_aph][31:0]),
4486                        .in_par (nxt_descr_ptr_pad[queue_ptr_rx_aph][p_awid_par-1:p_awid_par-4]),
4487                        .op_val (next_descr_ptr_inc_val),
4488                        .op_add (1'b1),
4489                        .out_val(nxt_descr_ptr_aph_inc[31:0]),
4490                        .out_par(nxt_descr_ptr_aph_inc[35:32])
4491                      );
4492                    
4493                      // Get max rx buffer size based on current Queue
4494                      assign rx_buffer_size_cur = rx_buffer_size_array[queue_ptr_rx_aph];
4495                    
4496                      // When hdr/data splitting is on, in terms of writing the TCP/IP header out on the AHB interface,
4497                      // we need to add in the buffer start offset
4498                      wire [12:0] pld_offset_ahb;
4499                      assign pld_offset_ahb    = pld_offset + ({bit3n2data_add_64 &amp; {dma_bus_width[1],|dma_bus_width},
4500                                                                rx_dma_buffer_offset});
4501                    
4502                      // Convert pld_offset into words based on current data width
4503                      // This will match the number of DPRAM reads required to reach the payload offset
4504                      wire [10:0] pld_offset_words_ahb;
4505                      assign pld_offset_words_ahb  = dma_bus_width[1] ? {3'h0, pld_offset_ahb[11:4]} + |pld_offset_ahb[3:0] :
4506                                                     dma_bus_width[0] ? {2'h0, pld_offset_ahb[11:3]} + |pld_offset_ahb[2:0] :
4507                                                                        {1'b0, pld_offset_ahb[11:2]} + |pld_offset_ahb[1:0];
4508                    
4509                      // Calculate buffer depth per datawidth based on buffer_size register only
4510                      reg [11:0] buffer_size_words;
4511                      always @(*)
4512                      begin
4513       1/1              if (dma_bus_width[1])
4514       <font color = "red">0/1     ==>        buffer_size_words  = {2'b00,rx_buffer_size_cur[7:0],2'd0};</font>
4515       1/1              else if (dma_bus_width[0])
4516       <font color = "red">0/1     ==>        buffer_size_words  = {1'b0,rx_buffer_size_cur[7:0],3'd0};</font>
4517                        else
4518       1/1                buffer_size_words  = {rx_buffer_size_cur[7:0],4'd0};
4519                      end
4520                    
4521                      always@(posedge hclk or negedge n_hreset)
4522                      begin
4523       1/1              if (~n_hreset)
4524       1/1                offset_available_capt &lt;= 1'b0;
4525                        else
4526                        begin
4527       1/1                if (~enable_rx_hclk)
4528       1/1                  offset_available_capt &lt;= 1'b0;
4529                          else
4530                          begin
4531       1/1                  if ((rx_dma_next_man_wr &amp; rx_eof_written) | (nxt_rx_dma_state == RX_DMA_IDLE)) // end of frame
4532       1/1                    offset_available_capt &lt;= 1'b0;
4533       1/1                  else if (offset_has_become_available &amp; descriptor_captured &amp; rx_dma_state == RX_DMA_DATA_STORE) // Need to wait until descriptor_captured because offset is not fully setup until here
4534       1/1                    offset_available_capt &lt;= 1'b1;
                        MISSING_ELSE
4535                          end
4536                        end
4537                      end
4538                    
4539                      always @(*)
4540                      begin
4541       1/1              if (offset_has_become_available &amp; first_buffer_of_pkt &amp; ~offset_available_capt)
4542                        begin
4543       1/1                if ({1'b0,pld_offset_words_ahb} &lt;= buffer_size_words)
4544       1/1                  nxt_remaining_hdr_bytes = 12'h000;
4545                          else
4546       <font color = "red">0/1     ==>          nxt_remaining_hdr_bytes = {1'b0,pld_offset_words_ahb} - buffer_size_words;</font>
4547                        end
4548       1/1                else if ({1'b0,remaining_hdr_bytes} &lt;= buffer_size_words)
4549       1/1                  nxt_remaining_hdr_bytes = 12'h000;
4550                          else
4551       1/1                  nxt_remaining_hdr_bytes = {1'b0,remaining_hdr_bytes} - buffer_size_words;
4552                      end
4553                    
4554                    
4555                      // Calculate the RX buffer depth in stripes
4556                      // In non hdr data splitting modes, it is based directly on the rx buffer size register
4557                      // and the datawidth
4558                      // in hdr data splitting modes, it must take into account the payload offset, which essentially
4559                      // indicates the length of the header
4560                      // when infinite_last_dbuf_size_en mode is enabled, then the databuffer pointed to by the descriptor
4561                      // at the top of the descriptor table is of infinite size 
4562                      generate if(p_edma_axi == 1'b1) begin: gen_from_rx_dma_buff_depth
4563                        reg [11:0] rx_buff_depth; // buffer depth (in 32-bit words)
4564                    
4565                        always @ *
4566                        begin
4567       1/1                if (infinite_last_dbuf_size_en &amp; current_wrap_bit_aph)
4568       <font color = "red">0/1     ==>          rx_buff_depth = 12'hfff;  // Set to max size</font>
4569       1/1                else if (hdr_data_splitting_en &amp; (|remaining_hdr_bytes) &amp; ({1'b0,remaining_hdr_bytes} &lt; buffer_size_words))
4570       <font color = "red">0/1     ==>          rx_buff_depth = {1'b0,remaining_hdr_bytes};</font>
4571                          else
4572       1/1                  rx_buff_depth = buffer_size_words;
4573                        end
4574                        assign from_rx_dma_buff_depth = rx_buff_depth;
4575                        
4576                      end else begin: no_gen_from_rx_dma_buff_depth
4577                        assign from_rx_dma_buff_depth = 12'd0;
4578                      end
4579                      endgenerate
4580                      
4581                      always@(posedge hclk or negedge n_hreset)
4582                      begin
4583       1/1              if (~n_hreset)
4584                        begin
4585       1/1                buffer_fill_lvl     &lt;= 12'h000;
4586       1/1                remaining_hdr_bytes &lt;= 11'h000;
4587                        end
4588                        else
4589                        begin
4590       1/1                if (~enable_rx_hclk)
4591                          begin
4592       1/1                  buffer_fill_lvl &lt;= 12'h000;
4593       1/1                  remaining_hdr_bytes &lt;= 11'h000;
4594                          end
4595                          else
4596                          begin
4597                            //  reset buffer_fill_lvl to something other than 0 as soon as we have the required data.
4598                            // In priority queues, this is when the queue information is ready.
4599                            // In all modes, we also have to have the pld_offset for cases where header/data splitting is enabled
4600                            // When infinite_last_dbuf_size_en mode is enabled, the buffer fill level is set to infinite if this is
4601                            // the last descriptor in the ring
4602       1/1                  if (ahbreqph_strobe_data &amp; infinite_last_dbuf_size_en &amp; current_wrap_bit_rph)
4603       <font color = "red">0/1     ==>            buffer_fill_lvl &lt;= 12'hfff;</font>
4604                    
4605                            // First buffer of packet.
4606       1/1                  else if (offset_has_become_available &amp; first_buffer_of_pkt &amp; ~offset_available_capt)
4607                            begin
4608                              // If there are less bytes in the payload offset than in the max programmed buffer depth, then set
4609                              // to pld_offset_words_ahb, otherwise buffer_size from register.
4610                              // Its possible offset_has_become_available happens at same time as first AHB request strobe.
4611                              // This is okay as we will always expect frames to be bigger than 1 write, however, we need to take
4612                              // it into account here.
4613       1/1                    remaining_hdr_bytes &lt;= pld_offset_words_ahb;
4614       1/1                    if (|pld_offset_words_ahb &amp; ({1'b0,pld_offset_words_ahb} &lt;= buffer_size_words) &amp; hdr_data_splitting_en)
4615       <font color = "red">0/1     ==>              buffer_fill_lvl &lt;= {1'd0, {pld_offset_words_ahb - {10'd0,ahbreqph_strobe_data}}};</font>
4616                              else
4617       1/1                      buffer_fill_lvl &lt;= buffer_size_words - {11'd0,ahbreqph_strobe_data};
4618                            end
4619                    
4620       1/1                  else if (rx_dma_state == RX_DMA_MAN_RD &amp; last_rx_dma_state != RX_DMA_MAN_RD)
4621                            begin
4622                              // On the first descriptor rd of a frame, just set buffer_fill_lvl to something non zero. This is so that
4623                              // buffer_available can get set. buffer_fill_lvl enters that logic to drive buffer_available just
4624                              // to make it easier to reset buffer_available once a buffer has become exhausted - i.e. after
4625                              // loads of data accesses.  This is never the case following the first man_rd.
4626                              // Note we must guarantee that this logic is just used after the 1st descriptor read to set buffer_fill_lvl
4627                              // to something, and will be updated with the correct value when 'offset_has_become_available' as above.
4628       1/1                    if (first_buffer_of_pkt)
4629                              begin
4630       1/1                      remaining_hdr_bytes &lt;= remaining_hdr_bytes;
4631       1/1                      buffer_fill_lvl &lt;= buffer_size_words;
4632                              end
4633                    
4634                              // If not the furst buffer of the frame, then set to either nxt_remaining_hdr_bytes if this is the last
4635                              // buffer of the header, or buffer_size_words
4636                              else
4637                              begin
4638       <font color = "red">0/1     ==>              remaining_hdr_bytes &lt;= nxt_remaining_hdr_bytes[10:0];</font>
4639       <font color = "red">0/1     ==>              if (({1'b0,nxt_remaining_hdr_bytes[10:0]} &lt;= buffer_size_words) &amp; hdr_data_splitting_en &amp; (|nxt_remaining_hdr_bytes[10:0]))</font>
4640       <font color = "red">0/1     ==>                buffer_fill_lvl &lt;= {1'b0,nxt_remaining_hdr_bytes[10:0]};</font>
4641                                else
4642       <font color = "red">0/1     ==>                buffer_fill_lvl &lt;= buffer_size_words;</font>
4643                              end
4644                            end
4645                    
4646       1/1                  else if (ahbreqph_strobe_data &amp; |buffer_fill_lvl)
4647       1/1                    buffer_fill_lvl &lt;= buffer_fill_lvl - 12'h001;
                        MISSING_ELSE
4648                          end
4649                        end
4650                      end
4651                    
4652                      always@(posedge hclk or negedge n_hreset)
4653                      begin
4654       1/1              if (~n_hreset)
4655       1/1                in_header     &lt;= 1'b1;
4656                        else
4657                        begin
4658       1/1                if (~enable_rx_hclk )
4659       1/1                  in_header   &lt;= 1'b1;
4660       1/1                else if (nxt_rx_dma_state != RX_DMA_MAN_WR &amp; rx_dma_state == RX_DMA_MAN_WR &amp;
4661                                  ({1'b0,remaining_hdr_bytes} &lt;= buffer_size_words))
4662                          begin
4663       1/1                  if (rx_eof_written)
4664       1/1                    in_header   &lt;= 1'b1;
4665                            else
4666       <font color = "red">0/1     ==>            in_header   &lt;= 1'b0;</font>
4667                          end
                        MISSING_ELSE
4668                        end
4669                      end
4670                    
4671                    
4672                      // Identify the period of time the AHB will be writing out PAD to the memory
4673                      // This is the case when force_max_ahb_burst_rx is set and the EOP is not at
4674                      // the end of a max length burst
4675                      always@(posedge hclk or negedge n_hreset)
4676                      begin
4677       1/1              if (~n_hreset)
4678                        begin
4679       1/1                padding_rph &lt;= 1'b0;
4680       1/1                padding_aph &lt;= 1'b0;
4681                        end
4682                        else
4683                        begin
4684       1/1                if (~enable_rx_hclk)
4685                          begin
4686       1/1                  padding_rph &lt;= 1'b0;
4687       1/1                  padding_aph &lt;= 1'b0;
4688                          end
4689                          else
4690                          begin
4691       1/1                  if (padding_rph &amp; last_access_burst_req &amp; ahbreqph_strobe_data)
4692       <font color = "red">0/1     ==>            padding_rph &lt;= 1'b0;</font>
4693       1/1                  else if (force_max_ahb_burst_rx &amp; |ahb_burst_length[4:2] &amp;
4694                    
4695                                     // The next request is the last one either of the packet or the buffer ...
4696                                     (real_eop_ahb_rph |
4697                                      (buffer_fill_lvl == 12'h001 &amp; ~real_eop_ahb_aph &amp; hready)) &amp;
4698                    
4699                                     // The next access is not the last of a burst
4700                                     ~last_access_burst_req &amp;
4701                    
4702                                     // if at the end of the packet we are close to a 1k boundary(&lt; 4 words),
4703                                     // then we might have to block the padding.  In order to pad,
4704                                     // one of the following 3 things must be true
4705                                     //   1. We are not close to a 1k boundary
4706                                     //   2. We are already in the middle of a burst, which means there must
4707                                     //      be enough room to complete that burst
4708                                     //   3. If we are about to start a new burst (ahb_access_cnt == 4'h0) and
4709                                     //      there is at least enough room for a burst of 4
4710                                     // Else do NOT pad
4711                                     (~brk1kbndry_burst |
4712                                     (|hburst[2:1] &amp; |ahb_access_cnt) |
4713                                     (ahb_access_cnt == 4'h0 &amp; |bndry1k_acc_size[3:2])) &amp;
4714                    
4715                                     // Ensure this only happen in the data state! there is also a cycle
4716                                     // at the end of the data state we want to ignore - this is the cycle
4717                                     // following the end of padding_rph
4718                                     ~padding_aph &amp;
4719                                     rx_dma_state == RX_DMA_DATA_STORE)
4720       <font color = "red">0/1     ==>            padding_rph &lt;= 1'b1;</font>
                        MISSING_ELSE
4721                    
4722       1/1                  if (hready)
4723       1/1                    padding_aph &lt;= padding_rph;
                        MISSING_ELSE
4724                          end
4725                        end
4726                      end
4727                    
4728                    
4729                      // last_data_to_buffer (AHB Request phase)
4730                      // Set at the end of each buffer at EOP
4731                      // Held off until next req phase if offset is used and residue is
4732                      always @(*)
4733                      begin
4734       1/1              if (force_max_ahb_burst_rx &amp; |ahb_burst_length[4:2])
4735       <font color = "red">0/1     ==>        last_data_to_buff_rph = ahbreqph_strobe_data &amp;</font>
4736                                  (last_access_burst_req &amp;
4737                                  (buffer_fill_lvl &lt;= 12'h001 | padding_rph));
4738                    
4739                        else
4740       1/1                last_data_to_buff_rph = ahbreqph_strobe_data &amp;
4741                                  (buffer_fill_lvl == 12'h001 | real_eop_ahb_rph);
4742                      end
4743                    
4744                      // If the eop resides in the residue buffer then another AHB access
4745                      // is required so hold off the eop indication.
4746                      // This access will take place on the next AHB data strobe when the
4747                      // indication can be reset.
4748                      wire real_eop_ahb_rph_pulse;
4749                      wire real_eop_ahb_aph_pulse;
4750                      always@(posedge hclk or negedge n_hreset)
4751                      begin
4752       1/1              if (~n_hreset)
4753       1/1                reading_eop_dpram_rph_del   &lt;= 1'b0;
4754       1/1              else if (~enable_rx_hclk)
4755       1/1                reading_eop_dpram_rph_del   &lt;= 1'b0;
4756       1/1              else if (real_eop_ahb_rph)
4757       1/1                reading_eop_dpram_rph_del  &lt;= 1'b0;
4758       1/1              else if (reading_eop_dpram_rph &amp; ahbreqph_strobe_data)
4759       <font color = "red">0/1     ==>        reading_eop_dpram_rph_del  &lt;= 1'b1;</font>
                        MISSING_ELSE
4760                      end
4761                    
4762                      // If the eop resides in the residue buffer then another AHB access
4763                      // is required so hold off the eop indication.
4764                      // This access will take place on the next AHB data strobe when the
4765                      always@(posedge hclk or negedge n_hreset)
4766                      begin
4767       1/1              if (~n_hreset)
4768                        begin
4769       1/1                reading_eop_dpram_aph_del   &lt;= 1'b0;
4770                        end
4771       1/1              else if (~enable_rx_hclk)
4772       1/1                reading_eop_dpram_aph_del   &lt;= 1'b0;
4773       1/1              else if (real_eop_ahb_aph)
4774       1/1                reading_eop_dpram_aph_del  &lt;= 1'b0;
4775       1/1              else if (reading_eop_dpram_aph &amp; ahbaddph_strobe_data)
4776       <font color = "red">0/1     ==>        reading_eop_dpram_aph_del  &lt;= 1'b1;</font>
                        MISSING_ELSE
4777                      end
4778                    
4779                      // last_data_to_buffer (AHB Address phase)
4780                      assign last_data_to_buff_aph = ahbaddph_strobe_data &amp;
4781                                                    (buffer_fill_lvl == 12'h000 |
4782                                                     real_eop_ahb_aph |
4783                                                    (padding_aph &amp; ~padding_rph));
4784                    
4785                    
4786                      assign last_buff_req_aph = last_data_to_buff_aph &amp; ~padding_rph;
4787                      reg last_buff_req_aph_d1;
4788                      always@(posedge hclk or negedge n_hreset)
4789                      begin
4790       1/1              if (~n_hreset)
4791       1/1                last_buff_req_aph_d1 &lt;= 1'b0;
4792       1/1              else if (~enable_rx_hclk)
4793       1/1                last_buff_req_aph_d1 &lt;= 1'b0;
4794                        else
4795                        begin
4796       1/1                if (hready)
4797                          begin
4798       1/1                  if (last_buff_req_aph)
4799       1/1                    last_buff_req_aph_d1 &lt;= 1'b1;
4800                            else
4801       1/1                    last_buff_req_aph_d1 &lt;= 1'b0;  // Holds until end of burst to ensure this works for force burst mode
4802                          end
                        MISSING_ELSE
4803                        end
4804                      end
4805                      assign last_buff_req_dph   = last_buff_req_aph_d1 &amp; hready;
4806                    
4807                      assign buffer_available    = (rx_dma_next_data &amp; |buffer_fill_lvl &amp;
4808                                                   (~hresp_notok_hold | rx_cutthru));
4809                    
4810                      // Fix for Jira ETH-358
4811                      // used bit read in 64bit addressing was not being picked up correctly.
4812                      reg rx_used_bit_2_acc;
4813                      always@(posedge hclk or negedge n_hreset)
4814                      begin
4815       1/1              if (~n_hreset)
4816       1/1                rx_used_bit_2_acc  &lt;= 1'b0;
4817       1/1              else if (ahbdataph_strobe_descr_rd)
4818       1/1                rx_used_bit_2_acc  &lt;= rx_dma_data_in_w0_p[0] &amp; descriptor_rd_2_access &amp; (descr_rd_dataph_cnt == 2'h0);
                        MISSING_ELSE
4819                    
4820                      end
4821                      assign rx_buffer_used_bit  = ((rx_dma_data_in_w0_p[0] &amp; descriptor_rd_1_access) | rx_used_bit_2_acc) &amp;
4822                                                   ahbdataph_strobe_descr_rd &amp; rx_dma_state != RX_DMA_IDLE;
4823                    
4824                      // Need to use the current str_descriptor based on which queue is being accessed
4825                      // to check the wrap bit
4826                      assign current_wrap_bit_rph  = str_descriptor_pad[queue_ptr_rx_rph][1];
4827                      assign current_wrap_bit_aph  = str_descriptor_pad[queue_ptr_rx_aph][1];
4828                    
4829                      reg   [1:0]             rx_dma_burst_addr_src;
4830                      reg   [31:0]            rx_dma_burst_dscr_inc_val;
4831                      wire  [35:0]            rx_dma_burst_addr_inc;
4832                      reg   [31:0]            ahb_data_addr_shift;
4833                      wire  [p_awid_par-1:0]  ahb_data_addr_shift_p;
4834                    
4835                      // Calculate the address used on the AHB.  This is made combinatorial
4836                      // There are 3 possible sources for rx_dma_burst_addr:
4837                      //  rx_dma_base_addr_arr[queue_ptr_rx_rph]
4838                      //  nxt_descr_ptr[queue_ptr_rx_rph] with arithmetic operation
4839                      //  ahb_data_addr with shift operation
4840                      // For the purposes of parity protection of these operations they are separated
4841                      // out such that this process will select the source and increment value which
4842                      // will be used to update rx_dma_burst_addr in the next process.
4843                      // The encodings for rx_dma_burst_addr_src are:
4844                      //    0:  rx_dma_base_addr_arr[queue_ptr_rx_rph]
4845                      //    1:  nxt_descr_ptr[queue_ptr_rx_rph] + rx_dma_burst_dscr_inc_val
4846                      //    2:  ahb_data_addr which will be shifted based on dma_bus_width.
4847                      always @ ( * )
4848                      begin
4849       1/1              rx_dma_burst_dscr_inc_val = 32'd0;  // Default no increment
4850                    
4851                        // Setup address for upcoming MANRD
4852                        // If current access has been made to the top queue and as the
4853                        // address for this needs to be set up in the last man_write state
4854                        // then check wrap bit for that queue.
4855                        // Only applies when accessing the top queue
4856       1/1              if (ahbreqph_strobe_descr_rd)
4857                        begin
4858       1/1                if (astrobe_manwr_last &amp; current_wrap_bit_rph &amp; queue_ptr_rx_rph == queue_ptr_rx_aph) // Wrap
4859       <font color = "red">0/1     ==>          rx_dma_burst_addr_src = 2'b00;  // rx_dma_burst_addr = rx_dma_base_addr_arr[queue_ptr_rx_rph];</font>
4860       1/1                else if (astrobe_manwr_last &amp; queue_ptr_rx_rph == queue_ptr_rx_aph)
4861                          begin
4862       1/1                  rx_dma_burst_addr_src     = 2'b01;  // rx_dma_burst_addr = nxt_descr_ptr_pad[queue_ptr_rx_rph] + NEXT_DESCR_PTR_INC;
4863       1/1                  rx_dma_burst_dscr_inc_val = next_descr_ptr_inc_val;
4864                          end
4865                          // update address for next MANRD word access
4866       1/1                else if (rx_dma_state_man_rd &amp; descriptor_rd_2_access)
4867                          begin
4868       <font color = "red">0/1     ==>          rx_dma_burst_addr_src     = 2'b01;  // rx_dma_burst_addr = nxt_descr_ptr_pad[queue_ptr_rx_rph] + {26'd0,descr_rd_reqph_cnt,3'd0};</font>
4869       <font color = "red">0/1     ==>          rx_dma_burst_dscr_inc_val = {26'd0,descr_rd_reqph_cnt,3'd0};</font>
4870                          end
4871                          else
4872       1/1                  rx_dma_burst_addr_src = 2'b01;  // rx_dma_burst_addr = nxt_descr_ptr_pad[queue_ptr_rx_rph];
4873                        end
4874                    
4875       1/1              else if (rx_dma_state_data)
4876       1/1                rx_dma_burst_addr_src = 2'b10;  // rx_dma_burst_addr = ahb_data_addr_shift;  // Shifted according to dma_bus_width
4877                    
4878                    
4879                        // Setup address for MAN WR
4880                        // For single man wr accesses all words are written to nxt_descr_ptr* address
4881                        // For two or four man wr accesses the address depends on data bus width
4882                        // and if 64b addressing is enabled
4883                    
4884                    
4885       1/1              else if(descriptor_wr_1_access)
4886       <font color = "red">0/1     ==>        rx_dma_burst_addr_src = 2'b01;  // rx_dma_burst_addr = nxt_descr_ptr_pad[queue_ptr_rx_rph];</font>
4887                    
4888       1/1              else if(descriptor_wr_2_access) begin
4889                    
4890                           // Setup address for Last management write (with WORD containing Ownership bit)
4891       1/1                 if (inc_rx_dma_mux_addr_1)
4892       1/1                   rx_dma_burst_addr_src  = 2'b01;  // rx_dma_burst_addr = nxt_descr_ptr_pad[queue_ptr_rx_rph];
4893                    
4894                           // Setup address for First management write
4895                           else
4896       1/1                   if (~rx_bd_extended_mode_en)
4897                             begin
4898       1/1                     rx_dma_burst_addr_src      = 2'b01;  // rx_dma_burst_addr = nxt_descr_ptr_pad[queue_ptr_rx_rph] + 32'h00000004;
4899       1/1                     rx_dma_burst_dscr_inc_val  = 32'h00000004;
4900                             end
4901                             else
4902       <font color = "red">0/1     ==>             if ( ~gem_dma_addr_w_is_64)</font>
4903                               begin
4904       <font color = "red">0/1     ==>               rx_dma_burst_addr_src      = 2'b01;  // rx_dma_burst_addr = nxt_descr_ptr_pad[queue_ptr_rx_rph] + 32'h00000008;</font>
4905       <font color = "red">0/1     ==>               rx_dma_burst_dscr_inc_val  = 32'h00000008;</font>
4906                               end
4907                               else
4908                               begin
4909       <font color = "red">0/1     ==>               rx_dma_burst_addr_src      = 2'b01;  // rx_dma_burst_addr = nxt_descr_ptr_pad[queue_ptr_rx_rph] + 32'h00000010;</font>
4910       <font color = "red">0/1     ==>               rx_dma_burst_dscr_inc_val  = 32'h00000010;</font>
4911                               end
4912                    
4913                        end
4914                    
4915                        else begin // descriptor_wr_4_access
4916                    
4917                          // Setup address for 4th (Last) management write (with WORD containing Ownership bit)
4918       1/1                if (inc_rx_dma_mux_addr_3)
4919       <font color = "red">0/1     ==>          rx_dma_burst_addr_src = 2'b01;  // rx_dma_burst_addr = nxt_descr_ptr_pad[queue_ptr_rx_rph];</font>
4920                    
4921                          // Setup address for 3rd management write
4922       1/1                else if (inc_rx_dma_mux_addr_2)
4923                          begin
4924       <font color = "red">0/1     ==>          rx_dma_burst_addr_src     = 2'b01;  // rx_dma_burst_addr = nxt_descr_ptr_pad[queue_ptr_rx_rph] + 32'h00000004;</font>
4925       <font color = "red">0/1     ==>          rx_dma_burst_dscr_inc_val = 32'h00000004;</font>
4926                          end
4927                    
4928                          // Setup address for 2nd management write
4929       1/1                else if (inc_rx_dma_mux_addr_1)
4930                          begin
4931       <font color = "red">0/1     ==>          if (~gem_dma_addr_w_is_64)</font>
4932                            begin
4933       <font color = "red">0/1     ==>            rx_dma_burst_addr_src     = 2'b01;  // rx_dma_burst_addr = nxt_descr_ptr_pad[queue_ptr_rx_rph] + 32'h00000008;</font>
4934       <font color = "red">0/1     ==>            rx_dma_burst_dscr_inc_val = 32'h00000008;</font>
4935                            end
4936                            else
4937                            begin
4938       <font color = "red">0/1     ==>            rx_dma_burst_addr_src     = 2'b01;  // rx_dma_burst_addr = nxt_descr_ptr_pad[queue_ptr_rx_rph] + 32'h00000010;</font>
4939       <font color = "red">0/1     ==>            rx_dma_burst_dscr_inc_val = 32'h00000010;</font>
4940                            end
4941                          end
4942                          // Setup address for 1st management write
4943                          else // default setup addr if ((~astrobe_manwr_1st &amp; ~manwr_astrobe2_en) &amp; (manwr_astrobe_cnt == 4'h0))
4944                          begin
4945       1/1                  if (~gem_dma_addr_w_is_64)
4946                            begin
4947       1/1                    rx_dma_burst_addr_src     = 2'b01;  // rx_dma_burst_addr = nxt_descr_ptr_pad[queue_ptr_rx_rph] + 32'h0000000c;
4948       1/1                    rx_dma_burst_dscr_inc_val = 32'h0000000c;
4949                            end
4950                            else
4951                            begin
4952       <font color = "red">0/1     ==>            rx_dma_burst_addr_src     = 2'b01;  // rx_dma_burst_addr = nxt_descr_ptr_pad[queue_ptr_rx_rph] + 32'h00000014;</font>
4953       <font color = "red">0/1     ==>            rx_dma_burst_dscr_inc_val = 32'h00000014;</font>
4954                            end
4955                          end
4956                        end
4957                    
4958                      end
4959                    
4960                      // Shift ahb_data_addr based on dma_bus_width
4961                      always@(*)
4962                      begin
4963       1/1              if (dma_bus_width == 2'b00)
4964       1/1                ahb_data_addr_shift = {ahb_data_addr[31:2],2'b00};
4965       <font color = "red">0/1     ==>      else if (dma_bus_width == 2'b01)</font>
4966       <font color = "red">0/1     ==>        ahb_data_addr_shift = {ahb_data_addr[31:3],3'b000};</font>
4967                        else
4968       <font color = "red">0/1     ==>        ahb_data_addr_shift = {ahb_data_addr[31:4],4'b0000};</font>
4969                      end
4970                    
4971                      assign ahb_data_addr_shift_p[31:0]  = ahb_data_addr_shift;
4972                    
4973                      // Optional parity regeneration:
4974                      generate if (p_edma_asf_dap_prot == 1) begin : gen_ahb_data_addr_shift_par
4975                        gem_par_chk_regen #(.p_chk_dwid (32),.p_new_dwid(32)) i_regen_par (
4976                          .odd_par  (1'b0),
4977                          .chk_dat  (ahb_data_addr[31:0]),
4978                          .chk_par  (ahb_data_addr[p_awid_par-1:p_awid_par-4]),
4979                          .new_dat  (ahb_data_addr_shift),
4980                          .dat_out  (),
4981                          .par_out  (ahb_data_addr_shift_p[35:32]),
4982                          .chk_err  ()  // No need to check here as parity will be stored in register soon for checking.
4983                        );
4984                      end
4985                      endgenerate
4986                    
4987                      // The adder for nxt_descr_ptr to generate rx_dma_burst_addr_inc
4988                      edma_arith_par #(
4989                        .p_dwidth (32),
4990                        .p_pwidth (4),
4991                        .p_has_par(p_edma_asf_dap_prot)
4992                      ) i_arith_rx_dma_burst_addr_inc (
4993                        .in_val (nxt_descr_ptr_pad[queue_ptr_rx_rph][31:0]),
4994                        .in_par (nxt_descr_ptr_pad[queue_ptr_rx_rph][p_awid_par-1:p_awid_par-4]),
4995                        .op_val (rx_dma_burst_dscr_inc_val),
4996                        .op_add (1'b1),
4997                        .out_val(rx_dma_burst_addr_inc[31:0]),
4998                        .out_par(rx_dma_burst_addr_inc[35:32])
4999                      );
5000                    
5001                      // Finally select the source for rx_dma_burst_addr:
5002                      always@(*)
5003                      begin
5004       1/1              case (rx_dma_burst_addr_src)
5005       1/1                2'b01:    rx_dma_burst_addr = rx_dma_burst_addr_inc[p_awid_par-1:0];
5006       1/1                2'b10:    rx_dma_burst_addr = ahb_data_addr_shift_p[p_awid_par-1:0];
5007       <font color = "red">0/1     ==>        default:  rx_dma_burst_addr = rx_dma_base_addr_arr[queue_ptr_rx_rph];</font>
5008                        endcase
5009                      end
5010                    
5011                      // instantiate the alignment block
5012                      reg [3:0] eob_mod_in;
5013                      always@(posedge hclk or negedge n_hreset)
5014                      begin
5015       1/1              if (~n_hreset)
5016       1/1                eob_mod_in &lt;= 4'h0;
5017       1/1              else if (hdr_data_splitting_en &amp; in_header &amp; ({1'b0,remaining_hdr_bytes} &lt;= buffer_size_words))
5018       <font color = "red">0/1     ==>        eob_mod_in &lt;= (pld_offset[3:0] &amp; {dma_bus_width[1],|dma_bus_width[1:0],2'b11});</font>
5019                        else
5020       1/1                eob_mod_in &lt;= 4'h0;
5021                      end
5022                    
5023                      edma_pbuf_rx_align #(.p_edma_asf_dap_prot(p_edma_asf_dap_prot)) i_edma_pbuf_rx_align (
5024                    
5025                       .hclk                 (hclk),
5026                       .n_hreset             (n_hreset),
5027                    
5028                       .dma_bus_width        (dma_bus_width),
5029                       .hdr_data_splitting_en(hdr_data_splitting_en),
5030                       .soft_reset           (~enable_rx_hclk | hresp_notok_eob),
5031                       .data_in              (rxdpram_dob_downsize_pad),
5032                       .par_in               (rxdpram_dob_downsize_par_pad),
5033                       .data_in_vld          (prev_ahbreqph_strobe &amp; ~padding_aph),
5034                    
5035                       .start_byte_in       ({bit3n2data_add_64,rx_dma_buffer_offset} &amp; {dma_bus_width[1],|dma_bus_width[1:0],2'b11}),
5036                       .eob_mod_in           (eob_mod_in &amp; {4{buffer_fill_lvl == 12'h000}}),
5037                    
5038                    
5039                       .eop_in               (reading_eop_dpram_aph),
5040                       .mod_in               (status_word_3[3:0] &amp; {dma_bus_width[1],|dma_bus_width[1:0],2'b11}),
5041                       .early_eop_in         (reading_eop_dpram_rph),
5042                       .all_outputs_sampled  (real_eop_ahb_dph),
5043                       .eob_in               (buffer_fill_lvl == 12'h000),
5044                       .push_residue         (prev_ahbreqph_strobe),
5045                    
5046                       .data_out             (rxdpram_dob_offset),
5047                       .par_out              (rxdpram_dob_par_offset),
5048                       .eop_out              (real_eop_ahb_aph_pulse),
5049                       .early_eop_out        (real_eop_ahb_rph_pulse),
5050                       .words_in_residue     (words_in_residue)
5051                       );
5052                    
5053                      // real_eop_ahb_aph_pulse is a pulse that is generated 1 cycle after the request phase.
5054                      // We need to time real_eop_ahb_aph to the address phase, so this needs to be stretched
5055                      // until prev_ahbaddph_strobe
5056                      always@(posedge hclk or negedge n_hreset)
5057                      begin
5058       1/1              if (~n_hreset)
5059                        begin
5060       1/1                real_eop_ahb_rph_reg   &lt;= 1'b0;
5061       1/1                real_eop_ahb_aph_reg   &lt;= 1'b0;
5062       1/1                real_eop_ahb_dph_reg   &lt;= 1'b0;
5063                        end
5064                        else
5065                        begin
5066       1/1                if (~enable_rx_hclk)
5067                          begin
5068       1/1                  real_eop_ahb_rph_reg &lt;= 1'b0;
5069       1/1                  real_eop_ahb_aph_reg &lt;= 1'b0;
5070                          end
5071                          else
5072                          begin
5073       1/1                  if (ahbreqph_strobe_data_nopad)
5074       1/1                    real_eop_ahb_rph_reg &lt;= 1'b0;
5075       1/1                  else if (real_eop_ahb_rph_pulse)
5076       <font color = "red">0/1     ==>            real_eop_ahb_rph_reg &lt;= 1'b1;</font>
                        MISSING_ELSE
5077                    
5078       1/1                  if (ahbaddph_strobe_data_nopad)
5079       1/1                    real_eop_ahb_aph_reg &lt;= 1'b0;
5080       1/1                  else if (real_eop_ahb_aph_pulse)
5081       1/1                    real_eop_ahb_aph_reg &lt;= 1'b1;
                        MISSING_ELSE
5082                    
5083       1/1                  if (ahbdataph_strobe_data &amp; real_eop_ahb_dph_reg)
5084       1/1                    real_eop_ahb_dph_reg &lt;= 1'b0;
5085       1/1                  else if (real_eop_ahb_aph)
5086       1/1                    real_eop_ahb_dph_reg &lt;= 1'b1;
                        MISSING_ELSE
5087                          end
5088                        end
5089                      end
5090                      assign real_eop_ahb_rph = (real_eop_ahb_rph_reg | real_eop_ahb_rph_pulse) &amp; ahbreqph_strobe_data_nopad;
5091                      assign real_eop_ahb_aph = (real_eop_ahb_aph_reg | real_eop_ahb_aph_pulse) &amp; ahbaddph_strobe_data_nopad;
5092                      assign real_eop_ahb_dph = real_eop_ahb_dph_reg &amp; ahbdataph_strobe_data;
5093                    
5094                      assign current_descriptor = str_descriptor_pad[queue_ptr_rx_aph];
5095                    
5096                      always @(*)
5097                      begin
5098       1/1              if (~rx_bd_extended_mode_en | ~rx_eof_written)
5099       1/1                descr_wback_data_bit_2  = current_descriptor[2];
5100                        else
5101       1/1                descr_wback_data_bit_2  = status_word_2[31];
5102                    
5103       1/1              if (~jumbo_enable &amp; rx_no_crc_check &amp; ~rsc_en)
5104       <font color = "red">0/1     ==>        descr_wback_data_bit_46 = status_word_2[28];    // rx_w_crc_error_hclk</font>
5105                        else
5106       1/1                descr_wback_data_bit_46 = status_word_3[13];   // rx_w_frame_length[13]
5107                    
5108       1/1              if (crc_error_report)
5109       <font color = "red">0/1     ==>        descr_wback_data_bit_49 = status_word_2[28];    // rx_w_crc_error_hclk</font>
5110                        else
5111       1/1                descr_wback_data_bit_49 = status_word_2[17];   // rx_w_tci_hclk[0]
5112                      end
5113                    
5114                      // The actual packet data driven to AHB will originate from the DPRAM.
5115                      // However,
5116                      always @ ( * )
5117                      begin
5118       1/1              if (rx_dma_state_data &amp; padding_aph)
5119       <font color = "red">0/1     ==>        rx_dma_data_out   = 128'd0;</font>
5120                    
5121       1/1              else if (rx_dma_state_data)
5122       1/1                rx_dma_data_out   = rxdpram_dob_offset[127:0];
5123                    
5124                        // Provide data for the 1st descriptor write (which actually happens second)
5125                        // rx_dma_data_out is stored in dpram_do_str register before going into
5126                        // hwdata register.  HWDATA is AHB dataphase, so we need dpram_do_str to be
5127                        // address phase, and therefore rx_dma_data_out must be request phase
5128       1/1              else if (descriptor_wr_1_access)
5129                        begin
5130       <font color = "red">0/1     ==>        rx_dma_data_out[127:64] = {22'd0, rx_timestamp};</font>
5131       <font color = "red">0/1     ==>        rx_dma_data_out[31:0]   = {current_descriptor[31:3],</font>
5132                                                    descr_wback_data_bit_2 ,
5133                                                    current_descriptor[1],
5134                                                    1'b1};
5135       <font color = "red">0/1     ==>        if (rx_eof_written)  // last BD of frame contains stats updates</font>
5136       <font color = "red">0/1     ==>          rx_dma_data_out[63:32] = {</font>
5137                                               status_word_2[26],      // rx_w_broadcast_frame
5138                                               status_word_2[25],      // rx_w_mult_hash_match
5139                                               status_word_2[24],      // rx_w_uni_hash_match
5140                                               status_word_2[13],      // |rx_w_ext_match
5141                                               status_word_2[12],      // |rx_w_add_match
5142                                               status_word_2[11:10],   // rx_add_match_code
5143                                               status_word_2[16:14],   // rx_type_match_code
5144                                               status_word_2[23],      // rx_w_vlan_tag_hclk
5145                                               status_word_2[22],      // rx_w_prty_tag_hclk
5146                                               status_word_2[20:18],   // rx_w_tci_hclk[3:1]
5147                                               descr_wback_data_bit_49,
5148                                               rx_eof_written,
5149                                               rx_sof_written,
5150                                               descr_wback_data_bit_46,// rx_w_frame_length[13]
5151                                               status_word_3[12:0]};   // rx_w_frame_length[12:0]
5152                          else  // if not the last BD of frame
5153       <font color = "red">0/1     ==>          rx_dma_data_out[63:32] = {</font>
5154                                               14'd0,
5155                                               (hdr_data_splitting_en &amp; in_header &amp; ({1'b0,remaining_hdr_bytes} &lt;= buffer_size_words)),
5156                                               (hdr_data_splitting_en &amp; in_header),
5157                                               1'b0,
5158                                               rx_sof_written,
5159                                               2'b00,
5160                                               ({12{hdr_data_splitting_en &amp; in_header}} &amp; pld_offset)};
5161                    
5162                        end
5163       1/1              else  if(descriptor_wr_2_access)
5164                        begin
5165       1/1                if (dma_bus_width == 2'b00)  // 32b data bus
5166                          begin
5167       1/1                  if (rx_dma_state_man_wr &amp; manwr_astrobe2_en)   // last BD word to be written contains ownership bit
5168       1/1                    if (rx_eof_written)  // update descr_wback_data_bit_2 in last BD of frame
5169       1/1                      rx_dma_data_out = {96'd0,
5170                                                   current_descriptor[31:3],
5171                                                   descr_wback_data_bit_2 ,
5172                                                   current_descriptor[1],
5173                                                   1'b1};
5174                              else
5175       <font color = "red">0/1     ==>              rx_dma_data_out = {96'd0,current_descriptor[31:1],1'b1};</font>
5176                    
5177                    
5178                    
5179                            // Provide data FIRST BD WRITE word after whole frame has been stored
5180                            // in the memory. The 2nd descriptor word actually is written first
5181                            // If not doing jumbo frames the top bit of the length field is borrowed
5182                            // for indicating a frame which was copied but had bad CRC (in ignore
5183                            // FCS mode).
5184       1/1                  else if (rx_dma_next_man_wr &amp; rx_eof_written) // last BD of frame contains stats updates
5185       1/1                    rx_dma_data_out = {96'd0,
5186                                                 status_word_2[26],      // rx_w_broadcast_frame
5187                                                 status_word_2[25],      // rx_w_mult_hash_match
5188                                                 status_word_2[24],      // rx_w_uni_hash_match
5189                                                 status_word_2[13],      // |rx_w_ext_match
5190                                                 status_word_2[12],      // |rx_w_add_match
5191                                                 status_word_2[11:10],   // rx_add_match_code
5192                                                 status_word_2[16:14],   // rx_type_match_code
5193                                                 status_word_2[23],      // rx_w_vlan_tag_hclk
5194                                                 status_word_2[22],      // rx_w_prty_tag_hclk
5195                                                 status_word_2[20:18],   // rx_w_tci_hclk[3:1]
5196                                                 descr_wback_data_bit_49,
5197                                                 rx_eof_written,
5198                                                 rx_sof_written,
5199                                                 descr_wback_data_bit_46,// rx_w_frame_length[13]
5200                                                 status_word_3[12:0]};   // rx_w_frame_length[12:0]
5201                    
5202                            // provide data for  first descrptr write but the buffer is not the last
5203                            // one for current frame so we don't update stats
5204                            else  // if not last BD of frame
5205       1/1                    rx_dma_data_out = {110'd0,
5206                                                 (hdr_data_splitting_en &amp; in_header &amp; ({1'b0,remaining_hdr_bytes} &lt;= buffer_size_words)),
5207                                                 (hdr_data_splitting_en &amp; in_header),
5208                                                 1'b0,
5209                                                 rx_sof_written,
5210                                                 2'b00,
5211                                                 ({12{hdr_data_splitting_en &amp; in_header}} &amp; pld_offset)};
5212                          end
5213                          else  // 64b and 128b data bus
5214                          begin
5215       <font color = "red">0/1     ==>          if (rx_dma_state_man_wr &amp; manwr_astrobe2_en)   // last BD word to be written contains ownership bit</font>
5216       <font color = "red">0/1     ==>            if (rx_eof_written)  // update descr_wback_data_bit_2 in last BD of frame</font>
5217                                begin
5218       <font color = "red">0/1     ==>                rx_dma_data_out[127:64] = {22'd0, rx_timestamp};</font>
5219       <font color = "red">0/1     ==>                rx_dma_data_out[31:0] = {current_descriptor[31:3],</font>
5220                                                           descr_wback_data_bit_2 ,
5221                                                           current_descriptor[1],
5222                                                           1'b1};
5223       <font color = "red">0/1     ==>                rx_dma_data_out[63:32] = {</font>
5224                                                     status_word_2[26],      // rx_w_broadcast_frame
5225                                                     status_word_2[25],      // rx_w_mult_hash_match
5226                                                     status_word_2[24],      // rx_w_uni_hash_match
5227                                                     status_word_2[13],      // |rx_w_ext_match
5228                                                     status_word_2[12],      // |rx_w_add_match
5229                                                     status_word_2[11:10],   // rx_add_match_code
5230                                                     status_word_2[16:14],   // rx_type_match_code
5231                                                     status_word_2[23],      // rx_w_vlan_tag_hclk
5232                                                     status_word_2[22],      // rx_w_prty_tag_hclk
5233                                                     status_word_2[20:18],   // rx_w_tci_hclk[3:1]
5234                                                     descr_wback_data_bit_49,
5235                                                     rx_eof_written,
5236                                                     rx_sof_written,
5237                                                     descr_wback_data_bit_46,// rx_w_frame_length[13]
5238                                                     status_word_3[12:0]};   // rx_w_frame_length[12:0]
5239                    
5240                                // provide data for  first descrptr write but the buffer is not the last
5241                                // one for current frame so we don't update stats
5242                                end
5243                              else
5244                              begin
5245       <font color = "red">0/1     ==>              rx_dma_data_out[127:32] = {78'd0,</font>
5246                                                           (hdr_data_splitting_en &amp; in_header &amp; ({1'b0,remaining_hdr_bytes} &lt;= buffer_size_words)),
5247                                                           (hdr_data_splitting_en &amp; in_header),
5248                                                           1'b0,
5249                                                           rx_sof_written,
5250                                                           2'b00,
5251                                                          ({12{hdr_data_splitting_en &amp; in_header}} &amp; pld_offset)};
5252       <font color = "red">0/1     ==>              rx_dma_data_out[31:0] = {current_descriptor[31:3],</font>
5253                                                         current_descriptor[2],
5254                                                         current_descriptor[1],
5255                                                         1'b1};
5256                    
5257                              end
5258                            // Provide data FIRST BD WRITE word after whole frame has been stored
5259                            // in the memory. The 2nd descriptor word actually is written first
5260                            // If not doing jumbo frames the top bit of the length field is borrowed
5261                            // for indicating a frame which was copied but had bad CRC (in ignore
5262                            // FCS mode).
5263       <font color = "red">0/1     ==>          else if (rx_dma_next_man_wr &amp; rx_eof_written) // last BD of frame contains stats updates</font>
5264       <font color = "red">0/1     ==>            rx_dma_data_out = {86'd0, rx_timestamp };</font>
5265                    
5266                            // provide data for  first descrptr write but the buffer is not the last
5267                            // one for current frame so we don't update stats
5268                            else  // if not last BD of frame
5269       <font color = "red">0/1     ==>            rx_dma_data_out = {128'd0};</font>
5270                          end
5271                        end
5272                    
5273                        else // if(descriptor_wr_4_access) only for 32b data bus
5274                        begin
5275       1/1                if (rx_dma_state_man_wr &amp; manwr_astrobe4_en)   // BD word 0 to be written contains ownership bit
5276       <font color = "red">0/1     ==>          if (rx_eof_written)  // update ts-to_be_written in last BD of frame</font>
5277       <font color = "red">0/1     ==>            rx_dma_data_out = {96'd0,</font>
5278                                                 current_descriptor[31:3],
5279                                                 descr_wback_data_bit_2 ,
5280                                                 current_descriptor[1],
5281                                                 1'b1};
5282                            else
5283       <font color = "red">0/1     ==>            rx_dma_data_out = {96'd0,current_descriptor[31:1],1'b1};</font>
5284                    
5285                    
5286                          // Provide data for 2nd last word after whole frame has been stored
5287                          // in the memory. The 2nd descriptor word actually is written first
5288                          // If not doing jumbo frames the top bit of the length field is borrowed
5289                          // for indicating a frame which was copied but had bad CRC (in ignore
5290                          // FCS mode).
5291       1/1                else if (rx_dma_state_man_wr &amp; manwr_astrobe3_en)   // BD word 1 to be written contains stats
5292       <font color = "red">0/1     ==>          if (rx_eof_written) // last BD of frame contains stats updates</font>
5293       <font color = "red">0/1     ==>            rx_dma_data_out = {96'd0,</font>
5294                                                 status_word_2[26],      // rx_w_broadcast_frame
5295                                                 status_word_2[25],      // rx_w_mult_hash_match
5296                                                 status_word_2[24],      // rx_w_uni_hash_match
5297                                                 status_word_2[13],      // |rx_w_ext_match
5298                                                 status_word_2[12],      // |rx_w_add_match
5299                                                 status_word_2[11:10],   // rx_add_match_code
5300                                                 status_word_2[16:14],   // rx_type_match_code
5301                                                 status_word_2[23],      // rx_w_vlan_tag_hclk
5302                                                 status_word_2[22],      // rx_w_prty_tag_hclk
5303                                                 status_word_2[20:18],   // rx_w_tci_hclk[3:1]
5304                                                 descr_wback_data_bit_49,
5305                                                 rx_eof_written,
5306                                                 rx_sof_written,
5307                                                 descr_wback_data_bit_46,
5308                                                 status_word_3[12:0]};   // rx_w_frame_length[12:0]
5309                    
5310                            // provide data for  first descrptr write but the buffer is not the last
5311                            // one for current frame
5312                            else  // if not last BD of frame
5313       <font color = "red">0/1     ==>            rx_dma_data_out = {110'd0,</font>
5314                                                 (hdr_data_splitting_en &amp; in_header &amp; ({1'b0,remaining_hdr_bytes} &lt;= buffer_size_words)),
5315                                                 (hdr_data_splitting_en &amp; in_header),
5316                                                 1'b0,
5317                                                 rx_sof_written,
5318                                                 2'd0,
5319                                                 ({12{hdr_data_splitting_en &amp; in_header}} &amp; pld_offset)};
5320                    
5321       1/1                else if (rx_dma_state_man_wr &amp; manwr_astrobe2_en)   // 2nd BD word to be written
5322       <font color = "red">0/1     ==>            rx_dma_data_out = {96'd0, rx_timestamp[31:0]};</font>
5323                    
5324                          else // 1st BD word to be written
5325       1/1                    rx_dma_data_out = {118'd0, rx_timestamp[41:32]};
5326                    
5327                        end
5328                    
5329                      end
5330                    
5331                      always@(posedge hclk or negedge n_hreset)
5332                      begin
5333       1/1              if (~n_hreset)
5334       1/1                hresp_notok_hold   &lt;= 1'b0;
5335                        else
5336                        begin
5337       1/1                if (~enable_rx_hclk | hresp_notok_eob)
5338       1/1                  hresp_notok_hold   &lt;= 1'b0;
5339       1/1                else if (hresp_not_ok)
5340       <font color = "red">0/1     ==>          hresp_notok_hold  &lt;= 1'b1;</font>
                        MISSING_ELSE
5341                        end
5342                      end
5343                    
5344                      generate for (g=0; g&lt;p_edma_queues; g=g+1) begin : gen_rx_dma_descr_ptr
5345                        assign rx_dma_descr_ptr[(g*32)+31:g*32]   = nxt_descr_ptr_pad[g][31:0];
5346                        assign rx_dma_descr_ptr_par[(g*4)+3:g*4]  = (p_edma_asf_dap_prot == 1)  ? nxt_descr_ptr_pad[g][p_awid_par-1:p_awid_par-4] : 4'h0;
5347                      end
5348                      endgenerate
5349                    
5350                    
5351                      always@(posedge hclk or negedge n_hreset)
5352                      begin
5353       1/1              if (~n_hreset)
5354       1/1                rx_descr_ptr_reset &lt;= 1'b0;
5355                        else
5356       1/1                rx_descr_ptr_reset &lt;= p_edma_axi == 1 &amp; mac_err_vld &amp; ~rx_dma_state_man_wr ;
5357                      end
5358                    
5359                    
5360                      // ---------------------------------------------------------------
5361                      // Update the Statistics in the PCLK domain
5362                      // This can be done as soon as the STATUS words have been read
5363                    
5364                      edma_sync_toggle_detect i_edma_sync_toggle_detect_rx_pkt_status_wr_tog (
5365                        .clk(hclk),
5366                        .reset_n(n_hreset),
5367                        .din(rx_pkt_status_wr_tog),
5368                        .rise_edge(),
5369                        .fall_edge(),
5370                        .any_edge(rx_pkt_status_wr_tog_edge));
5371                    
5372                      always@(posedge hclk or negedge n_hreset)
5373                      begin
5374       1/1              if (~n_hreset)
5375                        begin
5376       1/1                rx_pkt_end_tog      &lt;= 1'b0;
5377       1/1                prev_stats_captured &lt;= 1'b1;
5378                        end
5379                        else
5380                        begin
5381       1/1                if (~enable_rx_hclk)
5382                          begin
5383       1/1                  rx_pkt_end_tog      &lt;= rx_pkt_end_tog;
5384       1/1                  prev_stats_captured &lt;= 1'b1;
5385                          end
5386                    
5387       1/1                else if (last_dpram_rd_state == P_STATUS_WORD_4)
5388                          begin
5389       1/1                  rx_pkt_end_tog      &lt;= ~rx_pkt_end_tog;
5390       1/1                  prev_stats_captured &lt;= 1'b0;
5391                          end
5392                    
5393                          // If we are waiting for the register block to capture the
5394                          // stats off the status_word busses, we must ensure these
5395                          // busses remain static - i.e we cant start reading a new pkt
5396                          // from the DPRAM until the register block indicates it is done
5397                          // with the data ...
5398       1/1                else if (rx_pkt_status_wr_tog_edge)
5399       1/1                  prev_stats_captured &lt;= 1'b1;
                        MISSING_ELSE
5400                        end
5401                      end
5402                    
5403                    
5404                      // ---------------------------------------------------------------
5405                      // When the packet is completely read from the DPRAM, inform the
5406                      // write side of the packet buffer how many bytes can be recovered ..
5407                      always @(*)
5408                      begin
5409       1/1              if (ahbreqph_strobe_data &amp; ~status_word1_capt &amp; rx_cutthru)
5410                        begin
5411       <font color = "red">0/1     ==>        if (hresp_notok_eob)</font>
5412       <font color = "red">0/1     ==>          last_partpkt_rph = 1'b0;</font>
5413                          else
5414       <font color = "red">0/1     ==>          last_partpkt_rph = ((part_dplocns == rx_cutthru_threshold) &amp; empty_downsize);</font>
5415                        end
5416                    
5417       1/1              else if  (hresp_data_cutthru | flush_next_packet)
5418       <font color = "red">0/1     ==>        last_partpkt_rph = 1'b1;</font>
5419                    
5420       1/1              else if (ahb_err_pktdiscarded_wait4end)
5421                        // While we are waiting for the end of the packet to be read after an error
5422                        // event then just recover every time a part of packet is read in
5423       <font color = "red">0/1     ==>        last_partpkt_rph = part_pkt_written_d1;</font>
5424                    
5425                        else
5426       1/1                last_partpkt_rph = 1'b0;
5427                      end
5428                    
5429                      // ahb_err_discard_recover will be set when a packet needs to be flushed ...
5430                      // This only occurs when an ahb error happens and we are configured in cut-thru modes
5431                      // or when force_discard_on_err is set ...
5432                      // For the case where we want to use rx_buffer_used_bit in store/forward, we need to make
5433                      // sure we have read the status from the DPRAM and the part_dplocns_left is
5434                      // updated properly before we can act on it -
5435                      // otherwise we wont know how many locations to clear up
5436                      always @(posedge hclk or negedge n_hreset)
5437                      begin
5438       1/1              if (~n_hreset)
5439                        begin
5440       1/1                rx_buffer_used_bit_d1 &lt;= 1'b0;
5441       1/1                ahb_sf_err_hold &lt;= 1'b0;
5442       1/1                ahb_sf_err_vld &lt;= 1'b0;
5443                        end
5444                        else
5445                        begin
5446       1/1                rx_buffer_used_bit_d1 &lt;= rx_buffer_used_bit;
5447                    
5448       1/1                if (status_word1_capt | nxt_rx_dma_state != RX_DMA_IDLE | flush_next_packet)
5449       1/1                  ahb_sf_err_hold &lt;= 1'b0;
5450       1/1                else if (ahbdataph_strobe_descr_rd &amp; (|num_pkts_needing_read))
5451       <font color = "red">0/1     ==>          ahb_sf_err_hold &lt;= rx_buffer_used_bit | hresp_notok_eob;</font>
                        MISSING_ELSE
5452       1/1                ahb_sf_err_vld &lt;= (rx_buffer_used_bit | (ahb_sf_err_hold &amp; rx_dma_state == RX_DMA_IDLE) |
5453                                                (hresp_notok_eob &amp; ahbdataph_strobe_descr_rd &amp; ~rx_cutthru)) &amp;
5454                                                status_word1_capt &amp; status_word_1[0] &amp; ~flush_next_packet;
5455                    
5456                        end
5457                      end
5458                    
5459                      // -----------------------------------------------------------------------------
5460                      // Per-queue receive flushing Mode1 implementation
5461                      // -----------------------------------------------------------------------------
5462                      // This has to be a register because otherwise there would
5463                      // be a combinatorial loop between queue_ptr_rx_rph
5464                      // and force_discard_on_err_queue
5465                      wire [15:0] force_discard_on_err_q_pad;
5466                      assign force_discard_on_err_q_pad[p_edma_queues-1:0] = force_discard_on_err_q;
5467                      always @ (posedge hclk or negedge n_hreset)
5468                      begin
5469       1/1              if(~n_hreset)
5470       1/1                force_discard_on_err_queue &lt;= 1'b0;
5471                        else
5472                          begin
5473       1/1                  if(force_discard_on_err_q_pad[queue_ptr_rx_rph])
5474       <font color = "red">0/1     ==>            force_discard_on_err_queue &lt;= 1'b1;</font>
5475                            else
5476       1/1                    force_discard_on_err_queue &lt;= 1'b0;
5477                          end
5478                      end
5479                    
5480                      assign force_discard_on_error = force_discard_on_err_queue | force_discard_on_err;
5481                    
5482                    
5483                      // In store and forward mode, we can discard a packet when a resource error occurs,
5484                      // but only after the status has been captured.  We can also discard when an HRESP
5485                      // error occurs in either the descriptor read or data write states
5486                      assign ahb_sf_err = ~(rx_cutthru &amp; frame_reading_as_cutthru) &amp;
5487                                           (force_discard_on_error | rx_cutthru)  &amp;
5488                                          ((hresp_notok_eob &amp; ahbdataph_strobe_data &amp; ~rx_cutthru) | ahb_sf_err_vld);
5489                    
5490                      // In cut-thru modes, things are done a little differently and we can discard based on the
5491                      // raw information.
5492                      assign ahb_ct_err =  rx_cutthru &amp;
5493                                            ((hresp_notok_eob &amp; rx_dma_state != RX_DMA_IDLE)     |
5494                                             (rx_buffer_used_bit_d1 &amp; frame_reading_as_cutthru)) &amp;
5495                                             (ahbdataph_strobe_data    |
5496                                             (|num_parts_needing_read) |
5497                                             (|num_pkts_needing_read));
5498                    
5499                      assign ahb_err_discard  =  (ahb_sf_err | ahb_ct_err);
5500                    
5501                      assign ahb_err_discard_recover = ahb_err_discard;
5502                    
5503                      edma_sync_toggle_detect i_edma_sync_toggle_detect_pkt_done_capt_tog (
5504                        .clk(hclk),
5505                        .reset_n(n_hreset),
5506                        .din(pkt_done_capt_tog),
5507                        .rise_edge(),
5508                        .fall_edge(),
5509                        .any_edge(pkt_done_capt_tog_edge));
5510                    
5511                      always @(posedge hclk or negedge n_hreset)
5512                      begin
5513       1/1              if (~n_hreset)
5514                        begin
5515       1/1                frame_reading_as_cutthru  &lt;= 1'b0;
5516                        end
5517                        else
5518                        begin
5519       1/1                if (dpram_rd_state == P_IDLE)
5520       1/1                  frame_reading_as_cutthru &lt;= start_reading_at_risk;
                        MISSING_ELSE
5521                        end
5522                      end
5523                    
5524                    
5525                    // This section has come out to try improve code coverage ...
5526                    always @(*)
5527                    begin
5528       1/1            if (~(|recover_dplocns_err[p_edma_rx_pbuf_addr-1:0]) &amp; (last_partpkt_rph | reading_eop_dpram_rph)) begin
5529       <font color = "red">1/2     ==>      if (gem_rx_pbuf_data_w_is_128)    pkt_done_dplocns_nxt = part_dplocns_p2[p_edma_rx_pbuf_addr-1:0];</font>
5530       <font color = "red">1/2     ==>      else if (dma_bus_width[0])        pkt_done_dplocns_nxt = part_dplocns_p3[p_edma_rx_pbuf_addr-1:0];</font>
5531       2/2              else if (~rx_bd_extended_mode_en) pkt_done_dplocns_nxt = part_dplocns_p4[p_edma_rx_pbuf_addr-1:0];
5532       <font color = "red">0/1     ==>      else                              pkt_done_dplocns_nxt = part_dplocns_p5[p_edma_rx_pbuf_addr-1:0];</font>
5533                      end
5534                      else begin
5535       <font color = "red">1/2     ==>      if (gem_rx_pbuf_data_w_is_128)    pkt_done_dplocns_nxt = recover_dplocns_err_p1[p_edma_rx_pbuf_addr-1:0];</font>
5536       <font color = "red">1/2     ==>      else if (dma_bus_width[0])        pkt_done_dplocns_nxt = recover_dplocns_err_p2[p_edma_rx_pbuf_addr-1:0];</font>
5537       2/2              else if (~rx_bd_extended_mode_en) pkt_done_dplocns_nxt = recover_dplocns_err_p3[p_edma_rx_pbuf_addr-1:0];
5538       1/1              else                              pkt_done_dplocns_nxt = recover_dplocns_err_p4[p_edma_rx_pbuf_addr-1:0];
5539                      end
5540                    end
5541                    
5542                    // Helper signal ...
5543                      always @(*)
5544                      begin
5545       1/1              if (gem_rx_pbuf_data_w_is_128)
5546       <font color = "red">0/1     ==>        pkt_dplocns_to_flush_plus_st    = recover_dplocns_err_p1[p_edma_rx_pbuf_addr-1:0];</font>
5547       1/1              else if (dma_bus_width[0])
5548       <font color = "red">0/1     ==>        pkt_dplocns_to_flush_plus_st    = recover_dplocns_err_p2[p_edma_rx_pbuf_addr-1:0];</font>
5549                        else
5550       1/1                if (~rx_bd_extended_mode_en)
5551       1/1                  pkt_dplocns_to_flush_plus_st  = recover_dplocns_err_p3[p_edma_rx_pbuf_addr-1:0];
5552                          else
5553       1/1                  pkt_dplocns_to_flush_plus_st  = recover_dplocns_err_p4[p_edma_rx_pbuf_addr-1:0];
5554                      end
5555                    
5556                      wire [16:0] pkt_dplocns_plus_part_dplocns_left;  
5557                      assign      pkt_dplocns_plus_part_dplocns_left = {5'd0,pkt_dplocns} + {{(17-p_edma_rx_pbuf_addr){1'b0}},part_dplocns_left};
5558                    
5559                      always @(posedge hclk or negedge n_hreset)
5560                      begin
5561       1/1              if (~n_hreset)
5562                        begin
5563       1/1                pkt_done_tog          &lt;= 1'b0;
5564       1/1                part_dplocns_left     &lt;= {p_edma_rx_pbuf_addr{1'b0}};
5565       1/1                part_dplocns          &lt;= {p_edma_rx_pbuf_addr{1'b0}};
5566       1/1                pkt_dplocns           &lt;= 12'h000;
5567       1/1                pkt_dplocns_str       &lt;= {p_edma_rx_pbuf_addr{1'b0}};
5568       1/1                pkt_done_dplocns      &lt;= {p_edma_rx_pbuf_addr{1'b0}};
5569       1/1                wait_for_pktdone_capt &lt;= 1'b0;
5570       1/1                take_stored_value     &lt;= 1'b0;
5571       1/1                hresp_data_cutthru    &lt;= 1'b0;
5572       1/1                part_pkt_written_d1   &lt;= 1'b0;
5573                        end
5574                        else
5575                        begin
5576       1/1                hresp_data_cutthru    &lt;= ahb_err_discard_recover;
5577       1/1                part_pkt_written_d1   &lt;= part_pkt_written;
5578                    
5579       1/1                if (~enable_rx_hclk)
5580                          begin
5581       1/1                  pkt_done_tog          &lt;= pkt_done_tog;
5582       1/1                  part_dplocns_left     &lt;= {p_edma_rx_pbuf_addr{1'b0}};
5583       1/1                  part_dplocns          &lt;= {p_edma_rx_pbuf_addr{1'b0}};
5584       1/1                  pkt_dplocns           &lt;= 12'h000;
5585       1/1                  pkt_dplocns_str       &lt;= {p_edma_rx_pbuf_addr{1'b0}};
5586       1/1                  pkt_done_dplocns      &lt;= {p_edma_rx_pbuf_addr{1'b0}};
5587       1/1                  wait_for_pktdone_capt &lt;= 1'b0;
5588       1/1                  take_stored_value     &lt;= 1'b0;
5589                          end
5590                          else
5591                          begin
5592                            // pkt_dplocns,part_dplocns and part_dplocns_left are used to identify where the EOP
5593                            // of a packet is, and also to calculate how many DPRAM locations must be recovered
5594                            // after either an EOP, an end of &quot;part&quot;, or after some error event.
5595                            // 'pkt_dplocns' keeps track of the number of DPRAM reads.
5596                            // 'part_dplocns' also keeps track of the number of DPRAM reads, but resets when
5597                            // we reach a part of packet boundary
5598                            // 'part_dplocns_left' is used to understand how many reads remain until we hit a
5599                            // part of packet boundary - NOTE we need both part_dplocns and part_dplocns_left
5600                            //
5601                            // MAJOR COMPLICATION !
5602                            // In normal operating modes, the packet does not start to be fetched from DPRAM
5603                            // until we have obtained the status of that packet, and therefore know the length
5604                            // of the packet, and if the packet was errored in some way.  For cut-thru modes,
5605                            // we dont have this information, so we read &quot;at risk&quot;.  At some point before the end
5606                            // of the packet, we will obtain the status (actually this will always be on a
5607                            // 'part of packet' boundary).  For every 'part of packet' that we successuly fetch
5608                            // we will free up the resources that that 'part of packet' used in the DPRAM.  If we
5609                            // eventually discover that the packet was BAD (errored from the MAC side of DPRAM),
5610                            // then we will want to stop fetching data, and free up the remaining resources of
5611                            // that packet.  Since we know we will be on a part of packet boundary, we can
5612                            // guarantee that the remaining resources = (total pkt length - pkt_dplocns)
5613                            // If there is an error on this side of the DPRAM, like an HRESP error, then we
5614                            // cannot guarantee that this will happen on a 'part of packet' boundary.  Furthermore,
5615                            // it is quite possible due to cut-thru that the packet has not even been fully written
5616                            // into the DPRAM yet and writes on the AHB side continue.  If we simply stop fetching
5617                            // data until the status is known, there is a real risk of overflow which will
5618                            // just confuse the software and is not very elegant.  Therefore, we need to do 3 things
5619                            // on discovering errors on the AHB side of the DPRAM whilst in cut-thru
5620                            //  1) On discovering the error(like hresp, or resource error),  we need to bump
5621                            //     'pkt_dplocns' and 'part_dplocns' up to a packet boundary and initiate a
5622                            //     part_of_packet dpram space recovery
5623                            //  2) On every subsequent 'part_pkt_written' we perform a part_of_packet dpram
5624                            //     space recovery
5625                            //  3) When 'pkt_written_dpram' is written, we need to recover the last few locations
5626                            //     of the packet
5627                            //     as identified by part_dplocns_left
5628                    
5629                            // On an AHB error, bump 'pkt_dplocns' up to a part of pkt boundary.
5630       1/1                  if (ahb_err_discard_recover)
5631       <font color = "red">0/1     ==>            pkt_dplocns  &lt;= pkt_dplocns_plus_part_dplocns_left[11:0];</font>
5632                    
5633                            // ahb_err_pktdiscarded_wait4end indicates that we are just reading the remaining
5634                            // packet data from DPRAM but discarding it without forwarding to AHB
5635                            // Essentially we can just keep adding rx_cutthru_threshold to pkt_dplocns
5636                            // whenever a full part has been read from DPRAM
5637                            // Once the status has been obtained we can reset pkt_dplocns
5638       1/1                  else if (ahb_err_pktdiscarded_wait4end)
5639                            begin
5640       <font color = "red">0/1     ==>            if (status_word1_capt)</font>
5641       <font color = "red">0/1     ==>              pkt_dplocns  &lt;= 12'h000;</font>
5642       <font color = "red">0/1     ==>            else if (part_pkt_written &amp; (num_pkts_needing_read == {p_edma_rx_pbuf_addr{1'b0}}))</font>
5643       <font color = "red">0/1     ==>              pkt_dplocns  &lt;= pkt_dplocns_c1;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
5644                            end
5645                    
5646                            // Can clear down when we are done with it ...
5647                            //  - when we read the status, we should be done with this packet
5648                            //  - or an hresp error while not in cut-thru
5649                            //  - or when we are flushing the frame and ahb_err_pktdiscarded_wait4end is low
5650       1/1                  else if ((last_dpram_rd_state == P_STATUS_WORD_4 &amp; ~status_word_1[0]) |
5651                                      hresp_notok_eob | hresp_data_cutthru | flush_next_packet)
5652       <font color = "red">0/1     ==>            pkt_dplocns  &lt;= 12'h000;</font>
5653                    
5654                            // Else just increment when we read
5655       1/1                  else if (ahbreqph_strobe_data_nopad &amp; ~reading_eop_dpram_rph_del)
5656                            begin
5657       1/1                    if (reading_eop_dpram_rph)
5658       1/1                      pkt_dplocns  &lt;= 12'h000;
5659       1/1                    else if (empty_downsize &amp;&amp; dpram_rd_state != P_IDLE)
5660       1/1                        pkt_dplocns  &lt;= pkt_dplocns + 12'h001;
                   <font color = "red">==>  MISSING_ELSE</font>
5661                    
5662                            end
                        MISSING_ELSE
5663                    
5664                    
5665                    
5666                            // On an AHB error, bump 'part_dplocns' up to a part of pkt boundary.
5667       1/1                  if (ahb_err_discard_recover)
5668       <font color = "red">0/1     ==>            part_dplocns  &lt;= part_dplocns + part_dplocns_left</font>
5669                                              - {{p_edma_rx_pbuf_addr-1{1'b0}},1'b1};
5670                    
5671                            // ahb_err_pktdiscarded_wait4end indicates that we are just reading the remaining
5672                            // packet data from DPRAM but discarding it without forwarding to AHB
5673                            // Essentially we can just set part_dplocns to rx_cutthru_threshold and
5674                            // whenever a full part has been read from DPRAM, we can just recover it
5675                            // Once the status has been obtained, we are done with the frame and can
5676                            // reset part_dplocns
5677       1/1                  else if (ahb_err_pktdiscarded_wait4end)
5678                            begin
5679       <font color = "red">0/1     ==>            if (status_word_early_fetch_count &gt; 3'd0 || status_word1_capt ||</font>
5680                                  last_dpram_rd_state == P_STATUS_WORD_1 || last_dpram_rd_state == P_STATUS_WORD_2)
5681       <font color = "red">0/1     ==>              part_dplocns  &lt;= {p_edma_rx_pbuf_addr{1'b0}};</font>
5682       <font color = "red">0/1     ==>            else if (part_pkt_written)</font>
5683       <font color = "red">0/1     ==>              part_dplocns  &lt;= rx_cutthru_threshold;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
5684                            end
5685                    
5686                            // Can clear down when we are done with it ...
5687                            //  - when we read the status
5688                            //  - or an hresp error while not in cut-thru
5689                            //  - or when we are flushing the frame and ahb_err_pktdiscarded_wait4end is low
5690       1/1                  else if ((last_dpram_rd_state == P_STATUS_WORD_4 &amp; ~status_word_1[0]) |
5691                                     hresp_notok_eob | hresp_data_cutthru | flush_next_packet)
5692       <font color = "red">0/1     ==>            part_dplocns  &lt;= {p_edma_rx_pbuf_addr{1'b0}};</font>
5693                    
5694                            // Else just increment when we read
5695       1/1                  else if (ahbreqph_strobe_data_nopad &amp; ~reading_eop_dpram_rph_del)
5696                            begin
5697       1/1                    if (last_partpkt_rph | reading_eop_dpram_rph)
5698       1/1                      part_dplocns  &lt;= {p_edma_rx_pbuf_addr{1'b0}};
5699       1/1                    else if (empty_downsize &amp;&amp; dpram_rd_state != P_IDLE)
5700       1/1                      part_dplocns  &lt;= part_dplocns + {{p_edma_rx_pbuf_addr-1{1'b0}},1'b1};
                   <font color = "red">==>  MISSING_ELSE</font>
5701                            end
                        MISSING_ELSE
5702                    
5703                            // part_dplocns_left is similar to part_dplocns except that it is
5704                            // a decrementing counter. It is used to calculate the end
5705                            // of a burst when there are no more packet parts to fetch
5706                            // If hburst, then we will replay the full packet, but since we
5707                            // already have the status, we can just reload part_dplocns_left
5708       1/1                  if (hresp_notok_eob &amp; ~rx_cutthru &amp; dpram_rd_state == P_PKT_DATA)
5709       <font color = "red">0/1     ==>            part_dplocns_left  &lt;= status_word_1[14+p_edma_rx_pbuf_addr:15];</font>
5710                    
5711       1/1                  else if (hresp_data_cutthru | ahb_err_pktdiscarded_wait4end | flush_next_packet)
5712       <font color = "red">0/1     ==>            part_dplocns_left &lt;= {p_edma_rx_pbuf_addr{1'b0}};</font>
5713                    
5714       1/1                  else if (status_word1_capt &amp; ~status_word2_capt &amp; status_word_1[0])
5715       1/1                    part_dplocns_left  &lt;= tmp_recovery_bus[p_edma_rx_pbuf_addr-1:0] - {{p_edma_rx_pbuf_addr-1{1'b0}}, ahbreqph_strobe_data_nopad &amp; empty_downsize};
5716                    
5717       1/1                  else if (start_reading_at_risk) begin
5718       <font color = "red">0/1     ==>            if (part_pkt_written)</font>
5719       <font color = "red">0/1     ==>              part_dplocns_left  &lt;= part_dplocns_left_c1[p_edma_rx_pbuf_addr-1:0];</font>
5720                              else
5721       <font color = "red">0/1     ==>              part_dplocns_left  &lt;= part_dplocns_pending;</font>
5722                            end
5723       1/1                  else if (part_pkt_written &amp;&amp; !part_dplocns_pending_for_new_frame) begin
5724       <font color = "red">0/1     ==>            if (ahbreqph_strobe_data_nopad &amp; empty_downsize)</font>
5725       <font color = "red">0/1     ==>              part_dplocns_left  &lt;= part_dplocns_left_c2[p_edma_rx_pbuf_addr-1:0];</font>
5726                              else
5727       <font color = "red">0/1     ==>              part_dplocns_left  &lt;= part_dplocns_left_c3[p_edma_rx_pbuf_addr-1:0];</font>
5728                            end
5729                    
5730                            // Standard decrement when we perform an AHB write
5731       1/1                  else if (ahbreqph_strobe_data_nopad &amp; (empty_downsize|reading_eop_dpram_rph))
5732                              // Don't allow to decrement beyond 0
5733       1/1                    if (part_dplocns_left!={p_edma_rx_pbuf_addr{1'b0}})
5734       1/1                      part_dplocns_left  &lt;= part_dplocns_left - {{p_edma_rx_pbuf_addr-1{1'b0}},1'b1};
                   <font color = "red">==>  MISSING_ELSE</font>
                        MISSING_ELSE
5735                    
5736                            // ---------------------------------------------------------------------------------
5737                    
5738                            // Identify how many locations we can clear the PKTBUFFER ...
5739                            // If there was no data associated with the packet, then we should
5740                            // always clear 3 locations (= to the number of status words)
5741                            // If we have finished reading a part of a packet, then we can
5742                            // clear the number of locations = to the part size
5743                            // If we have finished reading the packet, then we can clear the
5744                            // remaining number of locations ...
5745       1/1                  if (~wait_for_pktdone_capt | pkt_done_capt_tog_edge)
5746                            begin
5747       1/1                    if (take_stored_value)
5748                              begin
5749       1/1                      pkt_done_tog          &lt;= ~pkt_done_tog;
5750       1/1                      wait_for_pktdone_capt &lt;= 1'b1;
5751       1/1                      pkt_done_dplocns      &lt;= pkt_dplocns_str;
5752                              end
5753                    
5754       1/1                    else if (flush_next_packet)
5755                              begin
5756       <font color = "red">0/1     ==>              pkt_done_tog          &lt;= ~pkt_done_tog;</font>
5757       <font color = "red">0/1     ==>              wait_for_pktdone_capt &lt;= 1'b1;</font>
5758       <font color = "red">0/1     ==>              pkt_done_dplocns      &lt;= status_word_1[p_edma_rx_pbuf_addr+14:15];</font>
5759                              end
5760                    
5761                              // 3 events cause us to want to recover some dpram storage
5762       1/1                    else if ((last_dpram_rd_state == P_STATUS_WORD_4)|
5763                                        last_partpkt_rph |
5764                                        reading_eop_dpram_rph)
5765                              begin
5766       1/1                      pkt_done_tog          &lt;= ~pkt_done_tog;
5767       1/1                      wait_for_pktdone_capt &lt;= 1'b1;
5768                    
5769                                // Clear 3 locations when the status is read
5770                                // If cut-thru mode is active, then we need to caluclate how many
5771                                // locations to clear.  This is actually quite complex, as we might
5772                                // have already cleared away a lot of the packet as we were writing
5773                                // it to AHB memory.  The total number of locations we need to clear
5774                                // is given to us in status_word_1, bits [26:15].  The number
5775                                // of locations we have already cleared is given by pkt_dplocns
5776                                // This will already be a direct multiple of cut-thru threshold, as
5777                                // the status is only read after the end of writing a full pkt fragment
5778                                // To calculate the remainder, we need to subtract ...
5779       1/1                      if (last_dpram_rd_state == P_STATUS_WORD_4)
5780       1/1                        pkt_done_dplocns   &lt;= pkt_done_dplocns_nxt;
5781                                // Clear rx_cutthru_threshold locations when the
5782                                // part_dplocns == rx_cutthru_threshold
5783                                // Clear remaining number of locations when eop is read ...
5784                                else // if (last_partpkt_rph | reading_eop_dpram_rph)
5785       <font color = "red">0/1     ==>                pkt_done_dplocns    &lt;= part_dplocns + {{p_edma_rx_pbuf_addr-1{1'b0}},1'd1};</font>
5786                              end
5787                    
5788                              else
5789       1/1                      wait_for_pktdone_capt &lt;= 1'b0;
5790                            end
                        MISSING_ELSE
5791                    
5792                            // Store up dpram locations to recover while the handshake logic
5793                            // is busy
5794       1/1                  if (wait_for_pktdone_capt)
5795                            begin
5796       1/1                    if (pkt_done_capt_tog_edge)
5797                              begin
5798       1/1                      if (flush_next_packet)
5799                                begin
5800       <font color = "red">0/1     ==>                take_stored_value  &lt;= 1'b1;</font>
5801       <font color = "red">0/1     ==>                pkt_dplocns_str    &lt;= status_word_1[p_edma_rx_pbuf_addr+14:15];</font>
5802                                end
5803                    
5804                                // Clear 3 locations when the status is read
5805       1/1                      else if (last_dpram_rd_state == P_STATUS_WORD_4 &amp; take_stored_value)
5806       <font color = "red">0/1     ==>                pkt_dplocns_str   &lt;= pkt_dplocns_to_flush_plus_st;</font>
5807                    
5808                                // Clear rx_cutthru_threshold locations when the
5809                                // part_dplocns == rx_cutthru_threshold
5810                                // Clear remaining number of locations when eop is read ...
5811       1/1                      else if ((last_partpkt_rph | reading_eop_dpram_rph) &amp; take_stored_value)
5812                                begin
5813       <font color = "red">0/1     ==>                pkt_dplocns_str   &lt;= part_dplocns + {{p_edma_rx_pbuf_addr-1{1'b0}},1'b1};</font>
5814                                end
5815                    
5816                                else
5817                                begin
5818       1/1                        take_stored_value &lt;= 1'b0;
5819       1/1                        pkt_dplocns_str   &lt;= {p_edma_rx_pbuf_addr{1'b0}};
5820                                end
5821                              end
5822                              else
5823                              begin
5824       1/1                      if (flush_next_packet)
5825                                begin
5826       <font color = "red">0/1     ==>                take_stored_value &lt;= 1'b1;</font>
5827       <font color = "red">0/1     ==>                pkt_dplocns_str   &lt;= pkt_dplocns_str_c1[p_edma_rx_pbuf_addr-1:0];</font>
5828                                end
5829                    
5830                                // Clear 3 locations when the status is read
5831       1/1                      else if (last_dpram_rd_state == P_STATUS_WORD_4)
5832                                begin
5833       <font color = "red">0/1     ==>                take_stored_value &lt;= 1'b1;</font>
5834       <font color = "red">0/1     ==>                pkt_dplocns_str   &lt;= pkt_dplocns_str_c2[p_edma_rx_pbuf_addr-1:0];</font>
5835                                end
5836                    
5837                                // Clear rx_cutthru_threshold locations when the
5838                                // part_dplocns == rx_cutthru_threshold
5839                                // Clear remaining number of locations when eop is read ...
5840       1/1                      else if ((last_partpkt_rph &amp; ~last_partpkt_rph_seen_at_error) | reading_eop_dpram_rph)
5841                                begin
5842       1/1                        take_stored_value &lt;= 1'b1;
5843       1/1                        pkt_dplocns_str   &lt;= pkt_dplocns_str_c3[p_edma_rx_pbuf_addr-1:0];
5844                                end
                        MISSING_ELSE
5845                              end
5846                            end
5847                    
5848                            else
5849                            begin
5850       1/1                    take_stored_value     &lt;= 1'b0;
5851       1/1                    pkt_dplocns_str       &lt;= {p_edma_rx_pbuf_addr{1'b0}};
5852                            end
5853                          end
5854                        end
5855                      end
5856                    
5857                    
5858                      parameter WAIT      = 1'b1;
5859                      parameter DONT_WAIT = 1'b0;
5860                    
5861                      // Interrupt generation
5862                      // Write the status updates to the upper layer, which will in turn
5863                      // create the interrupt based on the information we send ...
5864                      assign pclk_has_captured_stat = (rx_stat_capt_pulse &amp; wait_for_capt);
5865                      always@(posedge hclk or negedge n_hreset)
5866                      begin
5867       1/1              if (~n_hreset)
5868                        begin
5869       1/1                rx_dma_stable_tog   &lt;= 1'b0;
5870       1/1                wait_for_capt       &lt;= DONT_WAIT;
5871       1/1                rx_dma_buff_not_rdy &lt;= 1'b0;
5872       1/1                rx_dma_complete_ok  &lt;= 1'b0;
5873       1/1                rx_dma_hresp_notok  &lt;= 1'b0;
5874       1/1                rx_dma_resource_err &lt;= 1'b0;
5875       1/1                buff_not_rdy_str    &lt;= 1'b0;
5876       1/1                hresp_notok_str     &lt;= 1'b0;
5877       1/1                complete_ok_str     &lt;= 1'b0;
5878       1/1                rx_dma_int_queue    &lt;= 4'h0;
5879       1/1                rx_dma_int_q_str    &lt;= 4'h0;
5880                        end
5881                        else
5882                        begin
5883       1/1                if (~enable_rx_hclk)
5884                          begin
5885       1/1                  buff_not_rdy_str    &lt;= 1'b0;
5886       1/1                  hresp_notok_str     &lt;= 1'b0;
5887       1/1                  complete_ok_str     &lt;= 1'b0;
5888       1/1                  rx_dma_stable_tog   &lt;= 1'b0;
5889       1/1                  wait_for_capt       &lt;= DONT_WAIT;
5890       1/1                  rx_dma_buff_not_rdy &lt;= 1'b0;
5891       1/1                  rx_dma_hresp_notok  &lt;= 1'b0;
5892       1/1                  rx_dma_complete_ok  &lt;= 1'b0;
5893       1/1                  rx_dma_resource_err &lt;= 1'b0;
5894       1/1                  rx_dma_int_queue    &lt;= 4'h0;
5895       1/1                  rx_dma_int_q_str    &lt;= 4'h0;
5896                          end
5897                          else
5898                          begin
5899                            // Interrupt information has been captured by PCLK ?
5900       1/1                  if (wait_for_capt)
5901                            begin
5902       1/1                    if (pclk_has_captured_stat)
5903                              begin
5904       1/1                      buff_not_rdy_str &lt;= 1'b0;
5905       1/1                      hresp_notok_str &lt;= 1'b0;
5906       1/1                      complete_ok_str &lt;= 1'b0;
5907       1/1                      if (buff_not_rdy_str | hresp_notok_str | complete_ok_str)
5908                                begin
5909       <font color = "red">0/1     ==>                wait_for_capt &lt;= WAIT;</font>
5910       <font color = "red">0/1     ==>                rx_dma_stable_tog &lt;= ~rx_dma_stable_tog;</font>
5911       <font color = "red">0/1     ==>                rx_dma_buff_not_rdy &lt;= buff_not_rdy_str;</font>
5912       <font color = "red">0/1     ==>                rx_dma_resource_err &lt;= buff_not_rdy_str;</font>
5913       <font color = "red">0/1     ==>                rx_dma_hresp_notok  &lt;= hresp_notok_str;</font>
5914       <font color = "red">0/1     ==>                rx_dma_complete_ok  &lt;= complete_ok_str;</font>
5915       <font color = "red">0/1     ==>                rx_dma_int_queue    &lt;= rx_dma_int_q_str;</font>
5916                                end
5917                    
5918       1/1                      else if (int_source)
5919                                begin
5920       <font color = "red">0/1     ==>                wait_for_capt &lt;= WAIT;</font>
5921       <font color = "red">0/1     ==>                rx_dma_stable_tog &lt;= ~rx_dma_stable_tog;</font>
5922       <font color = "red">0/1     ==>                rx_dma_buff_not_rdy &lt;= rx_buffer_used_bit;</font>
5923       <font color = "red">0/1     ==>                rx_dma_resource_err &lt;= rx_buffer_used_bit;</font>
5924       <font color = "red">0/1     ==>                rx_dma_hresp_notok  &lt;= hresp_notok_eob;</font>
5925       <font color = "red">0/1     ==>                rx_dma_complete_ok  &lt;= (int_source_rx_comp &amp;</font>
5926                                                          ~rx_buffer_used_bit &amp;
5927                                                          ~hresp_notok_eob);
5928       <font color = "red">0/1     ==>                rx_dma_int_queue    &lt;= queue_ptr_rx_dph;</font>
5929                                end
5930                                else
5931                                begin
5932       1/1                        wait_for_capt &lt;= DONT_WAIT;
5933       1/1                        rx_dma_buff_not_rdy &lt;= 1'b0;
5934       1/1                        rx_dma_resource_err &lt;= 1'b0;
5935       1/1                        rx_dma_hresp_notok  &lt;= 1'b0;
5936       1/1                        rx_dma_complete_ok  &lt;= 1'b0;
5937                                end
5938                              end
5939                    
5940       1/1                    else if (int_source)
5941                              begin
5942       <font color = "red">0/1     ==>              buff_not_rdy_str &lt;= rx_buffer_used_bit;</font>
5943       <font color = "red">0/1     ==>              hresp_notok_str  &lt;= hresp_notok_eob;</font>
5944       <font color = "red">0/1     ==>              complete_ok_str  &lt;= (int_source_rx_comp &amp;</font>
5945                                                     ~rx_buffer_used_bit &amp;
5946                                                     ~hresp_notok_eob &amp;
5947                                                     ~rx_dma_buff_not_rdy &amp;
5948                                                     ~rx_dma_resource_err &amp;
5949                                                     ~rx_dma_hresp_notok);
5950       <font color = "red">0/1     ==>              rx_dma_int_q_str    &lt;= queue_ptr_rx_dph;</font>
5951                              end
                        MISSING_ELSE
5952                            end
5953                    
5954       1/1                  else if (int_source)
5955                            begin
5956       1/1                        wait_for_capt &lt;= WAIT;
5957       1/1                        rx_dma_stable_tog &lt;= ~rx_dma_stable_tog;
5958       1/1                        rx_dma_buff_not_rdy &lt;= rx_buffer_used_bit;
5959       1/1                        rx_dma_resource_err &lt;= rx_buffer_used_bit;
5960       1/1                        rx_dma_hresp_notok  &lt;= hresp_notok_eob;
5961       1/1                        rx_dma_complete_ok  &lt;= (int_source_rx_comp &amp;
5962                                                          ~hresp_notok_eob &amp; ~hresp_notok_hold);
5963       1/1                        rx_dma_int_queue    &lt;= queue_ptr_rx_dph;
5964                            end
                        MISSING_ELSE
5965                          end
5966                        end
5967                      end
5968                    
5969                    // Condition to generate interrupt
5970                    // Generate interrupt once the writeback for the packet has finished ...
5971                    // or when a buffer was requested but is not available
5972                    // or when there is an AHB error
5973                    // or when a non zero pause frame is received
5974                    assign int_source_rx_comp =  (rx_dma_state != RX_DMA_MAN_WR &amp;
5975                                                  last_rx_dma_state == RX_DMA_MAN_WR &amp; rx_eof_written &amp; hready);
5976                    
5977                    assign int_source = (int_source_rx_comp | rx_buffer_used_bit | hresp_notok_eob );
5978                    
5979                    assign from_rx_dma_used_bit_read  = p_edma_axi == 1 ? rx_buffer_used_bit : 1'b0;
5980                    assign from_rx_dma_queue_ptr      = p_edma_axi == 1 ? queue_ptr_rx_dph : 4'h0;
5981                    
5982                    // Gemstone Specific for Flow Control
5983                    
5984                      always@(posedge hclk or negedge n_hreset)
5985                      begin
5986       1/1              if (~n_hreset)
5987       1/1                allow_wr_q    &lt;= 1'b0;
5988       1/1              else if (ahbreqph_strobe_data)
5989       1/1                allow_wr_q    &lt;= 1'b1;
5990       1/1              else if (astrobe_manwr_1st)
5991       1/1                allow_wr_q    &lt;= 1'b0;
                        MISSING_ELSE
5992                      end
5993                    
5994                      generate for (g=0; g&lt;p_edma_queues; g=g+1) begin : gen_rx_databuf_wr_q
5995                        always@(posedge hclk or negedge n_hreset)
5996                        begin
5997       1/1                if (~n_hreset)
5998       1/1                  rx_databuf_wr_q[g] &lt;= 1'b0;
5999       1/1                else if (ahbreqph_strobe_data &amp; ~allow_wr_q &amp; queue_ptr_rx_rph == g[3:0])
6000       1/1                  rx_databuf_wr_q[g] &lt;= ~rx_databuf_wr_q[g];
                        MISSING_ELSE
6001                        end
6002                      end
6003                      endgenerate
6004                    
6005                      assign ahb_queue_ptr_rx = queue_ptr_rx_dph;
6006                    
6007                      assign write_to_base_descr = p_edma_rsc == 1 &amp;&amp; astrobe_manwr_last;
6008                    
6009                      ///////////////////////////////////////////
6010                      // ASF - data path parity protection
6011                      generate if(p_edma_asf_dap_prot == 1) begin:gen_edma_dp_par
6012                    
6013                        wire  [p_edma_queues-1:0] dap_err_nxt_descr_ptr;
6014                        wire                      dap_err_dpram_dob_offset_c;
6015                        wire                      dap_err_dma_data_c;
6016                        reg                       dap_err_dma_data_r;
6017                        wire                      dap_err_hwdata;
6018                        wire                      dap_err_haddr;
6019                        wire                      dap_err_status_words;
6020                        reg                       asf_dap_rx_rd_err_r;
6021                        wire                      dap_err_dma_data;
6022                        // Check various sources that are used for creating rx_dma_data_out and regenerate
6023                        // parity for it based on new data.
6024                        // This is based on the following:
6025                        //  rxdpram_dob_offset
6026                        //  rx_timestamp - this is already based on status_word_2/3/4 so already checked those
6027                        //  current_descriptor
6028                        //  status_word_1
6029                        gem_par_chk_regen #(
6030                          .p_chk_dwid(42+32+32),
6031                          .p_new_dwid(128)
6032                        ) i_regen_rx_dma_data_out_par (
6033                          .odd_par  (1'b0),
6034                          .chk_dat  ({rx_timestamp,
6035                                      status_word_1[31:0],
6036                                      current_descriptor[31:0]}),
6037                          .chk_par  ({rx_timestamp_par,
6038                                      status_word_1[35:32],
6039                                      current_descriptor[35:32]}),
6040                          .new_dat  (rx_dma_data_out),
6041                          .dat_out  (),
6042                          .par_out  (rx_dma_data_out_par),
6043                          .chk_err  (dap_err_dma_data_c)
6044                        );
6045                    
6046                        // The rxdpram_dob_offset check is separated out as this comes direct from the RAM
6047                        // and can be unclean. This doesn't matter as it is not used in those circumstances
6048                        // but we still want to separate out the checking as the regen module above performs
6049                        // feed forward poisoning so if the RAM data is not needed, the poisoning will still
6050                        // affect the other sources.
6051                        cdnsdru_asf_parity_check_v1 #(.p_data_width(128)) i_par_chk_dob_offset (
6052                          .odd_par(1'b0),
6053                          .data_in(rxdpram_dob_offset),
6054                          .parity_in(rxdpram_dob_par_offset),
6055                          .parity_err(dap_err_dpram_dob_offset_c)
6056                        );
6057                    
6058                        // Register the parity check result as this is looking at RAM data which may be changing
6059                        // so register to keep it clean.. also only care when use_data_imm is set which is the
6060                        // sample point...
6061                        always@(posedge hclk or negedge n_hreset)
6062                        begin
6063                          if (~n_hreset)
6064                            dap_err_dma_data_r  &lt;= 1'b0;
6065                          else
6066                            if (use_data_imm)
6067                              dap_err_dma_data_r  &lt;= dap_err_dma_data_c | (dap_err_dpram_dob_offset_c &amp; rx_dma_state_data);
6068                            else
6069                              dap_err_dma_data_r  &lt;= 1'b0;
6070                        end
6071                        assign dap_err_dma_data = dap_err_dma_data_r;
6072                    
6073                    
6074                        // nxt_descr_ptr is present for each queue
6075                        genvar loop_q;
6076                        for (loop_q=0;loop_q&lt;p_edma_queues;loop_q=loop_q+1) begin : gen_chk_nxt_descr_ptr
6077                          cdnsdru_asf_parity_check_v1 #(.p_data_width(32)) i_par_chk (
6078                            .odd_par(1'b0),
6079                            .data_in(nxt_descr_ptr_pad[loop_q][31:0]),
6080                            .parity_in(nxt_descr_ptr_pad[loop_q][35:32]),
6081                            .parity_err(dap_err_nxt_descr_ptr[loop_q])
6082                          );
6083                        end
6084                    
6085                        // haddr is 64-bits
6086                        cdnsdru_asf_parity_check_v1 #(.p_data_width(64)) i_par_chk_haddr (
6087                          .odd_par(1'b0),
6088                          .data_in(haddr[63:0]),
6089                          .parity_in(haddr_par[7:0]),
6090                          .parity_err(dap_err_haddr)
6091                        );
6092                    
6093                        // Check the status words
6094                        cdnsdru_asf_parity_check_v1 #(.p_data_width(128)) i_par_chk_status_words (
6095                          .odd_par(1'b0),
6096                          .data_in({status_word_4[31:0],
6097                                    status_word_3[31:0],
6098                                    status_word_2[31:0],
6099                                    status_word_1[31:0]}),
6100                          .parity_in({status_word_4[35:32],
6101                                      status_word_3[35:32],
6102                                      status_word_2[35:32],
6103                                      status_word_1[35:32]}),
6104                          .parity_err(dap_err_status_words)
6105                        );
6106                    
6107                        //////////////
6108                        // Parity check at the hwdata
6109                        // Module output and is in fact the overall
6110                        // data output for the entire GEM when the DMA is included.
6111                        cdnsdru_asf_parity_check_v1 #(.p_data_width(128)) i_par_chk_hwdata (
6112                          .odd_par(1'b0),
6113                          .data_in(hwdata[127:0]),
6114                          .parity_in(hwdata_par[15:0]),
6115                          .parity_err(dap_err_hwdata)
6116                        );
6117                    
6118                        // Register the output
6119                        always@(posedge hclk or negedge n_hreset)
6120                        begin
6121                          if (~n_hreset)
6122                            asf_dap_rx_rd_err_r &lt;= 1'b0;
6123                          else
6124                            asf_dap_rx_rd_err_r &lt;= dap_err_hwdata |
6125                                                    dap_err_haddr |
6126                                                    dap_err_dma_data |
6127                                                    (|dap_err_nxt_descr_ptr) |
6128                                                    dap_err_status_words |
6129                                                    dap_err_addr_or_mask;
6130                        end
6131                        assign asf_dap_rx_rd_err  = asf_dap_rx_rd_err_r;
6132                      end // gen_edma_dp_par
6133                      else begin : gen_no_dp_parity
6134                        assign rx_dma_data_out_par     = 16'd0;
6135                        assign asf_dap_rx_rd_err       = 1'b0;
6136                      end
6137                      endgenerate
6138                    
6139                    
6140                      //------------------------------------------------------------------------------
6141                      // RX PER-QUEUE RX FLUSH : Per-queue DPSRAM Buffer Fill Level Detection (Mode2)
6142                      //------------------------------------------------------------------------------
6143                      reg [p_edma_rx_pbuf_addr-1:0] num_locns_to_free;
6144                      reg                     [2:0] num_status_words;
6145                      wire                          dpram_push;
6146                      wire                          dpram_pop;
6147                    
6148                      always @ *
6149                      begin
6150       1/1              if(gem_rx_pbuf_data_w_is_128)
6151       <font color = "red">0/1     ==>        num_status_words = 3'd1;</font>
6152                        else
6153                          begin
6154       1/1                  if(dma_bus_width[0]) // 64 bits
6155       <font color = "red">0/1     ==>            num_status_words = 3'd2;</font>
6156                            else
6157                              begin // 32 bits
6158       1/1                      if(~rx_bd_extended_mode_en)
6159       1/1                        num_status_words = 3'd3;
6160                                else
6161       1/1                        num_status_words = 3'd4;
6162                              end
6163                    
6164                          end
6165                      end
6166                    
6167                      always @ (*)
6168                      begin
6169       1/1              if(flush_next_packet)
6170       <font color = "red">0/1     ==>        num_locns_to_free = status_word_1[p_edma_rx_pbuf_addr+14:15];</font>
6171       1/1              else if(last_dpram_rd_state == P_STATUS_WORD_4)
6172       1/1                num_locns_to_free = pkt_done_dplocns_nxt;
6173                        else //if (last_partpkt_rph | reading_eop_dpram_rph)
6174       1/1                num_locns_to_free = part_dplocns + {{p_edma_rx_pbuf_addr-1{1'b0}},1'd1};
6175                      end
6176                    
6177                      assign dpram_pop    = flush_next_packet || (last_dpram_rd_state == P_STATUS_WORD_4) || last_partpkt_rph || reading_eop_dpram_rph;
6178                      assign dpram_push   = (dpram_rd_state == P_STATUS_WORD_4);
6179                    
6180                      genvar s;
6181                      generate for (s=0; s&lt;p_edma_queues; s=s+1) begin: gen_fill_lvl_q
6182                        wire                          dpram_push_q;
6183                        wire                          dpram_pop_q;
6184                        wire                   [16:0] fill_lvl_q_incr;
6185                        wire                   [16:0] fill_lvl_q_decr;
6186                        wire                   [15:0] max_val_pclk_q;
6187                        reg [p_edma_rx_pbuf_addr-1:0] fill_lvl_q;
6188                        reg [p_edma_rx_pbuf_addr-1:0] fill_lvl_128_q;
6189                    
6190                        assign dpram_push_q    = dpram_push &amp; ({{28{1'b0}},queue_ptr_rx_rph} == s);
6191                        assign dpram_pop_q     = dpram_pop  &amp; ({{28{1'b0}},queue_ptr_rx_rph} == s);
6192                        assign fill_lvl_q_incr = {17{dpram_push_q}} &amp; (pkt_length_corrected + {14'd0,num_status_words});
6193                        assign fill_lvl_q_decr = {17{dpram_pop_q}}  &amp; {{(17-p_edma_rx_pbuf_addr){1'b0}},num_locns_to_free};
6194                        assign max_val_pclk_q  = (max_val_pclk[(15+(16*s)):(16*s)]);
6195                    
6196                        always @ (posedge hclk or negedge n_hreset)
6197                        begin
6198       1/1                if(~n_hreset)
6199       1/1                  fill_lvl_q &lt;= {p_edma_rx_pbuf_addr{1'b0}};
6200                          else
6201                            begin
6202       1/1                    if (~enable_rx_hclk)
6203       1/1                      fill_lvl_q &lt;= {p_edma_rx_pbuf_addr{1'b0}};
6204                              else
6205       1/1                      fill_lvl_q &lt;= fill_lvl_q + fill_lvl_q_incr[p_edma_rx_pbuf_addr-1:0] - fill_lvl_q_decr[p_edma_rx_pbuf_addr-1:0];
6206                            end
6207                        end
6208                    
6209                        // In this section we will just create a signal which counts the
6210                        // 128 bytes chunks from fill_lvl_q, which counts words.
6211                        // This is made accordingly to the IP configuration
6212                        always @ *
6213                        begin
6214       1/1                if(gem_rx_pbuf_data_w_is_128)
6215                            // 128 bits: we need to divide by 8
6216       <font color = "red">0/1     ==>          fill_lvl_128_q = {3'd0,fill_lvl_q[p_edma_rx_pbuf_addr-1:3]};</font>
6217       1/1                else if(dma_bus_width[0])
6218                            // 64 bits: we need to divide by 16
6219       <font color = "red">0/1     ==>          fill_lvl_128_q = {4'd0,fill_lvl_q[p_edma_rx_pbuf_addr-1:4]};</font>
6220                          else
6221                            // 32 bits: we need to divide by 32
6222       1/1                  fill_lvl_128_q = {5'd0,fill_lvl_q[p_edma_rx_pbuf_addr-1:5]};
6223                        end
6224                    
6225                        // We are dealing with a static watermark event
6226                        // that will be high when the fill level is &gt; the static level and low otherwise.
6227                        // The static nature means it can be safely passed across a domain regardless of clock frequency,
6228                        // hence there is no need for handshaking in this case.
6229                        // This signal will be registered before passing it to the rx_clk domain
6230                        // so there will be no logic before the Synchronizers. This will improve
6231                        // the MTBF.
6232                        always @ (posedge hclk or negedge n_hreset)
6233                        begin
6234       1/1                if(~n_hreset)
6235       1/1                  fill_lvl_breached[s] &lt;= 1'b0;
6236                          else
6237       1/1                  fill_lvl_breached[s] &lt;= ((fill_lvl_128_q &gt; max_val_pclk_q[p_edma_rx_pbuf_addr-1:0]) &amp;&amp; limit_num_bytes_allowed_ambaclk[s]);
</pre>
</div>
<div class="ui-layout-south">
<table align=center><tr><td class="s0 cl">0%</td>
<td class="s1 cl">10%</td>
<td class="s2 cl">20%</td>
<td class="s3 cl">30%</td>
<td class="s4 cl">40%</td>
<td class="s5 cl">50%</td>
<td class="s6 cl">60%</td>
<td class="s7 cl">70%</td>
<td class="s8 cl">80%</td>
<td class="s9 cl">90%</td>
<td class="s10 cl">100%</td></tr></table></div>
</body>
</html>
