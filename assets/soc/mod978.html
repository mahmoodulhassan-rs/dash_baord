<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="Author" content="<username>"> <meta name="GENERATOR" content="urg/version [en] (platform name) [urg]">
<title>Unified Coverage Report :: Module :: edma_pbuf_axi_tx_rd</title>
<link type="text/css" rel="stylesheet" href="css/.urg.css">
<link type="text/css" rel="stylesheet" href="css/.layout.css">
<link type="text/css" rel="stylesheet" href="css/.breadcrumb.css">
<script type="text/javascript" src="js/.jquery.js"></script>
<script type="text/javascript" src="js/.jquery-ui.js"></script>
<script type="text/javascript" src="js/.sortable.js"></script>
<script type="text/javascript" src="js/.layout.js"></script>
<script type="text/javascript" src="js/.breadcrumb.js"></script>
<script type="text/javascript">
var layout, westLayout, centerLayout;
$(document).ready(function () {
  if ($("#north-bread-crumb")) {
    $("#north-bread-crumb").jBreadCrumb({easing:'swing'})
  }
  layout = $("body").layout({ 
    resizable: true,
    spacing_open: 4,
    spacing_closed: 4,
    north: {
      size: 76
    },
    south: {
      size: 45,
      initClosed: true
    },
    west: {
      size: 500,
      resizable: true,
      initClosed: false
    }
  });
  centerLayout = $('div.ui-layout-center').layout({
    north__paneSelector: ".ui-layout-center-inner-north",
    center__paneSelector: ".ui-layout-center-inner-center", 
    north__size: 50,
    spacing_open: 4,
    spacing_closed: 4
  });
});
</script>
</head>
<body onLoad="initPage();"><div class="ui-layout-north">
<div class="logo"></div>
<center class="pagetitle">Module Definition</center>
<div align="center"><a href="dashboard.html" ><b>dashboard</b></a> | <a href="hierarchy.html" ><b>hierarchy</b></a> | <a href="modlist.html" ><b>modlist</b></a> | groups | <a href="tests.html" ><b>tests</b></a> | <a href="asserts.html" ><b>asserts</b></a></div>

</div>
<div class="ui-layout-west">
<div name='tag_edma_pbuf_axi_tx_rd'>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module : <a href="#"  onclick="showContent('tag_edma_pbuf_axi_tx_rd')">edma_pbuf_axi_tx_rd</a></span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="s4 cl rt"> 48.76</td>
<td class="s8 cl rt"><a href="mod978.html#Line" > 83.28</a></td>
<td class="s4 cl rt"><a href="mod978.html#Cond" > 45.14</a></td>
<td class="s1 cl rt"><a href="mod978.html#Toggle" > 14.62</a></td>
<td class="s3 cl rt"><a href="mod978.html#FSM" > 35.71</a></td>
<td class="s6 cl rt"><a href="mod978.html#Branch" > 65.04</a></td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<span class=repname>Source File(s) : </span>
<br clear=all>
<a href="javascript:void(0);"  onclick="openSrcFile('/nfs_project/gemini/DV/nadeem/dv/night_reg/gemini/design/ip/GbE/hdl/edma_pbuf_axi_tx_rd.v')">/nfs_project/gemini/DV/nadeem/dv/night_reg/gemini/design/ip/GbE/hdl/edma_pbuf_axi_tx_rd.v</a><br clear=all>
<br clear=all>
<span class=repname>Module self-instances :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td>BRANCH</td><td>ASSERT</td></tr><tr>
<td class="wht cl wordwrap"><a href="mod978.html#inst_tag_124761"  onclick="showContent('inst_tag_124761')">config_ss_tb.DUT.config_ss.gbe_u.gem_top_u.i_gem_ss.i_gem_top.gen_dma.gen_pbuf_axi_dma.i_edma_pbuf_axi_top.i_edma_pbuf_axi_tx.i_edma_pbuf_axi_tx_rd<img src="fx.gif" class="icon"></a></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
<td class="wht cl rt"></td>
</tr></table></div>
</div>
<br clear=all>
</div>
<div class="ui-layout-center">
<div class="ui-layout-center-inner-center">
<div name='tag_edma_pbuf_axi_tx_rd'>
<a name="Line"></a>
Line Coverage for Module : <a href="mod978.html" >edma_pbuf_axi_tx_rd</a><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s8"><td class="lf">TOTAL</td><td></td><td>610</td><td>508</td><td>83.28</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>462</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s8"><td class="lf">ALWAYS</td><td>468</td><td>6</td><td>5</td><td>83.33</td></tr>
<tr class="s7"><td class="lf">ALWAYS</td><td>477</td><td>7</td><td>5</td><td>71.43</td></tr>
<tr class="s7"><td class="lf">ALWAYS</td><td>511</td><td>12</td><td>9</td><td>75.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>568</td><td>8</td><td>8</td><td>100.00</td></tr>
<tr class="s2"><td class="lf">ALWAYS</td><td>590</td><td>7</td><td>2</td><td>28.57</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>661</td><td>1</td><td>1</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>672</td><td>5</td><td>5</td><td>100.00</td></tr>
<tr class="s8"><td class="lf">ALWAYS</td><td>741</td><td>47</td><td>38</td><td>80.85</td></tr>
<tr class="s6"><td class="lf">ALWAYS</td><td>851</td><td>5</td><td>3</td><td>60.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>878</td><td>4</td><td>4</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>889</td><td>14</td><td>14</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>920</td><td>6</td><td>6</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>935</td><td>8</td><td>8</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>954</td><td>11</td><td>11</td><td>100.00</td></tr>
<tr class="s3"><td class="lf">ALWAYS</td><td>993</td><td>17</td><td>6</td><td>35.29</td></tr>
<tr class="s5"><td class="lf">ALWAYS</td><td>1057</td><td>8</td><td>4</td><td>50.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1080</td><td>12</td><td>12</td><td>100.00</td></tr>
<tr class="s7"><td class="lf">ALWAYS</td><td>1117</td><td>49</td><td>37</td><td>75.51</td></tr>
<tr class="s7"><td class="lf">ALWAYS</td><td>1212</td><td>53</td><td>42</td><td>79.25</td></tr>
<tr class="s8"><td class="lf">ALWAYS</td><td>1349</td><td>12</td><td>10</td><td>83.33</td></tr>
<tr class="s6"><td class="lf">ALWAYS</td><td>1414</td><td>3</td><td>2</td><td>66.67</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1523</td><td>2</td><td>2</td><td>100.00</td></tr>
<tr class="s7"><td class="lf">ALWAYS</td><td>1553</td><td>9</td><td>7</td><td>77.78</td></tr>
<tr class="s4"><td class="lf">ALWAYS</td><td>1571</td><td>37</td><td>18</td><td>48.65</td></tr>
<tr class="s9"><td class="lf">ALWAYS</td><td>1642</td><td>48</td><td>47</td><td>97.92</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1717</td><td>12</td><td>12</td><td>100.00</td></tr>
<tr class="s9"><td class="lf">ALWAYS</td><td>1784</td><td>19</td><td>18</td><td>94.74</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1816</td><td>11</td><td>11</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1848</td><td>9</td><td>9</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1880</td><td>8</td><td>8</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1906</td><td>4</td><td>4</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1919</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s6"><td class="lf">ALWAYS</td><td>1963</td><td>5</td><td>3</td><td>60.00</td></tr>
<tr class="s7"><td class="lf">ALWAYS</td><td>2009</td><td>20</td><td>14</td><td>70.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>2052</td><td>9</td><td>9</td><td>100.00</td></tr>
<tr class="s6"><td class="lf">ALWAYS</td><td>2121</td><td>14</td><td>9</td><td>64.29</td></tr>
<tr class="s7"><td class="lf">ROUTINE</td><td>2173</td><td>12</td><td>9</td><td>75.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>2356</td><td>6</td><td>6</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>2356</td><td>6</td><td>6</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>2356</td><td>6</td><td>6</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>2356</td><td>6</td><td>6</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>2356</td><td>6</td><td>6</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>2356</td><td>6</td><td>6</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>2356</td><td>6</td><td>6</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>2356</td><td>6</td><td>6</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>2356</td><td>6</td><td>6</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>2356</td><td>6</td><td>6</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>2356</td><td>6</td><td>6</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>2356</td><td>6</td><td>6</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>2356</td><td>6</td><td>6</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>2356</td><td>6</td><td>6</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>2356</td><td>6</td><td>6</td><td>100.00</td></tr>
</table>
<pre class="code"><br clear=all>
461                         always@(posedge tx_r_clk or negedge tx_r_rst_n)
462        1/1                if (~tx_r_rst_n)
463        1/1                  start_reading_at_risk_q[g] &lt;= 1'b0;
464                           else
465        1/1                  start_reading_at_risk_q[g] &lt;= start_reading_at_risk_q_nxt[g];
466                     
467                         always@(posedge tx_r_clk or negedge tx_r_rst_n)
468        1/1                if (~tx_r_rst_n)
469        1/1                  cutthru_pending_q &lt;= 1'b0;
470        1/1                else if (end_of_packet_edge[g])
471        1/1                  cutthru_pending_q &lt;= 1'b0;
472        1/1                else if (part_of_packet_edge[g] &amp;&amp; (read_state != IDLE || num_pkts_needing_read[g] != 8'd0))
473        <font color = "red">0/1     ==>          cutthru_pending_q &lt;= 1'b1;</font>
                        MISSING_ELSE
474                     
475                         always@(*) begin
476                     
477        1/1                start_reading_at_risk_q_nxt[g] = start_reading_at_risk_q[g];
478                     
479        1/1                if (complete_flush)
480        1/1                  start_reading_at_risk_q_nxt[g] = 1'b0;
481                           else
482                             // Parts of pkts are more straight forward
483                             // We only care about full duplex, so restarts are irrelevant here
484                             // Also transfers from the AHB side that contain no data (errored transfers)
485                             // also are irrelevant as they are only indicated through pkt_written
486                             // start_reading_at_risk_q_nxt gets set if part_of_packet_edge goes high
487        1/1                  if (start_reading_at_risk_q[g] &amp;
488                                   ((queue_dma == g[3:0] &amp; status_word3_obtained) | tx_r_underflow ))
489        <font color = "red">0/1     ==>            start_reading_at_risk_q_nxt[g] = 1'b0;</font>
490                     
491        1/1                  else if ((part_of_packet_edge[g]||cutthru_pending_q) &amp;&amp; read_state == IDLE &amp;&amp; !(|num_pkts_needing_read[g]))
492        <font color = "red">0/1     ==>            start_reading_at_risk_q_nxt[g] = 1'b1;</font>
                        MISSING_ELSE
493                         end
494                       end
495                       endgenerate
496                     
497                       // If we have cut-thru operation then monitor for the write side pushing data
498                       // to the status word FIFO. For cut-thru operation, we dont rely on obtaining
499                       // the status words from the SRAM as they could easily be overwritten by newer
500                       // frames.  Instead, we have a dedicated status xfer bus implemented in flops.
501                       // If data is there then compare the status word
502                       // with the current frame start address. If there is a match then flag a
503                       // match and pop the FIFO once the status words have been read.
504                     generate if (p_edma_pbuf_cutthru == 1) begin : gen_cutthru_logic
505                       reg cutthru_status_word_pop_r;
506                       reg cutthru_status_word_valid_r;
507                       //reg cutthru_status_word_err_r;
508                     
509                       always@(posedge tx_r_clk or negedge tx_r_rst_n)
510                       begin
511        1/1              if (~tx_r_rst_n)
512                         begin
513        1/1                cutthru_status_word_pop_r     &lt;= 1'b0;
514        1/1                cutthru_status_word_valid_r   &lt;= 1'b0;
515                         end
516                         else
517                         begin
518        1/1                if (complete_flush)
519                           begin
520        1/1                  cutthru_status_word_pop_r     &lt;= 1'b0;
521        1/1                  cutthru_status_word_valid_r   &lt;= 1'b0;
522                           end
523                           // When the SW0 has been sampled, we can always pop this FIFO as it means the this block has already captured the SW from
524                           // the cutthru buffer, or it wasnt needed at all. Also dont need it in IDLE state, as that would mean we can just get the
525                           // SW from SRAM
526        1/1                else if (!cutthru_status_word_empty &amp;&amp; (sample_sw0 || read_state == IDLE))
527                           begin
528        <font color = "red">0/1     ==>          cutthru_status_word_pop_r   &lt;= 1'b1;</font>
529        <font color = "red">0/1     ==>          cutthru_status_word_valid_r &lt;= 1'b0;</font>
530                           end
531                           else
532                           begin
533        1/1                  cutthru_status_word_pop_r   &lt;= 1'b0;
534                             // Only need to use the cutthru buffer if we have already said we would via start_reading_at risk
535                             // there cant be any full frames buffered for this to work ..
536        1/1                  if (start_reading_at_risk_q_nxt[queue_dma])
537                             begin
538                               // Determine if the status words in the cutthru status word FIFO match the current frame.
539        <font color = "red">0/1     ==>            cutthru_status_word_valid_r &lt;= !cutthru_status_word_empty &amp;&amp; !cutthru_status_word_pop_r &amp;&amp;</font>
540                                                               cutthru_status_word[p_edma_tx_pbuf_addr-1+128:128] == status_word0_nxt_add[queue_dma];
541                             end
                        MISSING_ELSE
542                           end
543                         end
544                       end
545                     
546                       assign cutthru_status_word_pop   = cutthru_status_word_pop_r;
547                       assign cutthru_status_word_valid = cutthru_status_word_valid_r;
548                     
549                     end else begin : gen_no_cutthru_logic
550                       assign cutthru_status_word_pop   = 1'b0;
551                       assign cutthru_status_word_valid = 1'b0;
552                     end
553                     endgenerate
554                     
555                     
556                     
557                       generate if (p_edma_tsu == 1) begin : gen_ts_to_be_written
558                     
559                         // Register tx timestamp
560                         // indicate ts is to be written to BD based on decoded frame type
561                         // and tx_bd_ts_mode
562                         // This isnt really used in this module, but the timestamp needs to be passed back to the
563                         // AXI/AHB side of the DMA for inclusion in the descriptor writeback.
564                         reg                             event_frame_tx_d1;
565                         reg                             general_frame_tx_d1;
566                         always@(posedge tx_r_clk or negedge tx_r_rst_n)
567                         begin
568        1/1                if (~tx_r_rst_n)
569                             begin
570        1/1                  event_frame_tx_d1   &lt;= 1'b0;
571        1/1                  general_frame_tx_d1 &lt;= 1'b0;
572                             end
573                           else
574                           begin
575        1/1                  if (complete_flush)
576                             begin
577        1/1                    event_frame_tx_d1   &lt;= 1'b0;
578        1/1                    general_frame_tx_d1 &lt;= 1'b0;
579                             end
580                             else
581                             begin
582        1/1                    event_frame_tx_d1   &lt;=  event_frame_tx;
583        1/1                    general_frame_tx_d1 &lt;=  general_frame_tx;
584                             end
585                           end
586                         end
587                     
588                         always@(*)
589                         begin
590        1/1                casex ({tx_bd_ts_mode, general_frame_tx_d1, event_frame_tx_d1})
591                             4'b00xx:  // no frames
592        1/1                           ts_to_be_written = 1'b0;
593                             4'b0101:  // event frames only
594        <font color = "red">0/1     ==>                   ts_to_be_written = 1'b1;</font>
595                             4'b1010:  // general frames (ie all ptp frames)
596        <font color = "red">0/1     ==>                   ts_to_be_written = 1'b1;</font>
597                             4'b1001:  // event frames (ie all ptp frames)
598        <font color = "red">0/1     ==>                   ts_to_be_written = 1'b1;</font>
599                             4'b11xx:  // all frames
600        <font color = "red">0/1     ==>                   ts_to_be_written = 1'b1;</font>
601        <font color = "red">0/1     ==>          default: ts_to_be_written = 1'b0;</font>
602                           endcase
603                         end
604                       end else begin : gen_no_ts_to_be_written
605                         wire zero;
606                         assign zero = 1'b0;
607                         always @(*)
608                           ts_to_be_written = zero;
609                       end
610                       endgenerate
611                     
612                     
613                     
614                       // ---------------------------------------------------------------------------
615                       // Sample various signals from the tx_wr domain (new frame, part of frame
616                       // toggle, xfer status captured, etc) from the tx_wr side and
617                       // also signal back to the tx_wr side that the frame has been captured.
618                       // Signal internally if a new frame has been written
619                       //
620                       // Synchronize the part of frame and end of frame toggles
621                       cdnsdru_datasync_v1 i_cdnsdru_datasync_v11 (.clk(tx_r_clk), .reset_n(tx_r_rst_n), .din(xfer_status_captured), .dout(xfer_status_captured_sync));
622                       cdnsdru_datasync_v1 #(.CDNSDRU_DATASYNC_DIN_W(p_edma_queues)) i_cdnsdru_datasync_v13 (.clk(tx_r_clk), .reset_n(tx_r_rst_n), .din(part_of_packet_tog), .dout(part_of_packet_tog_sync));
623                       cdnsdru_datasync_v1 #(.CDNSDRU_DATASYNC_DIN_W(p_edma_queues)) i_cdnsdru_datasync_v14 (.clk(tx_r_clk), .reset_n(tx_r_rst_n), .din(dpram_almost_empty[p_edma_queues-1:0]), .dout(dpram_almost_empty_sync[p_edma_queues-1:0]));
624                       cdnsdru_datasync_v1 #(.CDNSDRU_DATASYNC_DIN_W(p_edma_queues)) i_cdnsdru_datasync_v15 (.clk(tx_r_clk), .reset_n(tx_r_rst_n), .din(end_of_packet_tog), .dout(end_of_packet_tog_sync));
625                     
626                       // Detect an edge on the incoming frame and end of frame toggles
627                       edma_toggle_detect i_edma_toggle_detect1 (.clk(tx_r_clk),  .reset_n(tx_r_rst_n), .din(xfer_status_captured_sync),.rise_edge(),.fall_edge(),.any_edge(xfer_status_captured_edge));
628                       edma_toggle_detect #(.DIN_W(p_edma_queues)) i_edma_toggle_detect2 (.clk(tx_r_clk),  .reset_n(tx_r_rst_n), .din(part_of_packet_tog_sync),.rise_edge(),.fall_edge(),.any_edge(part_of_packet_edge));
629                       edma_toggle_detect #(.DIN_W(p_edma_queues)) i_edma_toggle_detect3 (.clk(tx_r_clk),  .reset_n(tx_r_rst_n), .din(end_of_packet_tog_sync),.rise_edge(),.fall_edge(),.any_edge(end_of_packet_edge));
630                     
631                       // Signal back to the tx_wr side that the incoming toggles have
632                       // been recognised
633                       edma_toggle_generate #(
634                         .DIN_W(p_edma_queues)
635                       ) i_edma_toggle_generate_pkt_captured (
636                         .clk(tx_r_clk),
637                         .reset_n(tx_r_rst_n),
638                         .din(part_of_packet_edge | end_of_packet_edge),
639                         .dout(pkt_captured));
640                     
641                     
642                       // pkt_written is the signal we use to know a packet has been written to the DPRAM and is fully synchronous
643                       // to tx_r_clk
644                       assign pkt_written  = end_of_packet_edge &amp;
645                                             pkt_end_new &amp;
646                                             {p_edma_queues{~(end_of_packet_edge[0] &amp; pkt_end_flush)}};
647                     
648                     
649                       // ---------------------------------------------------------------------------
650                       // Monitor the number of packets needing read. num_pkts_needing_read
651                       // counter is incremented when we identify a full new frame is available in the SRAM
652                       // for fetching.  decremented when a frame is sent to the MAC
653                       //
654                       genvar i;
655                       generate for (i=0; i&lt;p_edma_queues[31:0]; i=i+1) begin : gen_num_pkt_counters
656                         wire [3:0] num_pkts_xfer_safe;
657                         assign num_pkts_xfer_safe = (num_pkts_xfer[((i+1)*4)-1:i*4] &amp; {4{end_of_packet_edge[i]}}) &amp; {4{pkt_written[i]}} ;
658                         reg  [8:0] num_pkts_needing_read_loc; // Number of pkts in buffer still needing read
659                         always@(*)
660                         begin
661                           begin
662                             //  num_pkts_needing_read counts the number of packets in the pkbuffer
663                             // It is decremented as soon as we commit to a frame ...
664        1/1                  num_pkts_needing_read_loc =  num_pkts_needing_read[i] + num_pkts_xfer_safe[3:0];
665                     
666                           end
667                         end
668                         assign num_pkts_needing_read_nxt[i] =  num_pkts_needing_read_loc[7:0];
669                     
670                         always@(posedge tx_r_clk or negedge tx_r_rst_n)
671                         begin
672        1/1                if (~tx_r_rst_n)
673                           begin
674        1/1                  num_pkts_needing_read[i] &lt;= 8'h00;
675                           end
676        1/1                else if (complete_flush)
677                           begin
678        1/1                  num_pkts_needing_read[i] &lt;= 8'h00;
679                           end
680                           else
681                           begin
682        1/1                  num_pkts_needing_read[i] &lt;= num_pkts_needing_read_nxt[i] -
683                                                             (sample_sw0 &amp; (i == {{28{1'b0}},queue_dma_c}) &amp; !(|store_mac_sw0_en));
684                           end
685                         end
686                       end
687                       for (i=p_edma_queues; i&lt;16; i=i+1) begin : gen_num_pkt_counters_pad
688                         assign num_pkts_needing_read_nxt[i] =  8'h00;
689                       end
690                       endgenerate
691                     
692                     
693                     // Now for the main state machines that reads from the SRAM.
694                     // Packets are stored in the SRAM in regions, one region per queue.
695                     // The packets themselves are sandwiched between status words holding
696                     // key information.  There are 4 32-bit status words required, named
697                     // status_word0, status_word1, status_word2 and status_word3.  Of these, status_word0
698                     // is critical and contains all the really important information needed to
699                     // understand pkt length etc.  status_word1 is only relevant if we have extended bd enabled and
700                     // have enabled launch times.
701                     // We will therefore do a pre-fetch of status_word0
702                     // before we do any transmissions and try to maintain an early understanding of
703                     // what is at the head of each queue.
704                     // The information in status_word0 is actually ...
705                     // Bits 11:0        = pkt length in SRAM words ...
706                     // Bits 15:12       = number of bytes valid in the last word ...
707                     // Bits 23:16       = Add this to status_word_wr_0[11:0] to get the end address
708                     // Bits 26:24       = reserved
709                     // Bits 27          = pass through of bit 16 of the descriptor for this frame
710                     // Bits 31:28       = The error status bits - if bit 31 is set, this frame contains no data
711                     
712                     // In 32bit mode, the structure of the full frame is
713                     // status_word0 -&gt; status_word1 (extended bd mode only) -&gt; packet data -&gt; status_word2 -&gt; status_word3
714                     
715                     // In 64bit mode, the structure of the full frame is
716                     // status_word01 -&gt; packet data -&gt; status_word23
717                     
718                     // In 128bit mode, the structure of the full frame is
719                     // status_word0123 -&gt; packet data -&gt; status_word0123 (repeated)
720                     
721                     // perform a sweep of the status word0 and 1 and store in an bank of 32bit flops.
722                     // This sweep is done to obtain an early understanding of whats in each queue.
723                     // One bank per queue
724                     // need_sw0_nxt_req is set when we dont have the status_word0 information
725                     // when this is set, the SRAM arbiter will attempt to fetch the information
726                     // from SRAM as soon as there are packets available. One bit for each queue
727                     // got_sw0_nxt is set when we have the status_word0 info stored. this is an
728                     // indiation that we can pass this queue as a valid candidate for scheduling.
729                     // status_word0_nxt_add holds the address of the next status_work0 for each queue.
730                     // status_word0_nxt is the actual status word.
731                       genvar i1;
732                       generate for (i1=0; i1&lt;p_edma_queues[31:0]; i1=i1+1) begin : gen_req_sw0_nxt_access
733                         
734                         wire [17:0] tmp_end_addr;
735                         wire [16:0] tmp_end_addr2;
736                         reg  [17:0] tmp_nxt_start_addr;
737                         wire [31:0] local_sw0;
738                     
739                         always@(posedge tx_r_clk or negedge tx_r_rst_n)
740                         begin
741        1/1                if (~tx_r_rst_n)
742                           begin
743        1/1                  need_sw0_nxt_req[i1]        &lt;= 1'b1;
744        1/1                  need_sw1_nxt_req[i1]        &lt;= 1'b1;
745        1/1                  got_sw0_nxt[i1]             &lt;= 1'b0;
746        1/1                  got_sw1_nxt[i1]             &lt;= 1'b0;
747        1/1                  status_word0_nxt_add[i1]    &lt;= {p_edma_tx_pbuf_addr{1'b0}};
748        1/1                  status_word0_nxt[i1]        &lt;= {p_dword_w{1'b0}};
749        1/1                  status_word1_nxt[i1]        &lt;= {p_dword_w{1'b0}};
750                           end
751                           else
752                           begin
753        1/1                  if (complete_flush)
754                             begin
755        1/1                    need_sw0_nxt_req[i1]           &lt;= 1'b1;
756        1/1                    need_sw1_nxt_req[i1]           &lt;= bd_extended_mode_en &amp;&amp; !gem_tx_pbuf_data_w_is_128;
757        1/1                    got_sw0_nxt[i1]                &lt;= 1'b0;
758        1/1                    got_sw1_nxt[i1]                &lt;= 1'b0;
759        1/1                    status_word0_nxt_add[i1][p_edma_tx_pbuf_addr-1:p_edma_tx_pbuf_addr-p_edma_tx_pbuf_queue_segment_size] &lt;=
760                                                                           TX_PBUF_SEGMENTS_LOWER_ADDR_ARRAY[i1];
761        1/1                    status_word0_nxt_add[i1][p_edma_tx_pbuf_addr-p_edma_tx_pbuf_queue_segment_size-1:0] &lt;=
762                                                                           {p_edma_tx_pbuf_addr-p_edma_tx_pbuf_queue_segment_size{1'b0}};
763        1/1                    status_word0_nxt[i1]           &lt;= {p_dword_w{1'b0}};
764                             end
765                     
766                             else
767                             begin
768        1/1                    if (sample_cut_thru_sw &amp; {{28{1'b0}},queue_dma} == i1)
769                               begin
770        <font color = "red">0/1     ==>              need_sw0_nxt_req[i1]           &lt;= 1'b0;</font>
771        <font color = "red">0/1     ==>              need_sw1_nxt_req[i1]           &lt;= 1'b0;</font>
772                               end
773        1/1                    else if (sram_req_gnt[i1+3])
774                               begin
775        1/1                      if (!need_sw1_nxt_req[i1] || gem_tx_pbuf_data_w_is_128 || dma_bus_width == 2'b01) // If already requested the launch time in SW1, or can get both SW0 and SW1 in 1 access
776                                 begin
777        1/1                        need_sw1_nxt_req[i1]         &lt;= 1'b0;
778        1/1                        need_sw0_nxt_req[i1]         &lt;= 1'b0;
779                                 end
780                                 else
781        <font color = "red">0/1     ==>                need_sw1_nxt_req[i1]         &lt;= 1'b0; // 32 bit only - still need SW0</font>
782                               end
783        1/1                    else if (sample_sw0 &amp;&amp; (i1 == {{28{1'b0}},queue_dma_c}) &amp; ~(|store_mac_sw0_en))
784                               begin
785        1/1                      need_sw1_nxt_req[i1]      &lt;= bd_extended_mode_en &amp;&amp; !gem_tx_pbuf_data_w_is_128;
786        1/1                      need_sw0_nxt_req[i1]      &lt;= 1'b1;
787        1/1                      status_word0_nxt_add[i1]  &lt;= bind2queueRange(tmp_nxt_start_addr[p_edma_tx_pbuf_addr-1:0],
788                                                              TX_PBUF_SEGMENTS_UPPER_ADDR_ARRAY[i1],
789                                                              TX_PBUF_SEGMENTS_LOWER_ADDR_ARRAY[i1],
790                                                              TX_PBUF_NUM_SEGMENTS_ARRAY[i1]);
791                               end
792        1/1                    else if (!bd_extended_mode_en)
793        1/1                      need_sw1_nxt_req[i1]      &lt;= 1'b0;
                   <font color = "red">==>  MISSING_ELSE</font>
794                     
795                               // If the cutthru bus comes in first with the SW0, then need_sw0_nxt_req will go low on nxt cycle
796                               // thus blocking any chance for the normal SRAM request to fetch SW0
797                               // If the num_pkts_needing_read bus increments first, or at the same time, then we need to block
798                               // the result from this from loading got_sw0_nxt and the status word. This is because the sw0
799                               // and the got_sw0_nxt bus will be loaded from the cutthru bus instead.
800        1/1                    if (sample_cut_thru_sw &amp; {{28{1'b0}},queue_dma} == i1)
801                               begin
802        <font color = "red">0/1     ==>              got_sw0_nxt[i1]             &lt;= 1'b1;</font>
803        <font color = "red">0/1     ==>              got_sw1_nxt[i1]             &lt;= 1'b1;</font>
804        <font color = "red">0/1     ==>              status_word0_nxt[i1]        &lt;= ct_fifo_w0;</font>
805        <font color = "red">0/1     ==>              status_word1_nxt[i1]        &lt;= ct_fifo_w1;</font>
806                               end
807        1/1                    else if (sram_dat_gnt[i1+3])
808                               begin
809        1/1                      if (got_sw1_nxt[i1] || gem_tx_pbuf_data_w_is_128 || dma_bus_width == 2'b01 || !bd_extended_mode_en) // If we already have SW1, or can get both SW0 and SW1 in 1 access
810                                 begin
811        1/1                        got_sw0_nxt[i1]           &lt;= 1'b1;
812        1/1                        status_word0_nxt[i1]      &lt;= tx_dob_w0;
813        1/1                        if (!got_sw1_nxt[i1])
814                                   begin
815        1/1                          status_word1_nxt[i1]    &lt;= tx_dob_w1;
816        1/1                          got_sw1_nxt[i1]         &lt;= 1'b1;
817                                   end
                   <font color = "red">==>  MISSING_ELSE</font>
818                                 end
819                                 else  // 32 bit, got SW1 now, but still need SW0
820                                 begin
821        <font color = "red">0/1     ==>                got_sw1_nxt[i1]           &lt;= 1'b1;</font>
822        <font color = "red">0/1     ==>                status_word1_nxt[i1]      &lt;= tx_dob_w0;</font>
823                                 end
824                               end
825        1/1                    else if (sample_sw0 &amp;&amp; (i1 == {{28{1'b0}},queue_dma_c}) &amp; ~(|store_mac_sw0_en))
826                               begin
827        1/1                      got_sw0_nxt[i1]          &lt;= 1'b0;
828        1/1                      got_sw1_nxt[i1]          &lt;= 1'b0;
829                               end
                        MISSING_ELSE
830                             end
831                           end
832                         end
833                     
834                     
835                         // This is the SRAM request for fetching status word 0.  This will be passed to the SRAM arbiter
836                         assign sw0_nxt_req[i1] = need_sw0_nxt_req[i1] &amp; (|num_pkts_needing_read[i1]) &amp; !sample_cut_thru_sw;
837                     
838                         // Calculate the packet end addresses, using the start address, number of locations in a frame
839                         // and the offset to the frame end address. This is needed to identify the next status word 0 address.
840                         // We also sign extened the offset to the frame address as
841                         // at times we need to subtract 1.
842                         // Note. We extend the calculation to 16 bits to account for the scenario
843                         // where the edma_tx_pbuf_addr paramater is larger or smaller than the 12
844                         // bits allocated for the size of frame. We also sign extend the offset
845                         assign local_sw0          = status_word0_nxt[i1][31:0];
846                         assign tmp_end_addr2      = {{(17-p_edma_tx_pbuf_addr){1'b0}},status_word0_nxt_add[i1]} + {5'd0,local_sw0[11:0]};
847                         assign tmp_end_addr       = tmp_end_addr2 + {1'd0,{8{local_sw0[23]}},local_sw0[23:16]};
848                     
849                         always @(*)
850                         begin
851        1/1                if (gem_tx_pbuf_data_w_is_128)
852        <font color = "red">0/1     ==>          tmp_nxt_start_addr = tmp_end_addr[16:0] + 17'd1 ; // 4 status words fit into 1 SRAM locn</font>
853        1/1                else if (dma_bus_width[0])
854        <font color = "red">0/1     ==>          tmp_nxt_start_addr = tmp_end_addr[16:0] + 17'd2 ; // 4 status words fit into 2 SRAM locns</font>
855                           else
856        1/1                  tmp_nxt_start_addr = tmp_end_addr[16:0] + 17'd4;  // 4 status words fit into 4 SRAM locns
857                         end
858                     
859                       end
860                       endgenerate
861                     
862                     
863                     
864                     // Implement the SRAM arbiter
865                     // Top priority is the MAC request as failure to respond here will incur an underflow.
866                     // Once the MAC requests data, we must return data in 2 clock cycles.
867                     // We can use tx_r_rd_int as an early indicator that the MAC will set tx_r_rd on the next clock
868                     // That gives us 3 clocks total to read the SRAM and register the data back to ease timing on SRAM IO.
869                     // There is one request for the MAC, one request for each status word (excl sw0)
870                     // and up to 16 requests for the sw0_sweep.
871                       assign sram_req[0] = |tx_r_rd_int &amp;
872                                             ((read_state != IDLE &amp; empty_next_downsize) | read_state_tr_idle2data);
873                       assign sram_req[1] = sw2_req;
874                       assign sram_req[2] = sw3_req;
875                       assign sram_req[p_edma_queues+2:3] = sw0_nxt_req;
876                       always@(*)
877                       begin
878        1/1              sram_req_gnt = {p_edma_queues+3{1'b0}};
879        1/1              for (sram_arb_cnt=(p_edma_queues+2); sram_arb_cnt&gt;=0; sram_arb_cnt=sram_arb_cnt-1) begin
880        1/1                if (sram_req[sram_arb_cnt])
881        1/1                  sram_req_gnt = {{p_edma_queues+2{1'b0}},1'b1} &lt;&lt; sram_arb_cnt;
                        MISSING_ELSE
882                         end
883                       end
884                     
885                       // sram_add_gnt identifies which source is currently accessing the SRAM (address phase)
886                       // sram_dat_gnt identifies which source is currently accessing the SRAM (data phase)
887                       always@(posedge tx_r_clk or negedge tx_r_rst_n)
888                       begin
889        1/1              if (~tx_r_rst_n)
890                         begin
891        1/1                for (sram_arb_cnt2=(p_edma_queues+2); sram_arb_cnt2&gt;=0; sram_arb_cnt2=sram_arb_cnt2-1) begin
892        1/1                  sram_add_gnt[sram_arb_cnt2]  &lt;=  1'b0;
893        2/2                  if (sram_arb_cnt2 &gt; 0) sram_dat_gnt[sram_arb_cnt2]  &lt;=  1'b0;
                        MISSING_ELSE
894                           end
895                         end
896                         else
897                         begin
898        1/1                if (complete_flush)
899                           begin
900        1/1                  for (sram_arb_cnt2=(p_edma_queues+2); sram_arb_cnt2&gt;=0; sram_arb_cnt2=sram_arb_cnt2-1) begin
901        1/1                    sram_add_gnt[sram_arb_cnt2]  &lt;=  1'b0;
902        2/2                    if (sram_arb_cnt2 &gt; 0) sram_dat_gnt[sram_arb_cnt2]  &lt;=  1'b0;
                        MISSING_ELSE
903                             end
904                           end
905                           else
906                           begin
907        1/1                  for (sram_arb_cnt2=(p_edma_queues+2); sram_arb_cnt2&gt;=0; sram_arb_cnt2=sram_arb_cnt2-1) begin
908        1/1                    sram_add_gnt[sram_arb_cnt2]  &lt;=  sram_req_gnt[sram_arb_cnt2];
909        2/2                    if (sram_arb_cnt2 &gt; 0) sram_dat_gnt[sram_arb_cnt2]  &lt;=  sram_add_gnt[sram_arb_cnt2];
                        MISSING_ELSE
910                             end
911                           end
912                         end
913                       end
914                     
915                       // Create a signal that identifies whether the current address issued to the SRAM
916                       // is for obtaining the early SW0 or SW1 (launch time)
917                       reg [p_edma_queues-1:0] sram_add_sw1;
918                       always@(posedge tx_r_clk or negedge tx_r_rst_n)
919                       begin
920        1/1              if (~tx_r_rst_n)
921        1/1                sram_add_sw1  &lt;= {p_edma_queues{1'b0}};
922                         else
923        1/1                for (sram_add_cnt=p_edma_queues-1; sram_add_cnt&gt;=0; sram_add_cnt=sram_add_cnt-1) begin
924        1/1                  if (complete_flush || need_sw1_nxt_req[sram_add_cnt])
925        1/1                    sram_add_sw1[sram_add_cnt]  &lt;=  dma_bus_width == 2'b00;
926                             else
927        1/1                    sram_add_sw1[sram_add_cnt]  &lt;=  1'b0;
928                           end
929                       end
930                     
931                       // Based on the granted master, set the SRAM address. First identify the status_word0 sweep address
932                       // There is one of these per queue.
933                       always@(*)
934                       begin
935        1/1              sw0_sweep_sram_addr = {p_edma_tx_pbuf_addr{1'b0}};
936        1/1              sw0_sweep_sram_addr_p1 = {p_edma_tx_pbuf_addr{1'b0}};
937        1/1              sram_add_sw1_q         = 1'b1;
938        1/1              for (sram_add_cnt_index=p_edma_queues-1; sram_add_cnt_index&gt;=0; sram_add_cnt_index=sram_add_cnt_index-1) begin
939        1/1                if (sram_add_gnt[sram_add_cnt_index+3])
940                           begin
941        1/1                  sw0_sweep_sram_addr    = status_word0_nxt_add[sram_add_cnt_index];
942        1/1                  sw0_sweep_sram_addr_p1 = bind2queueRange((status_word0_nxt_add[sram_add_cnt_index] + {{p_edma_tx_pbuf_addr-2{1'b0}},2'b01}),
943                                                                    TX_PBUF_SEGMENTS_UPPER_ADDR_ARRAY[sram_add_cnt_index],
944                                                                    TX_PBUF_SEGMENTS_LOWER_ADDR_ARRAY[sram_add_cnt_index],
945                                                                    TX_PBUF_NUM_SEGMENTS_ARRAY[sram_add_cnt_index]);
946        1/1                  sram_add_sw1_q         = sram_add_sw1[sram_add_cnt_index];
947                           end
                        MISSING_ELSE
948                         end
949                       end
950                     
951                     
952                       always @(*)
953                       begin
954        1/1              tx_enb = |sram_add_gnt[2:0] | (|(sram_add_gnt[(p_edma_queues+2):3]));
955        1/1              tx_web = 1'b0;
956        2/2              if      (sram_add_gnt[0]) tx_addrb = pkt_data_sram_addr;                                                                           // Status Word 0
957        2/2              else if (sram_add_gnt[1]) tx_addrb = gem_tx_pbuf_data_w_is_128 ? status_word0_add : lstatus_word2_add;                             // Status Word 2
958        2/2              else if (sram_add_gnt[2]) tx_addrb = lstatus_word3_add;                                                                            // Status Word 3
959        2/2              else if (sram_add_sw1_q)  tx_addrb = sw0_sweep_sram_addr_p1;
960        1/1              else                      tx_addrb = sw0_sweep_sram_addr;
961                       end
962                     
963                     
964                     // Instantiate the transmit scheduler ...
965                     // First Identify whether there are packets in each queue
966                     // and identify what the length of the frame at the head of every non-empty queue
967                       wire  [(p_edma_queues*14)-1:0]    nxt_frame_size;
968                       wire  [15:0]                      status_frame_in_q;
969                       wire  [p_edma_queues-1:0]         tx_r_data_rdy_rph;
970                       reg   [p_edma_queues-1:0]         tx_r_data_rdy_aph;
971                       wire  [p_edma_queues-1:0]         tx_r_frame_size_vld_rph;
972                       wire  [3:0]                       status_index [p_edma_queues-1:0];
973                       wire  [1:0]                       dma_bus_width_override;
974                     
975                       // Override dma_bus_width if 128-bit SRAM for frame size calculation
976                       assign dma_bus_width_override = gem_tx_pbuf_data_w_is_128 ? 2'b10 : dma_bus_width;
977                     
978                       genvar i2;
979                       generate for (i2=0; i2&lt;p_edma_queues[31:0]; i2=i2+1) begin : gen_packets_in_q
980                         wire [31:0] local_sw0;
981                         wire [13:0] nxt_frame_size_word;
982                         reg  [14:0] nxt_frame_size_local;
983                         assign local_sw0          = status_word0_nxt[i2][31:0];
984                     
985                         // The frame size must be in bytes ...
986                         // Unfortunately, the local_sw0 is in SRAM words, and doesnt take into account any of the
987                         // bytes added by the MAC, such as the preamble CRC and IPG. So add 24 bytes.
988                         assign nxt_frame_size_word =  dma_bus_width_override == 2'b00 ? {local_sw0[11:0],2'b00} :
989                                                       dma_bus_width_override == 2'b01 ? {local_sw0[10:0],3'b000} :
990                                                                                         {local_sw0[9:0],4'b0000};
991                         always @(*)
992                         begin
993        1/1                case ({ (local_sw0[15] | !dma_bus_width_override[1]),
994                                   (local_sw0[14] | !(|dma_bus_width_override)),
995                                   (local_sw0[13:12])})
996        1/1                  4'b1111   : nxt_frame_size_local = nxt_frame_size_word + 14'd23; // +24-1
997        1/1                  4'b1110   : nxt_frame_size_local = nxt_frame_size_word + 14'd22; // +24-2
998        1/1                  4'b1101   : nxt_frame_size_local = nxt_frame_size_word + 14'd21;
999        1/1                  4'b1100   : nxt_frame_size_local = nxt_frame_size_word + 14'd20;
1000       <font color = "red">0/1     ==>          4'b1011   : nxt_frame_size_local = nxt_frame_size_word + 14'd19;</font>
1001       <font color = "red">0/1     ==>          4'b1010   : nxt_frame_size_local = nxt_frame_size_word + 14'd18;</font>
1002       <font color = "red">0/1     ==>          4'b1001   : nxt_frame_size_local = nxt_frame_size_word + 14'd17;</font>
1003       <font color = "red">0/1     ==>          4'b1000   : nxt_frame_size_local = nxt_frame_size_word + 14'd16;</font>
1004       <font color = "red">0/1     ==>          4'b0111   : nxt_frame_size_local = nxt_frame_size_word + 14'd15;</font>
1005       <font color = "red">0/1     ==>          4'b0110   : nxt_frame_size_local = nxt_frame_size_word + 14'd14;</font>
1006       <font color = "red">0/1     ==>          4'b0101   : nxt_frame_size_local = nxt_frame_size_word + 14'd13;</font>
1007       <font color = "red">0/1     ==>          4'b0100   : nxt_frame_size_local = nxt_frame_size_word + 14'd12;</font>
1008       <font color = "red">0/1     ==>          4'b0011   : nxt_frame_size_local = nxt_frame_size_word + 14'd11;</font>
1009       <font color = "red">0/1     ==>          4'b0010   : nxt_frame_size_local = nxt_frame_size_word + 14'd10;</font>
1010       <font color = "red">0/1     ==>          4'b0001   : nxt_frame_size_local = nxt_frame_size_word + 14'd9;</font>
1011       1/1                  default   : nxt_frame_size_local = nxt_frame_size_word + 14'd24;
1012                          endcase
1013                        end
1014                    
1015                        assign nxt_frame_size[(14*i2+13):(14*i2)] = nxt_frame_size_local[13:0];
1016                    
1017                        // tx_r_frame_size_vld is a FIFO interface signal that is visible only when the DMA is included
1018                        // It is similarly timed to the now that should be valid for the duration of the frame from the first tx_r_rd
1019                        assign tx_r_frame_size_vld_rph[i2]  = (|store_mac_sw0_en &amp; i2[3:0] == store_1st_sw0[p_dword_w+3:p_dword_w]) | (got_sw0_nxt[i2] &amp; !local_sw0[31]);
1020                        // Hold it for the duration of the frame ..
1021                        assign tx_r_frame_size_vld[i2]      =  tx_r_frame_size_vld_rph[i2] | (status_word0_obtained &amp; !status_word_0[31] &amp; queue_dma == i2[3:0]);
1022                    
1023                        assign tx_r_data_rdy_rph[i2]        =  ((|store_mac_sw0_en &amp; i2[3:0] == store_1st_sw0[p_dword_w+3:p_dword_w] &amp; !store_1st_sw0[31]) |
1024                                                               (!(|store_mac_sw0_en) &amp; ((|num_pkts_needing_read_nxt[i2] &amp; tx_r_frame_size_vld_rph[i2] &amp; !local_sw0[31]) | start_reading_at_risk_q_nxt[i2])));
1025                        assign tx_r_launch_time_vld[i2]     =  (store_mac_sw0_en == 2'b00 &amp;&amp; bd_extended_mode_en &amp;&amp; got_sw0_nxt[i2] &amp;&amp; local_sw0[24] &amp;&amp;  !local_sw0[31]);
1026                        assign tx_r_launch_time[(32*i2+31):(32*i2)] =  status_word1_nxt[i2][31:0];
1027                        assign status_frame_in_q[i2]        = (|store_mac_sw0_en &amp; i2[3:0] == store_1st_sw0[p_dword_w+3:p_dword_w] &amp; store_1st_sw0[31]) |
1028                                                              ((|num_pkts_needing_read_nxt[i2]) &amp; local_sw0[31] &amp; got_sw0_nxt[i2]);
1029                        assign status_index[i2] = i2[3:0];
1030                    
1031                        // Parity check for status word 0 and 1, used for frame size and launch time.
1032                        if (p_edma_asf_dap_prot == 1) begin : gen_par_chk
1033                          cdnsdru_asf_parity_check_v1 #(.p_data_width(64)) i_gem_par_chk_sw1 (
1034                            .odd_par(1'b0),
1035                            .data_in({status_word1_nxt[i2][31:0],
1036                                      status_word0_nxt[i2][31:0]}),
1037                            .parity_in({status_word1_nxt[i2][35:32],
1038                                        status_word0_nxt[i2][35:32]}),
1039                            .parity_err(sw01_par_err[i2])
1040                          );
1041                        end else begin : gen_no_par_chk
1042                          assign sw01_par_err[i2]  = 1'b0;
1043                        end
1044                      end
1045                      endgenerate
1046                      assign dma_is_busy         = (((|status_frame_in_q &amp;&amp; !(|store_mac_sw0_en)) || mac_bp) &amp;&amp; read_state == IDLE) || read_state == WAIT_FOR_STATUS;
1047                      assign tx_r_frame_size     = nxt_frame_size;
1048                    
1049                      // The selected queue is not something this module controls. It comes from the
1050                      // scheduler inside the MAC.  so we need to wait for tx_r_rd_int and then use tx_r_queue_int
1051                    
1052                    
1053                      // Set the queue ID based on the above scheduled_queue bus ...
1054                      integer q_cnt;
1055                      always@(*)
1056                      begin
1057       1/1              queue_dma_c = queue_dma;
1058       1/1              if (|store_mac_sw0_en)  // restart due to collision ...
1059       <font color = "red">0/1     ==>        queue_dma_c = store_1st_sw0[p_dword_w+3:p_dword_w];</font>
1060       1/1              else if (|status_frame_in_q &amp;&amp; read_state == IDLE)
1061       <font color = "red">0/1     ==>        for (q_cnt= 0; q_cnt&lt;p_edma_queues[31:0]; q_cnt=q_cnt+ 1)</font>
1062                          begin
1063       <font color = "red">0/1     ==>          if (status_frame_in_q[q_cnt])  // Fixed priority - highest queue num wins ...</font>
1064       <font color = "red">0/1     ==>            queue_dma_c = status_index[q_cnt];</font>
                   <font color = "red">==>  MISSING_ELSE</font>
1065                          end
1066                        else
1067       1/1                queue_dma_c = tx_r_queue_int;
1068                      end
1069                    
1070                      // transfers to the MAC must be back pressured if any of the following is true.
1071                      //  1. There are already 2 packets in the MAC pipeline ...
1072                      //  2. Any of the FIFO's in this module that communicate with other parts of the design are full
1073                      assign mac_bp = (num_pkts_in_mac == 2'b10 |
1074                                       sw_mac_fifo_full |
1075                                       wb_status_to_tx_wr_fifo_afull);
1076                    
1077                      // Store the queue information. Useful to know what the queue is as we fetch the frame from the SRAM and feed the MAC.
1078                      // Also udeful to know what the queue is as it passes through the MAC pipeline.
1079                      always@(posedge tx_r_clk or negedge tx_r_rst_n)
1080       1/1              if (~tx_r_rst_n)
1081                        begin
1082       1/1                queue_dma &lt;= 4'h0;
1083       1/1                queue_mac &lt;= 4'h0;
1084                        end
1085                        else
1086                        begin
1087       1/1                if (complete_flush)
1088                          begin
1089       1/1                  queue_dma &lt;= 4'h0;
1090       1/1                  queue_mac &lt;= 4'h0;
1091                          end
1092                          else
1093                          begin
1094       1/1                  if (read_state == IDLE)
1095       1/1                    queue_dma &lt;= queue_dma_c;
                        MISSING_ELSE
1096       1/1                  if (num_pkts_in_mac == 2'b00 &amp; read_state_tr_idle2data)
1097       1/1                    queue_mac &lt;= queue_dma_c;
1098       1/1                  else if (|num_pkts_in_mac &amp; pkt_mac_sent)
1099       1/1                    queue_mac &lt;= queue_dma;
                        MISSING_ELSE
1100                          end
1101                        end
1102                    
1103                      // Obtain the status word 0 for the next frame we want to transmit from ...
1104                      assign nxt_sw0_nxt  = |store_mac_sw0_en ? store_1st_sw0[31:0] : status_word0_nxt[queue_dma_c][31:0];
1105                    
1106                      // Implement the main state machine, which acts upon the queue decision
1107                      // and fetches the frame data for that queue. It also controls the main data_rdy
1108                      // signal to the MAC, which informs the MAC when data is available to fetch. The state
1109                      // machine will stay in the PKT_DATA state until all the frame data has been pushed to the MAC
1110                      // and all 3 status words have been successfully obtained.
1111                      // It will also handle the status-only frames, which are really just error status from
1112                      // the AHB/AXI side of the DMA passed through the SRAM to be in the correct packet order.
1113                      // Status-only frames dont have any packet data, so are handled a little differently.
1114                      // Note this state machine operates in the SRAM request phase
1115                      always @(*)
1116                      begin
1117       1/1                read_state_nxt          = read_state;
1118       1/1                read_state_tr_idle2data = 1'b0;
1119       1/1                sw2_req                 = 1'b0;
1120       1/1                sw3_req                 = 1'b0;
1121       1/1                sample_sw0              = 1'b0;
1122       1/1                sample_cut_thru_sw      = 1'b0;
1123       1/1                case (read_state)
1124                            IDLE  :
1125                            begin
1126       1/1                    if (mac_bp)
1127       <font color = "red">0/1     ==>              read_state_nxt          = IDLE;</font>
1128       1/1                    else if ((got_sw0_nxt[queue_dma_c] &amp;&amp; !(|store_mac_sw0_en | need_to_replay) &amp;&amp;
1129                                        (tx_r_rd_int_pad[queue_dma_c] || status_frame_in_q[queue_dma_c])) ||
1130                    
1131                                      ((|store_mac_sw0_en) &amp;&amp; (tx_r_rd_int_pad[queue_dma_c] || store_1st_sw0[31])))
1132                              begin
1133       1/1                      sw2_req                 = ~status_word2_obtained &amp; ~sram_add_gnt[1] &amp; ~sram_dat_gnt[1];
1134       1/1                      sw3_req                 = dma_bus_width_override == 2'b00 &amp; ~status_word3_obtained &amp; ~sram_add_gnt[2] &amp; ~sram_dat_gnt[2];
1135       1/1                      sample_sw0              = 1'b1;
1136                                // If the frame is a status only frame, then only go get status - i.e. no data to send MAC
1137       1/1                      if (nxt_sw0_nxt[31])
1138       <font color = "red">0/1     ==>                read_state_nxt        = WAIT_FOR_STATUS;</font>
1139                                else
1140                                begin
1141       1/1                        read_state_tr_idle2data = 1'b1;
1142       1/1                        if (reading_pkt_last_word_req_c)
1143       <font color = "red">0/1     ==>                  read_state_nxt        = WAIT_FOR_STATUS;</font>
1144                                  else
1145       1/1                          read_state_nxt        = PKT_DATA;
1146                                end
1147                              end
1148       1/1                    else if (start_reading_at_risk_q_nxt[queue_dma_c] &amp; tx_r_rd_int_pad[queue_dma_c])
1149                              begin
1150       <font color = "red">0/1     ==>              read_state_tr_idle2data = 1'b1;</font>
1151       <font color = "red">0/1     ==>              read_state_nxt          = PKT_DATA;</font>
1152                              end
                        MISSING_ELSE
1153                            end
1154                    
1155                            PKT_DATA :
1156                            begin
1157       1/1                    if  (need_to_replay | reading_pkt_last_word_req)
1158                              begin
1159       1/1                      if (status_word2_obtained &amp; status_word3_obtained)
1160       1/1                        read_state_nxt  = IDLE;
1161                                else
1162       <font color = "red">0/1     ==>                read_state_nxt  = WAIT_FOR_STATUS;</font>
1163                              end
1164       1/1                    else if (start_reading_at_risk_q_nxt[queue_dma] &amp; cutthru_status_word_valid &amp; !status_word0_obtained &amp; !got_sw0_nxt[queue_dma])
1165       <font color = "red">0/1     ==>              sample_cut_thru_sw = 1'b1; // This happens as soon as the cutthru_status_word becomes available to preload status_word_0_nxt</font>
1166       1/1                    else if (start_reading_at_risk_q_nxt[queue_dma] &amp; got_sw0_nxt[queue_dma] &amp; (|num_pkts_needing_read[queue_dma]) &amp; !status_word0_obtained)
1167       <font color = "red">0/1     ==>              sample_sw0      = 1'b1;// This happens a bit later than above when num_pkts_needing_read has been updated</font>
1168       1/1                    else if (sram_req_gnt[1])
1169       1/1                      read_state_nxt  = READ_LSTATUS_WORD2;
1170       1/1                    else if (sram_req_gnt[2])
1171       <font color = "red">0/1     ==>              read_state_nxt  = READ_LSTATUS_WORD3;</font>
                        MISSING_ELSE
1172                    
1173       1/1                    sw2_req           = ~status_word2_obtained &amp; status_word0_obtained &amp; ~sram_add_gnt[1] &amp; ~sram_dat_gnt[1];
1174       1/1                    sw3_req           = dma_bus_width_override == 2'b00 &amp;&amp; ~status_word3_obtained &amp;&amp; status_word0_obtained &amp;&amp; ~sram_add_gnt[2] &amp;&amp; ~sram_dat_gnt[2];
1175                            end
1176                    
1177                            READ_LSTATUS_WORD2 :
1178                            begin
1179       1/1                    sw3_req           = dma_bus_width_override == 2'b00 &amp;&amp; status_word0_obtained;  // Only in 32b/64b mode do we need to fetch status_word2 separately
1180       1/1                    if (need_to_replay | reading_pkt_last_word_req)
1181       <font color = "red">0/1     ==>              read_state_nxt  = WAIT_FOR_STATUS;</font>
1182       1/1                    else if (sram_req_gnt[2])
1183       1/1                      read_state_nxt  = READ_LSTATUS_WORD3;
1184                              else
1185       1/1                      read_state_nxt  = PKT_DATA;
1186                            end
1187                    
1188                            READ_LSTATUS_WORD3 :
1189                            begin
1190       1/1                    if (need_to_replay | reading_pkt_last_word_req)
1191       <font color = "red">0/1     ==>              read_state_nxt  = WAIT_FOR_STATUS;</font>
1192                              else
1193       1/1                      read_state_nxt  = PKT_DATA;
1194                            end
1195                    
1196                            default : // WAIT_FOR_STATUS only entered if we have finished reading the frame from SRAM, but havent yet got all the status words
1197                            begin
1198       1/1                    sw2_req               = ~status_word2_obtained &amp; status_word0_obtained &amp; ~sram_add_gnt[1] &amp; ~sram_dat_gnt[1];
1199       1/1                    sw3_req               = dma_bus_width_override == 2'b00 &amp; ~status_word3_obtained &amp; status_word0_obtained &amp; ~sram_add_gnt[2] &amp; ~sram_dat_gnt[2];
1200       1/1                    if (status_word3_obtained)
1201                              begin
1202       <font color = "red">0/1     ==>              read_state_nxt      = IDLE;</font>
1203                              end
                        MISSING_ELSE
1204                            end
1205                    
1206                    
1207                          endcase
1208                      end
1209                    
1210                      always @(posedge tx_r_clk or negedge tx_r_rst_n)
1211                      begin
1212       1/1              if (~tx_r_rst_n)
1213                        begin
1214       1/1                read_state            &lt;= IDLE;
1215       1/1                status_word_0         &lt;= {p_dword_w{1'b0}};
1216       1/1                status_word_2         &lt;= {p_dword_w{1'b0}};
1217       1/1                status_word_3         &lt;= {p_dword_w{1'b0}};
1218       1/1                status_word0_add_int  &lt;= {p_edma_tx_pbuf_addr{1'b0}};
1219       1/1                status_word0_obtained &lt;= 1'b0;
1220       1/1                status_word2_obtained &lt;= 1'b0;
1221       1/1                status_word3_obtained &lt;= 1'b0;
1222                        end
1223                        else
1224                        begin
1225       1/1                if (complete_flush | uflow_wait_for_dma)
1226                          begin
1227       1/1                  read_state            &lt;= IDLE;
1228       1/1                  status_word_0         &lt;= {p_dword_w{1'b0}};
1229       1/1                  status_word_2         &lt;= {p_dword_w{1'b0}};
1230       1/1                  status_word_3         &lt;= {p_dword_w{1'b0}};
1231       1/1                  status_word0_add_int  &lt;= {p_edma_tx_pbuf_addr{1'b0}};
1232       1/1                  status_word0_obtained &lt;= 1'b0;
1233       1/1                  status_word2_obtained &lt;= 1'b0;
1234       1/1                  status_word3_obtained &lt;= 1'b0;
1235                          end
1236                          else
1237                          begin
1238       1/1                  read_state              &lt;= read_state_nxt;
1239       1/1                  if (sample_sw0)
1240                            begin
1241       1/1                    if (|store_mac_sw0_en)
1242                              begin
1243       <font color = "red">0/1     ==>              status_word_0         &lt;= store_1st_sw0[p_dword_w-1:0];</font>
1244       <font color = "red">0/1     ==>              status_word0_add_int  &lt;= store_1st_sw0[p_dword_w+p_edma_tx_pbuf_addr+3:p_dword_w+4];</font>
1245                              end
1246                              else
1247                              begin
1248       1/1                      status_word_0         &lt;= status_word0_nxt[queue_dma_c];
1249       1/1                      status_word0_add_int  &lt;= status_word0_nxt_add[queue_dma_c];
1250                              end
1251                            end
                        MISSING_ELSE
1252                    
1253                            // For cut-thru operation, we can get the data straight from the cut-thru buffer
1254       1/1                  if (sample_sw0 &amp; cutthru_status_word_valid)
1255                            begin
1256       <font color = "red">0/1     ==>            status_word_2     &lt;= ct_fifo_w2;</font>
1257       <font color = "red">0/1     ==>            status_word_3     &lt;= ct_fifo_w3;</font>
1258                            end
1259       1/1                  else if (sram_dat_gnt[1])
1260                            begin
1261       1/1                    if (gem_tx_pbuf_data_w_is_128)
1262                              begin
1263       <font color = "red">0/1     ==>              status_word_2     &lt;= tx_dob_w2;</font>
1264       <font color = "red">0/1     ==>              status_word_3     &lt;= tx_dob_w3;</font>
1265                              end
1266       1/1                    else if (dma_bus_width[0])
1267                              begin
1268       <font color = "red">0/1     ==>              status_word_2     &lt;= tx_dob_w0;</font>
1269       <font color = "red">0/1     ==>              status_word_3     &lt;= tx_dob_w1;</font>
1270                              end
1271                              else
1272       1/1                      status_word_2     &lt;= tx_dob_w0;
1273                            end
1274       1/1                  else if (sram_dat_gnt[2])
1275       1/1                    status_word_3       &lt;= tx_dob_w0;
                        MISSING_ELSE
1276                    
1277                    
1278       1/1                  if (read_state_nxt == IDLE)
1279                            begin
1280       1/1                    status_word0_obtained   &lt;= 1'b0;
1281       1/1                    status_word2_obtained   &lt;= 1'b0;
1282       1/1                    status_word3_obtained   &lt;= 1'b0;
1283                            end
1284       1/1                  else if (sample_sw0)
1285                            begin
1286       1/1                    status_word0_obtained   &lt;= 1'b1;
1287       1/1                    if (cutthru_status_word_valid)
1288                              begin
1289       <font color = "red">0/1     ==>              status_word2_obtained   &lt;= 1'b1;</font>
1290       <font color = "red">0/1     ==>              status_word3_obtained   &lt;= 1'b1;</font>
1291                              end
                        MISSING_ELSE
1292                            end
1293       1/1                  else if (sram_dat_gnt[1] &amp; read_state != IDLE) // impossible to get status word 1 in IDLE state - if it is set, then it is residual from previous frame and should be ignored.
1294                            begin
1295       1/1                    status_word2_obtained   &lt;= 1'b1;
1296       1/1                    if (gem_tx_pbuf_data_w_is_128 || dma_bus_width != 2'b00)
1297       <font color = "red">0/1     ==>              status_word3_obtained &lt;= 1'b1;</font>
                        MISSING_ELSE
1298                            end
1299       1/1                  else if (sram_dat_gnt[2] &amp; read_state != IDLE) // impossible to get status word 2 in IDLE state - if it is set, then it is residual from previous frame and should be ignored.
1300       1/1                    status_word3_obtained &lt;= 1'b1;
                        MISSING_ELSE
1301                          end
1302                        end
1303                      end
1304                    
1305                      assign pkt_data_nxt_add  = bind2queueRange((pkt_data_sram_addr[p_edma_tx_pbuf_addr-1:0] + {{p_edma_tx_pbuf_addr-1{1'b0}},1'b1}),
1306                                                                   TX_PBUF_SEGMENTS_UPPER_ADDR_ARRAY[queue_dma],
1307                                                                   TX_PBUF_SEGMENTS_LOWER_ADDR_ARRAY[queue_dma],
1308                                                                   TX_PBUF_NUM_SEGMENTS_ARRAY[queue_dma]);
1309                    
1310                      wire [p_edma_tx_pbuf_addr-1:0] pkt_data_addr_inc1;
1311                      assign pkt_data_addr_inc1 = (gem_tx_pbuf_data_w_is_128 || dma_bus_width != 2'b00)  ? ({{p_edma_tx_pbuf_addr-2{1'b0}},2'b10})
1312                                                                                                         : ({{p_edma_tx_pbuf_addr-2{1'b0}},2'b11});
1313                      assign pkt_data_nxt_add2 = bind2queueRange((pkt_data_sram_addr[p_edma_tx_pbuf_addr-1:0] + pkt_data_addr_inc1),
1314                                                                   TX_PBUF_SEGMENTS_UPPER_ADDR_ARRAY[queue_dma],
1315                                                                   TX_PBUF_SEGMENTS_LOWER_ADDR_ARRAY[queue_dma],
1316                                                                   TX_PBUF_NUM_SEGMENTS_ARRAY[queue_dma]);
1317                    
1318                      assign lstatus_word2_add = bind2queueRange((pkt_end_addr_int[p_edma_tx_pbuf_addr-1:0] + {{p_edma_tx_pbuf_addr-2{1'b0}},2'b01}),
1319                                                                   TX_PBUF_SEGMENTS_UPPER_ADDR_ARRAY[queue_dma],
1320                                                                   TX_PBUF_SEGMENTS_LOWER_ADDR_ARRAY[queue_dma],
1321                                                                   TX_PBUF_NUM_SEGMENTS_ARRAY[queue_dma]);
1322                    
1323                      assign lstatus_word3_add = bind2queueRange((pkt_end_addr_int[p_edma_tx_pbuf_addr-1:0] + {{p_edma_tx_pbuf_addr-2{1'b0}},2'b10}),
1324                                                                   TX_PBUF_SEGMENTS_UPPER_ADDR_ARRAY[queue_dma],
1325                                                                   TX_PBUF_SEGMENTS_LOWER_ADDR_ARRAY[queue_dma],
1326                                                                   TX_PBUF_NUM_SEGMENTS_ARRAY[queue_dma]);
1327                    
1328                      // The following signal holds the SRAM address of the packet data.
1329                      // This is used by the main SRAM arbiter to load the SRAM address when the MAC is requesting data.
1330                      // It is a counter implemented in flops, the source of which needs to be request phase timed from
1331                      // the arbiters perspective.
1332                      // When the main statemachine (which is request phase timed) moves from IDLE to PKT_DATA, we load
1333                      // the initial frame address. This is identified by the signal &quot;read_state_tr_idle2data&quot;.
1334                      // When the MAC then issues read requests (granted via the SRAM arbiter by sram_req_gnt), we increment
1335                      // the address.
1336                      // If it is possible read_state_tr_idle2data will be set before the first tx_r_rd_int is issued by the MAC (when
1337                      // we are finishing off a previous frame, the MAC may delay). In this case we want to gate
1338                      // out the first address increment.
1339                      // Note with the move of the scheduler to the MAC, this cant actually happen anymore, so we can
1340                      // remove that code (9commented for furture reference -- see first_word_read)
1341                      //reg                   first_word_read;
1342                    
1343                      // The data starts 1 location after status word 0 for 64 and 128 bit modes and 2 locations after for 32 bit modes
1344                      wire [p_edma_tx_pbuf_addr-1:0] pkt_data_addr_inc;
1345                      assign pkt_data_addr_inc = (gem_tx_pbuf_data_w_is_128 || dma_bus_width != 2'b00)  ? ({{p_edma_tx_pbuf_addr-1{1'b0}},1'b1})
1346                                                                                                        : ({{p_edma_tx_pbuf_addr-2{1'b0}},2'b10});
1347                      always@(posedge tx_r_clk or negedge tx_r_rst_n)
1348                      begin
1349       1/1              if (~tx_r_rst_n)
1350                        begin
1351       1/1                pkt_data_sram_addr  &lt;= {p_edma_tx_pbuf_addr{1'b0}};
1352                          //first_word_read     &lt;= 1'b0;
1353                        end
1354                        else
1355                        begin
1356       1/1                if (complete_flush)
1357                          begin
1358       1/1                  pkt_data_sram_addr  &lt;= {p_edma_tx_pbuf_addr{1'b0}};
1359                            //first_word_read     &lt;= 1'b0;
1360                          end
1361                          else
1362                          begin
1363       1/1                  if (|store_mac_sw0_en &amp; read_state_tr_idle2data)
1364                            begin
1365       <font color = "red">0/1     ==>            pkt_data_sram_addr  &lt;= bind2queueRange((store_1st_sw0[p_dword_w+p_edma_tx_pbuf_addr+3:p_dword_w+4] + pkt_data_addr_inc),</font>
1366                                                                     TX_PBUF_SEGMENTS_UPPER_ADDR_ARRAY[queue_dma_c],
1367                                                                     TX_PBUF_SEGMENTS_LOWER_ADDR_ARRAY[queue_dma_c],
1368                                                                     TX_PBUF_NUM_SEGMENTS_ARRAY[queue_dma_c]);
1369                              //first_word_read   &lt;= sram_req_gnt[0];
1370                            end
1371       1/1                  else if (read_state_tr_idle2data)
1372                            begin
1373       1/1                    pkt_data_sram_addr  &lt;= bind2queueRange((status_word0_nxt_add[queue_dma_c] + pkt_data_addr_inc),
1374                                                                     TX_PBUF_SEGMENTS_UPPER_ADDR_ARRAY[queue_dma_c],
1375                                                                     TX_PBUF_SEGMENTS_LOWER_ADDR_ARRAY[queue_dma_c],
1376                                                                     TX_PBUF_NUM_SEGMENTS_ARRAY[queue_dma_c]);
1377                              //first_word_read   &lt;= sram_req_gnt[0];
1378                            end
1379       1/1                  else if (sram_req_gnt[0])
1380                            begin
1381                              //first_word_read   &lt;= 1'b1;
1382                              //if (first_word_read)
1383                              //begin
1384                                // Jump over status word
1385       1/1                      if ((!status_word0_obtained &amp; pkt_data_nxt_add == status_word0_nxt_add[queue_dma]) |
1386                                    (status_word0_obtained  &amp; pkt_data_nxt_add == status_word0_add_int))
1387       <font color = "red">0/1     ==>                pkt_data_sram_addr  &lt;= pkt_data_nxt_add2;</font>
1388                                else
1389       1/1                        pkt_data_sram_addr  &lt;= pkt_data_nxt_add;
1390                              //end
1391                            end
                        MISSING_ELSE
1392                          end
1393                        end
1394                      end
1395                      assign pkt_end_mod_aph  = |dma_bus_width | gem_tx_pbuf_data_w_is_128 ? status_word_0[15:12]
1396                                                                                           : {1'b0,status_word_0[14:12]};
1397                    
1398                      // in 32 bit modes, there are 2 locations used at the start of the frame for status, and 2 more at the end
1399                      // for 64/128 there is only 1 locn reserved at the start. This makes the end locn a bit more complex ..
1400                      wire [16:0] pkt_end_addr_intermediate;
1401                      wire [17:0] pkt_end_addr_sum1;
1402                      wire [16:0] pkt_end_addr_sum2;
1403                      
1404                      // pkt_end_addr_intermediate cannot overflow by construction so it will remain 17 bits. The same applies for pkt_end_addr_sum1 
1405                      // and pkt_end_addr_sum2 too.
1406                      // AFL is complaining about plt_end_addr_sum1 to have a bit more, so we will increase its size
1407                      // and do a part select for the calculation of pkt_end_addr_sum2
1408                      assign pkt_end_addr_intermediate = {{(17-p_edma_tx_pbuf_addr){1'b0}},status_word0_add_int} + {5'd0,status_word_0[11:0]};  
1409                      assign pkt_end_addr_sum1         = pkt_end_addr_intermediate                               + {9'd0,status_word_0[23:16]};  
1410                      assign pkt_end_addr_sum2         = pkt_end_addr_sum1[16:0]                                 + {18'd0,1'b1};
1411                        
1412                      always @(*)
1413                      begin
1414       1/1              if (|dma_bus_width || gem_tx_pbuf_data_w_is_128)
1415       <font color = "red">0/1     ==>        pkt_end_addr_int = pkt_end_addr_sum1[16:0];</font>
1416                        else
1417       1/1                pkt_end_addr_int = pkt_end_addr_sum2;
1418                      end
1419                    
1420                      wire [11:0] num_sram_rds_c;
1421                      wire [11:0] num_sram_rds;
1422                      assign num_sram_rds_c = nxt_sw0_nxt[11:0];
1423                    
1424                      assign num_sram_rds = status_word_0[11:0] ;
1425                    
1426                      // The last read to the SRAM (req ph) occurs when pkt_dplocns_cnt == num_sram_rds
1427                      wire                      reading_pkt_last_word_sram_req;
1428                      assign reading_pkt_last_word_sram_req_c = pkt_dplocns_cnt == num_sram_rds_c;
1429                      assign reading_pkt_last_word_sram_req   = pkt_dplocns_cnt == num_sram_rds &amp; status_word0_obtained;
1430                    
1431                      // When the width of the SRAM = the datawidth feeding the MAC, then reading_pkt_last_word_req
1432                      // is the same as reading_pkt_last_word_sram_req.
1433                      // Otherwise when we are downsizing, it depends on the MOD (number of bytes to feed into the MAC).
1434                      // these flops are only required in 128bit DP's, since downsizing only happens then
1435                      generate if (p_edma_tx_pbuf_data == 32'd128) begin : gen_flops_for_128bitDP
1436                        wire [3:0] pkt_end_mod_rph;  // Packet end mod, rph timed
1437                        wire [3:0] pkt_end_mod_nxt;  // Packet end mod rph timed, just valid while in the IDLE state
1438                        reg        reading_pkt_last_word_sram_d1;
1439                        reg        reading_pkt_last_word_sram_d2;
1440                        reg        reading_pkt_last_word_sram_d3;
1441                        assign     pkt_end_mod_rph  = read_state_tr_idle2data ? pkt_end_mod_nxt  : pkt_end_mod_aph;
1442                        assign     pkt_end_mod_nxt  = |dma_bus_width | gem_tx_pbuf_data_w_is_128 ? nxt_sw0_nxt[15:12]
1443                                                                                                 : {1'b0,nxt_sw0_nxt[14:12]};
1444                    
1445                        always@(posedge tx_r_clk or negedge tx_r_rst_n)
1446                        begin
1447                          if (~tx_r_rst_n)
1448                          begin
1449                            reading_pkt_last_word_sram_d1 &lt;= 1'b0;
1450                            reading_pkt_last_word_sram_d2 &lt;= 1'b0;
1451                            reading_pkt_last_word_sram_d3 &lt;= 1'b0;
1452                          end
1453                          else
1454                          begin
1455                            if (complete_flush | read_state_nxt == IDLE )
1456                            begin
1457                              reading_pkt_last_word_sram_d1 &lt;= 1'b0;
1458                              reading_pkt_last_word_sram_d2 &lt;= 1'b0;
1459                              reading_pkt_last_word_sram_d3 &lt;= 1'b0;
1460                            end
1461                            else if (|tx_r_rd_int)
1462                            begin
1463                              if (empty_next_downsize)
1464                                reading_pkt_last_word_sram_d1 &lt;= sample_sw0 ? reading_pkt_last_word_sram_req_c : reading_pkt_last_word_sram_req;
1465                              reading_pkt_last_word_sram_d2   &lt;= reading_pkt_last_word_sram_d1;
1466                              reading_pkt_last_word_sram_d3   &lt;= reading_pkt_last_word_sram_d2;
1467                            end
1468                          end
1469                        end
1470                    
1471                        always @(*)
1472                        begin
1473                          if (emac_bus_width == 2'b00)
1474                          begin
1475                            if (pkt_end_mod_rph &lt;= 4'h4 &amp; pkt_end_mod_rph &gt; 4'h0 &amp; empty_next_downsize)
1476                              reading_pkt_last_word_req_c = |tx_r_rd_int &amp; reading_pkt_last_word_sram_req_c;
1477                            else if (pkt_end_mod_rph &lt;= 4'h8 &amp; pkt_end_mod_rph != 4'h0)
1478                              reading_pkt_last_word_req_c = |tx_r_rd_int &amp; reading_pkt_last_word_sram_d1;
1479                            else if (pkt_end_mod_rph &lt;= 4'hc &amp; pkt_end_mod_rph != 4'h0)
1480                              reading_pkt_last_word_req_c = |tx_r_rd_int &amp; reading_pkt_last_word_sram_d2;
1481                            else
1482                              reading_pkt_last_word_req_c = |tx_r_rd_int &amp; reading_pkt_last_word_sram_d3;
1483                          end
1484                          else if (emac_bus_width == 2'b01)
1485                          begin
1486                            if (pkt_end_mod_rph &lt;= 4'h8 &amp; pkt_end_mod_rph &gt; 4'h0 &amp; empty_next_downsize)
1487                              reading_pkt_last_word_req_c = |tx_r_rd_int &amp; reading_pkt_last_word_sram_req_c;
1488                            else
1489                              reading_pkt_last_word_req_c = |tx_r_rd_int &amp; reading_pkt_last_word_sram_d1;
1490                          end
1491                          else
1492                            reading_pkt_last_word_req_c = |tx_r_rd_int &amp; reading_pkt_last_word_sram_req_c;
1493                        end
1494                    
1495                        always @(*)
1496                        begin
1497                          if (emac_bus_width == 2'b00)
1498                          begin
1499                            if (pkt_end_mod_rph &lt;= 4'h4 &amp; pkt_end_mod_rph &gt; 4'h0 &amp; empty_next_downsize)
1500                              reading_pkt_last_word_req = |tx_r_rd_int &amp; reading_pkt_last_word_sram_req;
1501                            else if (pkt_end_mod_rph &lt;= 4'h8 &amp; pkt_end_mod_rph != 4'h0)
1502                              reading_pkt_last_word_req = |tx_r_rd_int &amp; reading_pkt_last_word_sram_d1;
1503                            else if (pkt_end_mod_rph &lt;= 4'hc &amp; pkt_end_mod_rph != 4'h0)
1504                              reading_pkt_last_word_req = |tx_r_rd_int &amp; reading_pkt_last_word_sram_d2;
1505                            else
1506                              reading_pkt_last_word_req = |tx_r_rd_int &amp; reading_pkt_last_word_sram_d3;
1507                          end
1508                          else if (emac_bus_width == 2'b01)
1509                          begin
1510                            if (pkt_end_mod_rph &lt;= 4'h8 &amp; pkt_end_mod_rph &gt; 4'h0 &amp; empty_next_downsize)
1511                              reading_pkt_last_word_req = |tx_r_rd_int &amp; reading_pkt_last_word_sram_req;
1512                            else
1513                              reading_pkt_last_word_req = |tx_r_rd_int &amp; reading_pkt_last_word_sram_d1;
1514                          end
1515                    
1516                          else
1517                            reading_pkt_last_word_req = |tx_r_rd_int &amp; reading_pkt_last_word_sram_req;
1518                        end
1519                    
1520                      end else begin : gen_no_flops_for_128bitDP
1521                        always @(*)
1522                        begin
1523       1/1                reading_pkt_last_word_req_c = |tx_r_rd_int &amp; reading_pkt_last_word_sram_req_c;
1524       1/1                reading_pkt_last_word_req = |tx_r_rd_int &amp; reading_pkt_last_word_sram_req;
1525                        end
1526                      end
1527                      endgenerate
1528                    
1529                    
1530                      assign reading_pkt_last_word_req_vld = sample_sw0 ? reading_pkt_last_word_req_c : reading_pkt_last_word_req;
1531                    
1532                      assign status_word0_add = bind2queueRange((status_word0_add_int),
1533                                                                   TX_PBUF_SEGMENTS_UPPER_ADDR_ARRAY[queue_dma],
1534                                                                   TX_PBUF_SEGMENTS_LOWER_ADDR_ARRAY[queue_dma],
1535                                                                   TX_PBUF_NUM_SEGMENTS_ARRAY[queue_dma]);
1536                    
1537                      // error, but need to replay the pkt that has just been sent to MAC
1538                      assign replay_residual_frame = (pkt_mac_sent &amp; (late_coll_occured|too_many_retries) &amp; num_pkts_in_mac[1]);
1539                    
1540                      assign need_to_replay = replay_residual_frame | coll_occurred_le | need_to_replay_r;
1541                    
1542                    
1543                      // If we are in half duplex mode, it is possible the transmission will suffer collisions.
1544                      // For normal collisions, we will restart the transmission.
1545                      // this is complicated by the fact we might get collisions after the frame has left the DMA
1546                      // I.e. a collision during the last few bytes of the frame. To do this, we need to
1547                      // remember up to two status word_1's. The first is the one associated with the frame that caused
1548                      // the collision (status_word_mac_0). We already have this stored. The second is the one that
1549                      // is associated with the frame we are currently sending to the MAC. This may be different to the
1550                      // first one if the collision happened on a frame that has completely been sent in the past to the MAC
1551                      always@(*)
1552                      begin
1553       1/1              if (need_to_replay)
1554       <font color = "red">0/1     ==>        num_pkts_in_mac_nxt = 2'b00;</font>
1555       1/1              else if (read_state == IDLE &amp;&amp; read_state_nxt != IDLE)
1556                        begin
1557       1/1                if (~sw_mac_fifo_pop)
1558       1/1                  num_pkts_in_mac_nxt = num_pkts_in_mac + 2'b01;
1559                          else
1560       <font color = "red">0/1     ==>          num_pkts_in_mac_nxt = num_pkts_in_mac;</font>
1561                        end
1562       1/1              else if (sw_mac_fifo_pop)
1563       1/1                num_pkts_in_mac_nxt = num_pkts_in_mac - 2'b01;
1564                        else
1565       1/1                num_pkts_in_mac_nxt = num_pkts_in_mac;
1566                      end
1567                    
1568                    
1569                      always@(posedge tx_r_clk or negedge tx_r_rst_n)
1570                      begin
1571       1/1              if (~tx_r_rst_n)
1572                        begin
1573       1/1                num_pkts_in_mac             &lt;= 2'b00;
1574       1/1                store_mac_sw0_en            &lt;= 2'b00;
1575       1/1                store_1st_sw0               &lt;= {p_dword_w+p_edma_tx_pbuf_addr+4{1'b0}};
1576       1/1                store_2nd_sw0               &lt;= {p_dword_w+p_edma_tx_pbuf_addr+4{1'b0}};
1577       1/1                need_to_replay_r            &lt;= 1'b0;
1578                        end
1579                        else
1580                        begin
1581       1/1                if (complete_flush)
1582                          begin
1583       1/1                  num_pkts_in_mac             &lt;= 2'b00;
1584       1/1                  store_mac_sw0_en            &lt;= 2'b00;
1585       1/1                  store_1st_sw0               &lt;= {p_dword_w+p_edma_tx_pbuf_addr+4{1'b0}};
1586       1/1                  store_2nd_sw0               &lt;= {p_dword_w+p_edma_tx_pbuf_addr+4{1'b0}};
1587       1/1                  need_to_replay_r            &lt;= 1'b0;
1588                          end
1589                          else
1590                          begin
1591       1/1                  num_pkts_in_mac             &lt;= num_pkts_in_mac_nxt;
1592       1/1                  if (status_word2_obtained &amp; status_word3_obtained)
1593       1/1                    need_to_replay_r          &lt;= 1'b0;
1594       1/1                  else if (need_to_replay &amp; read_state != IDLE)
1595       <font color = "red">0/1     ==>            need_to_replay_r          &lt;= 1'b1;</font>
                        MISSING_ELSE
1596                    
1597       1/1                  if (need_to_replay &amp; ~store_mac_sw0_en[1])
1598                            begin
1599                              // Case 1 :  collision occuring while frame is being transferred, 1 pkt_in_mac - need to replay
1600       <font color = "red">0/1     ==>            if (num_pkts_in_mac == 2'b01 &amp; read_state != IDLE)</font>
1601                              begin
1602       <font color = "red">0/1     ==>              store_mac_sw0_en      &lt;= 2'b01;</font>
1603       <font color = "red">0/1     ==>              store_1st_sw0         &lt;= {status_word0_add_mac,queue_mac,status_word_mac_0};</font>
1604       <font color = "red">0/1     ==>              store_2nd_sw0         &lt;= {p_dword_w+p_edma_tx_pbuf_addr+4{1'b0}};</font>
1605                              end
1606                              // Case 2 : collision occuring after frame has being transferred, 1 pkt_in_mac - need to replay and shift
1607       <font color = "red">0/1     ==>            else if (num_pkts_in_mac == 2'b01)</font>
1608                              begin
1609       <font color = "red">0/1     ==>              store_mac_sw0_en      &lt;= store_mac_sw0_en + 2'b01;</font>
1610       <font color = "red">0/1     ==>              store_1st_sw0         &lt;= {status_word0_add_mac,queue_mac,status_word_mac_0};</font>
1611       <font color = "red">0/1     ==>              store_2nd_sw0         &lt;= store_1st_sw0;</font>
1612                              end
1613                              // Case 3 : normal collision, 2 pkt_in_mac, replay oldest
1614       <font color = "red">0/1     ==>            else if (num_pkts_in_mac == 2'b10 &amp; !replay_residual_frame)</font>
1615                              begin
1616       <font color = "red">0/1     ==>              store_mac_sw0_en      &lt;= 2'b10;</font>
1617       <font color = "red">0/1     ==>              store_1st_sw0         &lt;= {status_word0_add_mac,queue_mac,status_word_mac_0};</font>
1618       <font color = "red">0/1     ==>              store_2nd_sw0         &lt;= {status_word0_add,    queue_dma,status_word_0};</font>
1619                              end
1620                              // Case 4 : late collision/tmr, 2 pkt_in_mac, replay newest
1621                              else //if (num_pkts_in_mac == 2'b10)
1622                              begin
1623       <font color = "red">0/1     ==>              store_mac_sw0_en      &lt;= 2'b01;</font>
1624       <font color = "red">0/1     ==>              store_1st_sw0         &lt;= {status_word0_add,    queue_dma,status_word_0};</font>
1625       <font color = "red">0/1     ==>              store_2nd_sw0         &lt;= {p_dword_w+p_edma_tx_pbuf_addr+4{1'b0}};</font>
1626                              end
1627                            end
1628       1/1                  else if (read_state != IDLE &amp; read_state_nxt == IDLE &amp; (|store_mac_sw0_en) &amp; ~need_to_replay)
1629                            begin
1630       <font color = "red">0/1     ==>            store_mac_sw0_en      &lt;= store_mac_sw0_en - 2'b01;</font>
1631       <font color = "red">0/1     ==>            store_1st_sw0         &lt;= store_2nd_sw0;</font>
1632       <font color = "red">0/1     ==>            store_2nd_sw0         &lt;= {p_dword_w+p_edma_tx_pbuf_addr+4{1'b0}};</font>
1633                            end
                        MISSING_ELSE
1634                          end
1635                        end
1636                      end
1637                    
1638                      reg tx_r_control_r;
1639                    
1640                      always@(posedge tx_r_clk or negedge tx_r_rst_n)
1641                      begin
1642       1/1              if (~tx_r_rst_n)
1643                        begin
1644       1/1                reading_pkt_last_word_add   &lt;= 1'b0;
1645       1/1                tx_r_mod_dph                &lt;= 4'h0;
1646       1/1                tx_r_flushed_uflow          &lt;= 1'b0;
1647       1/1                tx_r_underflow_dph          &lt;= 1'b0;
1648       1/1                tx_r_sop_aph                &lt;= 1'b0;
1649       1/1                tx_r_sop_dph                &lt;= 1'b1;
1650       1/1                tx_r_eop_dph                &lt;= 1'b0;
1651       1/1                tx_r_err_dph                &lt;= 1'b0;
1652       1/1                tx_r_valid_dph              &lt;= 1'b0;
1653       1/1                tx_r_data_rdy_aph           &lt;= {p_edma_queues{1'b0}};
1654       1/1                tx_r_control_r              &lt;= 1'b0;
1655       1/1                tx_r_pip                    &lt;= 1'b0;
1656                        end
1657                        else
1658                        begin
1659       1/1                if (complete_flush)
1660                          begin
1661       1/1                  reading_pkt_last_word_add   &lt;= 1'b0;
1662       1/1                  tx_r_mod_dph                &lt;= 4'h0;
1663       1/1                  tx_r_flushed_uflow          &lt;= 1'b0;
1664       1/1                  tx_r_underflow_dph          &lt;= 1'b0;
1665       1/1                  tx_r_sop_dph                &lt;= 1'b1;
1666       1/1                  tx_r_eop_dph                &lt;= 1'b0;
1667       1/1                  tx_r_err_dph                &lt;= 1'b0;
1668       1/1                  tx_r_sop_aph                &lt;= 1'b0;
1669       1/1                  tx_r_valid_dph              &lt;= 1'b0;
1670       1/1                  tx_r_data_rdy_aph           &lt;= {p_edma_queues{1'b0}};
1671       1/1                  tx_r_control_r              &lt;= 1'b0;
1672       1/1                  tx_r_pip                    &lt;= 1'b0;
1673                          end
1674                          else
1675                          begin
1676       1/1                  tx_r_control_r  &lt;= tx_r_control;
1677                    
1678       1/1                  if (|tx_r_rd_int)
1679       1/1                    reading_pkt_last_word_add &lt;= reading_pkt_last_word_req_vld;
                        MISSING_ELSE
1680                    
1681       1/1                  for (b1=0;b1&lt;p_edma_queues[31:0];b1=b1+1)
1682                            begin
1683                              // Clear the stored tx_r_data_rdy on the last request
1684                              // Also need to clear everything down if we are about to replay due to a collision or if there was an udnerflow
1685       1/1                    if (need_to_replay | uflow_wait_for_dma)
1686       <font color = "red">0/1     ==>              tx_r_data_rdy_aph[b1]   &lt;= 1'b0;</font>
1687       1/1                    else if (tx_r_rd[b1] &amp; reading_pkt_last_word_add)
1688       1/1                      tx_r_data_rdy_aph[b1]   &lt;= tx_r_data_rdy_rph[b1];
1689       1/1                    else if (tx_r_data_rdy_rph[b1])
1690       1/1                      tx_r_data_rdy_aph[b1]   &lt;= 1'b1;
                        MISSING_ELSE
1691                            end
1692                    
1693       1/1                  tx_r_valid_dph              &lt;= |tx_r_rd;
1694                    
1695       1/1                  tx_r_mod_dph                &lt;= pkt_end_mod_aph[3:0];
1696       1/1                  tx_r_underflow_dph          &lt;= |tx_r_rd &amp; dpram_almost_empty_sync[queue_dma] &amp; start_reading_at_risk_q[queue_dma];
1697       1/1                  tx_r_sop_aph                &lt;= read_state_tr_idle2data;
1698       1/1                  tx_r_sop_dph                &lt;= tx_r_sop_aph;
1699       1/1                  tx_r_eop_dph                &lt;= (|tx_r_rd &amp; reading_pkt_last_word_add);
1700       1/1                  tx_r_err_dph                &lt;= (|tx_r_rd &amp; reading_pkt_last_word_add &amp; (|status_word_0[30:28]));
1701       1/1                  tx_r_flushed_uflow          &lt;= underflow_frame;
1702                    
1703       1/1                  if (tx_r_sop_aph)
1704       1/1                    tx_r_pip  &lt;= 1'b1;
1705       1/1                  else if (tx_r_eop_dph)
1706       1/1                    tx_r_pip  &lt;= 1'b0;
                        MISSING_ELSE
1707                    
1708                          end
1709                        end
1710                      end
1711                    
1712                      // Make combinatorial. This has allowed us to register the tx_r_rd_int signal from MAC to DMA
1713                      // thus breaking a long timing path (hurting slow FPGA builds).  It also saves a lot of gates -
1714                      // disadvantage is that the SRAM databus goes straight to the MAC block now ...
1715                      always@(*)
1716                      begin
1717       1/1              tx_r_valid                  = tx_r_valid_dph;
1718       1/1              tx_r_eop                    = tx_r_eop_dph;
1719                    
1720       1/1              if (status_word0_obtained)
1721       1/1                tx_r_control   = status_word_0[27] &amp; ~status_word_0[31];
1722       1/1              else if (tx_r_eop &amp; tx_r_valid)
1723       1/1                tx_r_control   = 1'b0;
1724                        else
1725       1/1                tx_r_control   = tx_r_control_r;
1726                    
1727       1/1              tx_r_mod                    = tx_r_mod_dph;
1728       1/1              tx_r_flushed                = coll_occurred_le | (pkt_mac_sent &amp; (late_coll_occured|too_many_retries)) | tx_r_flushed_uflow;
1729       1/1              tx_r_underflow              = tx_r_underflow_dph;
1730       1/1              tx_r_sop                    = tx_r_sop_dph;
1731       1/1              tx_r_err                    = tx_r_err_dph;
1732                      end
1733                    
1734                      assign tx_r_data_rdy  = tx_r_data_rdy_aph;
1735                    //  assign tx_r_data_rdy  = (tx_r_data_rdy_rph &amp; ~{p_edma_queues{uflow_wait_for_dma}}) | tx_r_data_rdy_aph;
1736                    
1737                      // This bus  is passed through directly out of
1738                      // this module and out of the DMA as tx_r_data.
1739                      assign tx_r_data      = (tx_r_pip &amp; tx_r_valid_dph) ? tx_dob_downsize[p_emac_bus_width-1:0]
1740                                                                          : {p_emac_bus_width{1'b0}};
1741                      assign tx_r_data_par  = (tx_r_pip &amp; tx_r_valid_dph) ? tx_dob_downsize_par[p_emac_bus_pwid-1:0]
1742                                                                          : {p_emac_bus_pwid{1'b0}};
1743                    
1744                    // -----------------------------------------------------------------------------------------------
1745                    // Now decide how to free up SRAM resources ...
1746                    // This is dependent on the mode of operation  ...
1747                    //  1) Only free up SRAM resources once the frame has been known to have transmitted to the wire.
1748                    //     This is after the last byte has been forwarded to the MAC, and which has also completely
1749                    //     passed through the MAC TX pipeline.  For this, we need to keep track of the number
1750                    //     of SRAM locations used by the frame until the frame has passed out of the MAC. This info
1751                    //     is held in the status words of a frame.
1752                    //     This mode of operation is needed when we need to replay the current frame from the start,
1753                    //     because of half duplex collisions, or because we want to repeat transmission of a frame
1754                    //     for whatever reason.
1755                    //
1756                    //  2) Free up SRAM locations as they are read and forwarded to the MAC.  We can do this in most
1757                    //     full duplex configurations, assuming we definately do not want to repeat the frame.  We must
1758                    //     do this in cut-through configs. Freeing up locations dynamically helps performance as well as
1759                    //     SRAM utilization. Performace is improved as the AXI/AHB side of the DMA can fill up space earlier
1760                    //     than it would otherwise do.  SRAM utilization is improved - we can support equal performance with
1761                    //     smaller SRAM's.
1762                    
1763                      // First select the mode ...
1764                      assign data_to_mac_xfer_mode = full_duplex;
1765                    
1766                      // The total number of locations to free up is stored in a bank of flops called
1767                      // clr_dplocns_val.
1768                      // When we first sample the status words, we can also capture the total number of SRAM locations used
1769                      // by this frame, which is stored in SW0.  This will depend on the size of the frame, and also the
1770                      // number of locations used to store the status words (which itself depends on the width of the SRAM).
1771                      // For mode 1 above, this signal will not change while the frame is being sent to the MAC.
1772                      // For mode 2 above however, we will reduce this periodically after a fixed amount of packet data
1773                      // has been forwarded. This fixed amount is set in parameter &quot;partpkt_threshold&quot;
1774                      assign part_pkt_trigger = (sram_req_gnt[0] &amp; ~reading_pkt_last_word_req_vld &amp; data_to_mac_xfer_mode &amp; !sample_sw0 &amp;
1775                                                 {12'd0,pkt_dplocns_cnt_part} == {{(17-p_edma_tx_pbuf_addr){1'b0}},partpkt_threshold[p_edma_tx_pbuf_addr-1:0]});
1776                    
1777                      reg [12:0] clr_dplocns_val_nxt;
1778                      reg [5:0]  pkt_dplocns_cnt_part_nxt;
1779                      reg [12:0] pkt_dplocns_cnt_nxt;
1780                      wire [16:0] tmp_clr_dplocns_nxt;
1781                      assign tmp_clr_dplocns_nxt = {5'd0,clr_dplocns_val} - {{(17-p_edma_tx_pbuf_addr){1'b0}},partpkt_threshold[p_edma_tx_pbuf_addr-1:0]};
1782                      always @(*)
1783                      begin
1784       1/1                if (read_state_nxt == IDLE | part_pkt_trigger)
1785       1/1                  pkt_dplocns_cnt_part_nxt = 5'h01;
1786       1/1                else if (sram_req_gnt[0] &amp; data_to_mac_xfer_mode)
1787       1/1                  pkt_dplocns_cnt_part_nxt = pkt_dplocns_cnt_part + 5'h01;
1788                          else
1789       1/1                  pkt_dplocns_cnt_part_nxt = {1'b0,pkt_dplocns_cnt_part};
1790                    
1791       1/1                if (read_state_nxt == IDLE)
1792       1/1                  pkt_dplocns_cnt_nxt    = 12'h001;
1793       1/1                else if (sram_req_gnt[0])
1794       1/1                  pkt_dplocns_cnt_nxt    = pkt_dplocns_cnt + 12'h001;
1795                          else
1796       1/1                  pkt_dplocns_cnt_nxt    = {1'b0,pkt_dplocns_cnt};
1797                    
1798       1/1                if (read_state_nxt == IDLE &amp;&amp; read_state != IDLE)
1799       1/1                  clr_dplocns_val_nxt    = 13'd0;
1800       1/1                else if (|store_mac_sw0_en &amp; read_state_tr_idle2data) // replaying a frame from storage buffer
1801       <font color = "red">0/1     ==>          clr_dplocns_val_nxt  = {1'b0,nxt_sw0_nxt[11:0]};</font>
1802       1/1                else if (sample_sw0)
1803       1/1                  clr_dplocns_val_nxt  = clr_dplocns_val + nxt_sw0_nxt[11:0];
1804                          else
1805                          begin
1806                            // Now reduce clr_dplocns_val as we progress through the frame ...
1807       1/1                  if (part_pkt_trigger)
1808       1/1                    clr_dplocns_val_nxt  = tmp_clr_dplocns_nxt[12:0];
1809                            else
1810       1/1                    clr_dplocns_val_nxt  = {1'b0,clr_dplocns_val};
1811                          end
1812                      end
1813                    
1814                      always @(posedge tx_r_clk or negedge tx_r_rst_n)
1815                      begin
1816       1/1              if (~tx_r_rst_n)
1817                        begin
1818       1/1                clr_dplocns_val       &lt;= 12'd0;
1819       1/1                pkt_dplocns_cnt_part  &lt;= 5'h00;
1820       1/1                pkt_dplocns_cnt       &lt;= 12'd0;
1821                        end
1822                        else
1823                        begin
1824       1/1                if (complete_flush)
1825                          begin
1826       1/1                  clr_dplocns_val       &lt;= 12'd0;
1827       1/1                  pkt_dplocns_cnt_part  &lt;= 5'h00;
1828       1/1                  pkt_dplocns_cnt       &lt;= 12'd0;
1829                          end
1830                          else
1831                          begin
1832       1/1                  clr_dplocns_val       &lt;= clr_dplocns_val_nxt[11:0];
1833       1/1                  pkt_dplocns_cnt_part  &lt;= pkt_dplocns_cnt_part_nxt[4:0];
1834       1/1                  pkt_dplocns_cnt       &lt;= pkt_dplocns_cnt_nxt[11:0];
1835                          end
1836                        end
1837                      end
1838                    
1839                    // The actual mechanism to free up SRAM locations is a handshake between this module and the AXI/AHB
1840                    // side of the DMA.  This is across a clock boundary and is handled using toggles.
1841                    // To free up part of the packet (Fixed at partpkt_threshold), we can just send the toggle directly
1842                    // without any accompanying information (other than the queue), since the AHB/AXI side can assume
1843                    // the number of locations is partpkt_threshold.
1844                    // Note that we assume the AXI/AHB clock frequency is at least 1/4 of the tx_clk frequency for this
1845                    // to sample correctly.
1846                      always@(posedge tx_r_clk or negedge tx_r_rst_n)
1847                      begin
1848       1/1              if (~tx_r_rst_n)
1849                        begin
1850       1/1                part_pkt_queue  &lt;= 4'h0;
1851       1/1                part_pkt_read   &lt;= 1'b0;
1852                        end
1853       1/1              else if (complete_flush)
1854                        begin
1855       1/1                part_pkt_queue  &lt;= 4'h0;
1856       1/1                part_pkt_read   &lt;= part_pkt_read;
1857                        end
1858       1/1              else if (part_pkt_trigger)
1859                        begin
1860       1/1                part_pkt_queue  &lt;= queue_dma;
1861       1/1                part_pkt_read   &lt;= ~part_pkt_read;
1862                        end
                        MISSING_ELSE
1863                      end
1864                    
1865                    // For the update at the end of the frame, we will send the clr_dplocns_val information
1866                    // along with other bits of the status information so the AHB/AXI can initiate a descriptor
1867                    // writeback, as well as free up the last remaining DPRAM locations.
1868                    // One complication to this is that we need to wait until the frame has successfully been
1869                    // sent to the wire before issuing the command.  Unfortunately this means we have to buffer
1870                    // all this information since the status words are lost once the final byte has been pushed
1871                    // to the MAC. We need to buffer the status information locally.
1872                    // We dont allow more than two EOP's in the MAC pipeline at any one time, so we should only have to
1873                    // buffer the status words twice ...
1874                    
1875                      // First Identify when the MAC actually transmits a frame to the wire ...
1876                      reg           dma_tx_end_tog_prev;        // MAC has transmitted the pkt
1877                      reg           dma_tx_small_end_tog_prev;  // XGM MAC has transmitted the small pkt
1878                      always@(posedge tx_r_clk or negedge tx_r_rst_n)
1879                      begin
1880       1/1              if (~tx_r_rst_n)
1881                        begin
1882       1/1                dma_tx_end_tog_prev       &lt;= 1'b0;
1883       1/1                dma_tx_small_end_tog_prev &lt;= 1'b0;
1884                        end
1885       1/1              else if (complete_flush)
1886                        begin
1887       1/1                dma_tx_end_tog_prev       &lt;= dma_tx_end_tog_prev;
1888       1/1                dma_tx_small_end_tog_prev &lt;= dma_tx_small_end_tog_prev;
1889                        end
1890                        else
1891                        begin
1892       1/1                dma_tx_end_tog_prev       &lt;= dma_tx_end_tog;
1893       1/1                dma_tx_small_end_tog_prev &lt;= dma_tx_small_end_tog;
1894                        end
1895                      end
1896                    
1897                      // dma_tx_status_tog
1898                      // Signal completion back to the gem_tx module. This toggle
1899                      // handshaking signal is set once both management writeback has
1900                      // completed and the pclk update has completed.
1901                      // Additionally if a collision has occured, this same handshaking
1902                      // mechanism is used by gem_tx to indicate that the collision has
1903                      // been seen and serviced by the DMA.
1904                      always@(posedge tx_r_clk or negedge tx_r_rst_n)
1905                      begin
1906       1/1            if (~tx_r_rst_n)
1907       1/1              dma_tx_status_tog &lt;= 1'b0;
1908                      else
1909                        begin
1910       1/1                if (pkt_mac_sent | coll_occurred_le)
1911       1/1                  dma_tx_status_tog &lt;= ~dma_tx_status_tog;
                        MISSING_ELSE
1912                        end
1913                      end
1914                    
1915                      // Detect edge on collision for acknowledge toggle
1916                      reg                 coll_occurred_d1;
1917                      always@(posedge tx_r_clk or negedge tx_r_rst_n)
1918                      begin
1919       1/1              if (~tx_r_rst_n)
1920       1/1                coll_occurred_d1 &lt;= 1'b0;
1921                        else
1922       1/1                coll_occurred_d1 &lt;= collision_occured;
1923                      end
1924                    
1925                      // Detect leading edge
1926                      assign coll_occurred_le =  collision_occured &amp; ~coll_occurred_d1;
1927                    
1928                    
1929                      assign pkt_mac_sent = (dma_tx_end_tog_prev        ^ dma_tx_end_tog) |
1930                                            (dma_tx_small_end_tog_prev  ^ dma_tx_small_end_tog);
1931                    
1932                      // now buffer the status words and the number of words to free up ...
1933                      assign sw_mac_fifo_push = sample_sw0;
1934                      assign sw_mac_fifo_din =  |store_mac_sw0_en ? {store_1st_sw0[p_dword_w+p_edma_tx_pbuf_addr+3:p_dword_w+4],store_1st_sw0[p_dword_w-1:0]}
1935                                                                  : {status_word0_nxt_add[queue_dma_c],status_word0_nxt[queue_dma_c]};
1936                    
1937                    // status word 0 (mac version) info might be needed if we need to replay the frame, which might happen as we
1938                    // xfer the frame through to the MAC from the DMA. We therefore need to load it as soon as we have it.
1939                    // For this info, we actually have it right from the start for full store and forward mode. It is later in
1940                    // partial store and forward mode, but we dont support replays in PSF.
1941                      edma_gen_fifo #( .FIFO_WIDTH(p_dword_w+p_edma_tx_pbuf_addr),
1942                                       .FIFO_DEPTH(2),
1943                                       .FIFO_ADDR_WIDTH(4'd1)
1944                                     ) i_status_word0_mac (
1945                    
1946                        .qout       ({status_word0_add_mac,status_word_mac_0}),
1947                        .qempty     (sw_mac_fifo_empty),
1948                        .qfull      (sw_mac_fifo_full),
1949                        .qlevel     (),
1950                        .clk_pcie   (tx_r_clk),
1951                        .rst_n      (tx_r_rst_n),
1952                    
1953                        .din        (sw_mac_fifo_din),
1954                        .push       (sw_mac_fifo_push),
1955                        .flush      (complete_flush | need_to_replay),
1956                        .pop        (sw_mac_fifo_pop)
1957                      );
1958                    
1959                       // add in the status words used for each frame...
1960                       reg  [12:0] clr_dplocns_val_pstatus;
1961                       always @(*)
1962                       begin
1963       1/1               if (gem_tx_pbuf_data_w_is_128)
1964       <font color = "red">0/1     ==>         clr_dplocns_val_pstatus  = clr_dplocns_val + 12'd1;</font>
1965       1/1               else if (dma_bus_width[0])
1966       <font color = "red">0/1     ==>         clr_dplocns_val_pstatus  = clr_dplocns_val + 12'd2;</font>
1967                         else
1968       1/1                 clr_dplocns_val_pstatus  = clr_dplocns_val + 12'd4;
1969                       end
1970                    
1971                    // the other status words, and the number of locations to clear for this frame dont need to be loaded until we
1972                    // finish processing the frame. This is beasically when we transition to IDLE.
1973                    // Also has parity if necessary
1974                      wire   read_state_nxt_is_idle;
1975                      assign read_state_nxt_is_idle = (read_state_nxt == IDLE);
1976                       
1977                      edma_gen_fifo #( .FIFO_WIDTH((p_dword_w*2)+12),
1978                                       .FIFO_DEPTH(2),
1979                                       .FIFO_ADDR_WIDTH(4'd1)
1980                                     ) i_status_word23_mac (
1981                    
1982                        .qout       ({clr_dplocns_val_mac,status_word_mac_3,status_word_mac_2}),
1983                        .qempty     (sw_mac_fifo_2_empty),
1984                        .qfull      (),
1985                        .qlevel     (),
1986                        .clk_pcie   (tx_r_clk),
1987                        .rst_n      (tx_r_rst_n),
1988                    
1989                        .din        ({clr_dplocns_val_pstatus[11:0],status_word_3,status_word_2}),
1990                        .push       (read_state_nxt_is_idle &amp;&amp; status_word3_obtained &amp; (|num_pkts_in_mac)),
1991                        .flush      (complete_flush | need_to_replay),
1992                        .pop        (sw_mac_fifo_pop)
1993                      );
1994                    
1995                    // The pop for both the FIFO's above should be when the MAC layer is completely done with the info.
1996                    // This is basically when the MAC has finished transmitting the frame to the wire, or when the status info at the
1997                    // head of the queue identifies a status only frame (in which case nothing is to be sent to the MAC).  There is
1998                    // one complication to this. for too many retries and late collisions, the MAC can signal pkt transmitted (via
1999                    // pkt_mac_sent) before the DMA has finished issuing the frame itself to the MAC. This means the FIFO's may not actually
2000                    // contain the data needed to pop.  To get around this, we first create a 'pop' signal, then we check if the fill
2001                    // levels of both FIFO's are the same. If they are, then we allow a pop.  If not, then we hold the pop signal until
2002                    // we do have the data.
2003                    // We also block this from popping if the downstream FIFO is full and cant take the contents.
2004                      assign sw_mac_fifo_pop_raw = ((pkt_mac_sent &amp; ~coll_occurred_le) |
2005                                                    status_word_mac_0[31]) &amp; !sw_mac_fifo_empty;
2006                    
2007                      always@(posedge tx_r_clk or negedge tx_r_rst_n)
2008                      begin
2009       1/1              if (~tx_r_rst_n)
2010                        begin
2011       1/1                sw_mac_fifo_pop_hold          &lt;= 1'b0;
2012       1/1                late_coll_occured_hold        &lt;= 1'b0;
2013       1/1                too_many_retries_hold         &lt;= 1'b0;
2014                        end
2015       1/1              else if (complete_flush)
2016                        begin
2017       1/1                sw_mac_fifo_pop_hold          &lt;= 1'b0;
2018       1/1                late_coll_occured_hold        &lt;= 1'b0;
2019       1/1                too_many_retries_hold         &lt;= 1'b0;
2020                        end
2021                        else
2022                        begin
2023       1/1                if      (sw_mac_fifo_pop_raw &amp; wb_status_to_tx_wr_fifo_full)
2024                          begin
2025       <font color = "red">0/1     ==>          sw_mac_fifo_pop_hold        &lt;= 1'b1;</font>
2026       <font color = "red">0/1     ==>          late_coll_occured_hold      &lt;= late_coll_occured;</font>
2027       <font color = "red">0/1     ==>          too_many_retries_hold       &lt;= too_many_retries;</font>
2028                          end
2029       1/1                else if (sw_mac_fifo_pop_raw &amp; sw_mac_fifo_2_empty)
2030                          begin
2031       <font color = "red">0/1     ==>          sw_mac_fifo_pop_hold        &lt;= 1'b1;</font>
2032       <font color = "red">0/1     ==>          late_coll_occured_hold      &lt;= late_coll_occured;</font>
2033       <font color = "red">0/1     ==>          too_many_retries_hold       &lt;= too_many_retries;</font>
2034                          end
2035       1/1                else if (!wb_status_to_tx_wr_fifo_full &amp; !sw_mac_fifo_2_empty)
2036                          begin
2037       1/1                  sw_mac_fifo_pop_hold        &lt;= 1'b0;
2038       1/1                  late_coll_occured_hold      &lt;= late_coll_occured_hold;
2039       1/1                  too_many_retries_hold       &lt;= too_many_retries_hold;
2040                          end
                        MISSING_ELSE
2041                        end
2042                      end
2043                      assign sw_mac_fifo_pop = ((sw_mac_fifo_pop_raw | sw_mac_fifo_pop_hold) &amp;
2044                                               (!wb_status_to_tx_wr_fifo_full &amp; !(sw_mac_fifo_empty | sw_mac_fifo_2_empty)));
2045                    
2046                      assign late_coll_occured_mac = sw_mac_fifo_pop_hold ? late_coll_occured_hold &amp; sw_mac_fifo_pop : late_coll_occured &amp; sw_mac_fifo_pop;
2047                      assign too_many_retries_mac  = sw_mac_fifo_pop_hold ? too_many_retries_hold &amp; sw_mac_fifo_pop : too_many_retries &amp; sw_mac_fifo_pop;
2048                    
2049                    // Now we have the information to send to the AHB/AXI side of the DMA.
2050                      always@(posedge tx_r_clk or negedge tx_r_rst_n)
2051                      begin
2052       1/1              if (~tx_r_rst_n)
2053                        begin
2054       1/1                full_pkt_read                 &lt;= 1'b0;
2055       1/1                xfer_status_captured_edge_d1  &lt;= 1'b0;
2056                        end
2057       1/1              else if (complete_flush)
2058                        begin
2059       1/1                full_pkt_read                 &lt;= full_pkt_read;
2060       1/1                xfer_status_captured_edge_d1  &lt;= 1'b0;
2061                        end
2062                        else
2063                        begin
2064       1/1                xfer_status_captured_edge_d1  &lt;= xfer_status_captured_edge &amp; !wb_status_to_tx_wr_fifo_empty;
2065       1/1                if ((xfer_status_captured_edge_d1 &amp; !wb_status_to_tx_wr_fifo_empty) |
2066                              (sw_mac_fifo_pop              &amp; wb_status_to_tx_wr_fifo_empty))
2067       1/1                  full_pkt_read               &lt;= ~full_pkt_read;
                        MISSING_ELSE
2068                    
2069                        end
2070                      end
2071                    
2072                      // The following is a 2 deep plumbing FIFO that stores the status information that is passed to
2073                      // the TX WR block.  It is loaded when a packet has been fully transmitted to the wire, or
2074                      // when a status only packet (errored, not passed to MAC) is detected - these status only
2075                      // frames are simply routed back to the TX WR
2076                      assign sword0_cmprsd_mac            = {sword0_cmprsd_mac_pad[18:15],sword0_cmprsd_mac_pad[13:0]};
2077                      edma_gen_fifo #( .FIFO_WIDTH(p_wb_fifo_w),
2078                                       .FIFO_DEPTH(2),
2079                                       .FIFO_ADDR_WIDTH(4'd1)
2080                                     ) i_wb_status_to_tx_wr_fifo (
2081                    
2082                        .qout       (wb_status_to_tx_wr_fifo_dout),
2083                        .qempty     (wb_status_to_tx_wr_fifo_empty),
2084                        .qfull      (wb_status_to_tx_wr_fifo_full),
2085                        .qlevel     (),
2086                        .clk_pcie   (tx_r_clk),
2087                        .rst_n      (tx_r_rst_n),
2088                    
2089                        .din        (wb_status_to_tx_wr_fifo_din),
2090                        .push       (sw_mac_fifo_pop),
2091                        .flush      (complete_flush),
2092                        .pop        (xfer_status_captured_edge)
2093                      );
2094                    
2095                      assign wb_status_to_tx_wr_fifo_afull = (!wb_status_to_tx_wr_fifo_empty &amp; sw_mac_fifo_pop) || wb_status_to_tx_wr_fifo_full;
2096                      assign sword0_cmprsd_mac_pad  = {status_word_mac_0[31:28],          // 18:15
2097                                                      1'd0,                               // 14
2098                                                      clr_dplocns_val_mac,                // 13:2
2099                                                      late_coll_occured_mac,              // 1
2100                                                      too_many_retries_mac} ;             // 0
2101                    
2102                    
2103                    
2104                    
2105                      // ---------------------------------------------------------------
2106                      // Underflow logic
2107                      // The initial underflow detection is made by tx_r_underflow_dph
2108                      // which looks at the current fill level of the DPRAM.
2109                      // if it is decided we are to underflow, then  tx_r_underflow is
2110                      // driven to the MAC.  The MAC will initiate it's own underflow
2111                      // logic and sometime in the future will drive underflow_frame
2112                      // On this, we need to perform a flush via tx_r_flushed and
2113                      // toggle the status back to the MAC via dma_tx_status_tog
2114                      // we will also drive an underflow_tog signal which will be
2115                      // passed back to the AHB side of the PBUF.  There, a full
2116                      // soft reset will be initiated, which in turn will be passed
2117                      // to this module via complete_flush.  Until this happens, we
2118                      // want to silence the MAC FIFO signals
2119                      always@(posedge tx_r_clk or negedge tx_r_rst_n)
2120                      begin
2121       1/1            if (~tx_r_rst_n)
2122                      begin
2123       1/1              uflow_wait_for_mac &lt;= 1'b0;
2124       1/1              uflow_wait_for_dma &lt;= 1'b0;
2125       1/1              underflow_tog  &lt;= 1'b0;
2126                      end
2127                      else
2128                      begin
2129       1/1              if (complete_flush)
2130                        begin
2131       1/1                uflow_wait_for_mac &lt;= 1'b0;
2132       1/1                uflow_wait_for_dma &lt;= 1'b0;
2133                        end
2134       1/1              else if (tx_r_underflow_dph)
2135                        begin
2136       <font color = "red">0/1     ==>        uflow_wait_for_mac &lt;= 1'b1;</font>
2137       <font color = "red">0/1     ==>        uflow_wait_for_dma &lt;= 1'b1;</font>
2138                        end
2139       1/1              else if (underflow_frame)
2140                        begin
2141       <font color = "red">0/1     ==>        uflow_wait_for_mac &lt;= 1'b0;</font>
2142       <font color = "red">0/1     ==>        if (uflow_wait_for_mac)</font>
2143       <font color = "red">0/1     ==>          underflow_tog &lt;= ~underflow_tog;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
2144                        end
                        MISSING_ELSE
2145                      end
2146                      end
2147                    
2148                    
2149                      // This function ensures a queue's upper address bits stay within its
2150                      // upper and lower address limits. dpram_addr_c will automatically increment
2151                      // on to the next address, which could be into the next queue's segment
2152                      // space. We therefore stop this happening by checking the segment bounds.
2153                    
2154                      function [p_edma_tx_pbuf_addr-1:0] bind2queueRange (
2155                        input [p_edma_tx_pbuf_addr-1:0] addr,
2156                        input [p_edma_tx_pbuf_queue_segment_size-1:0] q_upper_bound, // Upper bound for segment
2157                        input [p_edma_tx_pbuf_queue_segment_size-1:0] q_lower_bound, // Lower bound for segment
2158                        input [4:0] q_num_segments); // Number of segments for the queue
2159                    
2160                        reg [p_edma_tx_pbuf_queue_segment_size-1:0] q_segment_mask;
2161                        reg [p_edma_tx_pbuf_queue_segment_size+p_edma_tx_pbuf_addr-1:0] segment_addr_bits_pad;
2162                        reg [p_edma_tx_pbuf_queue_segment_size-1:0] segment_addr_bits;
2163                        reg [p_edma_tx_pbuf_addr-1:0] bind2queueRange_int;
2164                        reg [p_edma_tx_pbuf_queue_segment_size-1:0] local_add_var1;
2165                        reg [p_edma_tx_pbuf_queue_segment_size-1:0] local_add_var2;
2166                        reg [p_edma_tx_pbuf_queue_segment_size:0] local_add_var;
2167                    
2168                      begin
2169                    
2170                    
2171                          // A queue's segment range is always a power of 2 number so calculate the mask to keep
2172                          // within the power of 2 range.
2173       1/1                q_segment_mask = q_num_segments-5'd1;
2174                          // Get the segment address bits for the address coming in.
2175       1/1                segment_addr_bits_pad = addr &gt;&gt; (p_edma_tx_pbuf_addr - p_edma_tx_pbuf_queue_segment_size);
2176       1/1                segment_addr_bits = segment_addr_bits_pad[p_edma_tx_pbuf_queue_segment_size-1:0];
2177                    
2178                          // We don't touch the lower address bits so default the output and then later on
2179                          // we will change the upper address bits.
2180       1/1                bind2queueRange_int = addr;
2181                    
2182       1/1                local_add_var1 = (segment_addr_bits - q_lower_bound);
2183       1/1                local_add_var2 = (local_add_var1 &amp; q_segment_mask);
2184       1/1                local_add_var  = local_add_var2 + q_lower_bound;
2185                    
2186                          // If the queue is not within its bounds then bind the queue back to its bounds.
2187       1/1                if (addr[p_edma_tx_pbuf_addr-1:p_edma_tx_pbuf_addr-p_edma_tx_pbuf_queue_segment_size] &gt; q_upper_bound ||
2188                              addr[p_edma_tx_pbuf_addr-1:p_edma_tx_pbuf_addr-p_edma_tx_pbuf_queue_segment_size] &lt; q_lower_bound)
2189                            // If the queue only has one segment then default to the lower address
2190                          begin
2191       <font color = "red">0/1     ==>          if (q_num_segments == 5'd1)</font>
2192       <font color = "red">0/1     ==>            bind2queueRange_int[p_edma_tx_pbuf_addr-1:p_edma_tx_pbuf_addr-p_edma_tx_pbuf_queue_segment_size] = q_lower_bound;</font>
2193                            // Bind the queue to the correct position within its address bounds
2194                            else
2195       <font color = "red">0/1     ==>            bind2queueRange_int[p_edma_tx_pbuf_addr-1:p_edma_tx_pbuf_addr-p_edma_tx_pbuf_queue_segment_size] =</font>
2196                                    local_add_var[p_edma_tx_pbuf_queue_segment_size-1:0];
2197                          end
                        MISSING_ELSE
2198                    
2199       1/1                bind2queueRange = bind2queueRange_int;
2200                    
2201                      end
2202                      endfunction
2203                    
2204                    // -----------------------------------------------------------------------------
2205                    // ASF - End to end data path parity protection
2206                    // -----------------------------------------------------------------------------
2207                    
2208                    
2209                      /////////////////////////////////////////////////
2210                      // RAS - end to end parity check
2211                      generate if (p_edma_asf_dap_prot == 1) begin : gen_dp_parity
2212                        wire  dap_err_tx_r_data_c;
2213                        wire  dap_err_status_words;
2214                        wire  dap_err_xfer_sts_bus;
2215                        wire  dap_err_xfer_sts_bus_ts;
2216                        reg   asf_dap_tx_rd_err_r;
2217                    
2218                        // Parity check at the tx_r_data
2219                        // This bus  is passed through directly out of
2220                        // this module and out of the DMA as tx_r_data.
2221                        // A parity check should be performed on this bus
2222                        // at this stage and the parity bits then dropped.
2223                        cdnsdru_asf_parity_check_v1 #(.p_data_width(p_emac_bus_width)) i_par_chk_dp_tx_r_data (
2224                          .odd_par(1'b0),
2225                          .data_in(tx_r_data),
2226                          .parity_in(tx_r_data_par),
2227                          .parity_err(dap_err_tx_r_data_c)
2228                        );
2229                    
2230                        // Parity check the status words
2231                        cdnsdru_asf_parity_check_v1 #(.p_data_width(192)) i_par_chk_sts_words (
2232                          .odd_par(1'b0),
2233                          .data_in({status_word_3[31:0],
2234                                    status_word_2[31:0],
2235                                    status_word_0[31:0],
2236                                    status_word_mac_3[31:0],
2237                                    status_word_mac_2[31:0],
2238                                    status_word_mac_0[31:0]}),
2239                          .parity_in({status_word_3[35:32],
2240                                      status_word_2[35:32],
2241                                      status_word_0[35:32],
2242                                      status_word_mac_3[35:32],
2243                                      status_word_mac_2[35:32],
2244                                      status_word_mac_0[35:32]}),
2245                          .parity_err(dap_err_status_words)
2246                        );
2247                    
2248                        // Parity check xfer_status_bus
2249                        // Note that this has padding since the data is compressed and decompressed
2250                        // later in tx_wr so the parity check is not done directly here.
2251                        cdnsdru_asf_parity_check_v1 #(.p_data_width(88)) i_par_chk_xfer_sts_bus (
2252                          .odd_par(1'b0),
2253                          .data_in({xfer_status_bus[81:50], // Status word 3
2254                                    xfer_status_bus[49:18], // Status word 2
2255                                    6'h00,                  // Pad
2256                                    xfer_status_bus[17:0]   // Status word 0
2257                                    }),
2258                          .parity_in(xfer_status_bus_par),
2259                          .parity_err(dap_err_xfer_sts_bus)
2260                        );
2261                    
2262                        // Parity check xfer_status_bus_ts
2263                        cdnsdru_asf_parity_check_v1 #(.p_data_width(42)) i_par_chk_xfer_sts_bus_ts (
2264                          .odd_par(1'b0),
2265                          .data_in(xfer_status_bus_ts[41:0]), // Top bit is status and not protected
2266                          .parity_in(xfer_status_bus_ts_par),
2267                          .parity_err(dap_err_xfer_sts_bus_ts)
2268                        );
2269                    
2270                        // Register parity error
2271                        always@(posedge tx_r_clk or negedge tx_r_rst_n)
2272                        begin
2273                          if (~tx_r_rst_n)
2274                            asf_dap_tx_rd_err_r &lt;= 1'b0;
2275                          else
2276                            asf_dap_tx_rd_err_r &lt;= dap_err_tx_r_data_c  | (|sw01_par_err) | dap_err_status_words |
2277                                                    dap_err_xfer_sts_bus | dap_err_xfer_sts_bus_ts;
2278                        end
2279                        assign asf_dap_tx_rd_err  = asf_dap_tx_rd_err_r;
2280                    
2281                        // Pad words with parity
2282                        assign tx_dob_w0  = {tx_dob_par_pad[3:0],tx_dob_pad[31:0]};
2283                        assign tx_dob_w1  = {tx_dob_par_pad[7:4],tx_dob_pad[63:32]};
2284                        assign tx_dob_w2  = {tx_dob_par_pad[11:8],tx_dob_pad[95:64]};
2285                        assign tx_dob_w3  = {tx_dob_par_pad[15:12],tx_dob_pad[127:96]};
2286                        assign ct_fifo_w0 = {cutthru_status_word_par[3:0],cutthru_status_word[31:0]};
2287                        assign ct_fifo_w1 = {cutthru_status_word_par[7:4],cutthru_status_word[63:32]};
2288                        assign ct_fifo_w2 = {cutthru_status_word_par[11:8],cutthru_status_word[95:64]};
2289                        assign ct_fifo_w3 = {cutthru_status_word_par[15:12],cutthru_status_word[127:96]};
2290                    
2291                        // Add parity to the sword0_cmprsd_mac to create sword0_cmprsd_mac_p
2292                        cdnsdru_asf_parity_gen_v1 #(
2293                          .p_data_width (18)
2294                        ) i_par_gen_sword0_cmprsd_mac_p (
2295                          .odd_par    (1'b0),
2296                          .data_in    (sword0_cmprsd_mac),
2297                          .data_out   (sword0_cmprsd_mac_p[17:0]),
2298                          .parity_out (sword0_cmprsd_mac_p[20:18])
2299                        );
2300                    
2301                        // If no p_edma_tsu is not defined, then no need to store the timestamp bits
2302                        if (p_edma_tsu == 0) begin : gen_no_ts
2303                          assign wb_status_to_tx_wr_fifo_din  = {status_word_mac_3,status_word_mac_2,sword0_cmprsd_mac_p};
2304                          assign xfer_status_bus_ts_par       = 6'h00;
2305                          assign xfer_status_bus_ts           = {43{1'b0}};
2306                        end else begin : gen_ts
2307                          assign wb_status_to_tx_wr_fifo_din  = {tx_timestamp_prty,ts_to_be_written,tx_timestamp,
2308                                                                status_word_mac_3,status_word_mac_2,sword0_cmprsd_mac_p};
2309                          assign xfer_status_bus_ts_par       = wb_status_to_tx_wr_fifo_dout[141:136];
2310                          assign xfer_status_bus_ts           = wb_status_to_tx_wr_fifo_dout[135:93];
2311                        end
2312                    
2313                        // Re-order output to separate parity bus from data
2314                        assign xfer_status_bus_par[10:7]    = wb_status_to_tx_wr_fifo_dout[92:89];
2315                        assign xfer_status_bus[81:50]       = wb_status_to_tx_wr_fifo_dout[88:57];
2316                        assign xfer_status_bus_par[6:3]     = wb_status_to_tx_wr_fifo_dout[56:53];
2317                        assign xfer_status_bus[49:18]       = wb_status_to_tx_wr_fifo_dout[52:21];
2318                        assign xfer_status_bus_par[2:0]     = wb_status_to_tx_wr_fifo_dout[20:18];
2319                        assign xfer_status_bus[17:0]        = wb_status_to_tx_wr_fifo_dout[17:0];
2320                      end else begin : gen_no_dp_parity
2321                        assign asf_dap_tx_rd_err = 1'b0;
2322                        assign tx_dob_w0  = tx_dob_pad[31:0];
2323                        assign tx_dob_w1  = tx_dob_pad[63:32];
2324                        assign tx_dob_w2  = tx_dob_pad[95:64];
2325                        assign tx_dob_w3  = tx_dob_pad[127:96];
2326                        assign ct_fifo_w0 = cutthru_status_word[31:0];
2327                        assign ct_fifo_w1 = cutthru_status_word[63:32];
2328                        assign ct_fifo_w2 = cutthru_status_word[95:64];
2329                        assign ct_fifo_w3 = cutthru_status_word[127:96];
2330                    
2331                        assign sword0_cmprsd_mac_p          = sword0_cmprsd_mac;
2332                    
2333                        // If no p_edma_tsu is not defined, then no need to store the timestamp bits
2334                        if (p_edma_tsu == 0) begin : gen_no_ts
2335                          assign wb_status_to_tx_wr_fifo_din  = {status_word_mac_3,status_word_mac_2,sword0_cmprsd_mac_p};
2336                          assign xfer_status_bus_ts           = {43{1'b0}};
2337                        end else begin : gen_ts
2338                          assign wb_status_to_tx_wr_fifo_din  = {ts_to_be_written,tx_timestamp,
2339                                                                status_word_mac_3,status_word_mac_2,sword0_cmprsd_mac_p};
2340                          assign xfer_status_bus_ts           = wb_status_to_tx_wr_fifo_dout[124:82];
2341                        end
2342                    
2343                        assign xfer_status_bus              = wb_status_to_tx_wr_fifo_dout[81:0];
2344                        assign xfer_status_bus_ts_par       = 6'h00;
2345                        assign xfer_status_bus_par          = 11'h000;
2346                      end
2347                      endgenerate
2348                    
2349                      // The following is just for lint
2350                      genvar unused_q_cnt;
2351                      generate for (unused_q_cnt=p_edma_queues[31:0]; unused_q_cnt&lt;16; unused_q_cnt = unused_q_cnt+1)
2352                      begin : set_unused_sigs
2353                        wire zero = 1'b0;
2354                        always@(*)
2355                        begin
2356       1/1                status_word0_nxt[unused_q_cnt] = {p_dword_w{zero}};
2357       1/1                got_sw0_nxt[unused_q_cnt] = zero;
2358       1/1                start_reading_at_risk_q_nxt[unused_q_cnt] = zero;
2359       1/1                start_reading_at_risk_q[unused_q_cnt] = zero;
2360       1/1                num_pkts_needing_read[unused_q_cnt] = {8{zero}};
2361       1/1                status_word0_nxt_add[unused_q_cnt] = {p_edma_tx_pbuf_addr{zero}};
***repeat 1
2356       1/1                status_word0_nxt[unused_q_cnt] = {p_dword_w{zero}};
2357       1/1                got_sw0_nxt[unused_q_cnt] = zero;
2358       1/1                start_reading_at_risk_q_nxt[unused_q_cnt] = zero;
2359       1/1                start_reading_at_risk_q[unused_q_cnt] = zero;
2360       1/1                num_pkts_needing_read[unused_q_cnt] = {8{zero}};
2361       1/1                status_word0_nxt_add[unused_q_cnt] = {p_edma_tx_pbuf_addr{zero}};
***repeat 2
2356       1/1                status_word0_nxt[unused_q_cnt] = {p_dword_w{zero}};
2357       1/1                got_sw0_nxt[unused_q_cnt] = zero;
2358       1/1                start_reading_at_risk_q_nxt[unused_q_cnt] = zero;
2359       1/1                start_reading_at_risk_q[unused_q_cnt] = zero;
2360       1/1                num_pkts_needing_read[unused_q_cnt] = {8{zero}};
2361       1/1                status_word0_nxt_add[unused_q_cnt] = {p_edma_tx_pbuf_addr{zero}};
***repeat 3
2356       1/1                status_word0_nxt[unused_q_cnt] = {p_dword_w{zero}};
2357       1/1                got_sw0_nxt[unused_q_cnt] = zero;
2358       1/1                start_reading_at_risk_q_nxt[unused_q_cnt] = zero;
2359       1/1                start_reading_at_risk_q[unused_q_cnt] = zero;
2360       1/1                num_pkts_needing_read[unused_q_cnt] = {8{zero}};
2361       1/1                status_word0_nxt_add[unused_q_cnt] = {p_edma_tx_pbuf_addr{zero}};
***repeat 4
2356       1/1                status_word0_nxt[unused_q_cnt] = {p_dword_w{zero}};
2357       1/1                got_sw0_nxt[unused_q_cnt] = zero;
2358       1/1                start_reading_at_risk_q_nxt[unused_q_cnt] = zero;
2359       1/1                start_reading_at_risk_q[unused_q_cnt] = zero;
2360       1/1                num_pkts_needing_read[unused_q_cnt] = {8{zero}};
2361       1/1                status_word0_nxt_add[unused_q_cnt] = {p_edma_tx_pbuf_addr{zero}};
***repeat 5
2356       1/1                status_word0_nxt[unused_q_cnt] = {p_dword_w{zero}};
2357       1/1                got_sw0_nxt[unused_q_cnt] = zero;
2358       1/1                start_reading_at_risk_q_nxt[unused_q_cnt] = zero;
2359       1/1                start_reading_at_risk_q[unused_q_cnt] = zero;
2360       1/1                num_pkts_needing_read[unused_q_cnt] = {8{zero}};
2361       1/1                status_word0_nxt_add[unused_q_cnt] = {p_edma_tx_pbuf_addr{zero}};
***repeat 6
2356       1/1                status_word0_nxt[unused_q_cnt] = {p_dword_w{zero}};
2357       1/1                got_sw0_nxt[unused_q_cnt] = zero;
2358       1/1                start_reading_at_risk_q_nxt[unused_q_cnt] = zero;
2359       1/1                start_reading_at_risk_q[unused_q_cnt] = zero;
2360       1/1                num_pkts_needing_read[unused_q_cnt] = {8{zero}};
2361       1/1                status_word0_nxt_add[unused_q_cnt] = {p_edma_tx_pbuf_addr{zero}};
***repeat 7
2356       1/1                status_word0_nxt[unused_q_cnt] = {p_dword_w{zero}};
2357       1/1                got_sw0_nxt[unused_q_cnt] = zero;
2358       1/1                start_reading_at_risk_q_nxt[unused_q_cnt] = zero;
2359       1/1                start_reading_at_risk_q[unused_q_cnt] = zero;
2360       1/1                num_pkts_needing_read[unused_q_cnt] = {8{zero}};
2361       1/1                status_word0_nxt_add[unused_q_cnt] = {p_edma_tx_pbuf_addr{zero}};
***repeat 8
2356       1/1                status_word0_nxt[unused_q_cnt] = {p_dword_w{zero}};
2357       1/1                got_sw0_nxt[unused_q_cnt] = zero;
2358       1/1                start_reading_at_risk_q_nxt[unused_q_cnt] = zero;
2359       1/1                start_reading_at_risk_q[unused_q_cnt] = zero;
2360       1/1                num_pkts_needing_read[unused_q_cnt] = {8{zero}};
2361       1/1                status_word0_nxt_add[unused_q_cnt] = {p_edma_tx_pbuf_addr{zero}};
***repeat 9
2356       1/1                status_word0_nxt[unused_q_cnt] = {p_dword_w{zero}};
2357       1/1                got_sw0_nxt[unused_q_cnt] = zero;
2358       1/1                start_reading_at_risk_q_nxt[unused_q_cnt] = zero;
2359       1/1                start_reading_at_risk_q[unused_q_cnt] = zero;
2360       1/1                num_pkts_needing_read[unused_q_cnt] = {8{zero}};
2361       1/1                status_word0_nxt_add[unused_q_cnt] = {p_edma_tx_pbuf_addr{zero}};
***repeat 10
2356       1/1                status_word0_nxt[unused_q_cnt] = {p_dword_w{zero}};
2357       1/1                got_sw0_nxt[unused_q_cnt] = zero;
2358       1/1                start_reading_at_risk_q_nxt[unused_q_cnt] = zero;
2359       1/1                start_reading_at_risk_q[unused_q_cnt] = zero;
2360       1/1                num_pkts_needing_read[unused_q_cnt] = {8{zero}};
2361       1/1                status_word0_nxt_add[unused_q_cnt] = {p_edma_tx_pbuf_addr{zero}};
***repeat 11
2356       1/1                status_word0_nxt[unused_q_cnt] = {p_dword_w{zero}};
2357       1/1                got_sw0_nxt[unused_q_cnt] = zero;
2358       1/1                start_reading_at_risk_q_nxt[unused_q_cnt] = zero;
2359       1/1                start_reading_at_risk_q[unused_q_cnt] = zero;
2360       1/1                num_pkts_needing_read[unused_q_cnt] = {8{zero}};
2361       1/1                status_word0_nxt_add[unused_q_cnt] = {p_edma_tx_pbuf_addr{zero}};
***repeat 12
2356       1/1                status_word0_nxt[unused_q_cnt] = {p_dword_w{zero}};
2357       1/1                got_sw0_nxt[unused_q_cnt] = zero;
2358       1/1                start_reading_at_risk_q_nxt[unused_q_cnt] = zero;
2359       1/1                start_reading_at_risk_q[unused_q_cnt] = zero;
2360       1/1                num_pkts_needing_read[unused_q_cnt] = {8{zero}};
2361       1/1                status_word0_nxt_add[unused_q_cnt] = {p_edma_tx_pbuf_addr{zero}};
***repeat 13
2356       1/1                status_word0_nxt[unused_q_cnt] = {p_dword_w{zero}};
2357       1/1                got_sw0_nxt[unused_q_cnt] = zero;
2358       1/1                start_reading_at_risk_q_nxt[unused_q_cnt] = zero;
2359       1/1                start_reading_at_risk_q[unused_q_cnt] = zero;
2360       1/1                num_pkts_needing_read[unused_q_cnt] = {8{zero}};
2361       1/1                status_word0_nxt_add[unused_q_cnt] = {p_edma_tx_pbuf_addr{zero}};
***repeat 14
2356       1/1                status_word0_nxt[unused_q_cnt] = {p_dword_w{zero}};
2357       1/1                got_sw0_nxt[unused_q_cnt] = zero;
2358       1/1                start_reading_at_risk_q_nxt[unused_q_cnt] = zero;
2359       1/1                start_reading_at_risk_q[unused_q_cnt] = zero;
2360       1/1                num_pkts_needing_read[unused_q_cnt] = {8{zero}};
2361       1/1                status_word0_nxt_add[unused_q_cnt] = {p_edma_tx_pbuf_addr{zero}};
</pre>
<hr>
<a name="Cond"></a>
Cond Coverage for Module : <a href="mod978.html" >edma_pbuf_axi_tx_rd</a><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s4"><td class="lf">Conditions</td><td>144</td><td>65</td><td>45.14</td></tr>
<tr class="s4"><td class="lf">Logical</td><td>144</td><td>65</td><td>45.14</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       359
 EXPRESSION ((dma_bus_width &gt; emac_bus_width_max) ? emac_bus_width_max : dma_bus_width)
             ------------------1-----------------
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       366
 EXPRESSION (((!enable_tx_sync)) || tx_wr_seen_uflow_sync)
             ---------1---------    ----------2----------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       472
 EXPRESSION (part_of_packet_edge[0] &amp;&amp; ((read_state != IDLE) || (num_pkts_needing_read[0] != 8'b0)))
             -----------1----------    ------------------------------2-----------------------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       472
 SUB-EXPRESSION ((read_state != IDLE) || (num_pkts_needing_read[0] != 8'b0))
                 ----------1---------    -----------------2----------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       491
 EXPRESSION ((part_of_packet_edge[0] || gen_start_reading_at_risk[0].cutthru_pending_q) &amp;&amp; (read_state == IDLE) &amp;&amp; ((!(|num_pkts_needing_read[0]))))
             -------------------------------------1------------------------------------    ----------2---------    ----------------3---------------
</pre>
<table class="noborder">
<col span="3" width="40">
<tr><th>-1-</th><th>-2-</th><th>-3-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>1</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       491
 SUB-EXPRESSION (part_of_packet_edge[0] || gen_start_reading_at_risk[0].cutthru_pending_q)
                 -----------1----------    -----------------------2----------------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       526
 EXPRESSION (((!cutthru_status_word_empty)) &amp;&amp; (sample_sw0 || (read_state == IDLE)))
             ---------------1--------------    ------------------2-----------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       526
 SUB-EXPRESSION (sample_sw0 || (read_state == IDLE))
                 -----1----    ----------2---------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       539
 EXPRESSION 
 Number  Term
      1  ((!cutthru_status_word_empty)) &amp;&amp; 
      2  ((!gen_cutthru_logic.cutthru_status_word_pop_r)) &amp;&amp; 
      3  (cutthru_status_word[((p_edma_tx_pbuf_addr - 1) + 128):128] == status_word0_nxt_add[queue_dma]))
</pre>
<table class="noborder">
<col span="3" width="40">
<tr><th>-1-</th><th>-2-</th><th>-3-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       756
 EXPRESSION (bd_extended_mode_en &amp;&amp; ((!gem_tx_pbuf_data_w_is_128)))
             ---------1---------    ---------------2--------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       775
 EXPRESSION (((!need_sw1_nxt_req[0])) || gem_tx_pbuf_data_w_is_128 || (dma_bus_width == 2'b1))
             ------------1-----------    ------------2------------    -----------3-----------
</pre>
<table class="noborder">
<col span="3" width="40">
<tr><th>-1-</th><th>-2-</th><th>-3-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td>0</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       783
 EXPRESSION (sample_sw0 &amp;&amp; (((0 == {{28 {1'b0}}, queue_dma_c}) &amp; (~(|store_mac_sw0_en)))))
             -----1----    -------------------------------2------------------------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       785
 EXPRESSION (bd_extended_mode_en &amp;&amp; ((!gem_tx_pbuf_data_w_is_128)))
             ---------1---------    ---------------2--------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       809
 EXPRESSION (got_sw1_nxt[0] || gem_tx_pbuf_data_w_is_128 || (dma_bus_width == 2'b1) || ((!bd_extended_mode_en)))
             -------1------    ------------2------------    -----------3-----------    ------------4-----------
</pre>
<table class="noborder">
<col span="4" width="40">
<tr><th>-1-</th><th>-2-</th><th>-3-</th><th>-4-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>0</td><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>0</td><td>0</td><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>0</td><td>0</td><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td>0</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       825
 EXPRESSION (sample_sw0 &amp;&amp; (((0 == {{28 {1'b0}}, queue_dma_c}) &amp; (~(|store_mac_sw0_en)))))
             -----1----    -------------------------------2------------------------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       957
 EXPRESSION (gem_tx_pbuf_data_w_is_128 ? status_word0_add : lstatus_word2_add)
             ------------1------------
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       976
 EXPRESSION (gem_tx_pbuf_data_w_is_128 ? 2'b10 : dma_bus_width)
             ------------1------------
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       988
 EXPRESSION 
 Number  Term
      1  (dma_bus_width_override == 2'b0) ? ({gen_packets_in_q[0].local_sw0[11:0], 2'b0}) : ((dma_bus_width_override == 2'b1) ? ({gen_packets_in_q[0].local_sw0[10:0], 3'b0}) : ({gen_packets_in_q[0].local_sw0[9:0], 4'b0})))
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       988
 SUB-EXPRESSION ((dma_bus_width_override == 2'b1) ? ({gen_packets_in_q[0].local_sw0[10:0], 3'b0}) : ({gen_packets_in_q[0].local_sw0[9:0], 4'b0}))
                 ----------------1---------------
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1025
 EXPRESSION ((store_mac_sw0_en == 2'b0) &amp;&amp; bd_extended_mode_en &amp;&amp; got_sw0_nxt[0] &amp;&amp; gen_packets_in_q[0].local_sw0[24] &amp;&amp; ((!gen_packets_in_q[0].local_sw0[31])))
             -------------1------------    ---------2---------    -------3------    ----------------4----------------    -------------------5------------------
</pre>
<table class="noborder">
<col span="5" width="40">
<tr><th>-1-</th><th>-2-</th><th>-3-</th><th>-4-</th><th>-5-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1046
 EXPRESSION ((((((|status_frame_in_q)) &amp;&amp; ((!(|store_mac_sw0_en)))) || mac_bp) &amp;&amp; (read_state == IDLE)) || (read_state == WAIT_FOR_STATUS))
             ---------------------------------------------1--------------------------------------------    ---------------2---------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1046
 SUB-EXPRESSION (((((|status_frame_in_q)) &amp;&amp; ((!(|store_mac_sw0_en)))) || mac_bp) &amp;&amp; (read_state == IDLE))
                 --------------------------------1-------------------------------    ----------2---------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1046
 SUB-EXPRESSION ((((|status_frame_in_q)) &amp;&amp; ((!(|store_mac_sw0_en)))) || mac_bp)
                 --------------------------1-------------------------    ---2--
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1046
 SUB-EXPRESSION (((|status_frame_in_q)) &amp;&amp; ((!(|store_mac_sw0_en))))
                 -----------1----------    ------------2-----------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1060
 EXPRESSION (((|status_frame_in_q)) &amp;&amp; (read_state == IDLE))
             -----------1----------    ----------2---------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1104
 EXPRESSION (((|store_mac_sw0_en)) ? store_1st_sw0[31:0] : status_word0_nxt[queue_dma_c][31:0])
             ----------1----------
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1128
 EXPRESSION 
 Number  Term
      1  (got_sw0_nxt[queue_dma_c] &amp;&amp; ((!((|store_mac_sw0_en) | need_to_replay))) &amp;&amp; (tx_r_rd_int_pad[queue_dma_c] || status_frame_in_q[queue_dma_c])) || 
      2  (((|store_mac_sw0_en)) &amp;&amp; (tx_r_rd_int_pad[queue_dma_c] || store_1st_sw0[31])))
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1128
 SUB-EXPRESSION (got_sw0_nxt[queue_dma_c] &amp;&amp; ((!((|store_mac_sw0_en) | need_to_replay))) &amp;&amp; (tx_r_rd_int_pad[queue_dma_c] || status_frame_in_q[queue_dma_c]))
                 ------------1-----------    ---------------------2---------------------    --------------------------------3-------------------------------
</pre>
<table class="noborder">
<col span="3" width="40">
<tr><th>-1-</th><th>-2-</th><th>-3-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1128
 SUB-EXPRESSION (tx_r_rd_int_pad[queue_dma_c] || status_frame_in_q[queue_dma_c])
                 --------------1-------------    ---------------2--------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1128
 SUB-EXPRESSION (((|store_mac_sw0_en)) &amp;&amp; (tx_r_rd_int_pad[queue_dma_c] || store_1st_sw0[31]))
                 ----------1----------    -------------------------2-------------------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1128
 SUB-EXPRESSION (tx_r_rd_int_pad[queue_dma_c] || store_1st_sw0[31])
                 --------------1-------------    --------2--------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1174
 EXPRESSION ((dma_bus_width_override == 2'b0) &amp;&amp; ((~status_word3_obtained)) &amp;&amp; status_word0_obtained &amp;&amp; ((~sram_add_gnt[2])) &amp;&amp; ((~sram_dat_gnt[2])))
             ----------------1---------------    -------------2------------    ----------3----------    ----------4---------    ----------5---------
</pre>
<table class="noborder">
<col span="5" width="40">
<tr><th>-1-</th><th>-2-</th><th>-3-</th><th>-4-</th><th>-5-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1179
 EXPRESSION ((dma_bus_width_override == 2'b0) &amp;&amp; status_word0_obtained)
             ----------------1---------------    ----------2----------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1296
 EXPRESSION (gem_tx_pbuf_data_w_is_128 || (dma_bus_width != 2'b0))
             ------------1------------    -----------2-----------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1311
 EXPRESSION 
 Number  Term
      1  (gem_tx_pbuf_data_w_is_128 || (dma_bus_width != 2'b0)) ? ({{(p_edma_tx_pbuf_addr - 2) {1'b0}}, 2'b10}) : ({{(p_edma_tx_pbuf_addr - 2) {1'b0}}, 2'b11}))
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1311
 SUB-EXPRESSION (gem_tx_pbuf_data_w_is_128 || (dma_bus_width != 2'b0))
                 ------------1------------    -----------2-----------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1345
 EXPRESSION 
 Number  Term
      1  (gem_tx_pbuf_data_w_is_128 || (dma_bus_width != 2'b0)) ? ({{(p_edma_tx_pbuf_addr - 1) {1'b0}}, 1'b1}) : ({{(p_edma_tx_pbuf_addr - 2) {1'b0}}, 2'b10}))
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1345
 SUB-EXPRESSION (gem_tx_pbuf_data_w_is_128 || (dma_bus_width != 2'b0))
                 ------------1------------    -----------2-----------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1395
 EXPRESSION ((((|dma_bus_width) | gem_tx_pbuf_data_w_is_128)) ? status_word_0[15:12] : ({1'b0, status_word_0[14:12]}))
             ------------------------1-----------------------
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1414
 EXPRESSION (((|dma_bus_width)) || gem_tx_pbuf_data_w_is_128)
             ---------1--------    ------------2------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1530
 EXPRESSION (sample_sw0 ? reading_pkt_last_word_req_c : reading_pkt_last_word_req)
             -----1----
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1555
 EXPRESSION ((read_state == IDLE) &amp;&amp; (read_state_nxt != IDLE))
             ----------1---------    ------------2-----------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1739
 EXPRESSION (((tx_r_pip &amp; tx_r_valid_dph)) ? tx_dob_downsize[(p_emac_bus_width - 1):0] : ({p_emac_bus_width {1'b0}}))
             --------------1--------------
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1741
 EXPRESSION (((tx_r_pip &amp; tx_r_valid_dph)) ? tx_dob_downsize_par[(p_emac_bus_pwid - 1):0] : ({p_emac_bus_pwid {1'b0}}))
             --------------1--------------
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1798
 EXPRESSION ((read_state_nxt == IDLE) &amp;&amp; (read_state != IDLE))
             ------------1-----------    ----------2---------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1934
 EXPRESSION 
 Number  Term
      1  ((|store_mac_sw0_en)) ? ({store_1st_sw0[((p_dword_w + p_edma_tx_pbuf_addr) + 3):(p_dword_w + 4)], store_1st_sw0[(p_dword_w - 1):0]}) : ({status_word0_nxt_add[queue_dma_c], status_word0_nxt[queue_dma_c]}))
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       2046
 EXPRESSION (sw_mac_fifo_pop_hold ? ((late_coll_occured_hold &amp; sw_mac_fifo_pop)) : ((late_coll_occured &amp; sw_mac_fifo_pop)))
             ----------1---------
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       2047
 EXPRESSION (sw_mac_fifo_pop_hold ? ((too_many_retries_hold &amp; sw_mac_fifo_pop)) : ((too_many_retries &amp; sw_mac_fifo_pop)))
             ----------1---------
</pre>
<table class="noborder">
<col width="40">
<tr><th>-1-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       2095
 EXPRESSION ((((!wb_status_to_tx_wr_fifo_empty) &amp; sw_mac_fifo_pop)) || wb_status_to_tx_wr_fifo_full)
             ---------------------------1--------------------------    --------------2-------------
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th>                      </tr>
<tr class="uGreen"><td>0</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>0</td><td>1</td><td class="lf">Not Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
</table>
<hr>
<a name="Toggle"></a>
Toggle Coverage for Module : <a href="mod978.html" >edma_pbuf_axi_tx_rd</a><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s1">
<td>Totals</td>
<td class="rt">67</td>
<td class="rt">11</td>
<td class="rt">16.42 </td>
</tr><tr class="s1">
<td>Total Bits</td>
<td class="rt">1450</td>
<td class="rt">212</td>
<td class="rt">14.62 </td>
</tr><tr class="s1">
<td nowrap>Total Bits 0->1</td>
<td class="rt">725</td>
<td class="rt">114</td>
<td class="rt">15.72 </td>
</tr><tr class="s1">
<td nowrap>Total Bits 1->0</td>
<td class="rt">725</td>
<td class="rt">98</td>
<td class="rt">13.52 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s1">
<td>Ports</td>
<td class="rt">67</td>
<td class="rt">11</td>
<td class="rt">16.42 </td>
</tr><tr class="s1">
<td>Port Bits</td>
<td class="rt">1450</td>
<td class="rt">212</td>
<td class="rt">14.62 </td>
</tr><tr class="s1">
<td nowrap>Port Bits 0->1</td>
<td class="rt">725</td>
<td class="rt">114</td>
<td class="rt">15.72 </td>
</tr><tr class="s1">
<td nowrap>Port Bits 1->0</td>
<td class="rt">725</td>
<td class="rt">98</td>
<td class="rt">13.52 </td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>TX_PBUF_SEGMENTS_LOWER_ADDR</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>TX_PBUF_SEGMENTS_UPPER_ADDR</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>TX_PBUF_NUM_SEGMENTS[79:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>tx_r_clk</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>tx_r_rst_n</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>enable_transmit</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>tx_r_rd</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>tx_r_rd_int</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>tx_r_queue_int[3:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>dma_tx_end_tog</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>dma_tx_small_end_tog</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>collision_occured</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>late_coll_occured</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>too_many_retries</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>underflow_frame</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>dma_tx_status_tog</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_r_valid</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_r_data[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_r_data_par[3:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_r_eop</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_r_sop</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_r_mod[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_r_mod[3:2]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_r_err</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_r_flushed</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_r_underflow</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_r_data_rdy</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>dma_is_busy</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_r_control</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_r_frame_size_vld</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_r_frame_size[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_r_frame_size[2]</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_r_frame_size[3]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_r_frame_size[4]</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_r_frame_size[7:5]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_r_frame_size[13:8]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_r_launch_time_vld</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_r_launch_time[31:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_enb</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_web</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_addrb[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_addrb[8:6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_dob_pad[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>tx_dob_pad[127:32]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>tx_dob_par_pad[15:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>end_of_packet_tog</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>part_of_packet_tog</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>pkt_end_new</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>pkt_end_flush</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>num_pkts_xfer[0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>num_pkts_xfer[3:1]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>pkt_captured</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>dpram_almost_empty</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>underflow_tog</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>tx_wr_seen_uflow</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>xfer_status_captured</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>full_pkt_read</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>part_pkt_read</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>xfer_status_bus[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>xfer_status_bus[6:2]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>xfer_status_bus[19:7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>xfer_status_bus[20]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>xfer_status_bus[48:21]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>xfer_status_bus[56:49]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>xfer_status_bus[63:57]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>xfer_status_bus[64]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>xfer_status_bus[81:65]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>xfer_status_bus_par[10:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>part_pkt_queue[3:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>xfer_status_bus_ts[42:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>xfer_status_bus_ts_par[5:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>dma_bus_width[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>full_duplex</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>tx_bd_ts_mode[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>bd_extended_mode_en</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>tx_timestamp[41:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>tx_timestamp_prty[5:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>event_frame_tx</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>general_frame_tx</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>cutthru_status_word[136:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>cutthru_status_word_par[17:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>cutthru_status_word_empty</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>cutthru_status_word_pop</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>asf_dap_tx_rd_err</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<hr>
<a name="FSM"></a>
FSM Coverage for Module : <a href="mod978.html" >edma_pbuf_axi_tx_rd</a><br clear=all>
<table align=left class="noborder">
<caption><b>Summary for FSM :: read_state</b></caption>
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th><th nowrap width=200></th></tr><tr class="wht">
<td>States</td>
<td class="rt">5</td>
<td class="rt">4</td>
<td class="rt">80.00 </td>
<td>(Not included in score)</td>
</tr><tr class="s3">
<td>Transitions</td>
<td class="rt">14</td>
<td class="rt">5</td>
<td class="rt">35.71 </td>
<td></td>
</tr><tr class="wht">
<td>Sequences</td>
<td class="rt">0</td>
<td class="rt">0</td>
<td></td>
<td></td>
</tr></table><br clear=all>
<b>State, Transition and Sequence Details for FSM :: read_state</b><hr>
<table align=left class="sortable noborder">
<tr class="sortablehead">
<td class="alfsrt">states</td><td>Line No.</td><td class="alfsrt">Covered</td></tr><tr class="uGreen">
<td nowrap>IDLE</td>
<td class="rt">1214</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td nowrap>PKT_DATA</td>
<td class="rt">1145</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td nowrap>READ_LSTATUS_WORD2</td>
<td class="rt">1169</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td nowrap>READ_LSTATUS_WORD3</td>
<td class="rt">1171</td>
<td>Covered</td>
</tr><tr class="uRed">
<td nowrap>WAIT_FOR_STATUS</td>
<td class="rt">1138</td>
<td>Not&nbsp;Covered</td>
</tr></table><br clear=all>
<br clear=all>
<table align=left class="sortable noborder">
<tr class="sortablehead">
<td class="alfsrt">transitions</td><td>Line No.</td><td class="alfsrt">Covered</td></tr><tr class="uGreen">
<td nowrap>IDLE->PKT_DATA</td>
<td class="rt">1145</td>
<td>Covered</td>
</tr><tr class="uRed">
<td nowrap>IDLE->WAIT_FOR_STATUS</td>
<td class="rt">1138</td>
<td>Not&nbsp;Covered</td>
</tr><tr class="uGreen">
<td nowrap>PKT_DATA->IDLE</td>
<td class="rt">1214</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td nowrap>PKT_DATA->READ_LSTATUS_WORD2</td>
<td class="rt">1169</td>
<td>Covered</td>
</tr><tr class="uRed">
<td nowrap>PKT_DATA->READ_LSTATUS_WORD3</td>
<td class="rt">1171</td>
<td>Not&nbsp;Covered</td>
</tr><tr class="uRed">
<td nowrap>PKT_DATA->WAIT_FOR_STATUS</td>
<td class="rt">1162</td>
<td>Not&nbsp;Covered</td>
</tr><tr class="uRed">
<td nowrap>READ_LSTATUS_WORD2->IDLE</td>
<td class="rt">1214</td>
<td>Not&nbsp;Covered</td>
</tr><tr class="uRed">
<td nowrap>READ_LSTATUS_WORD2->PKT_DATA</td>
<td class="rt">1185</td>
<td>Not&nbsp;Covered</td>
</tr><tr class="uGreen">
<td nowrap>READ_LSTATUS_WORD2->READ_LSTATUS_WORD3</td>
<td class="rt">1183</td>
<td>Covered</td>
</tr><tr class="uRed">
<td nowrap>READ_LSTATUS_WORD2->WAIT_FOR_STATUS</td>
<td class="rt">1181</td>
<td>Not&nbsp;Covered</td>
</tr><tr class="uRed">
<td nowrap>READ_LSTATUS_WORD3->IDLE</td>
<td class="rt">1214</td>
<td>Not&nbsp;Covered</td>
</tr><tr class="uGreen">
<td nowrap>READ_LSTATUS_WORD3->PKT_DATA</td>
<td class="rt">1193</td>
<td>Covered</td>
</tr><tr class="uRed">
<td nowrap>READ_LSTATUS_WORD3->WAIT_FOR_STATUS</td>
<td class="rt">1191</td>
<td>Not&nbsp;Covered</td>
</tr><tr class="uRed">
<td nowrap>WAIT_FOR_STATUS->IDLE</td>
<td class="rt">1214</td>
<td>Not&nbsp;Covered</td>
</tr></table><br clear=all>
<br clear=all>
<hr>
<a name="Branch"></a>
Branch Coverage for Module : <a href="mod978.html" >edma_pbuf_axi_tx_rd</a><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Line No.</th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s6">
<td>Branches</td>
<td></td>
<td class="rt">226</td>
<td class="rt">147</td>
<td class="rt">65.04 </td>
</tr><tr class="s5">
<td>TERNARY</td>
<td class="rt">359</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s5">
<td>TERNARY</td>
<td class="rt">976</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s5">
<td>TERNARY</td>
<td class="rt">1104</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s5">
<td>TERNARY</td>
<td class="rt">1311</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s5">
<td>TERNARY</td>
<td class="rt">1345</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s5">
<td>TERNARY</td>
<td class="rt">1395</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s10">
<td>TERNARY</td>
<td class="rt">1530</td>
<td class="rt">2</td>
<td class="rt">2</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>TERNARY</td>
<td class="rt">1739</td>
<td class="rt">2</td>
<td class="rt">2</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>TERNARY</td>
<td class="rt">1741</td>
<td class="rt">2</td>
<td class="rt">2</td>
<td class="rt">100.00</td>
</tr><tr class="s5">
<td>TERNARY</td>
<td class="rt">1934</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s5">
<td>TERNARY</td>
<td class="rt">2046</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s5">
<td>TERNARY</td>
<td class="rt">2047</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s3">
<td>TERNARY</td>
<td class="rt">988</td>
<td class="rt">3</td>
<td class="rt">1</td>
<td class="rt">33.33 </td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">889</td>
<td class="rt">3</td>
<td class="rt">3</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">920</td>
<td class="rt">2</td>
<td class="rt">2</td>
<td class="rt">100.00</td>
</tr><tr class="s8">
<td>IF</td>
<td class="rt">956</td>
<td class="rt">6</td>
<td class="rt">5</td>
<td class="rt">83.33 </td>
</tr><tr class="s3">
<td>IF</td>
<td class="rt">1058</td>
<td class="rt">3</td>
<td class="rt">1</td>
<td class="rt">33.33 </td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">1080</td>
<td class="rt">7</td>
<td class="rt">7</td>
<td class="rt">100.00</td>
</tr><tr class="s4">
<td>CASE</td>
<td class="rt">1123</td>
<td class="rt">20</td>
<td class="rt">9</td>
<td class="rt">45.00 </td>
</tr><tr class="s6">
<td>IF</td>
<td class="rt">1212</td>
<td class="rt">18</td>
<td class="rt">12</td>
<td class="rt">66.67 </td>
</tr><tr class="s7">
<td>IF</td>
<td class="rt">1349</td>
<td class="rt">7</td>
<td class="rt">5</td>
<td class="rt">71.43 </td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">1414</td>
<td class="rt">2</td>
<td class="rt">1</td>
<td class="rt">50.00 </td>
</tr><tr class="s6">
<td>IF</td>
<td class="rt">1553</td>
<td class="rt">5</td>
<td class="rt">3</td>
<td class="rt">60.00 </td>
</tr><tr class="s4">
<td>IF</td>
<td class="rt">1571</td>
<td class="rt">11</td>
<td class="rt">5</td>
<td class="rt">45.45 </td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">1642</td>
<td class="rt">7</td>
<td class="rt">7</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">1720</td>
<td class="rt">3</td>
<td class="rt">3</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">1784</td>
<td class="rt">3</td>
<td class="rt">3</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">1791</td>
<td class="rt">3</td>
<td class="rt">3</td>
<td class="rt">100.00</td>
</tr><tr class="s8">
<td>IF</td>
<td class="rt">1798</td>
<td class="rt">5</td>
<td class="rt">4</td>
<td class="rt">80.00 </td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">1816</td>
<td class="rt">3</td>
<td class="rt">3</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">1848</td>
<td class="rt">4</td>
<td class="rt">4</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">1880</td>
<td class="rt">3</td>
<td class="rt">3</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">1906</td>
<td class="rt">3</td>
<td class="rt">3</td>
<td class="rt">100.00</td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">1919</td>
<td class="rt">2</td>
<td class="rt">2</td>
<td class="rt">100.00</td>
</tr><tr class="s3">
<td>IF</td>
<td class="rt">1963</td>
<td class="rt">3</td>
<td class="rt">1</td>
<td class="rt">33.33 </td>
</tr><tr class="s6">
<td>IF</td>
<td class="rt">2009</td>
<td class="rt">6</td>
<td class="rt">4</td>
<td class="rt">66.67 </td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">2052</td>
<td class="rt">4</td>
<td class="rt">4</td>
<td class="rt">100.00</td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">2121</td>
<td class="rt">6</td>
<td class="rt">3</td>
<td class="rt">50.00 </td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">462</td>
<td class="rt">2</td>
<td class="rt">2</td>
<td class="rt">100.00</td>
</tr><tr class="s7">
<td>IF</td>
<td class="rt">468</td>
<td class="rt">4</td>
<td class="rt">3</td>
<td class="rt">75.00 </td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">479</td>
<td class="rt">4</td>
<td class="rt">2</td>
<td class="rt">50.00 </td>
</tr><tr class="s6">
<td>IF</td>
<td class="rt">511</td>
<td class="rt">5</td>
<td class="rt">3</td>
<td class="rt">60.00 </td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">568</td>
<td class="rt">3</td>
<td class="rt">3</td>
<td class="rt">100.00</td>
</tr><tr class="s1">
<td>CASE</td>
<td class="rt">590</td>
<td class="rt">6</td>
<td class="rt">1</td>
<td class="rt">16.67 </td>
</tr><tr class="s10">
<td>IF</td>
<td class="rt">672</td>
<td class="rt">3</td>
<td class="rt">3</td>
<td class="rt">100.00</td>
</tr><tr class="s5">
<td>IF</td>
<td class="rt">741</td>
<td class="rt">14</td>
<td class="rt">8</td>
<td class="rt">57.14 </td>
</tr><tr class="s3">
<td>IF</td>
<td class="rt">851</td>
<td class="rt">3</td>
<td class="rt">1</td>
<td class="rt">33.33 </td>
</tr><tr class="s3">
<td>CASE</td>
<td class="rt">993</td>
<td class="rt">16</td>
<td class="rt">5</td>
<td class="rt">31.25 </td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
359          wire [1:0] emac_bus_width = (dma_bus_width > emac_bus_width_max) ? emac_bus_width_max : dma_bus_width;
                                                                              <font color = "red">-1-</font>  
                                                                              <font color = "red">==></font>  
                                                                              <font color = "green">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
976          assign dma_bus_width_override = gem_tx_pbuf_data_w_is_128 ? 2'b10 : dma_bus_width;
                                                                       <font color = "red">-1-</font>  
                                                                       <font color = "red">==></font>  
                                                                       <font color = "green">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1104         assign nxt_sw0_nxt  = |store_mac_sw0_en ? store_1st_sw0[31:0] : status_word0_nxt[queue_dma_c][31:0];
                                                     <font color = "red">-1-</font>  
                                                     <font color = "red">==></font>  
                                                     <font color = "green">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1311         assign pkt_data_addr_inc1 = (gem_tx_pbuf_data_w_is_128 || dma_bus_width != 2'b00)  ? ({{p_edma_tx_pbuf_addr-2{1'b0}},2'b10})
                                                                                                <font color = "red">-1-</font>  
                                                                                                <font color = "red">==></font>  
                                                                                                <font color = "green">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1345         assign pkt_data_addr_inc = (gem_tx_pbuf_data_w_is_128 || dma_bus_width != 2'b00)  ? ({{p_edma_tx_pbuf_addr-1{1'b0}},1'b1})
                                                                                               <font color = "red">-1-</font>  
                                                                                               <font color = "red">==></font>  
                                                                                               <font color = "green">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1395         assign pkt_end_mod_aph  = |dma_bus_width | gem_tx_pbuf_data_w_is_128 ? status_word_0[15:12]
                                                                                  <font color = "red">-1-</font>  
                                                                                  <font color = "red">==></font>  
                                                                                  <font color = "green">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1530         assign reading_pkt_last_word_req_vld = sample_sw0 ? reading_pkt_last_word_req_c : reading_pkt_last_word_req;
                                                               <font color = "green">-1-</font>  
                                                               <font color = "green">==></font>  
                                                               <font color = "green">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1739         assign tx_r_data      = (tx_r_pip & tx_r_valid_dph) ? tx_dob_downsize[p_emac_bus_width-1:0]
                                                                 <font color = "green">-1-</font>  
                                                                 <font color = "green">==></font>  
                                                                 <font color = "green">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1741         assign tx_r_data_par  = (tx_r_pip & tx_r_valid_dph) ? tx_dob_downsize_par[p_emac_bus_pwid-1:0]
                                                                 <font color = "green">-1-</font>  
                                                                 <font color = "green">==></font>  
                                                                 <font color = "green">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1934         assign sw_mac_fifo_din =  |store_mac_sw0_en ? {store_1st_sw0[p_dword_w+p_edma_tx_pbuf_addr+3:p_dword_w+4],store_1st_sw0[p_dword_w-1:0]}
                                                         <font color = "red">-1-</font>  
                                                         <font color = "red">==></font>  
                                                         <font color = "green">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
2046         assign late_coll_occured_mac = sw_mac_fifo_pop_hold ? late_coll_occured_hold & sw_mac_fifo_pop : late_coll_occured & sw_mac_fifo_pop;
                                                                 <font color = "red">-1-</font>  
                                                                 <font color = "red">==></font>  
                                                                 <font color = "green">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
2047         assign too_many_retries_mac  = sw_mac_fifo_pop_hold ? too_many_retries_hold & sw_mac_fifo_pop : too_many_retries & sw_mac_fifo_pop;
                                                                 <font color = "red">-1-</font>  
                                                                 <font color = "red">==></font>  
                                                                 <font color = "green">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
988            assign nxt_frame_size_word =  dma_bus_width_override == 2'b00 ? {local_sw0[11:0],2'b00} :
                                                                             <font color = "red">-1-</font>  
                                                                             <font color = "green">==></font>  
989                                          dma_bus_width_override == 2'b01 ? {local_sw0[10:0],3'b000} :
                                                                             <font color = "red">-2-</font>  
                                                                             <font color = "red">==></font>  
                                                                             <font color = "red">==></font>  
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
889            if (~tx_r_rst_n)
               <font color = "green">-1-</font>  
890            begin
891              for (sram_arb_cnt2=(p_edma_queues+2); sram_arb_cnt2>=0; sram_arb_cnt2=sram_arb_cnt2-1) begin
           <font color = "green">      ==></font>
892                sram_add_gnt[sram_arb_cnt2]  <=  1'b0;
893                if (sram_arb_cnt2 > 0) sram_dat_gnt[sram_arb_cnt2]  <=  1'b0;
894              end
895            end
896            else
897            begin
898              if (complete_flush)
                 <font color = "green">-2-</font>  
899              begin
900                for (sram_arb_cnt2=(p_edma_queues+2); sram_arb_cnt2>=0; sram_arb_cnt2=sram_arb_cnt2-1) begin
           <font color = "green">        ==></font>
901                  sram_add_gnt[sram_arb_cnt2]  <=  1'b0;
902                  if (sram_arb_cnt2 > 0) sram_dat_gnt[sram_arb_cnt2]  <=  1'b0;
903                end
904              end
905              else
906              begin
907                for (sram_arb_cnt2=(p_edma_queues+2); sram_arb_cnt2>=0; sram_arb_cnt2=sram_arb_cnt2-1) begin
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
920            if (~tx_r_rst_n)
               <font color = "green">-1-</font>  
921              sram_add_sw1  <= {p_edma_queues{1'b0}};
           <font color = "green">      ==></font>
922            else
923              for (sram_add_cnt=p_edma_queues-1; sram_add_cnt>=0; sram_add_cnt=sram_add_cnt-1) begin
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
956            if      (sram_add_gnt[0]) tx_addrb = pkt_data_sram_addr;                                                                           // Status Word 0
               <font color = "green">-1-</font>  
           <font color = "green">    ==></font>
957            else if (sram_add_gnt[1]) tx_addrb = gem_tx_pbuf_data_w_is_128 ? status_word0_add : lstatus_word2_add;                             // Status Word 2
                    <font color = "green">-2-</font>                                                       <font color = "red">-3-</font>  
                                                                              <font color = "red">==></font>  
                                                                              <font color = "green">==></font>  
958            else if (sram_add_gnt[2]) tx_addrb = lstatus_word3_add;                                                                            // Status Word 3
                    <font color = "green">-4-</font>  
           <font color = "green">    ==></font>
959            else if (sram_add_sw1_q)  tx_addrb = sw0_sweep_sram_addr_p1;
                    <font color = "green">-5-</font>  
           <font color = "green">    ==></font>
960            else                      tx_addrb = sw0_sweep_sram_addr;
           <font color = "green">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1058           if (|store_mac_sw0_en)  // restart due to collision ...
               <font color = "red">-1-</font>  
1059             queue_dma_c = store_1st_sw0[p_dword_w+3:p_dword_w];
           <font color = "red">      ==></font>
1060           else if (|status_frame_in_q && read_state == IDLE)
                    <font color = "red">-2-</font>  
1061             for (q_cnt= 0; q_cnt<p_edma_queues[31:0]; q_cnt=q_cnt+ 1)
           <font color = "red">      ==></font>
1062             begin
1063               if (status_frame_in_q[q_cnt])  // Fixed priority - highest queue num wins ...
1064                 queue_dma_c = status_index[q_cnt];
1065             end
1066           else
1067             queue_dma_c = tx_r_queue_int;
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1080           if (~tx_r_rst_n)
               <font color = "green">-1-</font>  
1081           begin
1082             queue_dma <= 4'h0;
           <font color = "green">      ==></font>
1083             queue_mac <= 4'h0;
1084           end
1085           else
1086           begin
1087             if (complete_flush)
                 <font color = "green">-2-</font>  
1088             begin
1089               queue_dma <= 4'h0;
           <font color = "green">        ==></font>
1090               queue_mac <= 4'h0;
1091             end
1092             else
1093             begin
1094               if (read_state == IDLE)
                   <font color = "green">-3-</font>  
1095                 queue_dma <= queue_dma_c;
           <font color = "green">          ==></font>
                     MISSING_ELSE
           <font color = "green">          ==></font>
1096               if (num_pkts_in_mac == 2'b00 & read_state_tr_idle2data)
                   <font color = "green">-4-</font>  
1097                 queue_mac <= queue_dma_c;
           <font color = "green">          ==></font>
1098               else if (|num_pkts_in_mac & pkt_mac_sent)
                        <font color = "green">-5-</font>  
1099                 queue_mac <= queue_dma;
           <font color = "green">          ==></font>
                     MISSING_ELSE
           <font color = "green">          ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1123             case (read_state)
                 <font color = "green">-1-</font>  
1124               IDLE  :
1125               begin
1126                 if (mac_bp)
                     <font color = "red">-2-</font>  
1127                   read_state_nxt          = IDLE;
           <font color = "red">            ==></font>
1128                 else if ((got_sw0_nxt[queue_dma_c] && !(|store_mac_sw0_en | need_to_replay) &&
                          <font color = "green">-3-</font>  
1129                           (tx_r_rd_int_pad[queue_dma_c] || status_frame_in_q[queue_dma_c])) ||
1130       
1131                         ((|store_mac_sw0_en) && (tx_r_rd_int_pad[queue_dma_c] || store_1st_sw0[31])))
1132                 begin
1133                   sw2_req                 = ~status_word2_obtained & ~sram_add_gnt[1] & ~sram_dat_gnt[1];
1134                   sw3_req                 = dma_bus_width_override == 2'b00 & ~status_word3_obtained & ~sram_add_gnt[2] & ~sram_dat_gnt[2];
1135                   sample_sw0              = 1'b1;
1136                   // If the frame is a status only frame, then only go get status - i.e. no data to send MAC
1137                   if (nxt_sw0_nxt[31])
                       <font color = "red">-4-</font>  
1138                     read_state_nxt        = WAIT_FOR_STATUS;
           <font color = "red">              ==></font>
1139                   else
1140                   begin
1141                     read_state_tr_idle2data = 1'b1;
1142                     if (reading_pkt_last_word_req_c)
                         <font color = "red">-5-</font>  
1143                       read_state_nxt        = WAIT_FOR_STATUS;
           <font color = "red">                ==></font>
1144                     else
1145                       read_state_nxt        = PKT_DATA;
           <font color = "green">                ==></font>
1146                   end
1147                 end
1148                 else if (start_reading_at_risk_q_nxt[queue_dma_c] & tx_r_rd_int_pad[queue_dma_c])
                          <font color = "red">-6-</font>  
1149                 begin
1150                   read_state_tr_idle2data = 1'b1;
           <font color = "red">            ==></font>
1151                   read_state_nxt          = PKT_DATA;
1152                 end
                     MISSING_ELSE
           <font color = "green">          ==></font>
1153               end
1154       
1155               PKT_DATA :
1156               begin
1157                 if  (need_to_replay | reading_pkt_last_word_req)
                     <font color = "green">-7-</font>  
1158                 begin
1159                   if (status_word2_obtained & status_word3_obtained)
                       <font color = "red">-8-</font>  
1160                     read_state_nxt  = IDLE;
           <font color = "green">              ==></font>
1161                   else
1162                     read_state_nxt  = WAIT_FOR_STATUS;
           <font color = "red">              ==></font>
1163                 end
1164                 else if (start_reading_at_risk_q_nxt[queue_dma] & cutthru_status_word_valid & !status_word0_obtained & !got_sw0_nxt[queue_dma])
                          <font color = "red">-9-</font>  
1165                   sample_cut_thru_sw = 1'b1; // This happens as soon as the cutthru_status_word becomes available to preload status_word_0_nxt
           <font color = "red">            ==></font>
1166                 else if (start_reading_at_risk_q_nxt[queue_dma] & got_sw0_nxt[queue_dma] & (|num_pkts_needing_read[queue_dma]) & !status_word0_obtained)
                          <font color = "red">-10-</font>  
1167                   sample_sw0      = 1'b1;// This happens a bit later than above when num_pkts_needing_read has been updated
           <font color = "red">            ==></font>
1168                 else if (sram_req_gnt[1])
                          <font color = "green">-11-</font>  
1169                   read_state_nxt  = READ_LSTATUS_WORD2;
           <font color = "green">            ==></font>
1170                 else if (sram_req_gnt[2])
                          <font color = "red">-12-</font>  
1171                   read_state_nxt  = READ_LSTATUS_WORD3;
           <font color = "red">            ==></font>
                       MISSING_ELSE
           <font color = "green">            ==></font>
1172       
1173                 sw2_req           = ~status_word2_obtained & status_word0_obtained & ~sram_add_gnt[1] & ~sram_dat_gnt[1];
1174                 sw3_req           = dma_bus_width_override == 2'b00 && ~status_word3_obtained && status_word0_obtained && ~sram_add_gnt[2] && ~sram_dat_gnt[2];
1175               end
1176       
1177               READ_LSTATUS_WORD2 :
1178               begin
1179                 sw3_req           = dma_bus_width_override == 2'b00 && status_word0_obtained;  // Only in 32b/64b mode do we need to fetch status_word2 separately
1180                 if (need_to_replay | reading_pkt_last_word_req)
                     <font color = "red">-13-</font>  
1181                   read_state_nxt  = WAIT_FOR_STATUS;
           <font color = "red">            ==></font>
1182                 else if (sram_req_gnt[2])
                          <font color = "green">-14-</font>  
1183                   read_state_nxt  = READ_LSTATUS_WORD3;
           <font color = "green">            ==></font>
1184                 else
1185                   read_state_nxt  = PKT_DATA;
           <font color = "green">            ==></font>
1186               end
1187       
1188               READ_LSTATUS_WORD3 :
1189               begin
1190                 if (need_to_replay | reading_pkt_last_word_req)
                     <font color = "red">-15-</font>  
1191                   read_state_nxt  = WAIT_FOR_STATUS;
           <font color = "red">            ==></font>
1192                 else
1193                   read_state_nxt  = PKT_DATA;
           <font color = "green">            ==></font>
1194               end
1195       
1196               default : // WAIT_FOR_STATUS only entered if we have finished reading the frame from SRAM, but havent yet got all the status words
1197               begin
1198                 sw2_req               = ~status_word2_obtained & status_word0_obtained & ~sram_add_gnt[1] & ~sram_dat_gnt[1];
1199                 sw3_req               = dma_bus_width_override == 2'b00 & ~status_word3_obtained & status_word0_obtained & ~sram_add_gnt[2] & ~sram_dat_gnt[2];
1200                 if (status_word3_obtained)
                     <font color = "red">-16-</font>  
1201                 begin
1202                   read_state_nxt      = IDLE;
           <font color = "red">            ==></font>
1203                 end
                     MISSING_ELSE
           <font color = "green">          ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>-6-</th><th nowrap width=80>-7-</th><th nowrap width=80>-8-</th><th nowrap width=80>-9-</th><th nowrap width=80>-10-</th><th nowrap width=80>-11-</th><th nowrap width=80>-12-</th><th nowrap width=80>-13-</th><th nowrap width=80>-14-</th><th nowrap width=80>-15-</th><th nowrap width=80>-16-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>IDLE </td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>IDLE </td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>IDLE </td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>IDLE </td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>IDLE </td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>IDLE </td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>PKT_DATA </td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>PKT_DATA </td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>PKT_DATA </td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>PKT_DATA </td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>PKT_DATA </td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>PKT_DATA </td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>PKT_DATA </td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>READ_LSTATUS_WORD2 </td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>READ_LSTATUS_WORD2 </td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>READ_LSTATUS_WORD2 </td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>READ_LSTATUS_WORD3 </td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>READ_LSTATUS_WORD3 </td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>default</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>default</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1212           if (~tx_r_rst_n)
               <font color = "green">-1-</font>  
1213           begin
1214             read_state            <= IDLE;
           <font color = "green">      ==></font>
1215             status_word_0         <= {p_dword_w{1'b0}};
1216             status_word_2         <= {p_dword_w{1'b0}};
1217             status_word_3         <= {p_dword_w{1'b0}};
1218             status_word0_add_int  <= {p_edma_tx_pbuf_addr{1'b0}};
1219             status_word0_obtained <= 1'b0;
1220             status_word2_obtained <= 1'b0;
1221             status_word3_obtained <= 1'b0;
1222           end
1223           else
1224           begin
1225             if (complete_flush | uflow_wait_for_dma)
                 <font color = "green">-2-</font>  
1226             begin
1227               read_state            <= IDLE;
           <font color = "green">        ==></font>
1228               status_word_0         <= {p_dword_w{1'b0}};
1229               status_word_2         <= {p_dword_w{1'b0}};
1230               status_word_3         <= {p_dword_w{1'b0}};
1231               status_word0_add_int  <= {p_edma_tx_pbuf_addr{1'b0}};
1232               status_word0_obtained <= 1'b0;
1233               status_word2_obtained <= 1'b0;
1234               status_word3_obtained <= 1'b0;
1235             end
1236             else
1237             begin
1238               read_state              <= read_state_nxt;
1239               if (sample_sw0)
                   <font color = "green">-3-</font>  
1240               begin
1241                 if (|store_mac_sw0_en)
                     <font color = "red">-4-</font>  
1242                 begin
1243                   status_word_0         <= store_1st_sw0[p_dword_w-1:0];
           <font color = "red">            ==></font>
1244                   status_word0_add_int  <= store_1st_sw0[p_dword_w+p_edma_tx_pbuf_addr+3:p_dword_w+4];
1245                 end
1246                 else
1247                 begin
1248                   status_word_0         <= status_word0_nxt[queue_dma_c];
           <font color = "green">            ==></font>
1249                   status_word0_add_int  <= status_word0_nxt_add[queue_dma_c];
1250                 end
1251               end
                   MISSING_ELSE
           <font color = "green">        ==></font>
1252       
1253               // For cut-thru operation, we can get the data straight from the cut-thru buffer
1254               if (sample_sw0 & cutthru_status_word_valid)
                   <font color = "red">-5-</font>  
1255               begin
1256                 status_word_2     <= ct_fifo_w2;
           <font color = "red">          ==></font>
1257                 status_word_3     <= ct_fifo_w3;
1258               end
1259               else if (sram_dat_gnt[1])
                        <font color = "green">-6-</font>  
1260               begin
1261                 if (gem_tx_pbuf_data_w_is_128)
                     <font color = "red">-7-</font>  
1262                 begin
1263                   status_word_2     <= tx_dob_w2;
           <font color = "red">            ==></font>
1264                   status_word_3     <= tx_dob_w3;
1265                 end
1266                 else if (dma_bus_width[0])
                          <font color = "red">-8-</font>  
1267                 begin
1268                   status_word_2     <= tx_dob_w0;
           <font color = "red">            ==></font>
1269                   status_word_3     <= tx_dob_w1;
1270                 end
1271                 else
1272                   status_word_2     <= tx_dob_w0;
           <font color = "green">            ==></font>
1273               end
1274               else if (sram_dat_gnt[2])
                        <font color = "green">-9-</font>  
1275                 status_word_3       <= tx_dob_w0;
           <font color = "green">          ==></font>
                     MISSING_ELSE
           <font color = "green">          ==></font>
1276       
1277       
1278               if (read_state_nxt == IDLE)
                   <font color = "green">-10-</font>  
1279               begin
1280                 status_word0_obtained   <= 1'b0;
           <font color = "green">          ==></font>
1281                 status_word2_obtained   <= 1'b0;
1282                 status_word3_obtained   <= 1'b0;
1283               end
1284               else if (sample_sw0)
                        <font color = "green">-11-</font>  
1285               begin
1286                 status_word0_obtained   <= 1'b1;
1287                 if (cutthru_status_word_valid)
                     <font color = "red">-12-</font>  
1288                 begin
1289                   status_word2_obtained   <= 1'b1;
           <font color = "red">            ==></font>
1290                   status_word3_obtained   <= 1'b1;
1291                 end
                     MISSING_ELSE
           <font color = "green">          ==></font>
1292               end
1293               else if (sram_dat_gnt[1] & read_state != IDLE) // impossible to get status word 1 in IDLE state - if it is set, then it is residual from previous frame and should be ignored.
                        <font color = "green">-13-</font>  
1294               begin
1295                 status_word2_obtained   <= 1'b1;
1296                 if (gem_tx_pbuf_data_w_is_128 || dma_bus_width != 2'b00)
                     <font color = "red">-14-</font>  
1297                   status_word3_obtained <= 1'b1;
           <font color = "red">            ==></font>
                       MISSING_ELSE
           <font color = "green">            ==></font>
1298               end
1299               else if (sram_dat_gnt[2] & read_state != IDLE) // impossible to get status word 2 in IDLE state - if it is set, then it is residual from previous frame and should be ignored.
                        <font color = "green">-15-</font>  
1300                 status_word3_obtained <= 1'b1;
           <font color = "green">          ==></font>
                     MISSING_ELSE
           <font color = "green">          ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>-6-</th><th nowrap width=80>-7-</th><th nowrap width=80>-8-</th><th nowrap width=80>-9-</th><th nowrap width=80>-10-</th><th nowrap width=80>-11-</th><th nowrap width=80>-12-</th><th nowrap width=80>-13-</th><th nowrap width=80>-14-</th><th nowrap width=80>-15-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1349           if (~tx_r_rst_n)
               <font color = "green">-1-</font>  
1350           begin
1351             pkt_data_sram_addr  <= {p_edma_tx_pbuf_addr{1'b0}};
           <font color = "green">      ==></font>
1352             //first_word_read     <= 1'b0;
1353           end
1354           else
1355           begin
1356             if (complete_flush)
                 <font color = "green">-2-</font>  
1357             begin
1358               pkt_data_sram_addr  <= {p_edma_tx_pbuf_addr{1'b0}};
           <font color = "green">        ==></font>
1359               //first_word_read     <= 1'b0;
1360             end
1361             else
1362             begin
1363               if (|store_mac_sw0_en & read_state_tr_idle2data)
                   <font color = "red">-3-</font>  
1364               begin
1365                 pkt_data_sram_addr  <= bind2queueRange((store_1st_sw0[p_dword_w+p_edma_tx_pbuf_addr+3:p_dword_w+4] + pkt_data_addr_inc),
           <font color = "red">          ==></font>
1366                                                        TX_PBUF_SEGMENTS_UPPER_ADDR_ARRAY[queue_dma_c],
1367                                                        TX_PBUF_SEGMENTS_LOWER_ADDR_ARRAY[queue_dma_c],
1368                                                        TX_PBUF_NUM_SEGMENTS_ARRAY[queue_dma_c]);
1369                 //first_word_read   <= sram_req_gnt[0];
1370               end
1371               else if (read_state_tr_idle2data)
                        <font color = "green">-4-</font>  
1372               begin
1373                 pkt_data_sram_addr  <= bind2queueRange((status_word0_nxt_add[queue_dma_c] + pkt_data_addr_inc),
           <font color = "green">          ==></font>
1374                                                        TX_PBUF_SEGMENTS_UPPER_ADDR_ARRAY[queue_dma_c],
1375                                                        TX_PBUF_SEGMENTS_LOWER_ADDR_ARRAY[queue_dma_c],
1376                                                        TX_PBUF_NUM_SEGMENTS_ARRAY[queue_dma_c]);
1377                 //first_word_read   <= sram_req_gnt[0];
1378               end
1379               else if (sram_req_gnt[0])
                        <font color = "green">-5-</font>  
1380               begin
1381                 //first_word_read   <= 1'b1;
1382                 //if (first_word_read)
1383                 //begin
1384                   // Jump over status word
1385                   if ((!status_word0_obtained & pkt_data_nxt_add == status_word0_nxt_add[queue_dma]) |
                       <font color = "red">-6-</font>  
1386                       (status_word0_obtained  & pkt_data_nxt_add == status_word0_add_int))
1387                     pkt_data_sram_addr  <= pkt_data_nxt_add2;
           <font color = "red">              ==></font>
1388                   else
1389                     pkt_data_sram_addr  <= pkt_data_nxt_add;
           <font color = "green">              ==></font>
1390                 //end
1391               end
                   MISSING_ELSE
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>-6-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1414           if (|dma_bus_width || gem_tx_pbuf_data_w_is_128)
               <font color = "red">-1-</font>  
1415             pkt_end_addr_int = pkt_end_addr_sum1[16:0];
           <font color = "red">      ==></font>
1416           else
1417             pkt_end_addr_int = pkt_end_addr_sum2;
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1553           if (need_to_replay)
               <font color = "red">-1-</font>  
1554             num_pkts_in_mac_nxt = 2'b00;
           <font color = "red">      ==></font>
1555           else if (read_state == IDLE && read_state_nxt != IDLE)
                    <font color = "green">-2-</font>  
1556           begin
1557             if (~sw_mac_fifo_pop)
                 <font color = "red">-3-</font>             
1558               num_pkts_in_mac_nxt = num_pkts_in_mac + 2'b01;
           <font color = "green">        ==></font>
1559             else
1560               num_pkts_in_mac_nxt = num_pkts_in_mac;
           <font color = "red">        ==></font>
1561           end
1562           else if (sw_mac_fifo_pop)
                    <font color = "green">-4-</font>            
1563             num_pkts_in_mac_nxt = num_pkts_in_mac - 2'b01;
           <font color = "green">      ==></font>
1564           else
1565             num_pkts_in_mac_nxt = num_pkts_in_mac;
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1571           if (~tx_r_rst_n)
               <font color = "green">-1-</font>  
1572           begin
1573             num_pkts_in_mac             <= 2'b00;
           <font color = "green">      ==></font>
1574             store_mac_sw0_en            <= 2'b00;
1575             store_1st_sw0               <= {p_dword_w+p_edma_tx_pbuf_addr+4{1'b0}};
1576             store_2nd_sw0               <= {p_dword_w+p_edma_tx_pbuf_addr+4{1'b0}};
1577             need_to_replay_r            <= 1'b0;
1578           end
1579           else
1580           begin
1581             if (complete_flush)
                 <font color = "green">-2-</font>  
1582             begin
1583               num_pkts_in_mac             <= 2'b00;
           <font color = "green">        ==></font>
1584               store_mac_sw0_en            <= 2'b00;
1585               store_1st_sw0               <= {p_dword_w+p_edma_tx_pbuf_addr+4{1'b0}};
1586               store_2nd_sw0               <= {p_dword_w+p_edma_tx_pbuf_addr+4{1'b0}};
1587               need_to_replay_r            <= 1'b0;
1588             end
1589             else
1590             begin
1591               num_pkts_in_mac             <= num_pkts_in_mac_nxt;
1592               if (status_word2_obtained & status_word3_obtained)
                   <font color = "green">-3-</font>  
1593                 need_to_replay_r          <= 1'b0;
           <font color = "green">          ==></font>
1594               else if (need_to_replay & read_state != IDLE)
                        <font color = "red">-4-</font>  
1595                 need_to_replay_r          <= 1'b1;
           <font color = "red">          ==></font>
                     MISSING_ELSE
           <font color = "green">          ==></font>
1596       
1597               if (need_to_replay & ~store_mac_sw0_en[1])
                   <font color = "red">-5-</font>  
1598               begin
1599                 // Case 1 :  collision occuring while frame is being transferred, 1 pkt_in_mac - need to replay
1600                 if (num_pkts_in_mac == 2'b01 & read_state != IDLE)
                     <font color = "red">-6-</font>  
1601                 begin
1602                   store_mac_sw0_en      <= 2'b01;
           <font color = "red">            ==></font>
1603                   store_1st_sw0         <= {status_word0_add_mac,queue_mac,status_word_mac_0};
1604                   store_2nd_sw0         <= {p_dword_w+p_edma_tx_pbuf_addr+4{1'b0}};
1605                 end
1606                 // Case 2 : collision occuring after frame has being transferred, 1 pkt_in_mac - need to replay and shift
1607                 else if (num_pkts_in_mac == 2'b01)
                          <font color = "red">-7-</font>  
1608                 begin
1609                   store_mac_sw0_en      <= store_mac_sw0_en + 2'b01;
           <font color = "red">            ==></font>
1610                   store_1st_sw0         <= {status_word0_add_mac,queue_mac,status_word_mac_0};
1611                   store_2nd_sw0         <= store_1st_sw0;
1612                 end
1613                 // Case 3 : normal collision, 2 pkt_in_mac, replay oldest
1614                 else if (num_pkts_in_mac == 2'b10 & !replay_residual_frame)
                          <font color = "red">-8-</font>  
1615                 begin
1616                   store_mac_sw0_en      <= 2'b10;
           <font color = "red">            ==></font>
1617                   store_1st_sw0         <= {status_word0_add_mac,queue_mac,status_word_mac_0};
1618                   store_2nd_sw0         <= {status_word0_add,    queue_dma,status_word_0};
1619                 end
1620                 // Case 4 : late collision/tmr, 2 pkt_in_mac, replay newest
1621                 else //if (num_pkts_in_mac == 2'b10)
1622                 begin
1623                   store_mac_sw0_en      <= 2'b01;
           <font color = "red">            ==></font>
1624                   store_1st_sw0         <= {status_word0_add,    queue_dma,status_word_0};
1625                   store_2nd_sw0         <= {p_dword_w+p_edma_tx_pbuf_addr+4{1'b0}};
1626                 end
1627               end
1628               else if (read_state != IDLE & read_state_nxt == IDLE & (|store_mac_sw0_en) & ~need_to_replay)
                        <font color = "red">-9-</font>  
1629               begin
1630                 store_mac_sw0_en      <= store_mac_sw0_en - 2'b01;
           <font color = "red">          ==></font>
1631                 store_1st_sw0         <= store_2nd_sw0;
1632                 store_2nd_sw0         <= {p_dword_w+p_edma_tx_pbuf_addr+4{1'b0}};
1633               end
                   MISSING_ELSE
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>-6-</th><th nowrap width=80>-7-</th><th nowrap width=80>-8-</th><th nowrap width=80>-9-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1642           if (~tx_r_rst_n)
               <font color = "green">-1-</font>  
1643           begin
1644             reading_pkt_last_word_add   <= 1'b0;
           <font color = "green">      ==></font>
1645             tx_r_mod_dph                <= 4'h0;
1646             tx_r_flushed_uflow          <= 1'b0;
1647             tx_r_underflow_dph          <= 1'b0;
1648             tx_r_sop_aph                <= 1'b0;
1649             tx_r_sop_dph                <= 1'b1;
1650             tx_r_eop_dph                <= 1'b0;
1651             tx_r_err_dph                <= 1'b0;
1652             tx_r_valid_dph              <= 1'b0;
1653             tx_r_data_rdy_aph           <= {p_edma_queues{1'b0}};
1654             tx_r_control_r              <= 1'b0;
1655             tx_r_pip                    <= 1'b0;
1656           end
1657           else
1658           begin
1659             if (complete_flush)
                 <font color = "green">-2-</font>  
1660             begin
1661               reading_pkt_last_word_add   <= 1'b0;
           <font color = "green">        ==></font>
1662               tx_r_mod_dph                <= 4'h0;
1663               tx_r_flushed_uflow          <= 1'b0;
1664               tx_r_underflow_dph          <= 1'b0;
1665               tx_r_sop_dph                <= 1'b1;
1666               tx_r_eop_dph                <= 1'b0;
1667               tx_r_err_dph                <= 1'b0;
1668               tx_r_sop_aph                <= 1'b0;
1669               tx_r_valid_dph              <= 1'b0;
1670               tx_r_data_rdy_aph           <= {p_edma_queues{1'b0}};
1671               tx_r_control_r              <= 1'b0;
1672               tx_r_pip                    <= 1'b0;
1673             end
1674             else
1675             begin
1676               tx_r_control_r  <= tx_r_control;
1677       
1678               if (|tx_r_rd_int)
                   <font color = "green">-3-</font>  
1679                 reading_pkt_last_word_add <= reading_pkt_last_word_req_vld;
           <font color = "green">          ==></font>
                     MISSING_ELSE
           <font color = "green">          ==></font>
1680       
1681               for (b1=0;b1<p_edma_queues[31:0];b1=b1+1)
1682               begin
1683                 // Clear the stored tx_r_data_rdy on the last request
1684                 // Also need to clear everything down if we are about to replay due to a collision or if there was an udnerflow
1685                 if (need_to_replay | uflow_wait_for_dma)
1686                   tx_r_data_rdy_aph[b1]   <= 1'b0;
1687                 else if (tx_r_rd[b1] & reading_pkt_last_word_add)
1688                   tx_r_data_rdy_aph[b1]   <= tx_r_data_rdy_rph[b1];
1689                 else if (tx_r_data_rdy_rph[b1])
1690                   tx_r_data_rdy_aph[b1]   <= 1'b1;
1691               end
1692       
1693               tx_r_valid_dph              <= |tx_r_rd;
1694       
1695               tx_r_mod_dph                <= pkt_end_mod_aph[3:0];
1696               tx_r_underflow_dph          <= |tx_r_rd & dpram_almost_empty_sync[queue_dma] & start_reading_at_risk_q[queue_dma];
1697               tx_r_sop_aph                <= read_state_tr_idle2data;
1698               tx_r_sop_dph                <= tx_r_sop_aph;
1699               tx_r_eop_dph                <= (|tx_r_rd & reading_pkt_last_word_add);
1700               tx_r_err_dph                <= (|tx_r_rd & reading_pkt_last_word_add & (|status_word_0[30:28]));
1701               tx_r_flushed_uflow          <= underflow_frame;
1702       
1703               if (tx_r_sop_aph)
                   <font color = "green">-4-</font>  
1704                 tx_r_pip  <= 1'b1;
           <font color = "green">          ==></font>
1705               else if (tx_r_eop_dph)
                        <font color = "green">-5-</font>  
1706                 tx_r_pip  <= 1'b0;
           <font color = "green">          ==></font>
                     MISSING_ELSE
           <font color = "green">          ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1720           if (status_word0_obtained)
               <font color = "green">-1-</font>  
1721             tx_r_control   = status_word_0[27] & ~status_word_0[31];
           <font color = "green">      ==></font>
1722           else if (tx_r_eop & tx_r_valid)
                    <font color = "green">-2-</font>  
1723             tx_r_control   = 1'b0;
           <font color = "green">      ==></font>
1724           else
1725             tx_r_control   = tx_r_control_r;
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1784             if (read_state_nxt == IDLE | part_pkt_trigger)
                 <font color = "green">-1-</font>  
1785               pkt_dplocns_cnt_part_nxt = 5'h01;
           <font color = "green">        ==></font>
1786             else if (sram_req_gnt[0] & data_to_mac_xfer_mode)
                      <font color = "green">-2-</font>  
1787               pkt_dplocns_cnt_part_nxt = pkt_dplocns_cnt_part + 5'h01;
           <font color = "green">        ==></font>
1788             else
1789               pkt_dplocns_cnt_part_nxt = {1'b0,pkt_dplocns_cnt_part};
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1791             if (read_state_nxt == IDLE)
                 <font color = "green">-1-</font>  
1792               pkt_dplocns_cnt_nxt    = 12'h001;
           <font color = "green">        ==></font>
1793             else if (sram_req_gnt[0])
                      <font color = "green">-2-</font>  
1794               pkt_dplocns_cnt_nxt    = pkt_dplocns_cnt + 12'h001;
           <font color = "green">        ==></font>
1795             else
1796               pkt_dplocns_cnt_nxt    = {1'b0,pkt_dplocns_cnt};
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1798             if (read_state_nxt == IDLE && read_state != IDLE)
                 <font color = "green">-1-</font>  
1799               clr_dplocns_val_nxt    = 13'd0;
           <font color = "green">        ==></font>
1800             else if (|store_mac_sw0_en & read_state_tr_idle2data) // replaying a frame from storage buffer
                      <font color = "red">-2-</font>  
1801               clr_dplocns_val_nxt  = {1'b0,nxt_sw0_nxt[11:0]};
           <font color = "red">        ==></font>
1802             else if (sample_sw0)
                      <font color = "green">-3-</font>  
1803               clr_dplocns_val_nxt  = clr_dplocns_val + nxt_sw0_nxt[11:0];
           <font color = "green">        ==></font>
1804             else
1805             begin
1806               // Now reduce clr_dplocns_val as we progress through the frame ...
1807               if (part_pkt_trigger)
                   <font color = "green">-4-</font>  
1808                 clr_dplocns_val_nxt  = tmp_clr_dplocns_nxt[12:0];
           <font color = "green">          ==></font>
1809               else
1810                 clr_dplocns_val_nxt  = {1'b0,clr_dplocns_val};
           <font color = "green">          ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1816           if (~tx_r_rst_n)
               <font color = "green">-1-</font>  
1817           begin
1818             clr_dplocns_val       <= 12'd0;
           <font color = "green">      ==></font>
1819             pkt_dplocns_cnt_part  <= 5'h00;
1820             pkt_dplocns_cnt       <= 12'd0;
1821           end
1822           else
1823           begin
1824             if (complete_flush)
                 <font color = "green">-2-</font>  
1825             begin
1826               clr_dplocns_val       <= 12'd0;
           <font color = "green">        ==></font>
1827               pkt_dplocns_cnt_part  <= 5'h00;
1828               pkt_dplocns_cnt       <= 12'd0;
1829             end
1830             else
1831             begin
1832               clr_dplocns_val       <= clr_dplocns_val_nxt[11:0];
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1848           if (~tx_r_rst_n)
               <font color = "green">-1-</font>  
1849           begin
1850             part_pkt_queue  <= 4'h0;
           <font color = "green">      ==></font>
1851             part_pkt_read   <= 1'b0;
1852           end
1853           else if (complete_flush)
                    <font color = "green">-2-</font>  
1854           begin
1855             part_pkt_queue  <= 4'h0;
           <font color = "green">      ==></font>
1856             part_pkt_read   <= part_pkt_read;
1857           end
1858           else if (part_pkt_trigger)
                    <font color = "green">-3-</font>  
1859           begin
1860             part_pkt_queue  <= queue_dma;
           <font color = "green">      ==></font>
1861             part_pkt_read   <= ~part_pkt_read;
1862           end
               MISSING_ELSE
           <font color = "green">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1880           if (~tx_r_rst_n)
               <font color = "green">-1-</font>  
1881           begin
1882             dma_tx_end_tog_prev       <= 1'b0;
           <font color = "green">      ==></font>
1883             dma_tx_small_end_tog_prev <= 1'b0;
1884           end
1885           else if (complete_flush)
                    <font color = "green">-2-</font>  
1886           begin
1887             dma_tx_end_tog_prev       <= dma_tx_end_tog_prev;
           <font color = "green">      ==></font>
1888             dma_tx_small_end_tog_prev <= dma_tx_small_end_tog_prev;
1889           end
1890           else
1891           begin
1892             dma_tx_end_tog_prev       <= dma_tx_end_tog;
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1906         if (~tx_r_rst_n)
             <font color = "green">-1-</font>  
1907           dma_tx_status_tog <= 1'b0;
           <font color = "green">    ==></font>
1908         else
1909           begin
1910             if (pkt_mac_sent | coll_occurred_le)
                 <font color = "green">-2-</font>  
1911               dma_tx_status_tog <= ~dma_tx_status_tog;
           <font color = "green">        ==></font>
                   MISSING_ELSE
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1919           if (~tx_r_rst_n)
               <font color = "green">-1-</font>  
1920             coll_occurred_d1 <= 1'b0;
           <font color = "green">      ==></font>
1921           else
1922             coll_occurred_d1 <= collision_occured;
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
1963            if (gem_tx_pbuf_data_w_is_128)
                <font color = "red">-1-</font>  
1964              clr_dplocns_val_pstatus  = clr_dplocns_val + 12'd1;
           <font color = "red">       ==></font>
1965            else if (dma_bus_width[0])
                     <font color = "red">-2-</font>  
1966              clr_dplocns_val_pstatus  = clr_dplocns_val + 12'd2;
           <font color = "red">       ==></font>
1967            else
1968              clr_dplocns_val_pstatus  = clr_dplocns_val + 12'd4;
           <font color = "green">       ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
2009           if (~tx_r_rst_n)
               <font color = "green">-1-</font>  
2010           begin
2011             sw_mac_fifo_pop_hold          <= 1'b0;
           <font color = "green">      ==></font>
2012             late_coll_occured_hold        <= 1'b0;
2013             too_many_retries_hold         <= 1'b0;
2014           end
2015           else if (complete_flush)
                    <font color = "green">-2-</font>  
2016           begin
2017             sw_mac_fifo_pop_hold          <= 1'b0;
           <font color = "green">      ==></font>
2018             late_coll_occured_hold        <= 1'b0;
2019             too_many_retries_hold         <= 1'b0;
2020           end
2021           else
2022           begin
2023             if      (sw_mac_fifo_pop_raw & wb_status_to_tx_wr_fifo_full)
                 <font color = "red">-3-</font>                                                   
2024             begin
2025               sw_mac_fifo_pop_hold        <= 1'b1;
           <font color = "red">        ==></font>
2026               late_coll_occured_hold      <= late_coll_occured;
2027               too_many_retries_hold       <= too_many_retries;
2028             end
2029             else if (sw_mac_fifo_pop_raw & sw_mac_fifo_2_empty)
                      <font color = "red">-4-</font>                                  
2030             begin
2031               sw_mac_fifo_pop_hold        <= 1'b1;
           <font color = "red">        ==></font>
2032               late_coll_occured_hold      <= late_coll_occured;
2033               too_many_retries_hold       <= too_many_retries;
2034             end
2035             else if (!wb_status_to_tx_wr_fifo_full & !sw_mac_fifo_2_empty)
                      <font color = "green">-5-</font>                                             
2036             begin
2037               sw_mac_fifo_pop_hold        <= 1'b0;
           <font color = "green">        ==></font>
2038               late_coll_occured_hold      <= late_coll_occured_hold;
2039               too_many_retries_hold       <= too_many_retries_hold;
2040             end
                 MISSING_ELSE
           <font color = "green">      ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
2052           if (~tx_r_rst_n)
               <font color = "green">-1-</font>  
2053           begin
2054             full_pkt_read                 <= 1'b0;
           <font color = "green">      ==></font>
2055             xfer_status_captured_edge_d1  <= 1'b0;
2056           end
2057           else if (complete_flush)
                    <font color = "green">-2-</font>  
2058           begin
2059             full_pkt_read                 <= full_pkt_read;
           <font color = "green">      ==></font>
2060             xfer_status_captured_edge_d1  <= 1'b0;
2061           end
2062           else
2063           begin
2064             xfer_status_captured_edge_d1  <= xfer_status_captured_edge & !wb_status_to_tx_wr_fifo_empty;
2065             if ((xfer_status_captured_edge_d1 & !wb_status_to_tx_wr_fifo_empty) |
                 <font color = "green">-3-</font>                                                         
2066                 (sw_mac_fifo_pop              & wb_status_to_tx_wr_fifo_empty))
2067               full_pkt_read               <= ~full_pkt_read;
           <font color = "green">        ==></font>
                   MISSING_ELSE
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
2121         if (~tx_r_rst_n)
             <font color = "green">-1-</font>  
2122         begin
2123           uflow_wait_for_mac <= 1'b0;
           <font color = "green">    ==></font>
2124           uflow_wait_for_dma <= 1'b0;
2125           underflow_tog  <= 1'b0;
2126         end
2127         else
2128         begin
2129           if (complete_flush)
               <font color = "green">-2-</font>  
2130           begin
2131             uflow_wait_for_mac <= 1'b0;
           <font color = "green">      ==></font>
2132             uflow_wait_for_dma <= 1'b0;
2133           end
2134           else if (tx_r_underflow_dph)
                    <font color = "red">-3-</font>  
2135           begin
2136             uflow_wait_for_mac <= 1'b1;
           <font color = "red">      ==></font>
2137             uflow_wait_for_dma <= 1'b1;
2138           end
2139           else if (underflow_frame)
                    <font color = "red">-4-</font>  
2140           begin
2141             uflow_wait_for_mac <= 1'b0;
2142             if (uflow_wait_for_mac)
                 <font color = "red">-5-</font>  
2143               underflow_tog <= ~underflow_tog;
           <font color = "red">        ==></font>
                   MISSING_ELSE
           <font color = "red">        ==></font>
2144           end
               MISSING_ELSE
           <font color = "green">    ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
462              if (~tx_r_rst_n)
                 <font color = "green">-1-</font>  
463                start_reading_at_risk_q[g] <= 1'b0;
           <font color = "green">        ==></font>
464              else
465                start_reading_at_risk_q[g] <= start_reading_at_risk_q_nxt[g];
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
468              if (~tx_r_rst_n)
                 <font color = "green">-1-</font>  
469                cutthru_pending_q <= 1'b0;
           <font color = "green">        ==></font>
470              else if (end_of_packet_edge[g])
                      <font color = "green">-2-</font>  
471                cutthru_pending_q <= 1'b0;
           <font color = "green">        ==></font>
472              else if (part_of_packet_edge[g] && (read_state != IDLE || num_pkts_needing_read[g] != 8'd0))
                      <font color = "red">-3-</font>  
473                cutthru_pending_q <= 1'b1;
           <font color = "red">        ==></font>
                   MISSING_ELSE
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
479              if (complete_flush)
                 <font color = "green">-1-</font>  
480                start_reading_at_risk_q_nxt[g] = 1'b0;
           <font color = "green">        ==></font>
481              else
482                // Parts of pkts are more straight forward
483                // We only care about full duplex, so restarts are irrelevant here
484                // Also transfers from the AHB side that contain no data (errored transfers)
485                // also are irrelevant as they are only indicated through pkt_written
486                // start_reading_at_risk_q_nxt gets set if part_of_packet_edge goes high
487                if (start_reading_at_risk_q[g] &
                   <font color = "red">-2-</font>  
488                      ((queue_dma == g[3:0] & status_word3_obtained) | tx_r_underflow ))
489                  start_reading_at_risk_q_nxt[g] = 1'b0;
           <font color = "red">          ==></font>
490        
491                else if ((part_of_packet_edge[g]||cutthru_pending_q) && read_state == IDLE && !(|num_pkts_needing_read[g]))
                        <font color = "red">-3-</font>  
492                  start_reading_at_risk_q_nxt[g] = 1'b1;
           <font color = "red">          ==></font>
                     MISSING_ELSE
           <font color = "green">          ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
511            if (~tx_r_rst_n)
               <font color = "green">-1-</font>  
512            begin
513              cutthru_status_word_pop_r     <= 1'b0;
           <font color = "green">      ==></font>
514              cutthru_status_word_valid_r   <= 1'b0;
515            end
516            else
517            begin
518              if (complete_flush)
                 <font color = "green">-2-</font>  
519              begin
520                cutthru_status_word_pop_r     <= 1'b0;
           <font color = "green">        ==></font>
521                cutthru_status_word_valid_r   <= 1'b0;
522              end
523              // When the SW0 has been sampled, we can always pop this FIFO as it means the this block has already captured the SW from
524              // the cutthru buffer, or it wasnt needed at all. Also dont need it in IDLE state, as that would mean we can just get the
525              // SW from SRAM
526              else if (!cutthru_status_word_empty && (sample_sw0 || read_state == IDLE))
                      <font color = "red">-3-</font>  
527              begin
528                cutthru_status_word_pop_r   <= 1'b1;
           <font color = "red">        ==></font>
529                cutthru_status_word_valid_r <= 1'b0;
530              end
531              else
532              begin
533                cutthru_status_word_pop_r   <= 1'b0;
534                // Only need to use the cutthru buffer if we have already said we would via start_reading_at risk
535                // there cant be any full frames buffered for this to work ..
536                if (start_reading_at_risk_q_nxt[queue_dma])
                   <font color = "red">-4-</font>  
537                begin
538                  // Determine if the status words in the cutthru status word FIFO match the current frame.
539                  cutthru_status_word_valid_r <= !cutthru_status_word_empty && !cutthru_status_word_pop_r &&
           <font color = "red">          ==></font>
540                                                  cutthru_status_word[p_edma_tx_pbuf_addr-1+128:128] == status_word0_nxt_add[queue_dma];
541                end
                   MISSING_ELSE
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
568              if (~tx_r_rst_n)
                 <font color = "green">-1-</font>  
569                begin
570                event_frame_tx_d1   <= 1'b0;
           <font color = "green">        ==></font>
571                general_frame_tx_d1 <= 1'b0;
572                end
573              else
574              begin
575                if (complete_flush)
                   <font color = "green">-2-</font>  
576                begin
577                  event_frame_tx_d1   <= 1'b0;
           <font color = "green">          ==></font>
578                  general_frame_tx_d1 <= 1'b0;
579                end
580                else
581                begin
582                  event_frame_tx_d1   <=  event_frame_tx;
           <font color = "green">          ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
590              casex ({tx_bd_ts_mode, general_frame_tx_d1, event_frame_tx_d1})
                 <font color = "red">-1-</font>  
591                4'b00xx:  // no frames
592                         ts_to_be_written = 1'b0;
           <font color = "green">                 ==></font>
593                4'b0101:  // event frames only
594                         ts_to_be_written = 1'b1;
           <font color = "red">                 ==></font>
595                4'b1010:  // general frames (ie all ptp frames)
596                         ts_to_be_written = 1'b1;
           <font color = "red">                 ==></font>
597                4'b1001:  // event frames (ie all ptp frames)
598                         ts_to_be_written = 1'b1;
           <font color = "red">                 ==></font>
599                4'b11xx:  // all frames
600                         ts_to_be_written = 1'b1;
           <font color = "red">                 ==></font>
601                default: ts_to_be_written = 1'b0;
           <font color = "red">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>4'b00xx </td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>4'b0101 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>4'b1010 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>4'b1001 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>4'b11xx </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>default</td>
<td>Not Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
672              if (~tx_r_rst_n)
                 <font color = "green">-1-</font>  
673              begin
674                num_pkts_needing_read[i] <= 8'h00;
           <font color = "green">        ==></font>
675              end
676              else if (complete_flush)
                      <font color = "green">-2-</font>  
677              begin
678                num_pkts_needing_read[i] <= 8'h00;
           <font color = "green">        ==></font>
679              end
680              else
681              begin
682                num_pkts_needing_read[i] <= num_pkts_needing_read_nxt[i] -
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
741              if (~tx_r_rst_n)
                 <font color = "green">-1-</font>  
742              begin
743                need_sw0_nxt_req[i1]        <= 1'b1;
           <font color = "green">        ==></font>
744                need_sw1_nxt_req[i1]        <= 1'b1;
745                got_sw0_nxt[i1]             <= 1'b0;
746                got_sw1_nxt[i1]             <= 1'b0;
747                status_word0_nxt_add[i1]    <= {p_edma_tx_pbuf_addr{1'b0}};
748                status_word0_nxt[i1]        <= {p_dword_w{1'b0}};
749                status_word1_nxt[i1]        <= {p_dword_w{1'b0}};
750              end
751              else
752              begin
753                if (complete_flush)
                   <font color = "green">-2-</font>  
754                begin
755                  need_sw0_nxt_req[i1]           <= 1'b1;
           <font color = "green">          ==></font>
756                  need_sw1_nxt_req[i1]           <= bd_extended_mode_en && !gem_tx_pbuf_data_w_is_128;
757                  got_sw0_nxt[i1]                <= 1'b0;
758                  got_sw1_nxt[i1]                <= 1'b0;
759                  status_word0_nxt_add[i1][p_edma_tx_pbuf_addr-1:p_edma_tx_pbuf_addr-p_edma_tx_pbuf_queue_segment_size] <=
760                                                              TX_PBUF_SEGMENTS_LOWER_ADDR_ARRAY[i1];
761                  status_word0_nxt_add[i1][p_edma_tx_pbuf_addr-p_edma_tx_pbuf_queue_segment_size-1:0] <=
762                                                              {p_edma_tx_pbuf_addr-p_edma_tx_pbuf_queue_segment_size{1'b0}};
763                  status_word0_nxt[i1]           <= {p_dword_w{1'b0}};
764                end
765        
766                else
767                begin
768                  if (sample_cut_thru_sw & {{28{1'b0}},queue_dma} == i1)
                     <font color = "red">-3-</font>  
769                  begin
770                    need_sw0_nxt_req[i1]           <= 1'b0;
           <font color = "red">            ==></font>
771                    need_sw1_nxt_req[i1]           <= 1'b0;
772                  end
773                  else if (sram_req_gnt[i1+3])
                          <font color = "green">-4-</font>  
774                  begin
775                    if (!need_sw1_nxt_req[i1] || gem_tx_pbuf_data_w_is_128 || dma_bus_width == 2'b01) // If already requested the launch time in SW1, or can get both SW0 and SW1 in 1 access
                       <font color = "red">-5-</font>  
776                    begin
777                      need_sw1_nxt_req[i1]         <= 1'b0;
           <font color = "green">              ==></font>
778                      need_sw0_nxt_req[i1]         <= 1'b0;
779                    end
780                    else
781                      need_sw1_nxt_req[i1]         <= 1'b0; // 32 bit only - still need SW0
           <font color = "red">              ==></font>
782                  end
783                  else if (sample_sw0 && (i1 == {{28{1'b0}},queue_dma_c}) & ~(|store_mac_sw0_en))
                          <font color = "green">-6-</font>  
784                  begin
785                    need_sw1_nxt_req[i1]      <= bd_extended_mode_en && !gem_tx_pbuf_data_w_is_128;
           <font color = "green">            ==></font>
786                    need_sw0_nxt_req[i1]      <= 1'b1;
787                    status_word0_nxt_add[i1]  <= bind2queueRange(tmp_nxt_start_addr[p_edma_tx_pbuf_addr-1:0],
788                                                 TX_PBUF_SEGMENTS_UPPER_ADDR_ARRAY[i1],
789                                                 TX_PBUF_SEGMENTS_LOWER_ADDR_ARRAY[i1],
790                                                 TX_PBUF_NUM_SEGMENTS_ARRAY[i1]);
791                  end
792                  else if (!bd_extended_mode_en)
                          <font color = "red">-7-</font>  
793                    need_sw1_nxt_req[i1]      <= 1'b0;
           <font color = "green">            ==></font>
                       MISSING_ELSE
           <font color = "red">            ==></font>
794        
795                  // If the cutthru bus comes in first with the SW0, then need_sw0_nxt_req will go low on nxt cycle
796                  // thus blocking any chance for the normal SRAM request to fetch SW0
797                  // If the num_pkts_needing_read bus increments first, or at the same time, then we need to block
798                  // the result from this from loading got_sw0_nxt and the status word. This is because the sw0
799                  // and the got_sw0_nxt bus will be loaded from the cutthru bus instead.
800                  if (sample_cut_thru_sw & {{28{1'b0}},queue_dma} == i1)
                     <font color = "red">-8-</font>  
801                  begin
802                    got_sw0_nxt[i1]             <= 1'b1;
           <font color = "red">            ==></font>
803                    got_sw1_nxt[i1]             <= 1'b1;
804                    status_word0_nxt[i1]        <= ct_fifo_w0;
805                    status_word1_nxt[i1]        <= ct_fifo_w1;
806                  end
807                  else if (sram_dat_gnt[i1+3])
                          <font color = "green">-9-</font>  
808                  begin
809                    if (got_sw1_nxt[i1] || gem_tx_pbuf_data_w_is_128 || dma_bus_width == 2'b01 || !bd_extended_mode_en) // If we already have SW1, or can get both SW0 and SW1 in 1 access
                       <font color = "red">-10-</font>  
810                    begin
811                      got_sw0_nxt[i1]           <= 1'b1;
812                      status_word0_nxt[i1]      <= tx_dob_w0;
813                      if (!got_sw1_nxt[i1])
                         <font color = "red">-11-</font>  
814                      begin
815                        status_word1_nxt[i1]    <= tx_dob_w1;
           <font color = "green">                ==></font>
816                        got_sw1_nxt[i1]         <= 1'b1;
817                      end
                         MISSING_ELSE
           <font color = "red">              ==></font>
818                    end
819                    else  // 32 bit, got SW1 now, but still need SW0
820                    begin
821                      got_sw1_nxt[i1]           <= 1'b1;
           <font color = "red">              ==></font>
822                      status_word1_nxt[i1]      <= tx_dob_w0;
823                    end
824                  end
825                  else if (sample_sw0 && (i1 == {{28{1'b0}},queue_dma_c}) & ~(|store_mac_sw0_en))
                          <font color = "green">-12-</font>  
826                  begin
827                    got_sw0_nxt[i1]          <= 1'b0;
           <font color = "green">            ==></font>
828                    got_sw1_nxt[i1]          <= 1'b0;
829                  end
                     MISSING_ELSE
           <font color = "green">          ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>-3-</th><th nowrap width=80>-4-</th><th nowrap width=80>-5-</th><th nowrap width=80>-6-</th><th nowrap width=80>-7-</th><th nowrap width=80>-8-</th><th nowrap width=80>-9-</th><th nowrap width=80>-10-</th><th nowrap width=80>-11-</th><th nowrap width=80>-12-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>1</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>1</td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td align=center>0</td>
<td align=center nowrap>-</td>
<td align=center nowrap>-</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
851              if (gem_tx_pbuf_data_w_is_128)
                 <font color = "red">-1-</font>  
852                tmp_nxt_start_addr = tmp_end_addr[16:0] + 17'd1 ; // 4 status words fit into 1 SRAM locn
           <font color = "red">        ==></font>
853              else if (dma_bus_width[0])
                      <font color = "red">-2-</font>  
854                tmp_nxt_start_addr = tmp_end_addr[16:0] + 17'd2 ; // 4 status words fit into 2 SRAM locns
           <font color = "red">        ==></font>
855              else
856                tmp_nxt_start_addr = tmp_end_addr[16:0] + 17'd4;  // 4 status words fit into 4 SRAM locns
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>-2-</th><th nowrap width=80>Status</th></tr><tr class="uRed">
<td align=center>1</td>
<td align=center nowrap>-</td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>0</td>
<td align=center>1</td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>0</td>
<td align=center>0</td>
<td>Covered</td>
</tr></table><br clear=all>
<pre class="code"><br clear=all>
993              case ({ (local_sw0[15] | !dma_bus_width_override[1]),
                 <font color = "red">-1-</font>  
994                      (local_sw0[14] | !(|dma_bus_width_override)),
995                      (local_sw0[13:12])})
996                4'b1111   : nxt_frame_size_local = nxt_frame_size_word + 14'd23; // +24-1
           <font color = "green">        ==></font>
997                4'b1110   : nxt_frame_size_local = nxt_frame_size_word + 14'd22; // +24-2
           <font color = "green">        ==></font>
998                4'b1101   : nxt_frame_size_local = nxt_frame_size_word + 14'd21;
           <font color = "green">        ==></font>
999                4'b1100   : nxt_frame_size_local = nxt_frame_size_word + 14'd20;
           <font color = "green">        ==></font>
1000               4'b1011   : nxt_frame_size_local = nxt_frame_size_word + 14'd19;
           <font color = "red">        ==></font>
1001               4'b1010   : nxt_frame_size_local = nxt_frame_size_word + 14'd18;
           <font color = "red">        ==></font>
1002               4'b1001   : nxt_frame_size_local = nxt_frame_size_word + 14'd17;
           <font color = "red">        ==></font>
1003               4'b1000   : nxt_frame_size_local = nxt_frame_size_word + 14'd16;
           <font color = "red">        ==></font>
1004               4'b0111   : nxt_frame_size_local = nxt_frame_size_word + 14'd15;
           <font color = "red">        ==></font>
1005               4'b0110   : nxt_frame_size_local = nxt_frame_size_word + 14'd14;
           <font color = "red">        ==></font>
1006               4'b0101   : nxt_frame_size_local = nxt_frame_size_word + 14'd13;
           <font color = "red">        ==></font>
1007               4'b0100   : nxt_frame_size_local = nxt_frame_size_word + 14'd12;
           <font color = "red">        ==></font>
1008               4'b0011   : nxt_frame_size_local = nxt_frame_size_word + 14'd11;
           <font color = "red">        ==></font>
1009               4'b0010   : nxt_frame_size_local = nxt_frame_size_word + 14'd10;
           <font color = "red">        ==></font>
1010               4'b0001   : nxt_frame_size_local = nxt_frame_size_word + 14'd9;
           <font color = "red">        ==></font>
1011               default   : nxt_frame_size_local = nxt_frame_size_word + 14'd24;
           <font color = "green">        ==></font>
</pre>
<br clear=all>
<span class=repname>Branches:</span>
<br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=80>-1-</th><th nowrap width=80>Status</th></tr><tr class="uGreen">
<td align=center>4'b1111 </td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>4'b1110 </td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>4'b1101 </td>
<td>Covered</td>
</tr><tr class="uGreen">
<td align=center>4'b1100 </td>
<td>Covered</td>
</tr><tr class="uRed">
<td align=center>4'b1011 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>4'b1010 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>4'b1001 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>4'b1000 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>4'b0111 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>4'b0110 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>4'b0101 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>4'b0100 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>4'b0011 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>4'b0010 </td>
<td>Not Covered</td>
</tr><tr class="uRed">
<td align=center>4'b0001 </td>
<td>Not Covered</td>
</tr><tr class="uGreen">
<td align=center>default</td>
<td>Covered</td>
</tr></table><br clear=all>
</div>
</div>
<div class="ui-layout-center-inner-north">
<div id="center-bread-crumb" class="breadCrumb module urg-margin-bottom">
  <ul name="tag_edma_pbuf_axi_tx_rd">
    <li>
      <a href="#Line">Line</a>    </li>
    <li>
      <a href="#Cond">Cond</a>    </li>
    <li>
      <a href="#Toggle">Toggle</a>    </li>
    <li>
      <a href="#FSM">FSM</a>    </li>
    <li>
      <a href="#Branch">Branch</a>    </li>
  </ul>
</div>
</div>
</div>
<div class="ui-layout-south">
<table align=center><tr><td class="s0 cl">0%</td>
<td class="s1 cl">10%</td>
<td class="s2 cl">20%</td>
<td class="s3 cl">30%</td>
<td class="s4 cl">40%</td>
<td class="s5 cl">50%</td>
<td class="s6 cl">60%</td>
<td class="s7 cl">70%</td>
<td class="s8 cl">80%</td>
<td class="s9 cl">90%</td>
<td class="s10 cl">100%</td></tr></table></div>
</body>
</html>
